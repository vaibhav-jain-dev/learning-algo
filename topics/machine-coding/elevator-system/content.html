<h1 id="elevator-system-design">Elevator System Design</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>Design and implement an elevator control system for a multi-story building with multiple elevators. The system must efficiently handle pickup requests from floors and destination requests from inside cabins, optimizing for minimal wait times while ensuring fair service to all passengers.</p>
<p>This classic machine coding problem tests your ability to model real-world physical systems with <span>complex state transitions</span>, implement <span>scheduling algorithms</span> borrowed from operating systems, and design <span>coordination mechanisms</span> for distributed actors. Companies like Amazon, Google, Microsoft, and Uber use this problem to assess systems thinking, <a href="/topics/system-design/state-machine">[state-machine]</a> design, and algorithm selection.</p>
<div>
<div>Why This Problem Matters</div>
<div>
The elevator problem is a microcosm of distributed systems challenges: multiple independent actors (elevators) must coordinate to serve shared resources (passengers) while optimizing global metrics (wait time, throughput) without centralized real-time control. The algorithms you apply here—SCAN, LOOK, shortest-seek-time—originate from disk scheduling, making this an excellent bridge between OS concepts and real-world system design.
</div>
</div>
<hr />
<h2 id="requirements-analysis">Requirements Analysis</h2>
<h3 id="functional-requirements">Functional Requirements</h3>
<div>
<div>Core Capabilities</div>
<div>
<p><strong>External Requests (Hall Calls)</strong></p>
<ul>
<li>Handle UP/DOWN button presses from floor hallways</li>
<li>Track request origin floor and intended direction</li>
<li>Acknowledge request receipt with visual feedback</li>
</ul>
<p><strong>Internal Requests (Car Calls)</strong></p>
<ul>
<li>Handle floor selection from inside elevator cabins</li>
<li>Validate floor accessibility (some floors may be restricted)</li>
<li>Allow request cancellation (double-press to cancel)</li>
</ul>
<p><strong>Optimal Assignment</strong></p>
<ul>
<li>Route requests to the most suitable elevator</li>
<li>Consider current position, direction, and load</li>
<li>Balance load across elevator fleet</li>
</ul>
<p><strong>Real-time Status</strong></p>
<ul>
<li>Display current floor and direction for each elevator</li>
<li>Show estimated arrival times at floors</li>
<li>Indicate maintenance or emergency states</li>
</ul>
</div>
</div>
<h3 id="non-functional-requirements">Non-Functional Requirements</h3>
<div>
<div>System Constraints</div>
<div>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Target</th>
<th>Rationale</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Scalability</strong></td>
<td>1-100 floors, 1-16 elevators</td>
<td>Covers residential to commercial high-rises</td>
</tr>
<tr>
<td><strong>Latency</strong></td>
<td>&lt; 50ms request processing</td>
<td>Real-time responsiveness expected</td>
</tr>
<tr>
<td><strong>Fairness</strong></td>
<td>No request waits &gt; 5 minutes</td>
<td>Prevent starvation under load</td>
</tr>
<tr>
<td><strong>Throughput</strong></td>
<td>Handle 1000+ requests/minute</td>
<td>Peak rush hour in large buildings</td>
</tr>
<tr>
<td><strong>Availability</strong></td>
<td>99.9% uptime</td>
<td>Critical building infrastructure</td>
</tr>
</tbody>
</table>
</div>
</div>
<div>
<div>Assumption: Request Model</div>
<div>
We assume a <strong>two-phase request model</strong>: passengers first make a hall call (external) specifying only direction, then make a car call (internal) specifying destination after boarding. This reflects real elevator systems where you don't know the destination until the passenger enters. Some modern "destination dispatch" systems ask for the destination floor upfront at kiosks—this fundamentally changes the optimization problem and should be clarified with your interviewer.
</div>
</div>
<h3 id="interview-questions-requirements">Interview Questions: Requirements</h3>
<div>
<div>Level 1: Basic Understanding</div>
<div>
<p><strong>Q: Why do we need separate hall calls and car calls?</strong></p>
<p>Hall calls represent where passengers are waiting; car calls represent where they want to go. This separation reflects the physical reality that we don't know a passenger's destination until they board. It also enables important optimizations: we can batch multiple passengers going the same direction at the same floor, and we can assign the closest suitable elevator before knowing exact destinations.</p>
<div>
<div>Level 2: Design Implications</div>
<div>
<p><strong>Q: How would the system change with destination dispatch (passengers enter destination at hall kiosk)?</strong></p>
<p>Destination dispatch fundamentally transforms the optimization problem:</p>
<ol>
<li><strong>Better grouping</strong>: Passengers going to the same floor can be grouped into the same elevator before boarding</li>
<li><strong>Load balancing</strong>: We can distribute passengers across elevators based on destination zones</li>
<li><strong>Reduced stops</strong>: Each elevator serves fewer, more clustered floors</li>
<li><strong>Changed data model</strong>: Requests now carry full trip information (origin, destination) rather than just (origin, direction)</li>
</ol>
<p>The trade-off is increased complexity at the input interface and potential passenger confusion.</p>
<div>
<div>Level 3: Real-World Implications</div>
<div>
<p><strong>Q: In destination dispatch, how do you handle passengers who enter the wrong destination or change their mind after boarding?</strong></p>
<p>This reveals a critical UX and system design challenge:</p>
<ol>
<li><strong>In-cabin override panels</strong>: Allow destination changes but create suboptimal routes</li>
<li><strong>Request reallocation</strong>: If passenger changes destination, system may need to stop at unplanned floors</li>
<li><strong>Capacity recalculation</strong>: Original grouping assumed certain destinations; changes may overload segments</li>
<li><strong>Audit trail</strong>: Track original vs. actual to improve prediction models</li>
<li><strong>Timeout policies</strong>: Passengers who don't board their assigned elevator force reassignment</li>
</ol>
<p>Real systems like Otis Compass and Schindler PORT handle this with combination of in-cabin panels for corrections and machine learning to predict and account for typical &quot;change rates.&quot;</p>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="scheduling-algorithms-deep-dive">Scheduling Algorithms Deep Dive</h2>
<p>The core intellectual challenge of elevator systems is the <span>scheduling algorithm</span>—determining which floors to visit and in what order. These algorithms have direct parallels to <a href="/topics/operating-systems/disk-scheduling">[disk-scheduling]</a> in operating systems, where the elevator head movement mirrors disk seek operations.</p>
<div>
<div>Scheduling Algorithm Taxonomy</div>
<div>
<div>
<div>Naive</div>
<div>FCFS</div>
<div>High variance</div>
</div>
<div>→</div>
<div>
<div>Sweep-Based</div>
<div>SCAN / LOOK</div>
<div>Bounded wait</div>
</div>
<div>→</div>
<div>
<div>Greedy</div>
<div>SSTF</div>
<div>Starvation risk</div>
</div>
<div>→</div>
<div>
<div>Hybrid</div>
<div>SSTF + Aging</div>
<div>Best of both</div>
</div>
</div>
</div>
<h3 id="fcfs-first-come-first-served">FCFS (First-Come-First-Served)</h3>
<div>
<div>FCFS: The Naive Baseline</div>
<div>
<p>Service requests in the exact order they arrive, regardless of elevator position or direction.</p>
<p><strong>Mechanism</strong>: Maintain a simple queue; always go to the head of the queue next.</p>
<p><strong>Problem</strong>: Creates &quot;thrashing&quot;—elevator oscillates wildly between distant floors.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Current position: Floor 5</li>
<li>Request queue: [Floor 2, Floor 8, Floor 3, Floor 9]</li>
<li>FCFS path: 5 → 2 → 8 → 3 → 9 = 24 floors traveled</li>
<li>Optimal path: 5 → 3 → 2 → 8 → 9 = 12 floors traveled</li>
</ul>
<p><strong>When useful</strong>: Only in extremely low-traffic scenarios where simplicity outweighs efficiency.</p>
</div>
</div>
<h3 id="scan-algorithm-the-elevator-algorithm">SCAN Algorithm (The Elevator Algorithm)</h3>
<div>
<div>SCAN: Systematic Sweeping</div>
<div>
<p>Move in one direction serving all requests, then reverse direction and repeat. Continue to the building's end before reversing, even if no requests remain in that direction.</p>
<p><strong>Mechanism</strong>:</p>
<ol>
<li>Maintain current <span>direction state</span> (UP or DOWN)</li>
<li>Continue in that direction, stopping at requested floors</li>
<li>When reaching <span>building boundary</span> (top or bottom floor), reverse direction</li>
<li>Repeat indefinitely</li>
</ol>
<p><strong>Properties</strong>:</p>
<ul>
<li><span>Bounded wait time</span>: Maximum wait is 2 * (num_floors - 1) moves</li>
<li><span>No starvation</span>: Every floor gets served within one complete cycle</li>
<li><span>Predictable</span>: Passengers can estimate arrival based on elevator position</li>
</ul>
<p><strong>Trade-off</strong>: May travel to building extremes unnecessarily when no requests exist there.</p>
</div>
</div>
<div>
<div>SCAN Algorithm Visualization</div>
<div>
<div>
<div>F10</div>
<div>F9</div>
<div>F8</div>
<div>F7</div>
<div>F6</div>
<div>F5</div>
<div>F4</div>
<div>F3</div>
<div>F2</div>
<div>F1</div>
</div>
<div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
</div>
</div>
<div>
<div><div></div> Current Position</div>
<div><div></div> Pending Stop</div>
<div><div></div> Boundary (Must Visit)</div>
<div><div></div> UP Phase</div>
<div><div></div> DOWN Phase</div>
</div>
<div>
<strong>SCAN Path:</strong> Floor 5 → 7 → 9 → <span>10 (boundary)</span> → 8 → 4 → 2 → <span>1 (boundary)</span>
</div>
</div>
<pre><code class="language-python">class SCANElevator:
    &quot;&quot;&quot;SCAN algorithm implementation - always goes to building boundary.&quot;&quot;&quot;

    def __init__(self, min_floor: int, max_floor: int):
        self.current_floor = min_floor
        self.direction = Direction.UP
        self.stops: Set[int] = set()
        self.min_floor = min_floor
        self.max_floor = max_floor

    def get_next_floor(self) -&gt; int:
        &quot;&quot;&quot;
        SCAN: Continue to boundary, then reverse.

        Key insight: We go to min/max floor even if no requests there.
        This ensures predictable behavior but may waste movement.
        &quot;&quot;&quot;
        if self.direction == Direction.UP:
            # Find next stop above current position
            above = [f for f in self.stops if f &gt; self.current_floor]
            if above:
                return min(above)
            # No stops above, but continue to max floor (SCAN behavior)
            if self.current_floor &lt; self.max_floor:
                return self.current_floor + 1
            # At max floor, reverse direction
            self.direction = Direction.DOWN
            return self.get_next_floor()
        else:
            # Find next stop below current position
            below = [f for f in self.stops if f &lt; self.current_floor]
            if below:
                return max(below)
            # No stops below, but continue to min floor
            if self.current_floor &gt; self.min_floor:
                return self.current_floor - 1
            # At min floor, reverse direction
            self.direction = Direction.UP
            return self.get_next_floor()
</code></pre>
<h3 id="look-algorithm-optimized-scan">LOOK Algorithm (Optimized SCAN)</h3>
<div>
<div>LOOK: Smarter Boundary Handling</div>
<div>
<p>Like SCAN, but reverses direction when no more requests exist in the current direction—doesn't travel to building boundary unnecessarily.</p>
<p><strong>Mechanism</strong>:</p>
<ol>
<li>Maintain current direction</li>
<li>Continue in that direction, stopping at requested floors</li>
<li>When no more requests in current direction, <span>reverse immediately</span></li>
<li><span>&quot;Look ahead&quot;</span> before moving to see if direction change is needed</li>
</ol>
<p><strong>Improvement over SCAN</strong>: Eliminates <span>wasteful travel</span> to building boundaries when no requests exist there.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Current: Floor 5, Direction: UP</li>
<li>Stops: {7, 3, 1}</li>
<li>SCAN would go: 5 → 7 → (max floor) → 3 → 1</li>
<li>LOOK would go: 5 → 7 → 3 → 1 (reverses at 7, not max)</li>
</ul>
</div>
</div>
<div>
<div>SCAN vs LOOK Comparison</div>
<div>
<div>
<div>SCAN (Wasteful)</div>
<div>
<div>
<div>F10</div>
<div>
<div>← wasted travel</div>
</div>
</div>
<div>
<div>F7</div>
<div><div></div></div>
</div>
<div>
<div>F5</div>
<div><div></div></div>
</div>
<div>
<div>F3</div>
<div><div></div></div>
</div>
<div>
<div>F1</div>
<div><div></div></div>
</div>
</div>
<div><strong>Path:</strong> 5→7→8→9→10→3→1 = <strong>12 moves</strong></div>
</div>
<div>
<div>LOOK (Efficient)</div>
<div>
<div>
<div>F10</div>
<div>
<div>skipped</div>
</div>
</div>
<div>
<div>F7</div>
<div><div></div><span>reverse here!</span></div>
</div>
<div>
<div>F5</div>
<div><div></div></div>
</div>
<div>
<div>F3</div>
<div><div></div></div>
</div>
<div>
<div>F1</div>
<div><div></div></div>
</div>
</div>
<div><strong>Path:</strong> 5→7→3→1 = <strong>8 moves</strong></div>
</div>
</div>
<div>
<strong>LOOK saves 33% movement</strong> in this example by not traveling to floor 10 unnecessarily
</div>
</div>
<pre><code class="language-python">class LOOKElevator:
    &quot;&quot;&quot;LOOK algorithm - reverses at last request, not building boundary.&quot;&quot;&quot;

    def get_next_floor(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        LOOK: Reverse when no more requests in current direction.

        This is more efficient than SCAN in most real scenarios.
        &quot;&quot;&quot;
        if not self.stops:
            self.direction = Direction.IDLE
            return None

        if self.direction == Direction.UP or self.direction == Direction.IDLE:
            # Find stops above current position
            above = [f for f in self.stops if f &gt; self.current_floor]
            if above:
                return min(above)
            # No stops above - reverse (LOOK behavior: don't go to max)
            self.direction = Direction.DOWN

        if self.direction == Direction.DOWN:
            # Find stops below current position
            below = [f for f in self.stops if f &lt; self.current_floor]
            if below:
                return max(below)
            # No stops below - reverse
            self.direction = Direction.UP
            above = [f for f in self.stops if f &gt; self.current_floor]
            if above:
                return min(above)

        # Handle edge case: stop at current floor
        if self.current_floor in self.stops:
            return self.current_floor

        return None
</code></pre>
<h3 id="c-scan-and-c-look-circular-variants">C-SCAN and C-LOOK (Circular Variants)</h3>
<div>
<div>Circular Variants: Uniform Wait Time</div>
<div>
<p><strong>C-SCAN (Circular SCAN)</strong>: Service requests in one direction only. After reaching the end, return to the beginning without servicing and start again.</p>
<p><strong>C-LOOK</strong>: Like C-SCAN but reverses at last request rather than building boundary.</p>
<p><strong>Why Circular?</strong><br />
Standard SCAN/LOOK creates unfair wait times: floors in the middle get served twice per cycle (once going up, once down), while extreme floors get served once. C-SCAN ensures every floor waits approximately the same time.</p>
<p><strong>Trade-off</strong>: Wastes movement during the &quot;return&quot; phase, but provides more uniform service.</p>
<p><strong>Real-world usage</strong>: Rarely used in elevators (passengers expect bidirectional service), but common in disk scheduling where uniform latency matters.</p>
</div>
</div>
<h3 id="sstf-shortest-seek-time-first">SSTF (Shortest Seek Time First)</h3>
<div>
<div>SSTF: Greedy Optimization</div>
<div>
<p>Always go to the nearest requested floor, regardless of direction.</p>
<p><strong>Mechanism</strong>: At each decision point, calculate distance to all pending requests and choose the minimum.</p>
<p><strong>Advantage</strong>: Minimizes total travel distance in many scenarios.</p>
<p><strong>Critical Problem</strong>: <strong>Starvation</strong>. Floors far from the &quot;cluster&quot; of activity may never get served.</p>
<p><strong>Example of starvation</strong>:</p>
<ul>
<li>Current: Floor 5</li>
<li>Continuous requests at floors 4, 5, 6</li>
<li>Request at floor 1 waits indefinitely</li>
</ul>
<p><strong>When to use</strong>: Only with additional anti-starvation mechanisms (aging, priority boost).</p>
</div>
</div>
<pre><code class="language-python">class SSTFElevator:
    &quot;&quot;&quot;Shortest Seek Time First with anti-starvation aging.&quot;&quot;&quot;

    def __init__(self):
        self.stops: Dict[int, float] = {}  # floor -&gt; timestamp
        self.current_floor = 0
        self.max_wait_time = 60.0  # seconds before priority boost

    def add_stop(self, floor: int):
        if floor not in self.stops:
            self.stops[floor] = time.time()

    def get_next_floor(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        SSTF with aging: boost priority of long-waiting requests.

        Trade-off: We sacrifice pure distance optimization to prevent
        starvation. This is the practical choice for real systems.
        &quot;&quot;&quot;
        if not self.stops:
            return None

        current_time = time.time()
        best_floor = None
        best_score = float('inf')

        for floor, timestamp in self.stops.items():
            distance = abs(floor - self.current_floor)
            wait_time = current_time - timestamp

            # Aging: reduce effective distance for long-waiting requests
            # After max_wait_time, distance becomes 0 (highest priority)
            age_factor = max(0, 1 - (wait_time / self.max_wait_time))
            effective_distance = distance * age_factor

            if effective_distance &lt; best_score:
                best_score = effective_distance
                best_floor = floor

        return best_floor
</code></pre>
<h3 id="algorithm-comparison">Algorithm Comparison</h3>
<div>
<h4>Scheduling Algorithm Comparison</h4>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Avg Wait</th>
<th>Max Wait</th>
<th>Starvation Risk</th>
<th>Throughput</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>FCFS</td>
<td>High</td>
<td>Unbounded</td>
<td>None</td>
<td>Low</td>
<td>O(1)</td>
</tr>
<tr>
<td>SCAN</td>
<td>Medium</td>
<td>2*(n-1)</td>
<td>None</td>
<td>Medium</td>
<td>O(k log k)</td>
</tr>
<tr>
<td>LOOK</td>
<td>Medium</td>
<td>2*(n-1)</td>
<td>None</td>
<td>Medium-High</td>
<td>O(k log k)</td>
</tr>
<tr>
<td>C-SCAN</td>
<td>Medium</td>
<td>n</td>
<td>None</td>
<td>Medium</td>
<td>O(k log k)</td>
</tr>
<tr>
<td>SSTF</td>
<td>Low</td>
<td>Unbounded</td>
<td><strong>High</strong></td>
<td>High</td>
<td>O(k)</td>
</tr>
<tr>
<td>SSTF+Aging</td>
<td>Low-Medium</td>
<td>Bounded</td>
<td>Low</td>
<td>High</td>
<td>O(k)</td>
</tr>
</tbody>
</table>
<p><em>n = number of floors, k = number of pending requests</em></p>
</div>
<h3 id="interview-questions-scheduling-algorithms">Interview Questions: Scheduling Algorithms</h3>
<div>
<div>Level 1: Algorithm Understanding</div>
<div>
<p><strong>Q: Why is LOOK preferred over SCAN in most elevator implementations?</strong></p>
<p>LOOK eliminates unnecessary travel to building boundaries. In SCAN, if the elevator is at floor 5 going up with requests only at floors 6 and 7, it would still travel to the top floor (say, floor 20) before reversing. LOOK reverses at floor 7 immediately, saving 13 floors of travel. The only scenario where SCAN is better is when new requests consistently appear ahead of the elevator—SCAN's predictable path makes it easier for passengers to anticipate, but this rarely outweighs the efficiency loss.</p>
<div>
<div>Level 2: Trade-off Analysis</div>
<div>
<p><strong>Q: How would you modify SSTF to guarantee bounded wait times while preserving its efficiency benefits?</strong></p>
<p>The key insight is to use <strong>aging</strong> or <strong>deadline-based promotion</strong>:</p>
<ol>
<li>
<p><strong>Aging approach</strong>: Track request timestamps. Gradually reduce the &quot;effective distance&quot; of older requests. After a maximum wait threshold, their effective distance becomes 0, giving them highest priority regardless of physical distance.</p>
</li>
<li>
<p><strong>Deadline approach</strong>: Assign each request a deadline (e.g., 3 minutes from creation). Partition requests into &quot;urgent&quot; (approaching deadline) and &quot;normal.&quot; Always serve urgent requests first using any algorithm, then serve normal requests using SSTF.</p>
</li>
<li>
<p><strong>Hybrid approach</strong>: Use SSTF within a LOOK framework—apply SSTF to choose among requests in the current direction, but guarantee direction reversal ensures no request waits more than one full cycle.</p>
</li>
</ol>
<p>The trade-off: more complex bookkeeping and slightly reduced throughput, but bounded maximum wait time.</p>
<div>
<div>Level 3: System Design Implications</div>
<div>
<p><strong>Q: In a multi-elevator system, should each elevator run its own scheduling algorithm independently, or should there be a central coordinator? What are the implications of each approach?</strong></p>
<p>This is a fundamental distributed systems question with significant implications:</p>
<p><strong>Decentralized (each elevator independent)</strong>:</p>
<ul>
<li>Pros: Fault-tolerant (one elevator failure doesn't affect others), simpler implementation, no single point of failure</li>
<li>Cons: Suboptimal global behavior (two elevators might both respond to the same request), difficult to load balance, no global optimization</li>
<li>Implementation: Each elevator &quot;claims&quot; requests it can serve efficiently; unclaimed requests go to nearest idle elevator</li>
</ul>
<p><strong>Centralized coordinator</strong>:</p>
<ul>
<li>Pros: Global optimization, true load balancing, can implement sophisticated algorithms (Hungarian algorithm for optimal assignment)</li>
<li>Cons: Single point of failure, increased latency (all requests route through coordinator), coordinator becomes bottleneck at scale</li>
<li>Implementation: Central dispatcher receives all requests, runs assignment algorithm, sends commands to elevators</li>
</ul>
<p><strong>Hybrid (practical choice)</strong>:</p>
<ul>
<li>Central coordinator for assignment decisions (which elevator gets which request)</li>
<li>Local LOOK/SCAN for each elevator's internal scheduling (what order to visit assigned floors)</li>
<li>Coordinator failure fallback: elevators switch to decentralized mode</li>
<li>This balances global optimization with fault tolerance</li>
</ul>
<p>Real systems like Otis, Schindler, and KONE use hybrid approaches with central &quot;supervisory control&quot; and local &quot;car control&quot; layers.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="state-machine-design">State Machine Design</h2>
<p>A single elevator is fundamentally a <a href="/topics/system-design/state-machine">[state-machine]</a>—it exists in <span>discrete states</span> and transitions between them based on <span>events</span>. Correct state machine design is critical for <span>safety</span> and <span>correctness</span>.</p>
<div>
<div>State Machine Design Principles</div>
<div>
<div>
<div>1</div>
<div>Explicit States</div>
<div>Every possible elevator condition has a named state</div>
</div>
<div>
<div>2</div>
<div>Defined Transitions</div>
<div>Only valid (state, event) pairs cause state changes</div>
</div>
<div>
<div>3</div>
<div>Guard Conditions</div>
<div>Transitions can have boolean conditions that must be true</div>
</div>
<div>
<div>4</div>
<div>Actions on Transition</div>
<div>Side effects execute atomically with state change</div>
</div>
</div>
</div>
<h3 id="elevator-states">Elevator States</h3>
<div>
<h4>Elevator State Machine</h4>
<div>
<div>
<div>
<div>IDLE</div>
<div>Stationary, no requests</div>
</div>
<div>&#8594;</div>
<div>
<div>MOVING_UP</div>
<div>Ascending</div>
</div>
<div>&#8594;</div>
<div>
<div>STOPPING</div>
<div>Decelerating</div>
</div>
<div>&#8594;</div>
<div>
<div>DOORS_OPENING</div>
<div>Doors in motion</div>
</div>
</div>
<div>
<div>
<div>DOORS_OPEN</div>
<div>Passengers boarding</div>
</div>
<div>&#8594;</div>
<div>
<div>DOORS_CLOSING</div>
<div>Doors in motion</div>
</div>
<div>&#8594;</div>
<div>
<div>MOVING_DOWN</div>
<div>Descending</div>
</div>
<div>&#8594;</div>
<div>
<div>IDLE</div>
<div>Cycle complete</div>
</div>
</div>
<div>
<div>
<div>EMERGENCY_STOP</div>
<div>Reachable from any state</div>
</div>
</div>
</div>
</div>
<h3 id="state-transition-table">State Transition Table</h3>
<div>
<table>
<thead>
<tr>
<th>Current State</th>
<th>Event</th>
<th>Next State</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDLE</td>
<td>request_received</td>
<td>MOVING_UP/DOWN</td>
<td>Start motor, set direction</td>
</tr>
<tr>
<td>IDLE</td>
<td>door_button</td>
<td>DOORS_OPENING</td>
<td>Open doors (passenger boarding at current floor)</td>
</tr>
<tr>
<td>MOVING_UP</td>
<td>floor_reached &amp; is_stop</td>
<td>STOPPING</td>
<td>Begin deceleration</td>
</tr>
<tr>
<td>MOVING_UP</td>
<td>floor_reached &amp; !is_stop</td>
<td>MOVING_UP</td>
<td>Continue, update floor counter</td>
</tr>
<tr>
<td>MOVING_DOWN</td>
<td>floor_reached &amp; is_stop</td>
<td>STOPPING</td>
<td>Begin deceleration</td>
</tr>
<tr>
<td>STOPPING</td>
<td>stopped</td>
<td>DOORS_OPENING</td>
<td>Disengage motor, start door motor</td>
</tr>
<tr>
<td>DOORS_OPENING</td>
<td>doors_fully_open</td>
<td>DOORS_OPEN</td>
<td>Start door timer</td>
</tr>
<tr>
<td>DOORS_OPEN</td>
<td>timer_expired</td>
<td>DOORS_CLOSING</td>
<td>Start door close</td>
</tr>
<tr>
<td>DOORS_OPEN</td>
<td>obstruction_detected</td>
<td>DOORS_OPEN</td>
<td>Reset timer</td>
</tr>
<tr>
<td>DOORS_CLOSING</td>
<td>doors_fully_closed &amp; has_requests</td>
<td>MOVING_UP/DOWN</td>
<td>Start motor</td>
</tr>
<tr>
<td>DOORS_CLOSING</td>
<td>doors_fully_closed &amp; !has_requests</td>
<td>IDLE</td>
<td>All done</td>
</tr>
<tr>
<td>DOORS_CLOSING</td>
<td>obstruction_detected</td>
<td>DOORS_OPENING</td>
<td>Safety reversal</td>
</tr>
<tr>
<td>ANY</td>
<td>emergency_button</td>
<td>EMERGENCY_STOP</td>
<td>Stop motor, open doors, alert</td>
</tr>
<tr>
<td>EMERGENCY_STOP</td>
<td>reset_by_technician</td>
<td>IDLE</td>
<td>Clear emergency state</td>
</tr>
</tbody>
</table>
</div>
<h3 id="state-machine-implementation">State Machine Implementation</h3>
<pre><code class="language-python">from enum import Enum, auto
from typing import Callable, Dict, Optional, Set
from dataclasses import dataclass
import threading
import time


class ElevatorState(Enum):
    &quot;&quot;&quot;All possible elevator states.&quot;&quot;&quot;
    IDLE = auto()
    MOVING_UP = auto()
    MOVING_DOWN = auto()
    STOPPING = auto()
    DOORS_OPENING = auto()
    DOORS_OPEN = auto()
    DOORS_CLOSING = auto()
    EMERGENCY_STOP = auto()
    MAINTENANCE = auto()


class ElevatorEvent(Enum):
    &quot;&quot;&quot;Events that trigger state transitions.&quot;&quot;&quot;
    REQUEST_RECEIVED = auto()
    FLOOR_REACHED = auto()
    STOP_REACHED = auto()
    STOPPED = auto()
    DOORS_FULLY_OPEN = auto()
    DOOR_TIMER_EXPIRED = auto()
    DOORS_FULLY_CLOSED = auto()
    OBSTRUCTION_DETECTED = auto()
    EMERGENCY_BUTTON = auto()
    MAINTENANCE_MODE = auto()
    RESET = auto()


@dataclass
class Transition:
    &quot;&quot;&quot;Represents a state transition.&quot;&quot;&quot;
    from_state: ElevatorState
    event: ElevatorEvent
    to_state: ElevatorState
    guard: Optional[Callable[[], bool]] = None  # Condition that must be true
    action: Optional[Callable[[], None]] = None  # Action to execute


class ElevatorStateMachine:
    &quot;&quot;&quot;
    Formal state machine implementation for elevator control.

    Key design decisions:
    - Explicit transition table for clarity and verification
    - Guards enable conditional transitions
    - Actions execute on transition (Moore machine with Mealy extensions)
    - Thread-safe state access
    - Emergency stop reachable from any state
    &quot;&quot;&quot;

    def __init__(self, elevator_id: int, num_floors: int):
        self.id = elevator_id
        self.num_floors = num_floors
        self.current_floor = 0
        self.state = ElevatorState.IDLE
        self.target_direction: Optional[Direction] = None

        # Request tracking
        self.up_stops: Set[int] = set()
        self.down_stops: Set[int] = set()

        # Thread safety
        self.lock = threading.RLock()

        # Build transition table
        self.transitions: Dict[tuple, Transition] = {}
        self._build_transitions()

        # Timers
        self.door_timer: Optional[threading.Timer] = None
        self.door_open_duration = 3.0  # seconds

    def _build_transitions(self):
        &quot;&quot;&quot;Define all valid state transitions.&quot;&quot;&quot;

        transitions = [
            # From IDLE
            Transition(
                ElevatorState.IDLE,
                ElevatorEvent.REQUEST_RECEIVED,
                ElevatorState.MOVING_UP,
                guard=lambda: self._next_stop_above(),
                action=self._start_moving_up
            ),
            Transition(
                ElevatorState.IDLE,
                ElevatorEvent.REQUEST_RECEIVED,
                ElevatorState.MOVING_DOWN,
                guard=lambda: self._next_stop_below(),
                action=self._start_moving_down
            ),
            Transition(
                ElevatorState.IDLE,
                ElevatorEvent.REQUEST_RECEIVED,
                ElevatorState.DOORS_OPENING,
                guard=lambda: self._stop_at_current_floor(),
                action=self._open_doors
            ),

            # From MOVING_UP
            Transition(
                ElevatorState.MOVING_UP,
                ElevatorEvent.STOP_REACHED,
                ElevatorState.STOPPING,
                action=self._begin_stopping
            ),
            Transition(
                ElevatorState.MOVING_UP,
                ElevatorEvent.FLOOR_REACHED,
                ElevatorState.MOVING_UP,
                guard=lambda: self._has_stops_above(),
                action=self._update_floor_up
            ),

            # From MOVING_DOWN
            Transition(
                ElevatorState.MOVING_DOWN,
                ElevatorEvent.STOP_REACHED,
                ElevatorState.STOPPING,
                action=self._begin_stopping
            ),
            Transition(
                ElevatorState.MOVING_DOWN,
                ElevatorEvent.FLOOR_REACHED,
                ElevatorState.MOVING_DOWN,
                guard=lambda: self._has_stops_below(),
                action=self._update_floor_down
            ),

            # From STOPPING
            Transition(
                ElevatorState.STOPPING,
                ElevatorEvent.STOPPED,
                ElevatorState.DOORS_OPENING,
                action=self._open_doors
            ),

            # From DOORS_OPENING
            Transition(
                ElevatorState.DOORS_OPENING,
                ElevatorEvent.DOORS_FULLY_OPEN,
                ElevatorState.DOORS_OPEN,
                action=self._start_door_timer
            ),

            # From DOORS_OPEN
            Transition(
                ElevatorState.DOORS_OPEN,
                ElevatorEvent.DOOR_TIMER_EXPIRED,
                ElevatorState.DOORS_CLOSING,
                action=self._close_doors
            ),
            Transition(
                ElevatorState.DOORS_OPEN,
                ElevatorEvent.OBSTRUCTION_DETECTED,
                ElevatorState.DOORS_OPEN,
                action=self._reset_door_timer
            ),

            # From DOORS_CLOSING
            Transition(
                ElevatorState.DOORS_CLOSING,
                ElevatorEvent.DOORS_FULLY_CLOSED,
                ElevatorState.MOVING_UP,
                guard=lambda: self._has_stops_above(),
                action=self._start_moving_up
            ),
            Transition(
                ElevatorState.DOORS_CLOSING,
                ElevatorEvent.DOORS_FULLY_CLOSED,
                ElevatorState.MOVING_DOWN,
                guard=lambda: self._has_stops_below(),
                action=self._start_moving_down
            ),
            Transition(
                ElevatorState.DOORS_CLOSING,
                ElevatorEvent.DOORS_FULLY_CLOSED,
                ElevatorState.IDLE,
                guard=lambda: not self._has_any_stops(),
                action=self._become_idle
            ),
            Transition(
                ElevatorState.DOORS_CLOSING,
                ElevatorEvent.OBSTRUCTION_DETECTED,
                ElevatorState.DOORS_OPENING,
                action=self._open_doors  # Safety: reopen on obstruction
            ),
        ]

        for t in transitions:
            key = (t.from_state, t.event)
            if key not in self.transitions:
                self.transitions[key] = []
            self.transitions[key].append(t)

    def process_event(self, event: ElevatorEvent) -&gt; bool:
        &quot;&quot;&quot;
        Process an event and perform state transition if valid.

        Returns True if transition occurred, False otherwise.

        Thread-safe: uses lock for state access.
        &quot;&quot;&quot;
        with self.lock:
            # Emergency stop is special: reachable from any state
            if event == ElevatorEvent.EMERGENCY_BUTTON:
                self._emergency_stop()
                self.state = ElevatorState.EMERGENCY_STOP
                return True

            key = (self.state, event)
            if key not in self.transitions:
                return False  # No valid transition

            # Find first transition whose guard passes
            for transition in self.transitions[key]:
                if transition.guard is None or transition.guard():
                    # Execute action
                    if transition.action:
                        transition.action()
                    # Change state
                    self.state = transition.to_state
                    return True

            return False  # No guard passed

    # Guard methods
    def _next_stop_above(self) -&gt; bool:
        return any(f &gt; self.current_floor for f in self.up_stops | self.down_stops)

    def _next_stop_below(self) -&gt; bool:
        return any(f &lt; self.current_floor for f in self.up_stops | self.down_stops)

    def _stop_at_current_floor(self) -&gt; bool:
        return self.current_floor in self.up_stops or self.current_floor in self.down_stops

    def _has_stops_above(self) -&gt; bool:
        return any(f &gt; self.current_floor for f in self.up_stops | self.down_stops)

    def _has_stops_below(self) -&gt; bool:
        return any(f &lt; self.current_floor for f in self.up_stops | self.down_stops)

    def _has_any_stops(self) -&gt; bool:
        return len(self.up_stops) &gt; 0 or len(self.down_stops) &gt; 0

    # Action methods
    def _start_moving_up(self):
        self.target_direction = Direction.UP
        # In real system: send command to motor controller

    def _start_moving_down(self):
        self.target_direction = Direction.DOWN
        # In real system: send command to motor controller

    def _update_floor_up(self):
        self.current_floor += 1

    def _update_floor_down(self):
        self.current_floor -= 1

    def _begin_stopping(self):
        # In real system: command motor to decelerate
        pass

    def _open_doors(self):
        # Remove current floor from stops
        self.up_stops.discard(self.current_floor)
        self.down_stops.discard(self.current_floor)
        # In real system: command door motor

    def _close_doors(self):
        if self.door_timer:
            self.door_timer.cancel()
        # In real system: command door motor

    def _start_door_timer(self):
        self.door_timer = threading.Timer(
            self.door_open_duration,
            lambda: self.process_event(ElevatorEvent.DOOR_TIMER_EXPIRED)
        )
        self.door_timer.start()

    def _reset_door_timer(self):
        if self.door_timer:
            self.door_timer.cancel()
        self._start_door_timer()

    def _become_idle(self):
        self.target_direction = None

    def _emergency_stop(self):
        if self.door_timer:
            self.door_timer.cancel()
        # In real system: emergency brake, open doors, sound alarm
</code></pre>
<div>
<div>Design Choice: Guards vs. Multiple Transitions</div>
<div>
We use <strong>guard conditions</strong> on transitions rather than creating many micro-states. For example, DOORS_CLOSING can transition to MOVING_UP, MOVING_DOWN, or IDLE depending on pending requests. Alternative approach: create states like DOORS_CLOSING_WILL_GO_UP, but this explodes the state space. Guards keep the state machine manageable while handling conditional logic.
</div>
</div>
<h3 id="interview-questions-state-machines">Interview Questions: State Machines</h3>
<div>
<div>Level 1: State Machine Fundamentals</div>
<div>
<p><strong>Q: Why do we need separate DOORS_OPENING and DOORS_OPEN states instead of just one &quot;doors open&quot; state?</strong></p>
<p>The distinction models physical reality and enables proper safety handling:</p>
<ul>
<li><strong>DOORS_OPENING</strong>: Doors are in motion. Elevator cannot move. System is transitioning.</li>
<li><strong>DOORS_OPEN</strong>: Doors are fully open and stable. Timer is running. Passengers can safely board.</li>
</ul>
<p>This separation matters for:</p>
<ol>
<li><strong>Safety interlocks</strong>: Elevator motor must not start while doors are in motion</li>
<li><strong>Obstruction handling</strong>: Response differs based on whether doors are moving or stable</li>
<li><strong>Timer management</strong>: Timer only starts after doors are fully open</li>
<li><strong>Sensor interpretation</strong>: Door position sensors mean different things in each state</li>
</ol>
<div>
<div>Level 2: Safety Critical Design</div>
<div>
<p><strong>Q: How do you ensure the elevator never moves while doors are open? What could go wrong and how do you prevent it?</strong></p>
<p>This is a <strong>safety-critical invariant</strong> that must be enforced at multiple levels:</p>
<p><strong>Software enforcement</strong>:</p>
<ul>
<li>State machine structure: No transitions from DOORS_OPEN or DOORS_OPENING to MOVING states</li>
<li>Guard conditions: MOVING states require <code>doors_fully_closed</code> guard</li>
<li>Assertions: <code>assert self.state not in [DOORS_OPEN, DOORS_OPENING] before motor_start()</code></li>
</ul>
<p><strong>Hardware enforcement</strong> (defense in depth):</p>
<ul>
<li><strong>Door interlock switch</strong>: Physical switch that cuts motor power if doors not fully closed</li>
<li><strong>Door zone sensor</strong>: Separate sensor verifies door position independently</li>
<li><strong>Motor controller firmware</strong>: Refuses to energize motor unless interlock signal is true</li>
</ul>
<p><strong>What could go wrong</strong>:</p>
<ol>
<li>Software bug bypasses state check (mitigated by hardware interlock)</li>
<li>Door sensor fails &quot;closed&quot; when actually open (mitigated by redundant sensors)</li>
<li>Race condition: state changes between check and motor start (mitigated by atomic operations + hardware)</li>
</ol>
<p>Real elevator systems use IEC 62443 (industrial cybersecurity) and EN 81-20 (elevator safety) standards requiring multiple independent safety mechanisms.</p>
<div>
<div>Level 3: Fault Tolerance and Recovery</div>
<div>
<p><strong>Q: What happens if the door timer never fires (timer subsystem fails)? How do you design the system to handle this and similar failure modes?</strong></p>
<p>This is a classic reliability engineering problem. Solutions involve multiple layers:</p>
<p><strong>Detection mechanisms</strong>:</p>
<ol>
<li><strong>Watchdog timer</strong>: Separate hardware timer that resets the system if not &quot;fed&quot; regularly. If door timer fails, watchdog eventually triggers.</li>
<li><strong>State timeout monitoring</strong>: Supervisor process tracks time in each state. If DOORS_OPEN exceeds maximum (e.g., 30 seconds), force transition to DOORS_CLOSING.</li>
<li><strong>Health checks</strong>: Periodic verification that timer subsystem is responsive.</li>
</ol>
<p><strong>Recovery mechanisms</strong>:</p>
<ol>
<li><strong>Graceful degradation</strong>: If software timer fails, fall back to hardware timer or manual close button.</li>
<li><strong>State reset</strong>: After timeout, force state machine to known-good state (IDLE with doors closed).</li>
<li><strong>Maintenance alert</strong>: Notify building management of timer subsystem failure.</li>
</ol>
<p><strong>Architectural patterns</strong>:</p>
<ul>
<li><strong>Heartbeat pattern</strong>: Timer sends periodic &quot;alive&quot; signals; absence triggers recovery</li>
<li><strong>Supervision trees</strong> (like Erlang OTP): Supervisor process restarts failed timer process</li>
<li><strong>Circuit breaker</strong>: After repeated timer failures, disable automatic door closing and require manual operation</li>
</ul>
<p><strong>Real-world example</strong>: Otis elevators use redundant microcontrollers where one monitors the other. If the primary controller's door timer fails, the secondary takes over automatically.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="multi-elevator-coordination">Multi-Elevator Coordination</h2>
<p>With multiple elevators, the system must decide which elevator should serve each request. This is an <a href="/topics/algorithms/assignment-problem">[assignment-problem]</a> with real-time constraints.</p>
<h3 id="assignment-strategies">Assignment Strategies</h3>
<div>
<h4>Multi-Elevator System Architecture</h4>
<div>
<div>
<div>Central Dispatcher</div>
<div>
<div>
<div>Request Queue</div>
<div>Incoming hall calls</div>
</div>
<div>
<div>Assignment Engine</div>
<div>Scoring + optimization</div>
</div>
<div>
<div>Load Balancer</div>
<div>Even distribution</div>
</div>
</div>
</div>
<div>&#8595; Commands &#8595;</div>
<div>
<div>Elevator Fleet (Independent State Machines)</div>
<div>
<div>
<div>Elevator A</div>
<div>Floor 5 | UP</div>
<div>Stops: {7, 9, 12}</div>
</div>
<div>
<div>Elevator B</div>
<div>Floor 8 | IDLE</div>
<div>Stops: {}</div>
</div>
<div>
<div>Elevator C</div>
<div>Floor 15 | DOWN</div>
<div>Stops: {10, 3, 1}</div>
</div>
</div>
</div>
<div>&#8593; Status Updates &#8593;</div>
</div>
</div>
<h3 id="nearest-car-algorithm">Nearest Car Algorithm</h3>
<p>The simplest multi-elevator strategy: assign each request to the elevator that can reach it fastest.</p>
<pre><code class="language-python">class NearestCarDispatcher:
    &quot;&quot;&quot;
    Assign requests to nearest elevator considering direction.

    This is the baseline strategy—simple and effective for low-traffic.
    &quot;&quot;&quot;

    def __init__(self, elevators: List[Elevator]):
        self.elevators = elevators

    def assign_request(self, floor: int, direction: Direction) -&gt; Elevator:
        &quot;&quot;&quot;
        Find the elevator that can reach the floor fastest.

        Scoring considers:
        1. Physical distance
        2. Current direction alignment
        3. Whether floor is &quot;on the way&quot;
        &quot;&quot;&quot;
        best_elevator = None
        best_score = float('inf')

        for elevator in self.elevators:
            if elevator.state == ElevatorState.MAINTENANCE:
                continue

            score = self._calculate_score(elevator, floor, direction)

            if score &lt; best_score:
                best_score = score
                best_elevator = elevator

        return best_elevator

    def _calculate_score(self, elevator: Elevator, floor: int, direction: Direction) -&gt; float:
        &quot;&quot;&quot;
        Calculate assignment score (lower is better).

        The scoring function encodes our preferences:
        - Idle elevators are good (available immediately)
        - Same direction with floor on the way is ideal
        - Opposite direction is worst (must complete current trip first)
        &quot;&quot;&quot;
        distance = abs(elevator.current_floor - floor)

        # Case 1: Elevator is idle
        if elevator.state == ElevatorState.IDLE:
            return distance  # Simple distance

        # Case 2: Same direction, floor is on the way
        if elevator.target_direction == direction:
            if direction == Direction.UP and elevator.current_floor &lt;= floor:
                return distance  # Perfect: just continue
            if direction == Direction.DOWN and elevator.current_floor &gt;= floor:
                return distance  # Perfect: just continue

        # Case 3: Same direction, but floor is behind
        if elevator.target_direction == direction:
            # Must complete current direction, reverse, then reach floor
            if direction == Direction.UP:
                # Going up, floor is below: go to max stop, reverse, come back
                max_stop = max(elevator.up_stops) if elevator.up_stops else elevator.current_floor
                return (max_stop - elevator.current_floor) + (max_stop - floor)
            else:
                min_stop = min(elevator.down_stops) if elevator.down_stops else elevator.current_floor
                return (elevator.current_floor - min_stop) + (floor - min_stop)

        # Case 4: Opposite direction
        # Must complete current direction entirely, then reverse
        if elevator.target_direction == Direction.UP:
            max_stop = max(elevator.up_stops) if elevator.up_stops else elevator.current_floor
            return (max_stop - elevator.current_floor) + abs(max_stop - floor)
        else:
            min_stop = min(elevator.down_stops) if elevator.down_stops else elevator.current_floor
            return (elevator.current_floor - min_stop) + abs(floor - min_stop)
</code></pre>
<h3 id="zoned-elevator-systems">Zoned Elevator Systems</h3>
<div>
<div>Zoning Strategy</div>
<div>
<p>In tall buildings (30+ floors), divide elevators into zones:</p>
<p><strong>Low-rise zone</strong>: Elevators serving floors 1-15<br />
<strong>Mid-rise zone</strong>: Elevators serving floors 1, 16-30<br />
<strong>High-rise zone</strong>: Elevators serving floors 1, 31-45</p>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Reduced travel time (elevators don't traverse entire building)</li>
<li>Increased throughput (more elevators available per zone)</li>
<li>Simplified scheduling (smaller search space per elevator)</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>Passengers going across zones need to transfer</li>
<li>Uneven load if zones have different traffic patterns</li>
<li>Less flexibility during off-peak hours</li>
</ul>
<p><strong>Dynamic zoning</strong>: Modern systems adjust zones based on traffic patterns—morning rush has more elevators serving lobby-to-office floors, lunch rush adjusts for cafeteria floors.</p>
</div>
</div>
<pre><code class="language-python">class ZonedDispatcher:
    &quot;&quot;&quot;
    Assign elevators based on floor zones.

    Design decision: Zones overlap at lobby (floor 0) for transfers.
    &quot;&quot;&quot;

    def __init__(self, elevators: List[Elevator], num_floors: int, num_zones: int):
        self.elevators = elevators
        self.num_floors = num_floors
        self.num_zones = num_zones

        # Assign elevators to zones
        self.zones = self._create_zones()
        self.elevator_zones = self._assign_elevators_to_zones()

    def _create_zones(self) -&gt; List[tuple]:
        &quot;&quot;&quot;Create floor ranges for each zone.&quot;&quot;&quot;
        floors_per_zone = self.num_floors // self.num_zones
        zones = []

        for i in range(self.num_zones):
            start = i * floors_per_zone
            end = (i + 1) * floors_per_zone - 1 if i &lt; self.num_zones - 1 else self.num_floors - 1
            # All zones include lobby (floor 0) for transfers
            zones.append((0, start, end))  # (lobby, zone_start, zone_end)

        return zones

    def _assign_elevators_to_zones(self) -&gt; Dict[int, List[Elevator]]:
        &quot;&quot;&quot;Distribute elevators across zones.&quot;&quot;&quot;
        elevators_per_zone = len(self.elevators) // self.num_zones
        zone_assignments = {}

        for i, zone in enumerate(self.zones):
            start_idx = i * elevators_per_zone
            end_idx = start_idx + elevators_per_zone
            zone_assignments[i] = self.elevators[start_idx:end_idx]

            # Configure each elevator's floor range
            for elevator in zone_assignments[i]:
                elevator.min_floor = zone[1]  # Zone start
                elevator.max_floor = zone[2]  # Zone end
                elevator.serves_lobby = True  # All serve lobby

        return zone_assignments

    def assign_request(self, floor: int, direction: Direction) -&gt; Optional[Elevator]:
        &quot;&quot;&quot;Assign request to appropriate zone's elevator.&quot;&quot;&quot;
        # Find which zone this floor belongs to
        zone_id = self._get_zone_for_floor(floor)

        if zone_id is None:
            return None

        # Use nearest car within that zone
        zone_elevators = self.elevator_zones[zone_id]
        return self._nearest_in_zone(zone_elevators, floor, direction)
</code></pre>
<h3 id="load-balancing-and-fairness">Load Balancing and Fairness</h3>
<div>
<div>Trade-off: Efficiency vs. Fairness</div>
<div>
Pure efficiency optimization (always assign to nearest elevator) creates unfair outcomes: elevators near high-traffic floors get overloaded while others sit idle. We need to balance immediate efficiency with long-term fairness and load distribution.
</div>
</div>
<pre><code class="language-python">class LoadBalancedDispatcher:
    &quot;&quot;&quot;
    Balance load across elevators while maintaining efficiency.

    Uses weighted scoring that considers:
    - Distance (efficiency)
    - Current load (fairness)
    - Recent assignment count (distribution)
    &quot;&quot;&quot;

    def __init__(self, elevators: List[Elevator]):
        self.elevators = elevators
        self.assignment_counts = {e.id: 0 for e in elevators}
        self.assignment_window = 100  # Reset counts after this many assignments
        self.total_assignments = 0

        # Tunable weights
        self.distance_weight = 0.5
        self.load_weight = 0.3
        self.fairness_weight = 0.2

    def assign_request(self, floor: int, direction: Direction) -&gt; Elevator:
        &quot;&quot;&quot;
        Assign with load balancing.

        Score = w1 * normalized_distance + w2 * normalized_load + w3 * normalized_assignments
        &quot;&quot;&quot;
        scores = []

        # Calculate raw metrics for normalization
        distances = [self._effective_distance(e, floor, direction) for e in self.elevators]
        loads = [len(e.up_stops) + len(e.down_stops) for e in self.elevators]
        assignments = [self.assignment_counts[e.id] for e in self.elevators]

        # Normalize to [0, 1] range
        max_dist = max(distances) if max(distances) &gt; 0 else 1
        max_load = max(loads) if max(loads) &gt; 0 else 1
        max_assign = max(assignments) if max(assignments) &gt; 0 else 1

        for i, elevator in enumerate(self.elevators):
            if elevator.state == ElevatorState.MAINTENANCE:
                scores.append(float('inf'))
                continue

            norm_distance = distances[i] / max_dist
            norm_load = loads[i] / max_load
            norm_assignments = assignments[i] / max_assign

            score = (
                self.distance_weight * norm_distance +
                self.load_weight * norm_load +
                self.fairness_weight * norm_assignments
            )
            scores.append(score)

        best_idx = scores.index(min(scores))
        best_elevator = self.elevators[best_idx]

        # Update assignment tracking
        self.assignment_counts[best_elevator.id] += 1
        self.total_assignments += 1

        if self.total_assignments &gt;= self.assignment_window:
            self._reset_assignment_counts()

        return best_elevator

    def _reset_assignment_counts(self):
        &quot;&quot;&quot;Reset assignment counts periodically to adapt to changing patterns.&quot;&quot;&quot;
        self.assignment_counts = {e.id: 0 for e in self.elevators}
        self.total_assignments = 0
</code></pre>
<h3 id="interview-questions-multi-elevator-coordination">Interview Questions: Multi-Elevator Coordination</h3>
<div>
<div>Level 1: Basic Coordination</div>
<div>
<p><strong>Q: Two elevators are equidistant from a request. How do you break the tie?</strong></p>
<p>Several reasonable tie-breaking strategies:</p>
<ol>
<li><strong>Lower load</strong>: Choose elevator with fewer pending stops (more capacity)</li>
<li><strong>Same direction preference</strong>: Choose elevator already going toward the request</li>
<li><strong>Elevator ID</strong>: Deterministic fallback (lower ID wins) ensures consistency</li>
<li><strong>Round-robin</strong>: Alternate between tied elevators for fairness</li>
<li><strong>Recent history</strong>: Choose the one that hasn't been assigned recently</li>
</ol>
<p>The best choice depends on system goals. For throughput, prefer lower load. For fairness, prefer round-robin. Most systems use a combination: primary tie-breaker is load, secondary is round-robin.</p>
<div>
<div>Level 2: Dynamic Adaptation</div>
<div>
<p><strong>Q: How would you handle &quot;rush hour&quot; scenarios where traffic patterns are highly skewed (e.g., 8-9 AM, everyone going from lobby to upper floors)?</strong></p>
<p>Rush hour requires proactive strategies beyond reactive assignment:</p>
<p><strong>1. Predictive positioning</strong>:</p>
<ul>
<li>At 7:55 AM, move idle elevators to lobby</li>
<li>After dropping passengers at high floors, return to lobby immediately (don't wait for calls)</li>
<li>Use historical data to predict demand patterns</li>
</ul>
<p><strong>2. Up-peak mode</strong>:</p>
<ul>
<li>Ignore down calls during extreme up-peak (controversial but effective)</li>
<li>Batch passengers at lobby by destination floor (requires destination dispatch)</li>
<li>Express service: some elevators skip lower floors entirely</li>
</ul>
<p><strong>3. Load shedding</strong>:</p>
<ul>
<li>If all elevators full, show &quot;please wait&quot; at lobby</li>
<li>Implement queue management at lobby (physical or virtual)</li>
<li>Stagger service to prevent all elevators arriving at lobby simultaneously</li>
</ul>
<p><strong>4. Dynamic zone adjustment</strong>:</p>
<ul>
<li>Temporarily reassign high-rise elevators to serve mid-rise floors</li>
<li>Expand low-rise zone upward during morning rush</li>
</ul>
<div>
<div>Level 3: Distributed Systems Challenges</div>
<div>
<p><strong>Q: The central dispatcher fails. How do elevators continue to operate? Design a fault-tolerant coordination mechanism.</strong></p>
<p>This is a <a href="/topics/system-design/distributed-consensus">[distributed-consensus]</a> problem in disguise:</p>
<p><strong>Immediate failover</strong>:</p>
<ol>
<li>Each elevator detects dispatcher heartbeat timeout (e.g., 5 seconds)</li>
<li>Elevators switch to &quot;local mode&quot;: accept requests directly, use local LOOK scheduling</li>
<li>Building displays show &quot;individual elevator&quot; mode to passengers</li>
</ol>
<p><strong>Coordination without central dispatcher</strong>:</p>
<ol>
<li><strong>Peer-to-peer communication</strong>: Elevators broadcast their position and stops to each other</li>
<li><strong>Claim-based assignment</strong>: When a hall call arrives, all elevators calculate their score. Lowest score &quot;claims&quot; the request by broadcasting. Tie-breaker: lower elevator ID.</li>
<li><strong>Conflict resolution</strong>: If two elevators claim simultaneously, use vector clocks or Lamport timestamps to determine winner.</li>
</ol>
<p><strong>Consistency challenges</strong>:</p>
<ul>
<li><strong>Split-brain</strong>: Network partition could cause two elevators to both claim a request. Solution: Use majority quorum or accept occasional duplicate service (better than no service).</li>
<li><strong>Message loss</strong>: Elevator claims request but broadcast is lost. Solution: Periodic state synchronization; unclaimed requests get re-broadcast.</li>
</ul>
<p><strong>Real-world approach</strong> (Otis, Schindler):</p>
<ul>
<li>Hot standby dispatcher: Second dispatcher in warm standby, takes over within milliseconds</li>
<li>Local fallback: Each elevator has full scheduling logic; central dispatcher is optimization, not requirement</li>
<li>Graceful degradation: System continues functioning, just less efficiently</li>
</ul>
<p>This mirrors patterns from distributed databases like <a href="/topics/system-design/raft">[raft-consensus]</a> where leader election handles coordinator failure.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="emergency-handling-and-safety-systems">Emergency Handling and Safety Systems</h2>
<p><span>Emergency handling</span> is a critical aspect of elevator systems that interviewers love to explore. It tests your understanding of <a href="/topics/system-design/fault-tolerance">[fault-tolerance]</a>, safety-critical design, and graceful degradation patterns.</p>
<div>
<div>Emergency Response Architecture</div>
<div>
<div>
<div>Fire Emergency</div>
<div>Phase 1 Recall</div>
<div>
All elevators → Lobby<br/>
Doors open & hold<br/>
Disable hall calls<br/>
Firefighter key override
</div>
</div>
<div>
<div>Power Failure</div>
<div>Battery Backup</div>
<div>
One elevator at a time<br/>
Move to nearest floor<br/>
Open doors safely<br/>
Evacuate passengers
</div>
</div>
<div>
<div>Earthquake</div>
<div>Seismic Protocol</div>
<div>
Stop at nearest floor<br/>
Open doors immediately<br/>
Disable all operation<br/>
Require inspection reset
</div>
</div>
<div>
<div>Entrapment</div>
<div>Rescue Mode</div>
<div>
Emergency intercom<br/>
Ventilation maintained<br/>
Position broadcast<br/>
Manual override access
</div>
</div>
</div>
</div>
<h3 id="emergency-state-machine-extension">Emergency State Machine Extension</h3>
<pre><code class="language-python">class EmergencyState(Enum):
    &quot;&quot;&quot;Emergency states that override normal operation.&quot;&quot;&quot;
    NORMAL = auto()           # Standard operation
    FIRE_PHASE1 = auto()      # Recall to lobby
    FIRE_PHASE2 = auto()      # Firefighter manual control
    EARTHQUAKE = auto()       # Stop at nearest, open doors
    POWER_FAILURE = auto()    # Battery backup mode
    ENTRAPMENT = auto()       # Stuck between floors
    MAINTENANCE = auto()      # Out of service


class EmergencyHandler:
    &quot;&quot;&quot;
    Handles emergency scenarios with proper state transitions.

    Key design principle: Safety over efficiency.
    Emergency states override ALL normal scheduling logic.

    Related: [[circuit-breaker]](/topics/system-design/circuit-breaker)
    &quot;&quot;&quot;

    def __init__(self, controller: 'ElevatorController'):
        self.controller = controller
        self.emergency_state = EmergencyState.NORMAL
        self.fire_recall_floor = 0  # Usually lobby
        self.alternate_recall_floor = 1  # If fire at lobby

    def trigger_fire_alarm(self, fire_floor: Optional[int] = None):
        &quot;&quot;&quot;
        Initiate fire emergency Phase 1 recall.

        All elevators return to designated floor, open doors, and hold.
        This is mandated by ASME A17.1 elevator safety code.
        &quot;&quot;&quot;
        self.emergency_state = EmergencyState.FIRE_PHASE1

        # Determine recall floor (avoid fire floor)
        recall_floor = self.fire_recall_floor
        if fire_floor == self.fire_recall_floor:
            recall_floor = self.alternate_recall_floor

        for elevator in self.controller.elevators:
            # Clear all pending stops
            elevator.up_stops.clear()
            elevator.down_stops.clear()

            # Set single destination: recall floor
            if elevator.current_floor != recall_floor:
                elevator.add_stop(recall_floor, None)

            # Mark as emergency mode
            elevator.emergency_mode = True
            elevator.doors_held_open = True

        # Disable all hall call buttons
        self.controller.accept_hall_calls = False

        # Log for audit
        self._log_emergency(&quot;FIRE_PHASE1&quot;, f&quot;Recall to floor {recall_floor}&quot;)

    def trigger_earthquake_mode(self, intensity: float):
        &quot;&quot;&quot;
        Seismic event response.

        Strategy: Get passengers out ASAP at nearest safe floor.
        &quot;&quot;&quot;
        self.emergency_state = EmergencyState.EARTHQUAKE

        for elevator in self.controller.elevators:
            # Find nearest floor
            current = elevator.current_floor
            nearest = round(current)  # In case between floors

            # Clear stops, go to nearest
            elevator.up_stops.clear()
            elevator.down_stops.clear()

            if nearest != current:
                elevator.add_stop(nearest, None)
            else:
                # Already at a floor, open doors immediately
                elevator.state = ElevatorState.DOORS_OPEN
                elevator.doors_held_open = True

            elevator.emergency_mode = True

        self.controller.accept_hall_calls = False
        self._log_emergency(&quot;EARTHQUAKE&quot;, f&quot;Intensity: {intensity}&quot;)

    def handle_power_failure(self):
        &quot;&quot;&quot;
        Battery backup evacuation mode.

        Challenge: Limited battery capacity means we can't run
        all elevators simultaneously. Process one at a time.
        &quot;&quot;&quot;
        self.emergency_state = EmergencyState.POWER_FAILURE

        # Sort elevators by passenger count (evacuate occupied first)
        occupied = [e for e in self.controller.elevators if e.current_passengers &gt; 0]
        empty = [e for e in self.controller.elevators if e.current_passengers == 0]

        # Queue for sequential evacuation
        evacuation_queue = occupied + empty

        # Only first elevator operates on battery
        for i, elevator in enumerate(evacuation_queue):
            if i == 0:
                elevator.battery_mode = True
                nearest = round(elevator.current_floor)
                elevator.add_stop(nearest, None)
            else:
                # Suspend other elevators
                elevator.state = ElevatorState.EMERGENCY
                elevator.suspended = True

        self._log_emergency(&quot;POWER_FAILURE&quot;, f&quot;Evacuating {len(occupied)} occupied elevators&quot;)

    def handle_entrapment(self, elevator_id: int):
        &quot;&quot;&quot;
        Passenger trapped between floors.

        This is a critical scenario requiring:
        1. Communication with passengers
        2. Position tracking for rescue
        3. Ventilation maintenance
        &quot;&quot;&quot;
        elevator = self.controller.elevators[elevator_id]
        elevator.state = ElevatorState.EMERGENCY
        elevator.entrapment_detected = True

        # Activate emergency systems
        elevator.intercom_active = True
        elevator.ventilation_boost = True

        # Broadcast position for rescue
        position_info = {
            'elevator_id': elevator_id,
            'floor_position': elevator.current_floor,
            'between_floors': not elevator.current_floor.is_integer(),
            'passengers': elevator.current_passengers,
            'timestamp': time.time()
        }

        self._broadcast_rescue_info(position_info)
        self._log_emergency(&quot;ENTRAPMENT&quot;, f&quot;Elevator {elevator_id} at {elevator.current_floor}&quot;)

    def reset_emergency(self, authorized_key: str) -&gt; bool:
        &quot;&quot;&quot;
        Reset from emergency state (requires authorization).

        Only building management or emergency services can reset.
        Prevents unauthorized resumption of service.
        &quot;&quot;&quot;
        if not self._validate_authorization(authorized_key):
            return False

        self.emergency_state = EmergencyState.NORMAL

        for elevator in self.controller.elevators:
            elevator.emergency_mode = False
            elevator.doors_held_open = False
            elevator.battery_mode = False
            elevator.suspended = False
            elevator.state = ElevatorState.IDLE

        self.controller.accept_hall_calls = True
        self._log_emergency(&quot;RESET&quot;, &quot;Normal operation resumed&quot;)
        return True
</code></pre>
<h3 id="emergency-response-flow-diagram">Emergency Response Flow Diagram</h3>
<div>
<div>Emergency Detection and Response Flow</div>
<div>
<div>
<div>
<div>TRIGGER DETECTED</div>
<div>Fire/Quake/Power/Manual</div>
</div>
<div>→</div>
<div>
<div>HALT NEW REQUESTS</div>
<div>Disable hall buttons</div>
</div>
<div>→</div>
<div>
<div>CLEAR STOP QUEUES</div>
<div>Override scheduling</div>
</div>
</div>
<div>
<div>
<div>EXECUTE PROTOCOL</div>
<div>Type-specific response</div>
</div>
<div>→</div>
<div>
<div>SAFE STATE REACHED</div>
<div>Passengers evacuated</div>
</div>
<div>→</div>
<div>
<div>AWAIT RESET</div>
<div>Authorized personnel</div>
</div>
</div>
</div>
</div>
<h3 id="interview-questions-emergency-handling">Interview Questions: Emergency Handling</h3>
<div>
<div>Level 1: Basic Emergency Design</div>
<div>
<p><strong>Q: Why do elevators return to the lobby during a fire alarm instead of the nearest floor?</strong></p>
<p>The lobby is typically the <span>primary egress point</span> for a building and where firefighters will enter. Returning all elevators to lobby:</p>
<ol>
<li><strong>Centralizes evacuation</strong>: Passengers exit through monitored, accessible ground floor</li>
<li><strong>Firefighter access</strong>: Firefighters can commandeer elevators from lobby for rescue operations</li>
<li><strong>Smoke avoidance</strong>: Lobbies typically have better ventilation and fire separation</li>
<li><strong>Standardization</strong>: Emergency responders know exactly where to find the elevators</li>
</ol>
<p>Exception: If the fire is AT the lobby, elevators go to an alternate recall floor (usually one floor up).</p>
<div>
<div>Level 2: Safety Invariants</div>
<div>
<p><strong>Q: What safety invariants must NEVER be violated, even in software bugs? How do you enforce them?</strong></p>
<p>Critical <span>safety invariants</span> for elevator systems:</p>
<ol>
<li><strong>Elevator must not move with doors open</strong> - Enforced by hardware interlock (physical switch cuts motor power)</li>
<li><strong>Doors must not open between floors</strong> - Door motor circuit includes floor-position sensor</li>
<li><strong>Overspeed must trigger emergency brake</strong> - Mechanical governor activates independently of software</li>
<li><strong>Free-fall must be prevented</strong> - Multiple independent brake systems (rope brakes, safety gear)</li>
</ol>
<p><strong>Software enforcement is insufficient</strong> because:</p>
<ul>
<li>Software can have bugs, race conditions, memory corruption</li>
<li>Hardware provides independent safety layer</li>
<li>Regulations (ASME A17.1) mandate hardware interlocks</li>
</ul>
<p><strong>Design pattern</strong>: <span>Defense in depth</span> - multiple independent mechanisms protecting each invariant.</p>
<div>
<div>Level 3: Partial Failure Scenarios</div>
<div>
<p><strong>Q: The building loses power, but only 2 of 6 elevators have passengers. Battery backup can only run one elevator at a time for 30 minutes total. Design the evacuation strategy.</strong></p>
<p>This is a <span>resource-constrained optimization</span> problem:</p>
<p><strong>Analysis</strong>:</p>
<ul>
<li>2 occupied elevators need evacuation</li>
<li>30 minutes battery, 1 elevator at a time</li>
<li>Moving one floor typically takes ~5-10 seconds</li>
<li>Door open/close cycle ~10-15 seconds</li>
</ul>
<p><strong>Strategy</strong>:</p>
<pre><code>1. PRIORITIZE by risk:
   - Elevator with medical emergency passengers FIRST
   - Elevator with more passengers (maximize evacuees per battery-minute)
   - Elevator further from a floor (longer travel time)

2. OPTIMIZE movement:
   - Calculate nearest floor for each occupied elevator
   - Evacuate elevator that needs LESS movement first
   - This maximizes remaining battery for second elevator

3. SEQUENTIAL execution:
   - Power elevator A → nearest floor → open doors → passengers exit
   - Power elevator A → move to safe parking position (optional)
   - Switch to elevator B → repeat

4. FALLBACK if battery depletes:
   - Remaining passengers use emergency intercom
   - Ventilation runs on separate battery (longer duration)
   - Fire department notified for manual extraction
</code></pre>
<p><strong>Key insight</strong>: This mirrors <a href="/topics/operating-systems/scheduling">[resource-scheduling]</a> problems where you must make optimal decisions with limited resources. The &quot;shortest job first&quot; heuristic (evacuate faster elevator first) maximizes total passengers evacuated.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<h3 id="fire-service-phase-2-operation">Fire Service Phase 2 Operation</h3>
<div>
<div>Firefighter Manual Control Mode</div>
<div>
<p>After Phase 1 recall, firefighters can activate <span>Phase 2 operation</span> using a special key. In this mode:</p>
<ul>
<li><strong>Only in-car controls work</strong> (hall buttons remain disabled)</li>
<li><strong>Doors require constant pressure</strong> (dead-man switch for safety)</li>
<li><strong>Car call buttons illuminate but don't auto-close doors</strong></li>
<li><strong>Firefighter can override door obstruction sensors</strong></li>
</ul>
<p>This mode enables firefighters to:</p>
<ul>
<li>Access floors for rescue operations</li>
<li>Transport equipment up the building</li>
<li>Evacuate injured persons</li>
</ul>
<p><strong>Implementation note</strong>: Phase 2 is NOT automated—it's manual control with minimal software involvement, reducing failure modes during critical operations.</p>
</div>
</div>
<pre><code class="language-python">class FirefighterMode:
    &quot;&quot;&quot;
    Phase 2 firefighter operation mode.

    This is intentionally SIMPLE - minimal logic, maximum manual control.
    Complexity is the enemy of safety in emergency scenarios.
    &quot;&quot;&quot;

    def __init__(self, elevator: Elevator):
        self.elevator = elevator
        self.active = False
        self.door_hold_pressed = False

    def activate(self, firefighter_key: bool) -&gt; bool:
        &quot;&quot;&quot;Activate with physical key switch.&quot;&quot;&quot;
        if not firefighter_key:
            return False

        self.active = True
        self.elevator.automatic_doors = False
        self.elevator.hall_calls_enabled = False
        return True

    def move_to_floor(self, floor: int, door_hold: bool) -&gt; bool:
        &quot;&quot;&quot;
        Manual floor selection with door control.

        Door only stays open while door_hold is pressed (dead-man switch).
        This prevents firefighter from being separated from elevator.
        &quot;&quot;&quot;
        if not self.active:
            return False

        if not door_hold:
            # Must hold door button to move
            self.elevator.state = ElevatorState.DOORS_CLOSING
            return False

        # Close doors and move
        self.elevator.up_stops.clear()
        self.elevator.down_stops.clear()
        self.elevator.add_stop(floor, None)
        return True

    def hold_doors_open(self, pressed: bool):
        &quot;&quot;&quot;Doors only stay open while button is held.&quot;&quot;&quot;
        self.door_hold_pressed = pressed
        if pressed:
            self.elevator.state = ElevatorState.DOORS_OPEN
        else:
            self.elevator.state = ElevatorState.DOORS_CLOSING
</code></pre>
<hr />
<h2 id="complete-implementation">Complete Implementation</h2>
<pre><code class="language-python">&quot;&quot;&quot;
Complete Elevator System Implementation

This implementation demonstrates:
- State machine-based elevator control
- LOOK scheduling algorithm
- Multi-elevator coordination with load balancing
- Thread-safe concurrent operation
- Comprehensive edge case handling

Related concepts:
- [[state-machine]](/topics/system-design/state-machine)
- [[producer-consumer]](/topics/concurrency/producer-consumer)
- [[scheduling-algorithms]](/topics/operating-systems/scheduling)
&quot;&quot;&quot;

from enum import Enum, auto
from typing import List, Optional, Set, Dict, Callable
from dataclasses import dataclass, field
from collections import deque
import threading
import time
import heapq


class Direction(Enum):
    &quot;&quot;&quot;Movement direction with numeric values for arithmetic.&quot;&quot;&quot;
    UP = 1
    DOWN = -1
    IDLE = 0

    def opposite(self) -&gt; 'Direction':
        if self == Direction.UP:
            return Direction.DOWN
        elif self == Direction.DOWN:
            return Direction.UP
        return Direction.IDLE


class ElevatorState(Enum):
    &quot;&quot;&quot;Elevator operational states.&quot;&quot;&quot;
    IDLE = auto()
    MOVING_UP = auto()
    MOVING_DOWN = auto()
    DOORS_OPEN = auto()
    DOORS_CLOSING = auto()
    MAINTENANCE = auto()
    EMERGENCY = auto()


@dataclass(order=True)
class Request:
    &quot;&quot;&quot;
    Represents a floor request with priority support.

    Design decision: Use dataclass with ordering for priority queue compatibility.
    Priority is negative timestamp (older requests have higher priority).
    &quot;&quot;&quot;
    priority: float = field(compare=True)  # Negative timestamp for min-heap
    floor: int = field(compare=False)
    direction: Direction = field(compare=False)
    timestamp: float = field(default_factory=time.time, compare=False)
    request_type: str = field(default=&quot;hall&quot;, compare=False)  # &quot;hall&quot; or &quot;car&quot;

    @classmethod
    def create(cls, floor: int, direction: Direction, request_type: str = &quot;hall&quot;):
        ts = time.time()
        return cls(priority=-ts, floor=floor, direction=direction, timestamp=ts, request_type=request_type)


class Elevator:
    &quot;&quot;&quot;
    Single elevator with LOOK scheduling.

    Key design decisions:
    - Separate up_stops and down_stops for direction-aware scheduling
    - Thread-safe operations with RLock (reentrant for nested calls)
    - State machine pattern for clear operational logic
    &quot;&quot;&quot;

    def __init__(
        self,
        elevator_id: int,
        min_floor: int = 0,
        max_floor: int = 10,
        door_open_time: float = 3.0
    ):
        self.id = elevator_id
        self.min_floor = min_floor
        self.max_floor = max_floor
        self.door_open_time = door_open_time

        # Current state
        self.current_floor = min_floor
        self.state = ElevatorState.IDLE
        self.direction = Direction.IDLE

        # Stop tracking (LOOK algorithm uses two sets)
        self.up_stops: Set[int] = set()
        self.down_stops: Set[int] = set()

        # Capacity tracking
        self.max_capacity = 10
        self.current_passengers = 0

        # Thread safety
        self.lock = threading.RLock()

        # Callbacks for external notification
        self.on_arrival: Optional[Callable[[int, int], None]] = None
        self.on_state_change: Optional[Callable[[int, ElevatorState], None]] = None

    def add_stop(self, floor: int, direction: Optional[Direction] = None) -&gt; bool:
        &quot;&quot;&quot;
        Add a floor to the stop list.

        Logic:
        1. Validate floor is in range
        2. Determine appropriate stop set based on direction
        3. Handle edge case: already at requested floor

        Returns True if stop was added or elevator is already there.
        &quot;&quot;&quot;
        with self.lock:
            # Validate
            if floor &lt; self.min_floor or floor &gt; self.max_floor:
                return False

            # Already at this floor and idle/doors open
            if floor == self.current_floor and self.state in [ElevatorState.IDLE, ElevatorState.DOORS_OPEN]:
                return True

            # Determine which set to add to
            if direction == Direction.UP:
                self.up_stops.add(floor)
            elif direction == Direction.DOWN:
                self.down_stops.add(floor)
            elif floor &gt; self.current_floor:
                self.up_stops.add(floor)
            elif floor &lt; self.current_floor:
                self.down_stops.add(floor)
            else:
                # floor == current_floor but elevator is moving
                # Add to current direction's stops
                if self.direction == Direction.UP:
                    self.up_stops.add(floor)
                else:
                    self.down_stops.add(floor)

            return True

    def get_next_stop(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Determine next stop using LOOK algorithm.

        LOOK: Continue in current direction until no more stops,
        then reverse. Don't go to building boundary unnecessarily.
        &quot;&quot;&quot;
        with self.lock:
            if self.direction == Direction.UP or self.direction == Direction.IDLE:
                # Check for stops above
                above = [f for f in self.up_stops if f &gt; self.current_floor]
                if above:
                    return min(above)

                # Check for stops at current floor
                if self.current_floor in self.up_stops:
                    return self.current_floor

                # No stops above, check down stops (reverse direction)
                if self.down_stops:
                    return max(self.down_stops)

                # Check remaining up stops below (direction already reversed)
                if self.up_stops:
                    return max(self.up_stops)

            if self.direction == Direction.DOWN or self.direction == Direction.IDLE:
                # Check for stops below
                below = [f for f in self.down_stops if f &lt; self.current_floor]
                if below:
                    return max(below)

                # Check for stops at current floor
                if self.current_floor in self.down_stops:
                    return self.current_floor

                # No stops below, check up stops (reverse direction)
                if self.up_stops:
                    return min(self.up_stops)

                # Check remaining down stops above
                if self.down_stops:
                    return min(self.down_stops)

            return None

    def step(self) -&gt; Dict:
        &quot;&quot;&quot;
        Advance elevator by one time unit.

        Returns status dict including any arrival events.
        &quot;&quot;&quot;
        with self.lock:
            result = {
                'elevator_id': self.id,
                'floor': self.current_floor,
                'state': self.state.name,
                'arrived': False
            }

            # Handle door closing
            if self.state == ElevatorState.DOORS_CLOSING:
                self._close_doors()
                result['state'] = self.state.name
                return result

            # Handle doors open (waiting)
            if self.state == ElevatorState.DOORS_OPEN:
                # In real system, timer would handle this
                # For simulation, we transition immediately
                self.state = ElevatorState.DOORS_CLOSING
                result['state'] = self.state.name
                return result

            # Get next stop
            next_stop = self.get_next_stop()

            if next_stop is None:
                self.state = ElevatorState.IDLE
                self.direction = Direction.IDLE
                result['state'] = self.state.name
                return result

            # Move toward next stop
            if next_stop &gt; self.current_floor:
                self.direction = Direction.UP
                self.state = ElevatorState.MOVING_UP
                self.current_floor += 1
            elif next_stop &lt; self.current_floor:
                self.direction = Direction.DOWN
                self.state = ElevatorState.MOVING_DOWN
                self.current_floor -= 1

            result['floor'] = self.current_floor
            result['state'] = self.state.name

            # Check if we've arrived at a stop
            if self.current_floor == next_stop:
                self._arrive_at_floor()
                result['arrived'] = True
                result['state'] = self.state.name

                if self.on_arrival:
                    self.on_arrival(self.id, self.current_floor)

            return result

    def _arrive_at_floor(self):
        &quot;&quot;&quot;Handle arrival at a floor.&quot;&quot;&quot;
        # Remove from stop sets
        self.up_stops.discard(self.current_floor)
        self.down_stops.discard(self.current_floor)

        # Open doors
        self.state = ElevatorState.DOORS_OPEN

    def _close_doors(self):
        &quot;&quot;&quot;Handle door closing and decide next state.&quot;&quot;&quot;
        if self.up_stops or self.down_stops:
            next_stop = self.get_next_stop()
            if next_stop is not None:
                if next_stop &gt; self.current_floor:
                    self.state = ElevatorState.MOVING_UP
                    self.direction = Direction.UP
                else:
                    self.state = ElevatorState.MOVING_DOWN
                    self.direction = Direction.DOWN
            else:
                self.state = ElevatorState.IDLE
                self.direction = Direction.IDLE
        else:
            self.state = ElevatorState.IDLE
            self.direction = Direction.IDLE

    def effective_distance(self, floor: int, direction: Direction) -&gt; int:
        &quot;&quot;&quot;
        Calculate effective distance to serve a request.

        This is the key metric for elevator assignment.
        Considers current position, direction, and pending stops.
        &quot;&quot;&quot;
        with self.lock:
            # Idle: simple distance
            if self.direction == Direction.IDLE:
                return abs(self.current_floor - floor)

            # Same direction, floor is ahead
            if self.direction == Direction.UP and direction == Direction.UP:
                if floor &gt;= self.current_floor:
                    return floor - self.current_floor

            if self.direction == Direction.DOWN and direction == Direction.DOWN:
                if floor &lt;= self.current_floor:
                    return self.current_floor - floor

            # Need to complete current direction first
            if self.direction == Direction.UP:
                max_stop = max(self.up_stops) if self.up_stops else self.current_floor
                return (max_stop - self.current_floor) + abs(max_stop - floor)
            else:
                min_stop = min(self.down_stops) if self.down_stops else self.current_floor
                return (self.current_floor - min_stop) + abs(floor - min_stop)

    def has_pending_stops(self) -&gt; bool:
        &quot;&quot;&quot;Check if elevator has any pending stops.&quot;&quot;&quot;
        return len(self.up_stops) &gt; 0 or len(self.down_stops) &gt; 0

    def pending_stop_count(self) -&gt; int:
        &quot;&quot;&quot;Get total number of pending stops.&quot;&quot;&quot;
        return len(self.up_stops) + len(self.down_stops)

    def status(self) -&gt; Dict:
        &quot;&quot;&quot;Get current elevator status.&quot;&quot;&quot;
        with self.lock:
            return {
                'id': self.id,
                'floor': self.current_floor,
                'state': self.state.name,
                'direction': self.direction.name,
                'up_stops': sorted(self.up_stops),
                'down_stops': sorted(self.down_stops),
                'passengers': self.current_passengers
            }


class ElevatorController:
    &quot;&quot;&quot;
    Central controller for multi-elevator coordination.

    Responsibilities:
    - Receive and route requests
    - Assign optimal elevator to each request
    - Coordinate elevator movements
    - Provide system-wide status
    - Handle edge cases (all busy, maintenance, etc.)

    Related: [[load-balancer]](/topics/system-design/load-balancer)
    &quot;&quot;&quot;

    def __init__(self, num_elevators: int, num_floors: int):
        self.num_floors = num_floors
        self.elevators = [
            Elevator(i, 0, num_floors - 1)
            for i in range(num_elevators)
        ]

        # Pending requests that couldn't be immediately assigned
        self.pending_requests: List[Request] = []

        # Assignment tracking for load balancing
        self.assignment_counts = {i: 0 for i in range(num_elevators)}

        # Thread safety
        self.lock = threading.Lock()

        # Configuration
        self.max_pending_requests = 100
        self.assignment_reset_interval = 50
        self.total_assignments = 0

        # Weights for scoring (tunable)
        self.distance_weight = 0.5
        self.load_weight = 0.3
        self.fairness_weight = 0.2

    def request_elevator(self, floor: int, direction: Direction) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Handle hall call (external request).

        Returns assigned elevator ID, or None if request was queued.
        &quot;&quot;&quot;
        with self.lock:
            # Validate
            if floor &lt; 0 or floor &gt;= self.num_floors:
                raise ValueError(f&quot;Invalid floor: {floor}&quot;)

            # Find best elevator
            best_elevator = self._find_best_elevator(floor, direction)

            if best_elevator is None:
                # All elevators busy or in maintenance
                if len(self.pending_requests) &lt; self.max_pending_requests:
                    self.pending_requests.append(Request.create(floor, direction, &quot;hall&quot;))
                return None

            # Assign to elevator
            best_elevator.add_stop(floor, direction)
            self._update_assignment_tracking(best_elevator.id)

            return best_elevator.id

    def select_floor(self, elevator_id: int, floor: int) -&gt; bool:
        &quot;&quot;&quot;
        Handle car call (internal request from inside elevator).
        &quot;&quot;&quot;
        if elevator_id &lt; 0 or elevator_id &gt;= len(self.elevators):
            return False

        elevator = self.elevators[elevator_id]

        # Determine direction based on current floor
        if floor &gt; elevator.current_floor:
            direction = Direction.UP
        elif floor &lt; elevator.current_floor:
            direction = Direction.DOWN
        else:
            return True  # Already at floor

        return elevator.add_stop(floor, direction)

    def _find_best_elevator(self, floor: int, direction: Direction) -&gt; Optional[Elevator]:
        &quot;&quot;&quot;
        Find optimal elevator using weighted scoring.

        Score considers:
        - Effective distance (efficiency)
        - Current load (capacity)
        - Recent assignments (fairness)
        &quot;&quot;&quot;
        candidates = []

        for elevator in self.elevators:
            if elevator.state in [ElevatorState.MAINTENANCE, ElevatorState.EMERGENCY]:
                continue

            # Calculate metrics
            distance = elevator.effective_distance(floor, direction)
            load = elevator.pending_stop_count()
            assignments = self.assignment_counts[elevator.id]

            candidates.append({
                'elevator': elevator,
                'distance': distance,
                'load': load,
                'assignments': assignments
            })

        if not candidates:
            return None

        # Normalize and score
        max_distance = max(c['distance'] for c in candidates) or 1
        max_load = max(c['load'] for c in candidates) or 1
        max_assignments = max(c['assignments'] for c in candidates) or 1

        best_score = float('inf')
        best_elevator = None

        for c in candidates:
            score = (
                self.distance_weight * (c['distance'] / max_distance) +
                self.load_weight * (c['load'] / max_load) +
                self.fairness_weight * (c['assignments'] / max_assignments)
            )

            if score &lt; best_score:
                best_score = score
                best_elevator = c['elevator']

        return best_elevator

    def _update_assignment_tracking(self, elevator_id: int):
        &quot;&quot;&quot;Update assignment counts for load balancing.&quot;&quot;&quot;
        self.assignment_counts[elevator_id] += 1
        self.total_assignments += 1

        if self.total_assignments &gt;= self.assignment_reset_interval:
            self.assignment_counts = {i: 0 for i in range(len(self.elevators))}
            self.total_assignments = 0

    def step(self) -&gt; List[Dict]:
        &quot;&quot;&quot;
        Advance all elevators by one time unit.

        Also processes pending requests.
        &quot;&quot;&quot;
        results = []

        with self.lock:
            # Step each elevator
            for elevator in self.elevators:
                result = elevator.step()
                results.append(result)

            # Try to assign pending requests
            self._process_pending_requests()

        return results

    def _process_pending_requests(self):
        &quot;&quot;&quot;Attempt to assign pending requests to available elevators.&quot;&quot;&quot;
        if not self.pending_requests:
            return

        # Sort by timestamp (oldest first)
        self.pending_requests.sort(key=lambda r: r.timestamp)

        still_pending = []
        for request in self.pending_requests:
            elevator = self._find_best_elevator(request.floor, request.direction)
            if elevator:
                elevator.add_stop(request.floor, request.direction)
                self._update_assignment_tracking(elevator.id)
            else:
                still_pending.append(request)

        self.pending_requests = still_pending

    def get_status(self) -&gt; Dict:
        &quot;&quot;&quot;Get complete system status.&quot;&quot;&quot;
        return {
            'elevators': [e.status() for e in self.elevators],
            'pending_requests': len(self.pending_requests),
            'total_assignments': self.total_assignments
        }

    def display_status(self):
        &quot;&quot;&quot;Print formatted system status.&quot;&quot;&quot;
        print(&quot;\n&quot; + &quot;=&quot; * 50)
        print(&quot;ELEVATOR SYSTEM STATUS&quot;)
        print(&quot;=&quot; * 50)

        for elevator in self.elevators:
            status = elevator.status()
            direction_symbol = {'UP': '^', 'DOWN': 'v', 'IDLE': '-'}

            print(f&quot;\nElevator {status['id']}: Floor {status['floor']} &quot;
                  f&quot;[{direction_symbol[status['direction']]}] &quot;
                  f&quot;State: {status['state']}&quot;)

            if status['up_stops']:
                print(f&quot;  Up stops: {status['up_stops']}&quot;)
            if status['down_stops']:
                print(f&quot;  Down stops: {status['down_stops']}&quot;)

        if self.pending_requests:
            print(f&quot;\nPending requests: {len(self.pending_requests)}&quot;)


def run_simulation():
    &quot;&quot;&quot;Demonstrate elevator system operation.&quot;&quot;&quot;
    print(&quot;=&quot; * 60)
    print(&quot;ELEVATOR SYSTEM SIMULATION&quot;)
    print(&quot;=&quot; * 60)

    # Create controller: 3 elevators, 15 floors
    controller = ElevatorController(num_elevators=3, num_floors=15)

    # Simulate rush hour: multiple requests from lobby
    print(&quot;\n--- Morning Rush Hour Simulation ---&quot;)
    print(&quot;Multiple passengers at lobby want to go up&quot;)

    requests = [
        (0, Direction.UP),   # Lobby to upper floors
        (0, Direction.UP),
        (0, Direction.UP),
        (5, Direction.UP),   # Mid floor going up
        (10, Direction.DOWN), # Upper floor going down
        (7, Direction.DOWN),
    ]

    for floor, direction in requests:
        elevator_id = controller.request_elevator(floor, direction)
        print(f&quot;Request: Floor {floor} {direction.name} -&gt; Assigned to Elevator {elevator_id}&quot;)

    # Passengers select destinations
    print(&quot;\n--- Passengers Select Destinations ---&quot;)
    controller.select_floor(0, 8)   # Elevator 0 passenger goes to 8
    controller.select_floor(0, 12)  # Another passenger in elevator 0 goes to 12
    controller.select_floor(1, 6)   # Elevator 1 passenger goes to 6
    controller.select_floor(2, 3)   # Elevator 2 passenger goes to 3

    print(&quot;\n--- Running Simulation ---&quot;)
    for step in range(25):
        print(f&quot;\n=== Step {step + 1} ===&quot;)
        results = controller.step()

        for result in results:
            if result['arrived']:
                print(f&quot;  * Elevator {result['elevator_id']} arrived at floor {result['floor']}&quot;)

        controller.display_status()
        time.sleep(0.3)

        # Check if all done
        all_idle = all(
            e.state == ElevatorState.IDLE and not e.has_pending_stops()
            for e in controller.elevators
        )
        if all_idle and not controller.pending_requests:
            print(&quot;\n--- All requests served ---&quot;)
            break


if __name__ == &quot;__main__&quot;:
    run_simulation()
</code></pre>
<hr />
<h2 id="edge-cases-and-error-handling">Edge Cases and Error Handling</h2>
<div>
<div>Critical Edge Cases</div>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Problem</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Request at current floor</strong></td>
<td>Elevator might add to wrong stop set</td>
<td>Check if floor == current_floor; if idle, open doors immediately</td>
</tr>
<tr>
<td><strong>All elevators at max capacity</strong></td>
<td>New requests can't be served</td>
<td>Queue request, assign when capacity available; show &quot;please wait&quot;</td>
</tr>
<tr>
<td><strong>Elevator breakdown mid-trip</strong></td>
<td>Passengers stranded, stops orphaned</td>
<td>Redistribute stops to other elevators; emergency procedures</td>
</tr>
<tr>
<td><strong>Simultaneous requests same floor</strong></td>
<td>Multiple elevators might respond</td>
<td>Deduplication in dispatcher; only one elevator assigned per floor/direction</td>
</tr>
<tr>
<td><strong>Request during door close</strong></td>
<td>Door might close on passenger</td>
<td>Door obstruction sensor; reopen on detection</td>
</tr>
<tr>
<td><strong>Power failure</strong></td>
<td>System state lost</td>
<td>Battery backup for orderly shutdown; state persistence</td>
</tr>
<tr>
<td><strong>Invalid floor from API</strong></td>
<td>System crash or undefined behavior</td>
<td>Input validation at all entry points</td>
</tr>
<tr>
<td><strong>Rapid repeated requests</strong></td>
<td>System overload</td>
<td>Rate limiting; request deduplication</td>
</tr>
</tbody>
</table>
</div>
<h3 id="request-deduplication">Request Deduplication</h3>
<pre><code class="language-python">class DeduplicatingDispatcher:
    &quot;&quot;&quot;
    Prevent redundant elevator assignments for identical requests.

    Scenario: Multiple passengers at floor 5 press UP button within seconds.
    Without deduplication, system might assign multiple elevators.
    &quot;&quot;&quot;

    def __init__(self, controller: ElevatorController):
        self.controller = controller
        self.active_requests: Dict[tuple, float] = {}  # (floor, direction) -&gt; timestamp
        self.dedup_window = 30.0  # seconds

    def request_elevator(self, floor: int, direction: Direction) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Process request with deduplication.

        If identical request exists within window, return existing assignment.
        &quot;&quot;&quot;
        key = (floor, direction)
        current_time = time.time()

        # Clean expired entries
        self._cleanup_expired(current_time)

        # Check for existing active request
        if key in self.active_requests:
            # Request already being served
            # Find which elevator is handling it
            for elevator in self.controller.elevators:
                if direction == Direction.UP and floor in elevator.up_stops:
                    return elevator.id
                if direction == Direction.DOWN and floor in elevator.down_stops:
                    return elevator.id
            # Elevator already arrived and cleared the stop
            del self.active_requests[key]

        # New request
        elevator_id = self.controller.request_elevator(floor, direction)
        if elevator_id is not None:
            self.active_requests[key] = current_time

        return elevator_id

    def _cleanup_expired(self, current_time: float):
        &quot;&quot;&quot;Remove request entries older than dedup window.&quot;&quot;&quot;
        expired = [
            key for key, timestamp in self.active_requests.items()
            if current_time - timestamp &gt; self.dedup_window
        ]
        for key in expired:
            del self.active_requests[key]
</code></pre>
<h3 id="capacity-management">Capacity Management</h3>
<pre><code class="language-python">class CapacityAwareElevator(Elevator):
    &quot;&quot;&quot;
    Elevator with passenger capacity tracking.

    Design decision: Track passenger count, not weight.
    Real systems use weight sensors, but count is simpler for simulation.
    &quot;&quot;&quot;

    def __init__(self, *args, max_capacity: int = 10, **kwargs):
        super().__init__(*args, **kwargs)
        self.max_capacity = max_capacity
        self.current_passengers = 0

    def can_accept_passengers(self, count: int = 1) -&gt; bool:
        &quot;&quot;&quot;Check if elevator can accept more passengers.&quot;&quot;&quot;
        return self.current_passengers + count &lt;= self.max_capacity

    def board_passengers(self, count: int) -&gt; bool:
        &quot;&quot;&quot;
        Passengers board elevator.

        Returns False if would exceed capacity.
        &quot;&quot;&quot;
        if not self.can_accept_passengers(count):
            return False
        self.current_passengers += count
        return True

    def exit_passengers(self, count: int):
        &quot;&quot;&quot;Passengers exit elevator.&quot;&quot;&quot;
        self.current_passengers = max(0, self.current_passengers - count)

    def is_full(self) -&gt; bool:
        &quot;&quot;&quot;Check if elevator is at capacity.&quot;&quot;&quot;
        return self.current_passengers &gt;= self.max_capacity
</code></pre>
<h3 id="interview-questions-edge-cases">Interview Questions: Edge Cases</h3>
<div>
<div>Level 1: Basic Error Handling</div>
<div>
<p><strong>Q: A passenger inside the elevator presses a floor button that's in the opposite direction of travel. What happens?</strong></p>
<p>The request should be accepted and added to the appropriate stop set:</p>
<ol>
<li>If elevator is going UP and passenger presses a floor below, add to <code>down_stops</code></li>
<li>Elevator continues UP, serves all <code>up_stops</code>, then reverses and serves <code>down_stops</code></li>
<li>Passenger waits longer but their request is eventually served</li>
</ol>
<p>This is correct LOOK algorithm behavior. The alternative—rejecting the request—would strand passengers who made mistakes or changed their minds.</p>
<div>
<div>Level 2: Race Conditions</div>
<div>
<p><strong>Q: Two requests arrive simultaneously: Floor 5 UP and Floor 5 DOWN. How does the system handle this?</strong></p>
<p>This is a valid scenario (two people at same floor going opposite directions). The system should:</p>
<ol>
<li><strong>Assign potentially different elevators</strong>: Floor 5 UP might go to an elevator going up; Floor 5 DOWN to one going down</li>
<li><strong>Or assign same elevator</strong>: If one elevator can efficiently serve both (it's idle at floor 5), assign both to it</li>
<li><strong>Serve sequentially</strong>: Elevator stops at floor 5, opens doors. Passenger going in current direction boards. Elevator continues.</li>
</ol>
<p><strong>Race condition concern</strong>: If both requests processed simultaneously, ensure the stop sets are updated atomically. With proper locking:</p>
<pre><code class="language-python">with self.lock:
    elevator.up_stops.add(5)
    # Between these lines, another thread shouldn't see partial state
    elevator.down_stops.add(5)
</code></pre>
<p>Both stops are independent and can coexist. When elevator arrives at 5, it should serve the current-direction stop, let those passengers board, then handle direction change for the other stop.</p>
<div>
<div>Level 3: Cascading Failures</div>
<div>
<p><strong>Q: One elevator fails mid-trip with passengers inside. How do you prevent this failure from cascading and ensure other elevators handle the load?</strong></p>
<p>This requires a comprehensive failure handling strategy:</p>
<p><strong>Immediate response</strong>:</p>
<ol>
<li><strong>Detect failure</strong>: Watchdog timer detects elevator hasn't reported status for threshold period</li>
<li><strong>Mark unavailable</strong>: Set failed elevator to EMERGENCY state, remove from assignment pool</li>
<li><strong>Notify occupants</strong>: In-cabin communication system alerts passengers, emergency services if needed</li>
</ol>
<p><strong>Stop redistribution</strong>:</p>
<pre><code class="language-python">def handle_elevator_failure(self, failed_id: int):
    failed_elevator = self.elevators[failed_id]

    # Collect orphaned stops
    orphaned_stops = []
    for floor in failed_elevator.up_stops:
        orphaned_stops.append((floor, Direction.UP))
    for floor in failed_elevator.down_stops:
        orphaned_stops.append((floor, Direction.DOWN))

    # Clear failed elevator's stops
    failed_elevator.up_stops.clear()
    failed_elevator.down_stops.clear()
    failed_elevator.state = ElevatorState.EMERGENCY

    # Redistribute to other elevators
    for floor, direction in orphaned_stops:
        self.request_elevator(floor, direction)  # Uses remaining elevators
</code></pre>
<p><strong>Preventing cascade</strong>:</p>
<ol>
<li><strong>Circuit breaker pattern</strong>: If multiple elevators fail in short period, halt new assignments and alert maintenance</li>
<li><strong>Graceful degradation</strong>: Reduce service (longer wait times) rather than complete failure</li>
<li><strong>Isolation</strong>: Each elevator's state machine is independent; one crash doesn't affect others</li>
<li><strong>Bulkhead pattern</strong>: Limit concurrent requests per elevator to prevent overload after failures</li>
</ol>
<p><strong>Recovery</strong>:</p>
<ol>
<li>Failed elevator remains in EMERGENCY until technician clears</li>
<li>Gradual reintegration: After repair, elevator starts in IDLE with no stops assigned</li>
<li>Load rebalancing: System gradually shifts load back to recovered elevator</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="testing-strategy">Testing Strategy</h2>
<h3 id="unit-tests">Unit Tests</h3>
<pre><code class="language-python">import unittest
from unittest.mock import Mock, patch
import time


class TestElevator(unittest.TestCase):
    &quot;&quot;&quot;Unit tests for Elevator class.&quot;&quot;&quot;

    def setUp(self):
        self.elevator = Elevator(0, min_floor=0, max_floor=10)

    def test_add_stop_valid_floor(self):
        &quot;&quot;&quot;Stop added to correct set based on direction.&quot;&quot;&quot;
        self.elevator.current_floor = 5

        self.assertTrue(self.elevator.add_stop(8, Direction.UP))
        self.assertIn(8, self.elevator.up_stops)

        self.assertTrue(self.elevator.add_stop(2, Direction.DOWN))
        self.assertIn(2, self.elevator.down_stops)

    def test_add_stop_invalid_floor(self):
        &quot;&quot;&quot;Invalid floors are rejected.&quot;&quot;&quot;
        self.assertFalse(self.elevator.add_stop(-1, Direction.UP))
        self.assertFalse(self.elevator.add_stop(15, Direction.UP))

    def test_add_stop_current_floor_idle(self):
        &quot;&quot;&quot;Request at current floor when idle returns True immediately.&quot;&quot;&quot;
        self.elevator.current_floor = 5
        self.elevator.state = ElevatorState.IDLE

        result = self.elevator.add_stop(5, Direction.UP)

        self.assertTrue(result)
        # Floor should not be added to stops (already there)
        self.assertNotIn(5, self.elevator.up_stops)

    def test_look_algorithm_continues_direction(self):
        &quot;&quot;&quot;LOOK continues in current direction until no more stops.&quot;&quot;&quot;
        self.elevator.current_floor = 5
        self.elevator.direction = Direction.UP
        self.elevator.up_stops = {7, 9}
        self.elevator.down_stops = {2, 4}

        next_stop = self.elevator.get_next_stop()

        self.assertEqual(next_stop, 7)  # Nearest stop above

    def test_look_algorithm_reverses_at_last_stop(self):
        &quot;&quot;&quot;LOOK reverses when no more stops in current direction.&quot;&quot;&quot;
        self.elevator.current_floor = 9
        self.elevator.direction = Direction.UP
        self.elevator.up_stops = set()
        self.elevator.down_stops = {5, 2}

        next_stop = self.elevator.get_next_stop()

        self.assertEqual(next_stop, 5)  # Highest down stop

    def test_effective_distance_idle(self):
        &quot;&quot;&quot;Idle elevator: simple physical distance.&quot;&quot;&quot;
        self.elevator.current_floor = 5
        self.elevator.direction = Direction.IDLE

        distance = self.elevator.effective_distance(8, Direction.UP)

        self.assertEqual(distance, 3)

    def test_effective_distance_same_direction_ahead(self):
        &quot;&quot;&quot;Same direction, floor ahead: simple distance.&quot;&quot;&quot;
        self.elevator.current_floor = 5
        self.elevator.direction = Direction.UP
        self.elevator.up_stops = {10}

        distance = self.elevator.effective_distance(7, Direction.UP)

        self.assertEqual(distance, 2)

    def test_effective_distance_opposite_direction(self):
        &quot;&quot;&quot;Opposite direction: must complete current path first.&quot;&quot;&quot;
        self.elevator.current_floor = 5
        self.elevator.direction = Direction.UP
        self.elevator.up_stops = {8}

        # Request at floor 3 going down
        distance = self.elevator.effective_distance(3, Direction.DOWN)

        # Must go 5-&gt;8, then 8-&gt;3 = 3 + 5 = 8
        self.assertEqual(distance, 8)


class TestElevatorController(unittest.TestCase):
    &quot;&quot;&quot;Unit tests for ElevatorController class.&quot;&quot;&quot;

    def setUp(self):
        self.controller = ElevatorController(num_elevators=3, num_floors=10)

    def test_assigns_nearest_idle_elevator(self):
        &quot;&quot;&quot;Nearest idle elevator is assigned.&quot;&quot;&quot;
        # Move elevator 1 closer to floor 7
        self.controller.elevators[1].current_floor = 6

        assigned = self.controller.request_elevator(7, Direction.UP)

        self.assertEqual(assigned, 1)

    def test_prefers_same_direction_on_path(self):
        &quot;&quot;&quot;Elevator going same direction with floor on path is preferred.&quot;&quot;&quot;
        # Elevator 0 at floor 3, going up
        self.controller.elevators[0].current_floor = 3
        self.controller.elevators[0].direction = Direction.UP
        self.controller.elevators[0].up_stops = {8}

        # Elevator 1 idle at floor 4 (closer but idle)
        self.controller.elevators[1].current_floor = 4
        self.controller.elevators[1].direction = Direction.IDLE

        # Request floor 5 going up - elevator 0 is better (on the way)
        assigned = self.controller.request_elevator(5, Direction.UP)

        # Due to load balancing, either could be chosen
        # The key test is that the stop is added correctly
        self.assertTrue(
            5 in self.controller.elevators[0].up_stops or
            5 in self.controller.elevators[1].up_stops
        )

    def test_invalid_floor_raises_error(self):
        &quot;&quot;&quot;Invalid floor raises ValueError.&quot;&quot;&quot;
        with self.assertRaises(ValueError):
            self.controller.request_elevator(-1, Direction.UP)

        with self.assertRaises(ValueError):
            self.controller.request_elevator(100, Direction.UP)

    def test_select_floor_internal_request(self):
        &quot;&quot;&quot;Internal floor selection works correctly.&quot;&quot;&quot;
        self.controller.elevators[0].current_floor = 5

        result = self.controller.select_floor(0, 8)

        self.assertTrue(result)
        self.assertIn(8, self.controller.elevators[0].up_stops)


class TestIntegration(unittest.TestCase):
    &quot;&quot;&quot;Integration tests for complete elevator journeys.&quot;&quot;&quot;

    def test_complete_journey(self):
        &quot;&quot;&quot;Elevator completes a full pickup and dropoff.&quot;&quot;&quot;
        controller = ElevatorController(num_elevators=1, num_floors=10)

        # Request from floor 0 going up
        assigned = controller.request_elevator(0, Direction.UP)
        self.assertEqual(assigned, 0)

        # Passenger selects floor 5
        controller.select_floor(0, 5)

        # Run simulation until elevator reaches floor 5
        max_steps = 20
        for step in range(max_steps):
            controller.step()
            elevator = controller.elevators[0]
            if elevator.current_floor == 5 and not elevator.has_pending_stops():
                break

        # Verify arrival
        self.assertEqual(controller.elevators[0].current_floor, 5)
        self.assertFalse(controller.elevators[0].has_pending_stops())

    def test_multiple_pickups_same_direction(self):
        &quot;&quot;&quot;Multiple passengers going same direction are picked up in order.&quot;&quot;&quot;
        controller = ElevatorController(num_elevators=1, num_floors=15)

        # Requests at floors 3, 7, 5 all going up
        controller.request_elevator(3, Direction.UP)
        controller.request_elevator(7, Direction.UP)
        controller.request_elevator(5, Direction.UP)

        # Verify stops are registered
        elevator = controller.elevators[0]
        self.assertEqual(elevator.up_stops, {3, 5, 7})

        # Run and track arrival order
        arrivals = []
        for _ in range(20):
            results = controller.step()
            for r in results:
                if r['arrived']:
                    arrivals.append(r['floor'])

        # Should arrive in order: 3, 5, 7
        self.assertEqual(arrivals, [3, 5, 7])


if __name__ == '__main__':
    unittest.main()
</code></pre>
<hr />
<h2 id="complexity-analysis">Complexity Analysis</h2>
<div>
<h4>Time and Space Complexity</h4>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add_stop()</code></td>
<td>O(1)</td>
<td>O(1)</td>
<td>Set insertion</td>
</tr>
<tr>
<td><code>get_next_stop()</code></td>
<td>O(k)</td>
<td>O(k)</td>
<td>k = pending stops; list filtering</td>
</tr>
<tr>
<td><code>step()</code> (single elevator)</td>
<td>O(k)</td>
<td>O(1)</td>
<td>Calls get_next_stop</td>
</tr>
<tr>
<td><code>find_best_elevator()</code></td>
<td>O(e * k)</td>
<td>O(e)</td>
<td>e = elevators, k = avg stops</td>
</tr>
<tr>
<td><code>request_elevator()</code></td>
<td>O(e * k)</td>
<td>O(1)</td>
<td>Dominated by find_best</td>
</tr>
<tr>
<td><code>step()</code> (controller)</td>
<td>O(e * k)</td>
<td>O(1)</td>
<td>Steps all elevators</td>
</tr>
</tbody>
</table>
<p><strong>Space per elevator</strong>: O(f) where f = floors (max stops = floors)</p>
<p><strong>Total system space</strong>: O(e * f + r) where r = pending requests</p>
</div>
<h3 id="optimization-opportunities">Optimization Opportunities</h3>
<pre><code class="language-python"># Optimization 1: Use sorted containers for O(log k) get_next_stop
from sortedcontainers import SortedSet

class OptimizedElevator(Elevator):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.up_stops = SortedSet()
        self.down_stops = SortedSet()

    def get_next_stop(self) -&gt; Optional[int]:
        &quot;&quot;&quot;O(log k) with sorted sets.&quot;&quot;&quot;
        if self.direction == Direction.UP:
            # bisect_right gives first element &gt; current_floor
            idx = self.up_stops.bisect_right(self.current_floor)
            if idx &lt; len(self.up_stops):
                return self.up_stops[idx]
        # ... similar optimization for other cases


# Optimization 2: Cache effective distances
class CachingDispatcher:
    &quot;&quot;&quot;Cache effective distances; invalidate on elevator state change.&quot;&quot;&quot;

    def __init__(self, controller: ElevatorController):
        self.controller = controller
        self.distance_cache: Dict[tuple, int] = {}
        self.cache_valid = True

    def invalidate_cache(self):
        self.distance_cache.clear()
        self.cache_valid = False

    def get_effective_distance(self, elevator: Elevator, floor: int, direction: Direction) -&gt; int:
        key = (elevator.id, floor, direction, elevator.current_floor, elevator.direction)

        if key not in self.distance_cache:
            self.distance_cache[key] = elevator.effective_distance(floor, direction)

        return self.distance_cache[key]
</code></pre>
<hr />
<h2 id="interview-approach">Interview Approach</h2>
<div>
<div>45-Minute Interview Strategy</div>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Time</th>
<th>Focus</th>
<th>Deliverable</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Requirements</strong></td>
<td>5 min</td>
<td>Clarify scope, ask questions</td>
<td>Written list of constraints</td>
</tr>
<tr>
<td><strong>High-Level Design</strong></td>
<td>10 min</td>
<td>Architecture, components</td>
<td>Component diagram</td>
</tr>
<tr>
<td><strong>State Machine</strong></td>
<td>5 min</td>
<td>Elevator states and transitions</td>
<td>State diagram</td>
</tr>
<tr>
<td><strong>Algorithm Selection</strong></td>
<td>10 min</td>
<td>Explain SCAN/LOOK, justify choice</td>
<td>Pseudocode</td>
</tr>
<tr>
<td><strong>Implementation</strong></td>
<td>10 min</td>
<td>Core classes, key methods</td>
<td>Working code</td>
</tr>
<tr>
<td><strong>Edge Cases</strong></td>
<td>5 min</td>
<td>Error handling, failure modes</td>
<td>Test cases</td>
</tr>
</tbody>
</table>
</div>
<h3 id="key-points-to-demonstrate">Key Points to Demonstrate</h3>
<div>
<div>What Interviewers Look For</div>
<div>
<ol>
<li><strong>Systems thinking</strong>: See the problem holistically before diving into code</li>
<li><strong>Trade-off awareness</strong>: Articulate why LOOK &gt; SCAN, mention starvation in SSTF</li>
<li><strong>State machine proficiency</strong>: Model the elevator as explicit states and transitions</li>
<li><strong>Concurrency awareness</strong>: Mention thread safety even if not fully implementing</li>
<li><strong>Edge case anticipation</strong>: Proactively discuss failure modes</li>
<li><strong>Clean code structure</strong>: Separate concerns (elevator logic vs. coordination)</li>
</ol>
</div>
</div>
<h3 id="common-follow-up-questions">Common Follow-up Questions</h3>
<ul>
<li><strong>&quot;How would you handle VIP service?&quot;</strong> - Priority queue with different scoring weights</li>
<li><strong>&quot;What about fire emergency?&quot;</strong> - All elevators to lobby, doors open, disable hall calls</li>
<li><strong>&quot;How to prevent all elevators clustering at lobby?&quot;</strong> - Pre-position algorithm, zone assignment</li>
<li><strong>&quot;Capacity exceeded?&quot;</strong> - Skip floor, signal &quot;full&quot;, reassign pending requests</li>
<li><strong>&quot;Network partition between elevators?&quot;</strong> - Fall back to local scheduling, accept suboptimal behavior</li>
</ul>
<hr />
<h2 id="related-concepts">Related Concepts</h2>
<ul>
<li><a href="/topics/system-design/state-machine">[state-machine]</a> - Foundation for elevator behavior modeling</li>
<li><a href="/topics/operating-systems/scheduling">[scheduling-algorithms]</a> - SCAN, LOOK, SSTF origins</li>
<li><a href="/topics/concurrency/producer-consumer">[producer-consumer]</a> - Request queue pattern</li>
<li><a href="/topics/system-design/load-balancer">[load-balancer]</a> - Multi-elevator assignment</li>
<li><a href="/topics/system-design/distributed-consensus">[distributed-consensus]</a> - Coordinator failure handling</li>
<li><a href="/topics/system-design/rate-limiting">[rate-limiting]</a> - Request deduplication, overload protection</li>
</ul>
