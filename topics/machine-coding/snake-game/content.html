<h1 id="snake-game">Snake Game</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>Design the classic Snake game where a snake moves around a grid, eats food to grow, and the game ends when the snake collides with walls or itself. This is a canonical machine coding problem that tests your understanding of <strong>game loops</strong>, <strong>state management</strong>, <strong>collision detection algorithms</strong>, and <strong>efficient data structure usage</strong>.</p>
<div>
<h4>Core Challenge</h4>
<p>
The snake game appears simple but reveals deep systems design thinking: How do you model continuous movement in discrete time? How do you handle input that arrives between frames? What data structure allows O(1) growth while maintaining spatial ordering?
</p>
</div>
<hr />
<h2 id="section-1-game-loop-architecture">Section 1: Game Loop Architecture</h2>
<p>The <strong>game loop</strong> is the heartbeat of any real-time game. It orchestrates the continuous cycle of processing input, updating game state, and rendering output. Understanding game loops is critical because they appear in embedded systems, simulations, and any application requiring continuous state updates.</p>
<div>
<h4>Game Loop Execution Cycle</h4>
<div>
<div>
<div>
<div>1. PROCESS INPUT</div>
<div>Direction changes</div>
</div>
<div>&#8594;</div>
<div>
<div>2. UPDATE STATE</div>
<div>Move, collision, score</div>
</div>
<div>&#8594;</div>
<div>
<div>3. RENDER</div>
<div>Draw grid state</div>
</div>
</div>
<div>
<div>
<div>LOOP BACK</div>
<div>After fixed time delta or vsync</div>
</div>
</div>
</div>
</div>
<h3 id="fixed-vs-variable-time-step">Fixed vs Variable Time Step</h3>
<div>
<h4>Assumption: Fixed Time Step</h4>
<p>
The snake game assumes a <strong>fixed time step</strong> where each update moves the snake exactly one cell. This simplifies collision detection but creates a coupling between game speed and frame rate. In production games, you would decouple these using delta time accumulation.
</p>
</div>
<p>The <strong>fixed time step</strong> approach means:</p>
<ul>
<li>Each <code>update()</code> call advances game time by exactly one &quot;tick&quot;</li>
<li>Snake moves exactly one grid cell per tick</li>
<li>Collision detection only checks grid-aligned positions</li>
<li>Game speed is controlled by the delay between ticks, not the update logic</li>
</ul>
<div>
<h4>Trade-off: Fixed vs Variable Step</h4>
<div>
<strong>Fixed Step:</strong> Deterministic behavior, simpler collision, but speed tied to tick rate<br/>
<strong>Variable Step:</strong> Smooth movement at any framerate, but requires interpolation and continuous collision detection
</div>
</div>
<h3 id="input-buffering-and-the-180-degree-problem">Input Buffering and the 180-Degree Problem</h3>
<p>A critical edge case: What happens when the player presses opposite directions in rapid succession within a single frame?</p>
<pre><code>Frame N: Snake moving RIGHT
Player presses: UP, then LEFT (both within frame N)
</code></pre>
<p>Without input buffering, the last input (LEFT) would be applied, causing the snake to reverse into itself. Solutions include:</p>
<ol>
<li><strong>Input Queue</strong>: Buffer all inputs, process one per tick</li>
<li><strong>Direction Lock</strong>: Ignore inputs until next tick starts</li>
<li><strong>Validation</strong>: Reject any direction that would cause immediate self-collision</li>
</ol>
<h3 id="interview-questions-game-loop">Interview Questions: Game Loop</h3>
<div>
<h4>Level 1: Fundamentals</h4>
<p><strong>Q: What are the three phases of a game loop and why is their order important?</strong></p>
<p>
<em>Expected: Input processing must happen before update (so new direction takes effect). Update must happen before render (so we display current state). Render must complete before next input poll (to prevent visual lag).</em>
</p>
</div>
<div>
<h4>Level 2: Implementation Depth</h4>
<p><strong>Q: How would you handle input that arrives faster than your tick rate without losing responsiveness?</strong></p>
<p>
<em>Expected: Implement an input queue with timestamps. During each tick, process the oldest unprocessed input. This prevents "swallowing" rapid inputs while maintaining deterministic game state. Discussion should include queue size limits and input coalescing for mobile touch events.</em>
</p>
</div>
<div>
<h4>Level 3: System Design Integration</h4>
<p><strong>Q: If you needed to support networked multiplayer snake, how would you modify the game loop to handle latency and ensure consistency across clients?</strong></p>
<p>
<em>Expected: Implement lockstep or rollback networking. Lockstep: All clients wait for inputs from all players before advancing. Rollback: Predict opponent moves, then rewind and resimulate when actual input arrives. Discuss authoritative server model, input delay compensation, and the trade-off between responsiveness and consistency. Reference [[distributed systems]](/topic/system-design/distributed-systems) concepts like eventual consistency.</em>
</p>
</div>
<hr />
<h2 id="section-2-queue-based-snake-body-management">Section 2: Queue-Based Snake Body Management</h2>
<p>The snake body is the central data structure. The choice of data structure directly impacts the time complexity of movement, growth, and collision detection. This is where <a href="/topic/data-structures/deque">[deque]</a> knowledge becomes essential.</p>
<div>
<h4>Deque-Based Snake Body Operations</h4>
<div>
<div>
<div>HEAD</div>
<div>Body[1]</div>
<div>Body[2]</div>
<div>Body[3]</div>
<div>TAIL</div>
</div>
<div>
<div>
<div>MOVE</div>
<div>appendleft(new_head)<br/>pop() from tail</div>
<div>O(1) + O(1)</div>
</div>
<div>
<div>GROW</div>
<div>appendleft(new_head)<br/>skip pop()</div>
<div>O(1)</div>
</div>
<div>
<div>COLLISION CHECK</div>
<div>head in body_set?</div>
<div>O(1) with HashSet</div>
</div>
</div>
</div>
</div>
<h3 id="why-deque-over-other-structures">Why Deque Over Other Structures?</h3>
<table>
<thead>
<tr>
<th>Data Structure</th>
<th>Add Head</th>
<th>Remove Tail</th>
<th>Random Access</th>
<th>Self-Collision</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Array/List</strong></td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>Linked List</strong></td>
<td>O(1)</td>
<td>O(1)*</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>Deque</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)**</td>
<td>O(n) / O(1)***</td>
</tr>
</tbody>
</table>
<p>*Requires tail pointer. **Amortized for dynamic array deque. ***O(1) if augmented with HashSet.</p>
<div>
<h4>Design Choice: Deque + HashSet Hybrid</h4>
<p>
The optimal structure is a <strong>deque for ordering</strong> (maintains head-to-tail sequence for rendering) combined with a <strong>HashSet for O(1) membership queries</strong> (collision detection). This uses O(n) extra space but reduces collision check from O(n) to O(1) per move.
</p>
</div>
<h3 id="the-growing-flag-pattern">The Growing Flag Pattern</h3>
<p>A subtle implementation detail: when the snake eats food, we don't immediately add a segment. Instead, we set a <code>growing</code> flag that causes the next move to skip the tail removal.</p>
<pre><code class="language-python">def move(self) -&gt; Position:
    new_head = self.head.move(self.direction)
    self.body.appendleft(new_head)
    self.body_set.add(new_head)

    if not self.growing:
        removed_tail = self.body.pop()
        self.body_set.remove(removed_tail)
    else:
        self.growing = False  # Reset flag

    return new_head
</code></pre>
<div>
<h4>Edge Case: Multiple Consecutive Growth</h4>
<p>
What if food spawns allow eating multiple items in quick succession? The boolean flag only tracks one pending growth. For games with multiple food items or power-ups, use a <strong>growth counter</strong> instead: <code>self.pending_growth += food.growth_amount</code> and decrement each tick.
</p>
</div>
<h3 id="interview-questions-snake-body-data-structure">Interview Questions: Snake Body Data Structure</h3>
<div>
<h4>Level 1: Fundamentals</h4>
<p><strong>Q: Why is a deque preferred over an array for the snake body?</strong></p>
<p>
<em>Expected: Movement requires adding to head and removing from tail every tick. Arrays have O(n) insertion at front due to shifting. Deque provides O(1) for both operations. Candidate should mention that Python's deque is implemented as a doubly-linked list of fixed-size blocks.</em>
</p>
</div>
<div>
<h4>Level 2: Implementation Depth</h4>
<p><strong>Q: How do you maintain O(1) self-collision detection while keeping body segments ordered?</strong></p>
<p>
<em>Expected: Use two data structures - a deque for ordered traversal (rendering) and a HashSet for O(1) lookup. On move: add new head to both, remove tail from both. Trade-off is O(n) space overhead. Candidate should discuss keeping these structures synchronized and the bug potential if they diverge.</em>
</p>
</div>
<div>
<h4>Level 3: System Design Integration</h4>
<p><strong>Q: If the snake could grow to millions of segments (server-side simulation), how would you optimize memory and support fast serialization for network sync?</strong></p>
<p>
<em>Expected: Run-length encoding for straight segments (store direction + length instead of each position). Use spatial partitioning (quadtree) for collision. For serialization, send delta updates (new head position, removed tail) instead of full body. Discuss memory pooling for Position objects to reduce GC pressure. Reference [[spatial indexing]](/topic/algorithms/spatial-indexing) for large-scale collision systems.</em>
</p>
</div>
<hr />
<h2 id="section-3-collision-detection">Section 3: Collision Detection</h2>
<p>Collision detection in Snake involves two distinct checks: <strong>boundary collision</strong> (snake vs walls) and <strong>self-collision</strong> (snake head vs body). Each has different algorithmic characteristics.</p>
<div>
<h4>Collision Detection Decision Tree</h4>
<div>
<div>
<div>New Head Position Calculated</div>
</div>
<div>&#8595;</div>
<div>
<div>
<div>
<div>BOUNDARY CHECK</div>
<div>0 &lt;= x &lt; width?</div>
<div>0 &lt;= y &lt; height?</div>
</div>
<div>O(1) - constant</div>
</div>
<div>
<div>
<div>SELF-COLLISION</div>
<div>head in body_set?</div>
</div>
<div>O(1) with HashSet</div>
</div>
<div>
<div>
<div>FOOD COLLISION</div>
<div>head == food.pos?</div>
</div>
<div>O(1) - direct compare</div>
</div>
</div>
</div>
</div>
<h3 id="order-of-collision-checks-matters">Order of Collision Checks Matters</h3>
<div>
<h4>Critical Edge Case: Tail Removal Timing</h4>
<p>
In the LeetCode variant (353), the snake can move into the cell its tail is about to vacate. This requires removing the tail <strong>before</strong> checking self-collision. The order must be: (1) calculate new head, (2) if not eating: remove tail from body set, (3) check if new head collides with remaining body, (4) add new head to body.
</p>
</div>
<pre><code class="language-python"># Correct order for LeetCode 353 variant
def move(self, direction: str) -&gt; int:
    new_head = self.calculate_new_head(direction)

    # 1. Boundary check first
    if not self.is_within_bounds(new_head):
        return -1

    # 2. Determine if eating (before any modifications)
    eating = self.food_queue and new_head == self.food_queue[0]

    # 3. Remove tail BEFORE self-collision check (if not eating)
    if not eating:
        tail = self.snake.pop()
        self.snake_set.remove(tail)

    # 4. Now check self-collision (against reduced body)
    if new_head in self.snake_set:
        return -1

    # 5. Add new head
    self.snake.appendleft(new_head)
    self.snake_set.add(new_head)

    if eating:
        self.score += 1
        self.food_queue.popleft()

    return self.score
</code></pre>
<h3 id="wraparound-boundaries-vs-hard-walls">Wraparound Boundaries vs Hard Walls</h3>
<div>
<h4>Design Choice: Boundary Behavior</h4>
<p>
<strong>Hard walls:</strong> Collision = game over. Simpler to implement.<br/>
<strong>Wraparound (toroidal):</strong> Exiting right reappears left. Requires modulo arithmetic: <code>new_x = (head.x + dx) % width</code>. Changes strategy significantly - no "safe corners."
</p>
</div>
<h3 id="interview-questions-collision-detection">Interview Questions: Collision Detection</h3>
<div>
<h4>Level 1: Fundamentals</h4>
<p><strong>Q: In the LeetCode variant, why must we remove the tail before checking self-collision?</strong></p>
<p>
<em>Expected: The snake is allowed to move into the space its tail currently occupies because the tail will vacate that cell in the same move. If we check collision first, we'd falsely detect a collision with our own tail. This models the physical reality that head and tail move simultaneously.</em>
</p>
</div>
<div>
<h4>Level 2: Implementation Depth</h4>
<p><strong>Q: How would collision detection change if the snake moved at sub-cell granularity (smooth movement)?</strong></p>
<p>
<em>Expected: Would need continuous collision detection - check if the head's path intersects any body segment. Could use line-segment intersection for body represented as connected line segments, or swept AABB (Axis-Aligned Bounding Box) tests. Discuss the performance implications: O(n) segment checks per frame vs spatial partitioning with [[quadtrees]](/topic/data-structures/quadtree) for O(log n).</em>
</p>
</div>
<div>
<h4>Level 3: System Design Integration</h4>
<p><strong>Q: In a multiplayer snake game with 100 snakes of average length 50, how would you optimize collision detection between all snakes?</strong></p>
<p>
<em>Expected: Naive approach is O(n * m) where n = number of snakes, m = average length (5000 * 5000 = 25M checks). Use spatial hashing: divide grid into cells, only check collisions within same/adjacent cells. For moving objects, use sweep-and-prune algorithm. Discuss the trade-off between cell size (too small = many cells to check, too large = no benefit). Reference [[collision detection]](/topic/game-dev/collision-detection) and [[spatial partitioning]](/topic/algorithms/spatial-partitioning).</em>
</p>
</div>
<hr />
<h2 id="section-4-food-generation-and-placement">Section 4: Food Generation and Placement</h2>
<p>Food generation seems trivial but has interesting algorithmic implications as the snake grows. The naive approach degrades significantly when the board is nearly full.</p>
<div>
<h4>Food Generation Strategy Comparison</h4>
<div>
<div>
<div>
<div>NAIVE: Random Retry</div>
<div>
Generate random position<br/>
If occupied, retry<br/>
<span>Worst case: infinite loop when board 99% full</span>
</div>
<div>O(infinity) worst case</div>
</div>
<div>
<div>SCAN: Filter Empty</div>
<div>
Enumerate all cells<br/>
Filter out snake body<br/>
Random choice from remainder
</div>
<div>O(width * height) always</div>
</div>
<div>
<div>OPTIMAL: Maintain Empty Set</div>
<div>
Track empty cells in list<br/>
Random index selection<br/>
Update on snake move
</div>
<div>O(1) generation, O(1) update</div>
</div>
</div>
</div>
</div>
<h3 id="optimal-algorithm-maintained-empty-set">Optimal Algorithm: Maintained Empty Set</h3>
<pre><code class="language-python">class OptimizedFoodSpawner:
    def __init__(self, width: int, height: int, snake_body: set):
        # Initialize with all positions except snake
        self.empty_cells = []
        self.position_to_index = {}  # For O(1) removal

        for y in range(height):
            for x in range(width):
                pos = (x, y)
                if pos not in snake_body:
                    self.position_to_index[pos] = len(self.empty_cells)
                    self.empty_cells.append(pos)

    def spawn_food(self) -&gt; tuple:
        if not self.empty_cells:
            return None  # Board full - player wins!

        idx = random.randint(0, len(self.empty_cells) - 1)
        food_pos = self.empty_cells[idx]
        self._remove_position(food_pos)
        return food_pos

    def _remove_position(self, pos: tuple):
        &quot;&quot;&quot;O(1) removal using swap-with-last trick&quot;&quot;&quot;
        idx = self.position_to_index[pos]
        last_pos = self.empty_cells[-1]

        # Swap with last element
        self.empty_cells[idx] = last_pos
        self.position_to_index[last_pos] = idx

        # Remove last element
        self.empty_cells.pop()
        del self.position_to_index[pos]

    def on_snake_move(self, new_head: tuple, removed_tail: tuple):
        &quot;&quot;&quot;Update empty set when snake moves&quot;&quot;&quot;
        self._remove_position(new_head)  # Head occupies new cell
        if removed_tail:  # Tail vacates cell (unless growing)
            self.position_to_index[removed_tail] = len(self.empty_cells)
            self.empty_cells.append(removed_tail)
</code></pre>
<div>
<h4>Assumption: Uniform Random Distribution</h4>
<p>
We assume food should spawn with uniform probability across all empty cells. Some game variants use weighted distributions - food more likely near edges, or further from snake head to increase difficulty. The optimal algorithm supports weighted selection by storing weights with positions.
</p>
</div>
<h3 id="the-win-condition-edge-case">The Win Condition Edge Case</h3>
<p>When the snake fills the entire board, there's no space for food. This represents the win condition, but implementation must handle it gracefully:</p>
<pre><code class="language-python">def _spawn_food(self):
    if not self.empty_cells:
        self.game_over = True
        self.victory = True  # Distinguish from death
        return
    # ... normal spawning
</code></pre>
<h3 id="interview-questions-food-generation">Interview Questions: Food Generation</h3>
<div>
<h4>Level 1: Fundamentals</h4>
<p><strong>Q: What's wrong with the naive "generate random, retry if occupied" approach?</strong></p>
<p>
<em>Expected: When the snake covers 90% of the board, each random attempt has only 10% chance of finding an empty cell. Expected attempts = 10. At 99% coverage, expected attempts = 100. As coverage approaches 100%, attempts approach infinity. This is unacceptable for real-time games.</em>
</p>
</div>
<div>
<h4>Level 2: Implementation Depth</h4>
<p><strong>Q: How do you achieve O(1) removal from the empty cells list while maintaining random access for spawning?</strong></p>
<p>
<em>Expected: Use the "swap with last and pop" technique. Maintain a position-to-index mapping. When removing, swap the target with the last element, update the swapped element's index in the map, then pop from the end. This maintains O(1) random access (array indexing) while enabling O(1) removal. Reference [[array manipulation]](/topic/algorithms/array-techniques).</em>
</p>
</div>
<div>
<h4>Level 3: System Design Integration</h4>
<p><strong>Q: Design a food generation system for a massive multiplayer snake game where the board is 10,000 x 10,000 cells with 1000 concurrent snakes. Memory and latency are critical.</strong></p>
<p>
<em>Expected: Cannot enumerate all 100M cells. Use hierarchical approach: divide into regions, track empty count per region, select region proportionally to empty count, then use local spawner per region. For memory, use sparse representation - only track occupied cells, generate random positions and check against occupied set. Discuss consistent hashing for distributing regions across servers. Reference [[distributed systems]](/topic/system-design/distributed-systems) and [[sharding]](/topic/system-design/database-sharding).</em>
</p>
</div>
<hr />
<h2 id="section-5-score-tracking-and-game-state">Section 5: Score Tracking and Game State</h2>
<p>Score tracking extends beyond a simple counter. Production games need persistent storage, leaderboards, anti-cheat measures, and analytics. This connects to <a href="/topic/system-design/state-management">[state management]</a> patterns.</p>
<div>
<h4>Score State Machine</h4>
<div>
<div>
<div>
<div>PLAYING</div>
<div>score: N</div>
</div>
<div>&#8594;</div>
<div>
<div>eat food (+10)</div>
</div>
<div>&#8594;</div>
<div>
<div>PLAYING</div>
<div>score: N+10</div>
</div>
</div>
<div>
<div>
<div>&#8595;</div>
<div>
<div>collision</div>
</div>
<div>&#8595;</div>
</div>
</div>
<div>
<div>GAME OVER</div>
<div>final_score, persist to leaderboard</div>
</div>
</div>
</div>
<h3 id="scoring-strategies">Scoring Strategies</h3>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Formula</th>
<th>Game Feel</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Linear</strong></td>
<td><code>score += 10</code></td>
<td>Consistent, predictable</td>
</tr>
<tr>
<td><strong>Length-based</strong></td>
<td><code>score += 10 * snake_length</code></td>
<td>Rewards survival, exponential growth</td>
</tr>
<tr>
<td><strong>Time-pressure</strong></td>
<td><code>score += max(100 - ticks_since_food, 10)</code></td>
<td>Encourages aggressive play</td>
</tr>
<tr>
<td><strong>Combo</strong></td>
<td><code>score += 10 * combo_multiplier</code></td>
<td>Rewards consecutive quick eats</td>
</tr>
</tbody>
</table>
<div>
<h4>Design Choice: Immutable Game State</h4>
<p>
For replay systems, undo functionality, or debugging, consider making game state immutable. Each update creates a new state object. This enables time-travel debugging but increases memory usage. Use structural sharing (like in [[persistent data structures]](/topic/data-structures/persistent)) to mitigate.
</p>
</div>
<h3 id="state-serialization-for-saveload">State Serialization for Save/Load</h3>
<pre><code class="language-python">@dataclass
class GameState:
    snake_body: List[Tuple[int, int]]
    snake_direction: str
    food_position: Tuple[int, int]
    score: int
    moves: int
    timestamp: float

    def to_json(self) -&gt; str:
        return json.dumps(asdict(self))

    @classmethod
    def from_json(cls, data: str) -&gt; 'GameState':
        return cls(**json.loads(data))

    def checksum(self) -&gt; str:
        &quot;&quot;&quot;Integrity check for anti-cheat&quot;&quot;&quot;
        content = f&quot;{self.snake_body}{self.score}{self.moves}&quot;
        return hashlib.sha256(content.encode()).hexdigest()[:16]
</code></pre>
<div>
<h4>Trade-off: Client-side vs Server-side Score</h4>
<p>
<strong>Client-side:</strong> Responsive, works offline, but vulnerable to manipulation<br/>
<strong>Server-side:</strong> Authoritative, cheat-resistant, but requires connectivity and adds latency<br/>
<strong>Hybrid:</strong> Client runs game, server validates replay/input sequence. Best of both worlds but complex to implement.
</p>
</div>
<h3 id="interview-questions-score-and-state-management">Interview Questions: Score and State Management</h3>
<div>
<h4>Level 1: Fundamentals</h4>
<p><strong>Q: What information is minimally required to serialize a snake game state for save/load?</strong></p>
<p>
<em>Expected: Snake body positions (ordered list), current direction, food position, score, and board dimensions. Optionally: RNG seed for deterministic replay, move count for statistics. Note that direction must be saved separately from body since two snakes with identical body positions could be moving different directions.</em>
</p>
</div>
<div>
<h4>Level 2: Implementation Depth</h4>
<p><strong>Q: How would you implement a replay system that can play back any game from just the initial state and input sequence?</strong></p>
<p>
<em>Expected: Store initial RNG seed, board dimensions, and timestamped input events [(tick, direction), ...]. To replay: reconstruct initial state, apply inputs at correct ticks, use same RNG seed for deterministic food spawning. Discuss the importance of determinism - floating point issues, RNG implementation differences across platforms. Reference [[event sourcing]](/topic/system-design/event-sourcing).</em>
</p>
</div>
<div>
<h4>Level 3: System Design Integration</h4>
<p><strong>Q: Design a global leaderboard system for 10 million daily active users with real-time rank updates. How do you handle score submissions, prevent cheating, and display ranks efficiently?</strong></p>
<p>
<em>Expected: Use Redis sorted sets for O(log n) rank queries and updates. Shard by score ranges for horizontal scaling. For anti-cheat: require replay submission, server-side validation of physics/timing, statistical anomaly detection (impossibly fast scores). For real-time updates: use pub/sub to notify affected users when rank changes. Discuss eventual consistency trade-offs - showing slightly stale ranks is acceptable. Reference [[leaderboard design]](/topic/system-design/leaderboard) and [[redis data structures]](/topic/databases/redis).</em>
</p>
</div>
<hr />
<h2 id="complete-implementation">Complete Implementation</h2>
<h3 id="python">Python</h3>
<pre><code class="language-python">import random
from enum import Enum
from typing import List, Tuple, Optional, Set, Dict
from collections import deque
from dataclasses import dataclass, field
import json
import hashlib
import time


class Direction(Enum):
    &quot;&quot;&quot;Movement direction with delta values and opposite lookup.&quot;&quot;&quot;
    UP = (0, -1)
    DOWN = (0, 1)
    LEFT = (-1, 0)
    RIGHT = (1, 0)

    def opposite(self) -&gt; 'Direction':
        opposites = {
            Direction.UP: Direction.DOWN,
            Direction.DOWN: Direction.UP,
            Direction.LEFT: Direction.RIGHT,
            Direction.RIGHT: Direction.LEFT
        }
        return opposites[self]

    @property
    def delta(self) -&gt; Tuple[int, int]:
        return self.value


@dataclass(frozen=True)
class Position:
    &quot;&quot;&quot;Immutable position with movement support.

    Using frozen=True makes Position hashable for set operations
    while ensuring positions cannot be accidentally mutated.
    &quot;&quot;&quot;
    x: int
    y: int

    def move(self, direction: Direction) -&gt; 'Position':
        dx, dy = direction.delta
        return Position(self.x + dx, self.y + dy)

    def __iter__(self):
        &quot;&quot;&quot;Allow tuple unpacking: x, y = position&quot;&quot;&quot;
        return iter((self.x, self.y))


class Snake:
    &quot;&quot;&quot;Snake entity with deque-based body management.

    Design decisions:
    - Deque for O(1) head/tail operations
    - Separate HashSet for O(1) collision lookup
    - Growing flag defers growth to next move (simpler than immediate extension)
    &quot;&quot;&quot;

    def __init__(self, start_pos: Position, initial_length: int = 3):
        self.body: deque[Position] = deque()
        self.body_set: Set[Position] = set()

        # Initialize snake body extending left from start position
        for i in range(initial_length):
            pos = Position(start_pos.x - i, start_pos.y)
            self.body.append(pos)
            self.body_set.add(pos)

        self.direction = Direction.RIGHT
        self._pending_growth = 0  # Support multiple consecutive growth

    @property
    def head(self) -&gt; Position:
        return self.body[0]

    @property
    def tail(self) -&gt; Position:
        return self.body[-1]

    @property
    def length(self) -&gt; int:
        return len(self.body)

    def move(self) -&gt; Tuple[Position, Optional[Position]]:
        &quot;&quot;&quot;Move snake in current direction.

        Returns:
            Tuple of (new_head, removed_tail or None if growing)
        &quot;&quot;&quot;
        new_head = self.head.move(self.direction)

        # Add new head
        self.body.appendleft(new_head)
        self.body_set.add(new_head)

        # Handle tail based on growth state
        removed_tail = None
        if self._pending_growth &gt; 0:
            self._pending_growth -= 1
        else:
            removed_tail = self.body.pop()
            self.body_set.remove(removed_tail)

        return new_head, removed_tail

    def grow(self, amount: int = 1):
        &quot;&quot;&quot;Queue growth for subsequent moves.&quot;&quot;&quot;
        self._pending_growth += amount

    def change_direction(self, new_direction: Direction) -&gt; bool:
        &quot;&quot;&quot;Change direction if valid (not opposite).

        Returns True if direction changed, False if rejected.
        &quot;&quot;&quot;
        if new_direction != self.direction.opposite():
            self.direction = new_direction
            return True
        return False

    def collides_with_self(self) -&gt; bool:
        &quot;&quot;&quot;Check if head position overlaps with body.

        Note: This is called AFTER move(), so head is already in body_set.
        We check if head appears more than once.
        &quot;&quot;&quot;
        # Count occurrences - head should appear exactly once
        return list(self.body).count(self.head) &gt; 1

    def occupies(self, pos: Position) -&gt; bool:
        &quot;&quot;&quot;O(1) check if snake occupies a position.&quot;&quot;&quot;
        return pos in self.body_set


@dataclass
class Food:
    &quot;&quot;&quot;Food item with position and point value.&quot;&quot;&quot;
    position: Position
    points: int = 10

    # Extension: different food types
    growth_amount: int = 1


class GameBoard:
    &quot;&quot;&quot;Game board managing boundaries and position validation.&quot;&quot;&quot;

    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self._total_cells = width * height

    def is_within_bounds(self, pos: Position) -&gt; bool:
        return 0 &lt;= pos.x &lt; self.width and 0 &lt;= pos.y &lt; self.height

    @property
    def total_cells(self) -&gt; int:
        return self._total_cells


class FoodSpawner:
    &quot;&quot;&quot;Optimized food spawner maintaining O(1) spawn time.

    Uses the &quot;swap with last&quot; technique for O(1) removal from available cells.
    &quot;&quot;&quot;

    def __init__(self, board: GameBoard, initial_occupied: Set[Position]):
        self.board = board
        self._available: List[Position] = []
        self._pos_to_index: Dict[Position, int] = {}

        # Initialize available positions
        for y in range(board.height):
            for x in range(board.width):
                pos = Position(x, y)
                if pos not in initial_occupied:
                    self._pos_to_index[pos] = len(self._available)
                    self._available.append(pos)

    def spawn(self) -&gt; Optional[Food]:
        &quot;&quot;&quot;Spawn food at random available position.

        Returns None if no space available (win condition).
        &quot;&quot;&quot;
        if not self._available:
            return None

        idx = random.randint(0, len(self._available) - 1)
        pos = self._available[idx]
        self._remove_position(pos)
        return Food(position=pos)

    def _remove_position(self, pos: Position):
        &quot;&quot;&quot;O(1) removal using swap-with-last.&quot;&quot;&quot;
        if pos not in self._pos_to_index:
            return

        idx = self._pos_to_index[pos]
        last_pos = self._available[-1]

        # Swap with last
        self._available[idx] = last_pos
        self._pos_to_index[last_pos] = idx

        # Remove last
        self._available.pop()
        del self._pos_to_index[pos]

    def _add_position(self, pos: Position):
        &quot;&quot;&quot;Add position back to available set.&quot;&quot;&quot;
        if pos in self._pos_to_index:
            return
        self._pos_to_index[pos] = len(self._available)
        self._available.append(pos)

    def on_snake_move(self, new_head: Position, removed_tail: Optional[Position]):
        &quot;&quot;&quot;Update available positions after snake move.&quot;&quot;&quot;
        self._remove_position(new_head)
        if removed_tail:
            self._add_position(removed_tail)

    def on_food_eaten(self, food_pos: Position):
        &quot;&quot;&quot;Food position already removed during spawn, nothing to do.&quot;&quot;&quot;
        pass

    @property
    def available_count(self) -&gt; int:
        return len(self._available)


class GameState(Enum):
    &quot;&quot;&quot;Explicit game state for state machine clarity.&quot;&quot;&quot;
    RUNNING = &quot;running&quot;
    GAME_OVER = &quot;game_over&quot;
    VICTORY = &quot;victory&quot;
    PAUSED = &quot;paused&quot;


@dataclass
class GameSnapshot:
    &quot;&quot;&quot;Serializable game state for save/load and replay.&quot;&quot;&quot;
    snake_body: List[Tuple[int, int]]
    snake_direction: str
    food_position: Optional[Tuple[int, int]]
    score: int
    moves: int
    board_width: int
    board_height: int
    state: str
    timestamp: float = field(default_factory=time.time)

    def to_json(self) -&gt; str:
        return json.dumps({
            'snake_body': self.snake_body,
            'snake_direction': self.snake_direction,
            'food_position': self.food_position,
            'score': self.score,
            'moves': self.moves,
            'board_width': self.board_width,
            'board_height': self.board_height,
            'state': self.state,
            'timestamp': self.timestamp
        })

    @classmethod
    def from_json(cls, data: str) -&gt; 'GameSnapshot':
        d = json.loads(data)
        return cls(**d)

    def checksum(self) -&gt; str:
        &quot;&quot;&quot;Integrity verification for anti-cheat.&quot;&quot;&quot;
        content = f&quot;{self.snake_body}:{self.score}:{self.moves}&quot;
        return hashlib.sha256(content.encode()).hexdigest()[:16]


class SnakeGame:
    &quot;&quot;&quot;Main game controller orchestrating all components.

    Responsibilities:
    - Game loop coordination (update cycle)
    - Input processing with validation
    - State transitions
    - Score management
    &quot;&quot;&quot;

    def __init__(self, width: int = 20, height: int = 20,
                 initial_length: int = 3, seed: Optional[int] = None):
        # Set RNG seed for deterministic replay
        if seed is not None:
            random.seed(seed)
        self._seed = seed

        self.board = GameBoard(width, height)
        start_pos = Position(width // 2, height // 2)
        self.snake = Snake(start_pos, initial_length)

        self.food_spawner = FoodSpawner(self.board, self.snake.body_set)
        self.food: Optional[Food] = None

        self.score = 0
        self.moves = 0
        self.state = GameState.RUNNING

        # Input buffering for handling rapid direction changes
        self._input_queue: deque[Direction] = deque(maxlen=2)

        # Statistics
        self.food_eaten = 0
        self.start_time = time.time()

        # Spawn initial food
        self._spawn_food()

    def _spawn_food(self):
        &quot;&quot;&quot;Attempt to spawn food, handle win condition.&quot;&quot;&quot;
        self.food = self.food_spawner.spawn()
        if self.food is None:
            self.state = GameState.VICTORY

    def queue_direction(self, direction: Direction):
        &quot;&quot;&quot;Queue a direction change for processing.

        Input buffering prevents losing rapid inputs and handles
        the 180-degree turn edge case.
        &quot;&quot;&quot;
        if self.state != GameState.RUNNING:
            return

        # Validate against current direction or last queued direction
        reference_dir = self._input_queue[-1] if self._input_queue else self.snake.direction
        if direction != reference_dir.opposite():
            self._input_queue.append(direction)

    def update(self) -&gt; bool:
        &quot;&quot;&quot;Execute one game tick.

        Returns True if game continues, False if ended.
        &quot;&quot;&quot;
        if self.state != GameState.RUNNING:
            return False

        # Process buffered input
        if self._input_queue:
            new_direction = self._input_queue.popleft()
            self.snake.change_direction(new_direction)

        # Move snake
        new_head, removed_tail = self.snake.move()
        self.moves += 1

        # Update food spawner tracking
        self.food_spawner.on_snake_move(new_head, removed_tail)

        # Check boundary collision
        if not self.board.is_within_bounds(new_head):
            self.state = GameState.GAME_OVER
            return False

        # Check self collision
        if self.snake.collides_with_self():
            self.state = GameState.GAME_OVER
            return False

        # Check food collision
        if self.food and new_head == self.food.position:
            self._handle_food_eaten()

        return True

    def _handle_food_eaten(self):
        &quot;&quot;&quot;Process food consumption.&quot;&quot;&quot;
        self.score += self.food.points
        self.snake.grow(self.food.growth_amount)
        self.food_eaten += 1
        self._spawn_food()

    def get_snapshot(self) -&gt; GameSnapshot:
        &quot;&quot;&quot;Create serializable snapshot of current state.&quot;&quot;&quot;
        return GameSnapshot(
            snake_body=[(p.x, p.y) for p in self.snake.body],
            snake_direction=self.snake.direction.name,
            food_position=(self.food.position.x, self.food.position.y) if self.food else None,
            score=self.score,
            moves=self.moves,
            board_width=self.board.width,
            board_height=self.board.height,
            state=self.state.value
        )

    def get_statistics(self) -&gt; dict:
        &quot;&quot;&quot;Get game statistics for analytics.&quot;&quot;&quot;
        elapsed = time.time() - self.start_time
        return {
            'score': self.score,
            'snake_length': self.snake.length,
            'food_eaten': self.food_eaten,
            'moves': self.moves,
            'elapsed_seconds': elapsed,
            'moves_per_food': self.moves / max(1, self.food_eaten),
            'efficiency': self.snake.length / max(1, self.moves),
            'board_coverage': self.snake.length / self.board.total_cells
        }

    def render(self) -&gt; str:
        &quot;&quot;&quot;Render game board as string for debugging.&quot;&quot;&quot;
        grid = [['.' for _ in range(self.board.width)]
                for _ in range(self.board.height)]

        # Draw snake
        for i, pos in enumerate(self.snake.body):
            if self.board.is_within_bounds(pos):
                grid[pos.y][pos.x] = 'O' if i == 0 else 'o'

        # Draw food
        if self.food:
            grid[self.food.position.y][self.food.position.x] = '*'

        # Build output
        border = '+' + '-' * self.board.width + '+'
        lines = [border]
        for row in grid:
            lines.append('|' + ''.join(row) + '|')
        lines.append(border)
        lines.append(f&quot;Score: {self.score} | Length: {self.snake.length} | &quot;
                    f&quot;Moves: {self.moves} | State: {self.state.value}&quot;)

        return '\n'.join(lines)


# LeetCode 353: Design Snake Game
class SnakeGameLC:
    &quot;&quot;&quot;
    LeetCode-style interface with predetermined food positions.

    Key difference from standard game:
    - Food positions are predetermined (queue)
    - Snake can move into tail's current position (tail moves first)
    - Returns score or -1 on game over
    &quot;&quot;&quot;

    def __init__(self, width: int, height: int, food: List[List[int]]):
        self.width = width
        self.height = height
        self.food_queue = deque(tuple(f) for f in food)  # [(row, col), ...]
        self.snake = deque([(0, 0)])  # [(row, col), ...]
        self.snake_set = {(0, 0)}
        self.score = 0

    def move(self, direction: str) -&gt; int:
        &quot;&quot;&quot;Move snake in direction. Returns score or -1 if game over.&quot;&quot;&quot;
        directions = {
            'U': (-1, 0),
            'D': (1, 0),
            'L': (0, -1),
            'R': (0, 1)
        }

        dr, dc = directions[direction]
        head_r, head_c = self.snake[0]
        new_head = (head_r + dr, head_c + dc)

        # Boundary check
        if not (0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width):
            return -1

        # Check if eating (before modifying body)
        eating = self.food_queue and self.food_queue[0] == new_head

        # CRITICAL: Remove tail BEFORE self-collision check
        # This allows snake to move into space tail is vacating
        if not eating:
            tail = self.snake.pop()
            self.snake_set.remove(tail)

        # Self collision check (against reduced body if not eating)
        if new_head in self.snake_set:
            return -1

        # Add new head
        self.snake.appendleft(new_head)
        self.snake_set.add(new_head)

        if eating:
            self.score += 1
            self.food_queue.popleft()

        return self.score


# Demo and testing
if __name__ == &quot;__main__&quot;:
    print(&quot;=== Snake Game Demo ===\n&quot;)

    # Create game with fixed seed for reproducibility
    game = SnakeGame(15, 10, seed=42)

    # Simulate moves
    moves = [
        (Direction.RIGHT, 3),
        (Direction.DOWN, 2),
        (Direction.LEFT, 4),
        (Direction.UP, 2),
    ]

    print(&quot;Initial state:&quot;)
    print(game.render())
    print()

    for direction, count in moves:
        game.queue_direction(direction)
        for _ in range(count):
            if not game.update():
                print(f&quot;Game ended: {game.state.value}&quot;)
                break

    print(&quot;After moves:&quot;)
    print(game.render())
    print()

    # Show statistics
    stats = game.get_statistics()
    print(&quot;Statistics:&quot;)
    for key, value in stats.items():
        if isinstance(value, float):
            print(f&quot;  {key}: {value:.3f}&quot;)
        else:
            print(f&quot;  {key}: {value}&quot;)

    # Demonstrate serialization
    print(&quot;\nSnapshot JSON:&quot;)
    snapshot = game.get_snapshot()
    print(snapshot.to_json()[:200] + &quot;...&quot;)
    print(f&quot;Checksum: {snapshot.checksum()}&quot;)
</code></pre>
<h3 id="go">Go</h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

// Direction represents movement direction with delta values
type Direction int

const (
	Up Direction = iota
	Down
	Left
	Right
)

func (d Direction) Opposite() Direction {
	switch d {
	case Up:
		return Down
	case Down:
		return Up
	case Left:
		return Right
	default:
		return Left
	}
}

func (d Direction) Delta() (int, int) {
	switch d {
	case Up:
		return 0, -1
	case Down:
		return 0, 1
	case Left:
		return -1, 0
	default:
		return 1, 0
	}
}

func (d Direction) String() string {
	names := []string{&quot;UP&quot;, &quot;DOWN&quot;, &quot;LEFT&quot;, &quot;RIGHT&quot;}
	return names[d]
}

// Position represents a grid coordinate
type Position struct {
	X, Y int
}

func (p Position) Move(d Direction) Position {
	dx, dy := d.Delta()
	return Position{p.X + dx, p.Y + dy}
}

func (p Position) Key() string {
	return fmt.Sprintf(&quot;%d,%d&quot;, p.X, p.Y)
}

// Snake manages the snake entity with optimized data structures
type Snake struct {
	Body          []Position
	BodySet       map[string]bool // O(1) collision lookup
	Dir           Direction
	PendingGrowth int
}

func NewSnake(start Position, length int) *Snake {
	body := make([]Position, length)
	bodySet := make(map[string]bool)

	for i := 0; i &lt; length; i++ {
		pos := Position{start.X - i, start.Y}
		body[i] = pos
		bodySet[pos.Key()] = true
	}

	return &amp;Snake{
		Body:    body,
		BodySet: bodySet,
		Dir:     Right,
	}
}

func (s *Snake) Head() Position {
	return s.Body[0]
}

func (s *Snake) Tail() Position {
	return s.Body[len(s.Body)-1]
}

func (s *Snake) Length() int {
	return len(s.Body)
}

// Move advances the snake, returns (newHead, removedTail or nil)
func (s *Snake) Move() (Position, *Position) {
	newHead := s.Head().Move(s.Dir)

	// Prepend new head
	s.Body = append([]Position{newHead}, s.Body...)
	s.BodySet[newHead.Key()] = true

	var removedTail *Position
	if s.PendingGrowth &gt; 0 {
		s.PendingGrowth--
	} else {
		tail := s.Body[len(s.Body)-1]
		removedTail = &amp;tail
		delete(s.BodySet, tail.Key())
		s.Body = s.Body[:len(s.Body)-1]
	}

	return newHead, removedTail
}

func (s *Snake) Grow(amount int) {
	s.PendingGrowth += amount
}

func (s *Snake) ChangeDirection(newDir Direction) bool {
	if newDir != s.Dir.Opposite() {
		s.Dir = newDir
		return true
	}
	return false
}

func (s *Snake) CollidesWithSelf() bool {
	head := s.Head()
	for _, pos := range s.Body[1:] {
		if pos == head {
			return true
		}
	}
	return false
}

func (s *Snake) Occupies(pos Position) bool {
	return s.BodySet[pos.Key()]
}

// Food represents a food item
type Food struct {
	Position     Position
	Points       int
	GrowthAmount int
}

// GameBoard manages the game boundaries
type GameBoard struct {
	Width, Height int
}

func (b *GameBoard) IsWithinBounds(pos Position) bool {
	return pos.X &gt;= 0 &amp;&amp; pos.X &lt; b.Width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; b.Height
}

func (b *GameBoard) TotalCells() int {
	return b.Width * b.Height
}

// FoodSpawner handles optimized food placement
type FoodSpawner struct {
	Board      *GameBoard
	Available  []Position
	PosToIndex map[string]int
}

func NewFoodSpawner(board *GameBoard, occupied map[string]bool) *FoodSpawner {
	spawner := &amp;FoodSpawner{
		Board:      board,
		Available:  make([]Position, 0),
		PosToIndex: make(map[string]int),
	}

	for y := 0; y &lt; board.Height; y++ {
		for x := 0; x &lt; board.Width; x++ {
			pos := Position{x, y}
			if !occupied[pos.Key()] {
				spawner.PosToIndex[pos.Key()] = len(spawner.Available)
				spawner.Available = append(spawner.Available, pos)
			}
		}
	}

	return spawner
}

func (fs *FoodSpawner) Spawn() *Food {
	if len(fs.Available) == 0 {
		return nil
	}

	idx := rand.Intn(len(fs.Available))
	pos := fs.Available[idx]
	fs.removePosition(pos)

	return &amp;Food{
		Position:     pos,
		Points:       10,
		GrowthAmount: 1,
	}
}

func (fs *FoodSpawner) removePosition(pos Position) {
	key := pos.Key()
	idx, exists := fs.PosToIndex[key]
	if !exists {
		return
	}

	// Swap with last
	lastPos := fs.Available[len(fs.Available)-1]
	fs.Available[idx] = lastPos
	fs.PosToIndex[lastPos.Key()] = idx

	// Remove last
	fs.Available = fs.Available[:len(fs.Available)-1]
	delete(fs.PosToIndex, key)
}

func (fs *FoodSpawner) addPosition(pos Position) {
	key := pos.Key()
	if _, exists := fs.PosToIndex[key]; exists {
		return
	}
	fs.PosToIndex[key] = len(fs.Available)
	fs.Available = append(fs.Available, pos)
}

func (fs *FoodSpawner) OnSnakeMove(newHead Position, removedTail *Position) {
	fs.removePosition(newHead)
	if removedTail != nil {
		fs.addPosition(*removedTail)
	}
}

// GameState represents the current state of the game
type GameState int

const (
	Running GameState = iota
	GameOver
	Victory
	Paused
)

func (gs GameState) String() string {
	names := []string{&quot;RUNNING&quot;, &quot;GAME_OVER&quot;, &quot;VICTORY&quot;, &quot;PAUSED&quot;}
	return names[gs]
}

// GameSnapshot for serialization
type GameSnapshot struct {
	SnakeBody      [][]int `json:&quot;snake_body&quot;`
	SnakeDirection string  `json:&quot;snake_direction&quot;`
	FoodPosition   []int   `json:&quot;food_position,omitempty&quot;`
	Score          int     `json:&quot;score&quot;`
	Moves          int     `json:&quot;moves&quot;`
	BoardWidth     int     `json:&quot;board_width&quot;`
	BoardHeight    int     `json:&quot;board_height&quot;`
	State          string  `json:&quot;state&quot;`
	Timestamp      int64   `json:&quot;timestamp&quot;`
}

// SnakeGame is the main game controller
type SnakeGame struct {
	Board       *GameBoard
	Snake       *Snake
	FoodSpawner *FoodSpawner
	Food        *Food
	Score       int
	Moves       int
	State       GameState
	InputQueue  []Direction
	FoodEaten   int
	StartTime   time.Time
}

func NewSnakeGame(width, height, initialLength int) *SnakeGame {
	board := &amp;GameBoard{width, height}
	startPos := Position{width / 2, height / 2}
	snake := NewSnake(startPos, initialLength)
	foodSpawner := NewFoodSpawner(board, snake.BodySet)

	game := &amp;SnakeGame{
		Board:       board,
		Snake:       snake,
		FoodSpawner: foodSpawner,
		State:       Running,
		InputQueue:  make([]Direction, 0, 2),
		StartTime:   time.Now(),
	}

	game.spawnFood()
	return game
}

func (g *SnakeGame) spawnFood() {
	g.Food = g.FoodSpawner.Spawn()
	if g.Food == nil {
		g.State = Victory
	}
}

func (g *SnakeGame) QueueDirection(dir Direction) {
	if g.State != Running || len(g.InputQueue) &gt;= 2 {
		return
	}

	var refDir Direction
	if len(g.InputQueue) &gt; 0 {
		refDir = g.InputQueue[len(g.InputQueue)-1]
	} else {
		refDir = g.Snake.Dir
	}

	if dir != refDir.Opposite() {
		g.InputQueue = append(g.InputQueue, dir)
	}
}

func (g *SnakeGame) Update() bool {
	if g.State != Running {
		return false
	}

	// Process buffered input
	if len(g.InputQueue) &gt; 0 {
		newDir := g.InputQueue[0]
		g.InputQueue = g.InputQueue[1:]
		g.Snake.ChangeDirection(newDir)
	}

	// Move snake
	newHead, removedTail := g.Snake.Move()
	g.Moves++

	// Update food spawner
	g.FoodSpawner.OnSnakeMove(newHead, removedTail)

	// Boundary collision
	if !g.Board.IsWithinBounds(newHead) {
		g.State = GameOver
		return false
	}

	// Self collision
	if g.Snake.CollidesWithSelf() {
		g.State = GameOver
		return false
	}

	// Food collision
	if g.Food != nil &amp;&amp; newHead == g.Food.Position {
		g.handleFoodEaten()
	}

	return true
}

func (g *SnakeGame) handleFoodEaten() {
	g.Score += g.Food.Points
	g.Snake.Grow(g.Food.GrowthAmount)
	g.FoodEaten++
	g.spawnFood()
}

func (g *SnakeGame) GetSnapshot() GameSnapshot {
	body := make([][]int, len(g.Snake.Body))
	for i, pos := range g.Snake.Body {
		body[i] = []int{pos.X, pos.Y}
	}

	snapshot := GameSnapshot{
		SnakeBody:      body,
		SnakeDirection: g.Snake.Dir.String(),
		Score:          g.Score,
		Moves:          g.Moves,
		BoardWidth:     g.Board.Width,
		BoardHeight:    g.Board.Height,
		State:          g.State.String(),
		Timestamp:      time.Now().Unix(),
	}

	if g.Food != nil {
		snapshot.FoodPosition = []int{g.Food.Position.X, g.Food.Position.Y}
	}

	return snapshot
}

func (g *SnakeGame) GetStatistics() map[string]interface{} {
	elapsed := time.Since(g.StartTime).Seconds()
	movesPerFood := float64(g.Moves)
	if g.FoodEaten &gt; 0 {
		movesPerFood = float64(g.Moves) / float64(g.FoodEaten)
	}

	return map[string]interface{}{
		&quot;score&quot;:          g.Score,
		&quot;snake_length&quot;:   g.Snake.Length(),
		&quot;food_eaten&quot;:     g.FoodEaten,
		&quot;moves&quot;:          g.Moves,
		&quot;elapsed_seconds&quot;: elapsed,
		&quot;moves_per_food&quot;: movesPerFood,
		&quot;board_coverage&quot;: float64(g.Snake.Length()) / float64(g.Board.TotalCells()),
	}
}

func (g *SnakeGame) Render() string {
	grid := make([][]rune, g.Board.Height)
	for y := range grid {
		grid[y] = make([]rune, g.Board.Width)
		for x := range grid[y] {
			grid[y][x] = '.'
		}
	}

	// Draw snake
	for i, pos := range g.Snake.Body {
		if g.Board.IsWithinBounds(pos) {
			if i == 0 {
				grid[pos.Y][pos.X] = 'O'
			} else {
				grid[pos.Y][pos.X] = 'o'
			}
		}
	}

	// Draw food
	if g.Food != nil {
		grid[g.Food.Position.Y][g.Food.Position.X] = '*'
	}

	// Build output
	var sb strings.Builder
	border := &quot;+&quot; + strings.Repeat(&quot;-&quot;, g.Board.Width) + &quot;+&quot;
	sb.WriteString(border + &quot;\n&quot;)
	for _, row := range grid {
		sb.WriteString(&quot;|&quot; + string(row) + &quot;|\n&quot;)
	}
	sb.WriteString(border + &quot;\n&quot;)
	sb.WriteString(fmt.Sprintf(&quot;Score: %d | Length: %d | Moves: %d | State: %s\n&quot;,
		g.Score, g.Snake.Length(), g.Moves, g.State))

	return sb.String()
}

// LeetCode 353 implementation
type SnakeGameLC struct {
	Width, Height int
	FoodQueue     [][]int
	Snake         [][]int
	SnakeSet      map[string]bool
	Score         int
}

func NewSnakeGameLC(width, height int, food [][]int) *SnakeGameLC {
	return &amp;SnakeGameLC{
		Width:     width,
		Height:    height,
		FoodQueue: food,
		Snake:     [][]int{{0, 0}},
		SnakeSet:  map[string]bool{&quot;0,0&quot;: true},
		Score:     0,
	}
}

func (g *SnakeGameLC) Move(direction string) int {
	dirs := map[string][]int{
		&quot;U&quot;: {-1, 0},
		&quot;D&quot;: {1, 0},
		&quot;L&quot;: {0, -1},
		&quot;R&quot;: {0, 1},
	}

	d := dirs[direction]
	head := g.Snake[0]
	newHead := []int{head[0] + d[0], head[1] + d[1]}

	// Boundary check
	if newHead[0] &lt; 0 || newHead[0] &gt;= g.Height ||
		newHead[1] &lt; 0 || newHead[1] &gt;= g.Width {
		return -1
	}

	eating := len(g.FoodQueue) &gt; 0 &amp;&amp;
		g.FoodQueue[0][0] == newHead[0] &amp;&amp;
		g.FoodQueue[0][1] == newHead[1]

	// Remove tail before collision check
	if !eating {
		tail := g.Snake[len(g.Snake)-1]
		key := fmt.Sprintf(&quot;%d,%d&quot;, tail[0], tail[1])
		delete(g.SnakeSet, key)
		g.Snake = g.Snake[:len(g.Snake)-1]
	}

	// Self collision
	key := fmt.Sprintf(&quot;%d,%d&quot;, newHead[0], newHead[1])
	if g.SnakeSet[key] {
		return -1
	}

	// Add new head
	g.Snake = append([][]int{newHead}, g.Snake...)
	g.SnakeSet[key] = true

	if eating {
		g.Score++
		g.FoodQueue = g.FoodQueue[1:]
	}

	return g.Score
}

func main() {
	rand.Seed(time.Now().UnixNano())

	fmt.Println(&quot;=== Snake Game Demo ===\n&quot;)

	game := NewSnakeGame(15, 10, 3)

	fmt.Println(&quot;Initial state:&quot;)
	fmt.Println(game.Render())

	// Simulate moves
	moves := []struct {
		dir   Direction
		count int
	}{
		{Right, 3},
		{Down, 2},
		{Left, 4},
		{Up, 2},
	}

	for _, m := range moves {
		game.QueueDirection(m.dir)
		for i := 0; i &lt; m.count; i++ {
			if !game.Update() {
				fmt.Printf(&quot;Game ended: %s\n&quot;, game.State)
				break
			}
		}
	}

	fmt.Println(&quot;After moves:&quot;)
	fmt.Println(game.Render())

	// Show statistics
	stats := game.GetStatistics()
	fmt.Println(&quot;Statistics:&quot;)
	for key, value := range stats {
		fmt.Printf(&quot;  %s: %v\n&quot;, key, value)
	}

	// Demonstrate serialization
	snapshot := game.GetSnapshot()
	jsonData, _ := json.MarshalIndent(snapshot, &quot;&quot;, &quot;  &quot;)
	fmt.Printf(&quot;\nSnapshot JSON:\n%s\n&quot;, string(jsonData)[:200]+&quot;...&quot;)
}
</code></pre>
<hr />
<h2 id="complexity-analysis">Complexity Analysis</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Move snake</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Deque operations</td>
</tr>
<tr>
<td>Self-collision check</td>
<td>O(1)</td>
<td>O(n)</td>
<td>HashSet lookup, n = snake length</td>
</tr>
<tr>
<td>Boundary check</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Simple comparison</td>
</tr>
<tr>
<td>Food spawn (naive)</td>
<td>O(W*H)</td>
<td>O(W*H)</td>
<td>W=width, H=height</td>
</tr>
<tr>
<td>Food spawn (optimized)</td>
<td>O(1)</td>
<td>O(W*H)</td>
<td>Maintained empty set</td>
</tr>
<tr>
<td>Render</td>
<td>O(W*H + n)</td>
<td>O(W*H)</td>
<td>Grid creation + snake overlay</td>
</tr>
<tr>
<td>Serialize state</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Snake body copying</td>
</tr>
</tbody>
</table>
<p><strong>Overall per-tick complexity: O(1)</strong> with optimized food spawner and HashSet collision detection.</p>
<hr />
<h2 id="related-topics">Related Topics</h2>
<ul>
<li><a href="/topic/data-structures/deque">[deque]</a> - Double-ended queue for O(1) body management</li>
<li><a href="/topic/data-structures/hash-set">[hash-set]</a> - O(1) collision detection</li>
<li><a href="/topic/design-patterns/state-machine">[state-machine]</a> - Game state transitions</li>
<li><a href="/topic/system-design/event-sourcing">[event-sourcing]</a> - Replay system design</li>
<li><a href="/topic/algorithms/spatial-partitioning">[spatial-partitioning]</a> - Multiplayer collision optimization</li>
<li><a href="/topic/game-dev/game-loop">[game-loop]</a> - Fixed vs variable time step patterns</li>
</ul>
