<h1 id="event-driven-architecture-complete-guide">Event-Driven Architecture: Complete Guide</h1>
<h2 id="overview">Overview</h2>
<p>Event-Driven Architecture (EDA) is a software design pattern where the flow of the program is determined by events. This comprehensive guide covers everything from fundamentals to advanced patterns, implementation details, and best practices.</p>
<p><strong>Tags:</strong> Events, Architecture, Kafka, Messaging, Design</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#fundamentals">Fundamentals</a></li>
<li><a href="#event-types">Event Types &amp; Structures</a></li>
<li><a href="#messaging-infrastructure">Messaging Infrastructure</a></li>
<li><a href="#event-sourcing">Event Sourcing</a></li>
<li><a href="#cqrs">CQRS Pattern</a></li>
<li><a href="#saga">Saga Pattern</a></li>
<li><a href="#schema-management">Schema Management</a></li>
<li><a href="#testing">Testing Strategies</a></li>
<li><a href="#observability">Observability</a></li>
<li><a href="#production">Production Considerations</a></li>
</ol>
<hr />
<h2 id="fundamentals">Fundamentals</h2>
<h3 id="what-is-event-driven-architecture">What is Event-Driven Architecture?</h3>
<div>
<h4>EVENT-DRIVEN ARCHITECTURE</h4>
  <!-- Traditional Request-Response -->
<div>TRADITIONAL REQUEST-RESPONSE:</div>
<div>
<div>
<div>Client</div>
<div>—Request→</div>
<div>Service A</div>
<div>—Request→</div>
<div>Service B</div>
</div>
<div>
<div>Client</div>
<div>←Response—</div>
<div>Service A</div>
<div>←Response—</div>
<div>Service B</div>
</div>
<div>
<span>Synchronous</span>
<span>Tight coupling</span>
<span>Caller waits</span>
<span>Failure propagates</span>
</div>
</div>
  <!-- Event-Driven -->
<div>EVENT-DRIVEN:</div>
<div>
<div>
<div>
<div>Service A</div>
<div>(Publisher)</div>
</div>
<div>—Event→</div>
<div>
<div>Event Bus</div>
<div>(Kafka)</div>
</div>
<div>—Event→</div>
<div>
<div>Service B</div>
<div>(Subscriber)</div>
</div>
</div>
<div>
<div></div>
<div></div>
<div>└—Event→</div>
<div>
<div>Service C</div>
<div>(Subscriber)</div>
</div>
</div>
<div>
<span>Asynchronous</span>
<span>Loose coupling</span>
<span>Publisher doesn't wait</span>
<span>Failure isolated</span>
</div>
</div>
</div>
<h3 id="core-concepts">Core Concepts</h3>
<div>
<h4>CORE EDA CONCEPTS</h4>
<div>
    <!-- EVENT -->
<div>
<div>EVENT</div>
<div>A record of something that happened in the system</div>
<div>
<div>Characteristics:</div>
<div>- Immutable (cannot be changed after creation)</div>
<div>- Past tense (OrderCreated, not CreateOrder)</div>
<div>- Contains enough data for consumers</div>
<div>- Self-describing (includes type and schema version)</div>
</div>
</div>
    <!-- PRODUCER -->
<div>
<div>PRODUCER (Publisher)</div>
<div>Service that emits events when something happens</div>
<div>
<div>Responsibilities:</div>
<div>- Create well-formed events</div>
<div>- Ensure delivery to message broker</div>
<div>- Handle publish failures</div>
<div>- Not responsible for post-publish handling</div>
</div>
</div>
    <!-- CONSUMER -->
<div>
<div>CONSUMER (Subscriber)</div>
<div>Service that reacts to events</div>
<div>
<div>Responsibilities:</div>
<div>- Subscribe to relevant topics</div>
<div>- Process events idempotently</div>
<div>- Handle processing failures</div>
<div>- Manage consumer offsets</div>
</div>
</div>
    <!-- EVENT BROKER -->
<div>
<div>EVENT BROKER</div>
<div>Infrastructure that routes events from producers to consumers</div>
<div>
<span>Kafka</span>
<span>RabbitMQ</span>
<span>EventBridge</span>
<span>Redis Streams</span>
</div>
<div>
<div>Responsibilities:</div>
<div>- Receive events from producers</div>
<div>- Store events (optionally)</div>
<div>- Deliver events to consumers</div>
<div>- Handle consumer groups and partitioning</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="event-types">Event Types</h2>
<h3 id="event-classification">Event Classification</h3>
<div>
<h4>EVENT TYPES</h4>
<div>
    <!-- Domain Events -->
<div>
<div>1. DOMAIN EVENTS</div>
<div>Business-meaningful events within a bounded context</div>
<div>
<span>OrderPlaced</span>
<span>PaymentReceived</span>
<span>InventoryReserved</span>
<span>ShipmentDelivered</span>
</div>
<div>
<div>- Named in business language</div>
<div>- Contains business-relevant data</div>
<div>- Triggers business workflows</div>
</div>
</div>
    <!-- Integration Events -->
<div>
<div>2. INTEGRATION EVENTS</div>
<div>Events that cross service boundaries</div>
<div>
<div>Design considerations:</div>
<div>- Should be versioned</div>
<div>- Minimize data exposure</div>
<div>- Consider backward compatibility</div>
</div>
<div>
<span>Anti-pattern:</span> <span>Exposing all domain events as integration events</span>
</div>
</div>
    <!-- Event Notification -->
<div>
<div>3. EVENT NOTIFICATION</div>
<div>Minimal event that signals something happened</div>
<div>
{ <span>"type"</span>: <span>"OrderStatusChanged"</span>, <span>"order_id"</span>: <span>"123"</span> }
</div>
<div>
<span>Pros:</span> <span>Small payload, less coupling</span><br/>
<span>Cons:</span> <span>Requires callback for details</span>
</div>
</div>
    <!-- Event-Carried State Transfer -->
<div>
<div>4. EVENT-CARRIED STATE TRANSFER</div>
<div>Event contains all data needed by consumers</div>
<div>
{ <span>"type"</span>: <span>"OrderCreated"</span>,<br/>
&nbsp;&nbsp;<span>"customer"</span>: { ... },<br/>
&nbsp;&nbsp;<span>"items"</span>: [...], <span>"total"</span>: <span>150.00</span> }
</div>
<div>
<span>Pros:</span> <span>No callbacks, consumer autonomous</span><br/>
<span>Cons:</span> <span>Larger payload, data duplication</span>
</div>
</div>
</div>
</div>
<h3 id="event-structure">Event Structure</h3>
<div>
<h4>STANDARD EVENT STRUCTURE</h4>
<div>
    <!-- Metadata Section -->
<div>
<div>METADATA (Envelope)</div>
<div>
<div><span>"id"</span>: <span>"evt-550e8400-..."</span></div>
<div><span>"type"</span>: <span>"com.company.order.OrderCreated"</span></div>
<div><span>"source"</span>: <span>"order-service"</span></div>
<div><span>"spec_version"</span>: <span>"1.0"</span></div>
<div><span>"time"</span>: <span>"2024-01-15T10:30:00Z"</span></div>
<div>
<span>// Correlation</span><br/>
<span>"correlation_id"</span>: <span>"req-abc123"</span><br/>
<span>"causation_id"</span>: <span>"evt-xyz789"</span>
</div>
</div>
</div>
    <!-- Payload Section -->
<div>
<div>PAYLOAD (Business Data)</div>
<div>
<div><span>"data"</span>: {</div>
<div><span>"order_id"</span>: <span>"ord-123"</span>,</div>
<div><span>"customer_id"</span>: <span>"cust-456"</span>,</div>
<div><span>"items"</span>: [{</div>
<div><span>"product_id"</span>: <span>"prod-789"</span>,</div>
<div><span>"quantity"</span>: <span>2</span>,</div>
<div><span>"unit_price"</span>: <span>49.99</span></div>
<div>}],</div>
<div><span>"total"</span>: <span>99.98</span></div>
<div>}</div>
</div>
</div>
</div>
  <!-- CloudEvents Specification -->
<div>
<div>CLOUDEVENTS SPECIFICATION</div>
<div>Industry standard for event format - <span>https://cloudevents.io/</span></div>
<div>
<div>
<span>Required:</span>
<span>id, source, specversion, type</span>
</div>
<div>
<span>Optional:</span>
<span>datacontenttype, dataschema, subject, time</span>
</div>
</div>
</div>
</div>
<hr />
<h2 id="messaging-infrastructure">Messaging Infrastructure</h2>
<h3 id="apache-kafka-deep-dive">Apache Kafka Deep Dive</h3>
<div>
<h4>KAFKA ARCHITECTURE</h4>
  <!-- Cluster Topology -->
<div>CLUSTER TOPOLOGY:</div>
<div>
<div>
<div>Producers</div>
<div>→</div>
<div>
<div>KAFKA CLUSTER</div>
<div>
<div>
<div>Broker 1</div>
<div>P0* P1 P2*</div>
</div>
<div>
<div>Broker 2</div>
<div>P0 P1 P2</div>
</div>
<div>
<div>Broker 3</div>
<div>P1* P2 P0</div>
</div>
</div>
</div>
<div>→</div>
<div>Consumers</div>
</div>
<div>
<span>P* = Partition Leader</span> | <span>P = Partition Replica</span>
</div>
</div>
  <!-- Topic & Partitions -->
<div>TOPIC & PARTITIONS:</div>
<div>
<div><strong>Topic:</strong> order-events (3 partitions, replication factor 3)</div>
<div>
<div><span>Partition 0:</span> <span>[msg0][msg3][msg6][msg9]...</span></div>
<div><span>Partition 1:</span> <span>[msg1][msg4][msg7][msg10]...</span></div>
<div><span>Partition 2:</span> <span>[msg2][msg5][msg8][msg11]...</span></div>
</div>
<div>
<div><strong>Partitioning strategy:</strong></div>
<div>- Key-based: hash(order_id) % num_partitions</div>
<div>- Round-robin: If no key specified</div>
<div><strong>Same key always goes to same partition - Ordering guarantee</strong></div>
</div>
</div>
  <!-- Consumer Groups -->
<div>CONSUMER GROUPS:</div>
<div>
<div>
<div>Group: order-processor</div>
<div>
<div>Consumer 1 ← Partition 0</div>
<div>Consumer 2 ← Partition 1</div>
<div>Consumer 3 ← Partition 2</div>
</div>
</div>
<div>
<div>Group: analytics</div>
<div>
<div>Consumer A ← All partitions</div>
<div>(single consumer handles all)</div>
</div>
</div>
</div>
<div>
<strong>Note:</strong> Max consumers per group = Number of partitions
</div>
</div>
<h3 id="topic-design">Topic Design</h3>
<div>
<h4>TOPIC DESIGN PATTERNS</h4>
<div>
    <!-- Single Event Type Per Topic -->
<div>
<div>1. SINGLE EVENT TYPE PER TOPIC</div>
<div>
<span>order.created</span>
<span>order.shipped</span>
<span>order.delivered</span>
<span>payment.received</span>
</div>
<div>
<div>+ Clear separation</div>
<div>+ Easy to subscribe to specific events</div>
<div>- Many topics to manage</div>
<div>- No ordering across event types</div>
</div>
</div>
    <!-- Multiple Event Types Per Topic -->
<div>
<div>2. MULTIPLE EVENT TYPES PER TOPIC</div>
<div>
<div><span>order.events</span>: OrderCreated, OrderShipped, OrderDelivered</div>
<div><span>payment.events</span>: PaymentReceived, RefundIssued</div>
</div>
<div>
<div>+ Fewer topics</div>
<div>+ Natural ordering within aggregate</div>
<div>- Consumers receive unneeded events</div>
</div>
</div>
</div>
  <!-- Partition Count Guidelines -->
<div>
<div>PARTITION COUNT GUIDELINES</div>
<div>
<div>
<div>Factors to consider:</div>
<div>
<div>- Expected throughput</div>
<div>- Number of consumer instances</div>
<div>- Ordering requirements</div>
</div>
</div>
<div>
<div>Rules of thumb:</div>
<div>
<div>- partitions>= max consumers</div>
<div>- Cannot reduce partitions later</div>
<div>- More partitions = more overhead</div>
</div>
</div>
</div>
<div>
<div>Example Calculation:</div>
<div>
  Target: 100K msgs/sec | Single partition: ~10K msgs/sec | Need: 10 partitions | With buffer: 12-15 partitions
</div>
</div>
</div>
</div>
<hr />
<h2 id="event-sourcing-deep-dive">Event Sourcing Deep Dive</h2>
<div>
<h4>EVENT SOURCING ARCHITECTURE</h4>
  <!-- Overview -->
<div>
<div>OVERVIEW</div>
<div>Instead of storing current state, store ALL state changes (events)</div>
<div>
<div>
<span>Traditional:</span> <span>State = current_values</span>
</div>
<div>
<span>Event Sourced:</span> <span>State = fold(initial, all_events)</span>
</div>
</div>
</div>
  <!-- Event Store -->
<div>EVENT STORE:</div>
<div>
<table>
<tr>
<th>stream_id</th>
<th>version</th>
<th>event_type</th>
<th>ts</th>
</tr>
<tr>
<td>order-123</td>
<td>1</td>
<td>OrderCreated</td>
<td>t1</td>
</tr>
<tr>
<td>order-123</td>
<td>2</td>
<td>ItemAdded</td>
<td>t2</td>
</tr>
<tr>
<td>order-123</td>
<td>3</td>
<td>PaymentReceived</td>
<td>t3</td>
</tr>
<tr>
<td>order-123</td>
<td>4</td>
<td>OrderShipped</td>
<td>t4</td>
</tr>
</table>
<div>
<strong>Constraints:</strong> UNIQUE(stream_id, version) | Append-only (no updates/deletes)
</div>
</div>
  <!-- Rebuilding State & Snapshots -->
<div>
<div>
<div>REBUILDING STATE</div>
<div>
<div><span>1.</span> Load all events for entity</div>
<div><span>2.</span> Create empty aggregate</div>
<div><span>3.</span> Apply each event to build current state</div>
</div>
<div>
  for event in events:<br/>
  &nbsp;&nbsp;order.Apply(event)
</div>
</div>
<div>
<div>SNAPSHOTS (Optimization)</div>
<div>
<strong>Problem:</strong> Rebuilding from 10K events is slow
</div>
<div>
<strong>Solution:</strong> Periodically save snapshots
</div>
<div>
[E1][E2]...[E100][<span>Snapshot@100</span>][E101]...[E150]
</div>
<div>
  Load snapshot v100, apply events 101-150
</div>
</div>
</div>
</div>
<hr />
<h2 id="cqrs-implementation">CQRS Implementation</h2>
<div>
<h4>CQRS + EVENT SOURCING</h4>
  <!-- Application Flow -->
<div>
<div>APPLICATION</div>
</div>
<div>
    <!-- Commands (Write) Side -->
<div>
<div>↓</div>
<div>
<div>COMMANDS</div>
<div>
<span>CreateOrder</span>
<span>AddItem</span>
<span>ProcessPayment</span>
</div>
</div>
<div>↓</div>
<div>
<div>WRITE MODEL</div>
<div>
<div>- Event Store</div>
<div>- Domain Logic</div>
<div>- Aggregates</div>
</div>
</div>
<div>↓</div>
<div>
<strong>PostgreSQL</strong><br/>(Event Store)
</div>
</div>
    <!-- Queries (Read) Side -->
<div>
<div>↓</div>
<div>
<div>QUERIES</div>
<div>
<span>GetOrder</span>
<span>ListOrders</span>
<span>GetAnalytics</span>
</div>
</div>
<div>↓</div>
<div>
<div>READ MODEL</div>
<div>
<div>- Materialized Views</div>
<div>- Optimized for queries</div>
</div>
</div>
<div>↓</div>
<div>
<div>
<strong>Elasticsearch</strong><br/>(Search)
</div>
<div>
<strong>Redis</strong><br/>(Analytics)
</div>
</div>
</div>
</div>
  <!-- Events Flow -->
<div>
<div>
<strong>Events</strong> flow from Write Model → Read Model
</div>
</div>
  <!-- Projection Example -->
<div>
<div>PROJECTION EXAMPLE:</div>
<div>
<div><span>case</span> <span>OrderCreated</span>: INSERT INTO order_list...</div>
<div><span>case</span> <span>ItemAdded</span>: UPDATE order_list SET total += price</div>
<div><span>case</span> <span>OrderShipped</span>: UPDATE order_list SET status = 'SHIPPED'</div>
</div>
</div>
</div>
<hr />
<h2 id="schema-management">Schema Management</h2>
<div>
<h4>SCHEMA EVOLUTION</h4>
  <!-- Schema Registry Flow -->
<div>SCHEMA REGISTRY:</div>
<div>
<div>
<div>Producer</div>
<div>→</div>
<div>Schema Registry</div>
<div>→</div>
<div>Kafka</div>
<div>→</div>
<div>Consumer</div>
</div>
<div>
<span>1.</span> Register schema <span>2.</span> Get schema ID <span>3.</span> Send (id + data) <span>4.</span> Lookup <span>5.</span> Deserialize
</div>
<div>
<span>Confluent</span>
<span>AWS Glue</span>
<span>Karapace</span>
</div>
</div>
  <!-- Compatibility Modes -->
<div>COMPATIBILITY MODES:</div>
<div>
<div>
<div>BACKWARD (Recommended)</div>
<div>
<div>New schema reads old data</div>
<div>Deploy consumers first</div>
<div>+ Add optional fields</div>
<div>- Cannot add required</div>
</div>
</div>
<div>
<div>FORWARD</div>
<div>
<div>Old schema reads new data</div>
<div>Deploy producers first</div>
<div>+ Add fields</div>
<div>- Cannot remove required</div>
</div>
</div>
<div>
<div>FULL</div>
<div>
<div>Both directions compatible</div>
<div>Safest but restrictive</div>
<div>+ Optional fields w/ defaults</div>
</div>
</div>
</div>
  <!-- Avro Schema Example -->
<div>AVRO SCHEMA EXAMPLE:</div>
<div>
<div>
<div>Version 1</div>
<div>
{ <span>"fields"</span>: [<br/>
&nbsp;&nbsp;{<span>"order_id"</span>: <span>string</span>},<br/>
&nbsp;&nbsp;{<span>"customer_id"</span>: <span>string</span>},<br/>
&nbsp;&nbsp;{<span>"total"</span>: <span>double</span>}<br/>
  ]}
</div>
</div>
<div>
<div>Version 2 (backward compatible)</div>
<div>
{ <span>"fields"</span>: [<br/>
&nbsp;&nbsp;... <span>(same as v1)</span><br/>
&nbsp;&nbsp;{<span>"currency"</span>: <span>string</span>,<br/>
&nbsp;&nbsp;&nbsp;<span>"default"</span>: <span>"USD"</span>}<br/>
  ]}
</div>
</div>
</div>
</div>
<hr />
<h2 id="observability">Observability</h2>
<div>
<h4>EDA OBSERVABILITY</h4>
  <!-- Key Metrics -->
<div>KEY METRICS:</div>
<div>
<div>
<div>PRODUCER</div>
<div>
<div>- Events published/sec</div>
<div>- Publish latency (p50, p95, p99)</div>
<div>- Publish failures</div>
<div>- Batch size</div>
</div>
</div>
<div>
<div>CONSUMER</div>
<div>
<div>- Events consumed/sec</div>
<div>- Processing latency</div>
<div>- Consumer lag (CRITICAL!)</div>
<div>- Processing failures</div>
<div>- DLQ size</div>
</div>
</div>
<div>
<div>BROKER</div>
<div>
<div>- Messages in/out per topic</div>
<div>- Disk usage</div>
<div>- Replication lag</div>
<div>- Under-replicated partitions</div>
</div>
</div>
</div>
  <!-- Distributed Tracing -->
<div>DISTRIBUTED TRACING:</div>
<div>
<div>
<div>Producer: Include trace context</div>
<div>
  event := Event{<br/>
  &nbsp;&nbsp;TraceID: span.TraceID(),<br/>
  &nbsp;&nbsp;SpanID: span.SpanID(),<br/>
  &nbsp;&nbsp;CorrelationID: ctx.Value(...)<br/>
  }
</div>
</div>
<div>
<div>Consumer: Continue trace</div>
<div>
  parentCtx := trace.Context...<br/>
  ctx, span := tracer.Start(<br/>
  &nbsp;&nbsp;parentCtx, "process-event"<br/>
  )
</div>
</div>
</div>
  <!-- Alerting -->
<div>ALERTING:</div>
<div>
<div>
<div>CRITICAL</div>
<div>
<div>- Consumer lag> 10,000 messages</div>
<div>- DLQ messages> 0</div>
<div>- Under-replicated partitions> 0</div>
</div>
</div>
<div>
<div>WARNING</div>
<div>
<div>- Consumer lag growing</div>
<div>- Processing latency> SLA</div>
<div>- Disk usage> 80%</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="production-considerations">Production Considerations</h2>
<div>
<h4>PRODUCTION CHECKLIST</h4>
<div>
    <!-- Message Durability -->
<div>
<div>MESSAGE DURABILITY</div>
<div>
<div>[ ] Replication factor>= 3</div>
<div>[ ] min.insync.replicas>= 2</div>
<div>[ ] acks = all (producer)</div>
<div>[ ] Retention 7+ days for critical</div>
</div>
</div>
    <!-- Consumer Reliability -->
<div>
<div>CONSUMER RELIABILITY</div>
<div>
<div>[ ] Idempotent processing</div>
<div>[ ] Dead letter queue</div>
<div>[ ] Retry with backoff</div>
<div>[ ] Circuit breaker</div>
<div>[ ] Consumer lag alerting</div>
</div>
</div>
    <!-- Schema Management -->
<div>
<div>SCHEMA MANAGEMENT</div>
<div>
<div>[ ] Schema registry deployed</div>
<div>[ ] Compatibility configured</div>
<div>[ ] Schema validation in CI/CD</div>
</div>
</div>
    <!-- Observability -->
<div>
<div>OBSERVABILITY</div>
<div>
<div>[ ] Metrics (Prometheus/Datadog)</div>
<div>[ ] Tracing (Jaeger/Zipkin)</div>
<div>[ ] Centralized logging</div>
<div>[ ] Dashboards</div>
<div>[ ] Alerting configured</div>
</div>
</div>
    <!-- Security -->
<div>
<div>SECURITY</div>
<div>
<div>[ ] TLS for broker connections</div>
<div>[ ] Authentication (SASL)</div>
<div>[ ] Authorization (ACLs)</div>
<div>[ ] Encryption at rest</div>
</div>
</div>
    <!-- Operations -->
<div>
<div>OPERATIONS</div>
<div>
<div>[ ] Runbooks for common issues</div>
<div>[ ] Capacity planning</div>
<div>[ ] Disaster recovery plan</div>
<div>[ ] Replay procedures</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<ol>
<li><strong>Events are first-class citizens</strong> - Design events carefully, they are your API</li>
<li><strong>Idempotency is non-negotiable</strong> - Events will be delivered multiple times</li>
<li><strong>Schema evolution matters</strong> - Plan for backward compatibility from day one</li>
<li><strong>Monitor consumer lag</strong> - It's your early warning system</li>
<li><strong>Event sourcing is powerful but complex</strong> - Use only when audit trail is critical</li>
<li><strong>CQRS enables scale</strong> - But adds eventual consistency complexity</li>
<li><strong>Dead letter queues save lives</strong> - Never lose events, investigate failures later</li>
</ol>
