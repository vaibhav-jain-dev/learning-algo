<h1 id="components-used-in-microservices--distributed-systems">Components Used in Microservices &amp; Distributed Systems</h1>
<h2 id="overview">Overview</h2>
<p>Building microservices requires a rich ecosystem of components that handle service discovery, communication, data management, observability, and resilience. This guide covers all essential components needed to build production-ready distributed systems.</p>
<p><strong>Tags:</strong> Infrastructure, Components, Distributed Systems</p>
<hr />
<h2 id="architecture-component-map">Architecture Component Map</h2>
<div>
<h3>MICROSERVICES INFRASTRUCTURE</h3>
  <!-- Edge Layer -->
<div>
<div>EDGE LAYER</div>
<div>
<div>CDN</div>
<div>WAF</div>
<div>DDoS Protection</div>
<div>Rate Limiter</div>
</div>
</div>
<div>↓</div>
  <!-- API Gateway Layer -->
<div>
<div>API GATEWAY LAYER</div>
<div>
  Kong / AWS API GW / Nginx / Envoy<br/>
<span>Auth | Routing | Rate Limiting | Transformation</span>
</div>
</div>
<div>↓</div>
  <!-- Service Mesh Layer -->
<div>
<div>SERVICE MESH LAYER</div>
<div>
  Istio / Linkerd / Consul Connect<br/>
<span>mTLS | Traffic Management | Observability</span>
</div>
</div>
<div>↓</div>
  <!-- Service Layer -->
<div>
<div>SERVICE LAYER</div>
<div>
<div>User Service</div>
<div>Order Service</div>
<div>Payment Service</div>
<div>Inventory Service</div>
<div>Search Service</div>
</div>
</div>
<div>↓</div>
  <!-- Data Layer -->
<div>
<div>DATA LAYER</div>
<div>
<div>PostgreSQL</div>
<div>MongoDB</div>
<div>Redis</div>
<div>Kafka</div>
<div>Elasticsearch</div>
</div>
</div>
</div>
<hr />
<h2 id="1-api-gateway">1. API Gateway</h2>
<p>The <strong>single entry point</strong> for all client requests to backend services.</p>
<h3 id="key-functions">Key Functions</h3>
<div>
<h4>API GATEWAY FUNCTIONS</h4>
<div>
<div>
<div>ROUTING</div>
<div>/users → UserSvc<br/>/orders → OrderSvc</div>
</div>
<div>
<div>AUTHENTICATION</div>
<div>JWT Validation<br/>OAuth2/OIDC</div>
</div>
<div>
<div>RATE LIMITING</div>
<div>100 req/min<br/>Token Bucket</div>
</div>
<div>
<div>LOAD BALANCING</div>
<div>Round Robin<br/>Weighted</div>
</div>
<div>
<div>TRANSFORMATION</div>
<div>Request/Response<br/>Protocol Convert</div>
</div>
<div>
<div>CACHING</div>
<div>Response Cache<br/>CDN Integration</div>
</div>
</div>
</div>
<h3 id="popular-api-gateways">Popular API Gateways</h3>
<table>
<thead>
<tr>
<th>Gateway</th>
<th>Best For</th>
<th>Key Features</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Kong</strong></td>
<td>Flexibility, plugins</td>
<td>100+ plugins, Lua scripting</td>
</tr>
<tr>
<td><strong>AWS API Gateway</strong></td>
<td>AWS ecosystem</td>
<td>Serverless, managed</td>
</tr>
<tr>
<td><strong>Nginx</strong></td>
<td>Performance</td>
<td>High throughput, reverse proxy</td>
</tr>
<tr>
<td><strong>Envoy</strong></td>
<td>Service mesh</td>
<td>Cloud-native, observability</td>
</tr>
<tr>
<td><strong>Traefik</strong></td>
<td>Kubernetes</td>
<td>Auto-discovery, Let's Encrypt</td>
</tr>
</tbody>
</table>
<h3 id="example-kong-configuration">Example: Kong Configuration</h3>
<pre><code class="language-yaml"># Kong Service Configuration
services:
  - name: user-service
    url: http://user-service:8080
    routes:
      - name: user-route
        paths:
          - /api/users
    plugins:
      - name: rate-limiting
        config:
          minute: 100
      - name: jwt
        config:
          secret_is_base64: false
</code></pre>
<hr />
<h2 id="2-service-discovery">2. Service Discovery</h2>
<p>Enables services to <strong>find and communicate</strong> with each other dynamically.</p>
<h3 id="service-discovery-patterns">Service Discovery Patterns</h3>
<div>
<div>
<div>
<div>CLIENT-SIDE DISCOVERY</div>
<div>
<div>
<div>Client<br/>Service</div>
<div>1. Query →<br/>← 2. IPs</div>
<div>Service<br/>Registry</div>
</div>
<div>↓ 3. Direct Call</div>
<div>Target Service</div>
</div>
</div>
<div>
<div>SERVER-SIDE DISCOVERY</div>
<div>
<div>
<div>Client<br/>Service</div>
<div>→ 1. Request →</div>
<div>Load<br/>Balancer</div>
</div>
<div>
<div>2. Query ↔</div>
<div>Registry</div>
</div>
<div>↓ 3. Route</div>
<div>Target Service</div>
</div>
</div>
</div>
</div>
<h3 id="popular-service-discovery-tools">Popular Service Discovery Tools</h3>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Type</th>
<th>Key Features</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Consul</strong></td>
<td>Both</td>
<td>Health checks, KV store, service mesh</td>
</tr>
<tr>
<td><strong>Eureka</strong></td>
<td>Client-side</td>
<td>Spring Cloud native, Netflix OSS</td>
</tr>
<tr>
<td><strong>etcd</strong></td>
<td>Server-side</td>
<td>Distributed KV, Kubernetes native</td>
</tr>
<tr>
<td><strong>Zookeeper</strong></td>
<td>Server-side</td>
<td>Strong consistency, leader election</td>
</tr>
<tr>
<td><strong>Kubernetes DNS</strong></td>
<td>Server-side</td>
<td>Native K8s service discovery</td>
</tr>
</tbody>
</table>
<h3 id="example-consul-service-registration">Example: Consul Service Registration</h3>
<pre><code class="language-json">{
  &quot;service&quot;: {
    &quot;name&quot;: &quot;user-service&quot;,
    &quot;id&quot;: &quot;user-service-1&quot;,
    &quot;port&quot;: 8080,
    &quot;tags&quot;: [&quot;v1&quot;, &quot;primary&quot;],
    &quot;check&quot;: {
      &quot;http&quot;: &quot;http://localhost:8080/health&quot;,
      &quot;interval&quot;: &quot;10s&quot;,
      &quot;timeout&quot;: &quot;5s&quot;
    }
  }
}
</code></pre>
<hr />
<h2 id="3-load-balancer">3. Load Balancer</h2>
<p>Distributes traffic across multiple service instances.</p>
<h3 id="load-balancing-strategies">Load Balancing Strategies</h3>
<div>
<h4>LOAD BALANCING ALGORITHMS</h4>
<div>
<div>
<div>ROUND ROBIN</div>
<div>
<div>1</div>
<div>2</div>
<div>3</div>
</div>
<div>1→2→3→1→2→3</div>
</div>
<div>
<div>WEIGHTED ROUND ROBIN</div>
<div>
<div>1:3</div>
<div>2:2</div>
<div>3:1</div>
</div>
<div>1→1→1→2→2→3→1→1→1</div>
</div>
<div>
<div>LEAST CONNECTIONS</div>
<div>
<div>2</div>
<div>5</div>
<div>1</div>
</div>
<div>Next → Server 3</div>
</div>
<div>
<div>IP HASH</div>
<div>
<div>S1</div>
<div>S2</div>
<div>S3</div>
</div>
<div>hash(IP) % servers</div>
</div>
<div>
<div>LEAST RESPONSE TIME</div>
<div>
<div>50ms</div>
<div>100ms</div>
<div>30ms</div>
</div>
<div>Next → Server 3</div>
</div>
<div>
<div>RANDOM</div>
<div>
<div>?</div>
<div>?</div>
<div>?</div>
</div>
<div>Random selection</div>
</div>
</div>
</div>
<h3 id="layer-4-vs-layer-7-load-balancing">Layer 4 vs Layer 7 Load Balancing</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Layer 4 (Transport)</th>
<th>Layer 7 (Application)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Based on</strong></td>
<td>IP, TCP/UDP port</td>
<td>HTTP headers, cookies, URL</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Faster</td>
<td>Slower (inspects content)</td>
</tr>
<tr>
<td><strong>Features</strong></td>
<td>Basic routing</td>
<td>Advanced routing, SSL termination</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>High throughput</td>
<td>Content-based routing</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>HAProxy, AWS NLB</td>
<td>Nginx, AWS ALB, Envoy</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4-message-broker--event-bus">4. Message Broker / Event Bus</h2>
<p>Enables <strong>asynchronous communication</strong> between services.</p>
<h3 id="message-broker-architecture">Message Broker Architecture</h3>
<div>
<h4>MESSAGE BROKER PATTERNS</h4>
<div>
<div>POINT-TO-POINT (Queue)</div>
<div>
<div>Producer</div>
<div>→</div>
<div>Queue<br/><span>[1|2|3|4]</span></div>
<div>→</div>
<div>Consumer</div>
</div>
<div>(one consumer receives)</div>
</div>
<div>
<div>PUBLISH-SUBSCRIBE (Topic)</div>
<div>
<div>Publisher</div>
<div>→</div>
<div>Topic</div>
<div>
<div><span>→</span><div>Consumer 1</div></div>
<div><span>→</span><div>Consumer 2</div></div>
<div><span>→</span><div>Consumer 3</div></div>
</div>
</div>
<div>(all receive)</div>
</div>
<div>
<div>FAN-OUT</div>
<div>
<div>Producer</div>
<div>→</div>
<div>Exchange<br/>(fanout)</div>
<div>
<div><span>→</span><div>Queue A</div><span>→</span><div>Consumer A</div></div>
<div><span>→</span><div>Queue B</div><span>→</span><div>Consumer B</div></div>
</div>
</div>
</div>
</div>
<h3 id="message-broker-comparison">Message Broker Comparison</h3>
<table>
<thead>
<tr>
<th>Broker</th>
<th>Best For</th>
<th>Throughput</th>
<th>Ordering</th>
<th>Persistence</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Kafka</strong></td>
<td>Event streaming, logs</td>
<td>Very High (millions/sec)</td>
<td>Partition-level</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>RabbitMQ</strong></td>
<td>Task queues, RPC</td>
<td>High (100K/sec)</td>
<td>Queue-level</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Redis Streams</strong></td>
<td>Real-time, caching</td>
<td>Very High</td>
<td>Stream-level</td>
<td>Optional</td>
</tr>
<tr>
<td><strong>AWS SQS</strong></td>
<td>Serverless, AWS</td>
<td>High</td>
<td>FIFO optional</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>NATS</strong></td>
<td>IoT, edge computing</td>
<td>Very High</td>
<td>No guarantee</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<h3 id="example-kafka-topic-configuration">Example: Kafka Topic Configuration</h3>
<pre><code class="language-yaml"># Kafka Topic for Order Events
topics:
  - name: order-events
    partitions: 12
    replication-factor: 3
    config:
      retention.ms: 604800000  # 7 days
      cleanup.policy: delete
      min.insync.replicas: 2
</code></pre>
<hr />
<h2 id="5-cache-layer">5. Cache Layer</h2>
<p>Reduces latency and database load through <strong>data caching</strong>.</p>
<h3 id="caching-strategies">Caching Strategies</h3>
<div>
<h4>CACHING PATTERNS</h4>
<div>
<div>CACHE-ASIDE (Lazy Loading)</div>
<div>
<div>App</div>
<div>
<div>1. Read →</div>
<div>← Miss</div>
<div>3. Write →</div>
</div>
<div>Cache</div>
<div>2. Read ↔</div>
<div>DB</div>
</div>
</div>
<div>
<div>WRITE-THROUGH</div>
<div>
<div>App</div>
<div>1. Write →</div>
<div>Cache</div>
<div>2. Write →</div>
<div>DB</div>
</div>
</div>
<div>
<div>WRITE-BEHIND (Write-Back)</div>
<div>
<div>App</div>
<div>1. Write →</div>
<div>Cache</div>
<div>Async →</div>
<div>DB</div>
</div>
<div>(batched)</div>
</div>
</div>
<h3 id="cache-solutions">Cache Solutions</h3>
<table>
<thead>
<tr>
<th>Cache</th>
<th>Type</th>
<th>Use Case</th>
<th>Features</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Redis</strong></td>
<td>In-memory</td>
<td>Session, rate limiting</td>
<td>Pub/Sub, Lua scripting, clustering</td>
</tr>
<tr>
<td><strong>Memcached</strong></td>
<td>In-memory</td>
<td>Simple key-value</td>
<td>Multi-threaded, high performance</td>
</tr>
<tr>
<td><strong>Hazelcast</strong></td>
<td>Distributed</td>
<td>Distributed computing</td>
<td>Java native, IMDG</td>
</tr>
<tr>
<td><strong>CDN (CloudFlare)</strong></td>
<td>Edge</td>
<td>Static assets, API</td>
<td>Global distribution</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-database-layer">6. Database Layer</h2>
<h3 id="database-per-service-pattern">Database Per Service Pattern</h3>
<div>
<h4>DATABASE PER SERVICE PATTERN</h4>
<div>
<div>
<div>User Service</div>
<div>↓</div>
<div><div>PostgreSQL</div><div>(ACID)</div></div>
</div>
<div>
<div>Order Service</div>
<div>↓</div>
<div><div>MongoDB</div><div>(Flexible)</div></div>
</div>
<div>
<div>Search Service</div>
<div>↓</div>
<div><div>Elasticsearch</div><div>(Search)</div></div>
</div>
</div>
<div>
<div>WHY DIFFERENT DATABASES?</div>
<div>
<div>• User data needs strong consistency <span>(PostgreSQL)</span></div>
<div>• Orders have complex nested structures <span>(MongoDB)</span></div>
<div>• Search needs full-text indexing <span>(Elasticsearch)</span></div>
<div>• Sessions need fast access <span>(Redis)</span></div>
<div>• Analytics need columnar storage <span>(ClickHouse)</span></div>
</div>
</div>
</div>
<h3 id="polyglot-persistence">Polyglot Persistence</h3>
<pre><code>| Service | Database | Reason |
|---------|----------|--------|
| User Management | PostgreSQL | ACID, relations |
| Product Catalog | MongoDB | Flexible schema |
| Search | Elasticsearch | Full-text search |
| Session Store | Redis | Fast key-value |
| Analytics | ClickHouse | Columnar, aggregations |
| Time Series | InfluxDB | Time-based queries |
| Graph Relations | Neo4j | Complex relationships |

---
</code></pre>
<h2 id="7-observability-stack">7. Observability Stack</h2>
<h3 id="three-pillars-of-observability">Three Pillars of Observability</h3>
<div>
<h4>OBSERVABILITY PILLARS</h4>
<div>
<div>
<div>LOGS</div>
<div>What happened?</div>
<div>
<span>ELK/EFK</span>
<span>Loki</span>
</div>
</div>
<div>
<div>METRICS</div>
<div>How much happening?</div>
<div>
<span>Prometheus</span>
<span>Datadog</span>
</div>
</div>
<div>
<div>TRACES</div>
<div>Where it happened?</div>
<div>
<span>Jaeger</span>
<span>Zipkin</span>
</div>
</div>
</div>
<div>
<div>
<div>VISUALIZATION</div>
<div>
<span>Grafana</span>
<span>Kibana</span>
</div>
</div>
</div>
</div>
<h3 id="distributed-tracing">Distributed Tracing</h3>
<div>
<h4>DISTRIBUTED TRACE</h4>
<div>
<div>Trace ID: abc123</div>
<div>
<div>├── <span>Span: API Gateway</span> <span>(50ms)</span></div>
<div>└── <span>Span: Auth Service</span> <span>(10ms)</span></div>
<div>├── <span>Span: Order Service</span> <span>(200ms)</span></div>
<div>├── <span>Span: User Service</span> <span>(30ms)</span></div>
<div>├── <span>Span: Inventory Service</span> <span>(50ms)</span></div>
<div>└── <span>Span: Database Query</span> <span>(80ms)</span></div>
<div>└── <span>Span: Payment Service</span> <span>(150ms)</span></div>
<div>└── <span>Span: External Payment API</span> <span>(120ms)</span></div>
</div>
</div>
<div>Timeline:</div>
<div>
<div>
<span>0ms</span><span>100ms</span><span>200ms</span><span>300ms</span><span>400ms</span>
</div>
<div>
<div>API GW</div>
<div></div>
<div>Order Service</div>
<div></div>
<div></div>
<div></div>
<div>Payment</div>
<div></div>
</div>
</div>
</div>
<hr />
<h2 id="8-service-mesh">8. Service Mesh</h2>
<p>Handles <strong>service-to-service communication</strong> at the infrastructure layer.</p>
<h3 id="service-mesh-architecture">Service Mesh Architecture</h3>
<div>
<h4>SERVICE MESH ARCHITECTURE</h4>
<div>
<div>CONTROL PLANE</div>
<div>
<div><div>Pilot</div><div>(Discovery)</div></div>
<div><div>Citadel</div><div>(Certs)</div></div>
<div><div>Galley</div><div>(Config)</div></div>
</div>
</div>
<div>↓</div>
<div>
<div>DATA PLANE</div>
<div>
<div>
<div>Pod A</div>
<div>Sidecar (Envoy)</div>
<div>↕</div>
<div>Service A</div>
</div>
<div>← mTLS →</div>
<div>
<div>Pod B</div>
<div>Sidecar (Envoy)</div>
<div>↕</div>
<div>Service B</div>
</div>
</div>
</div>
</div>
<h3 id="service-mesh-features">Service Mesh Features</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>mTLS</strong></td>
<td>Automatic encryption between services</td>
</tr>
<tr>
<td><strong>Traffic Management</strong></td>
<td>Canary, blue-green, traffic splitting</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Automatic metrics, traces, logs</td>
</tr>
<tr>
<td><strong>Resilience</strong></td>
<td>Retries, timeouts, circuit breakers</td>
</tr>
<tr>
<td><strong>Policy Enforcement</strong></td>
<td>Access control, rate limiting</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="9-container-orchestration">9. Container Orchestration</h2>
<h3 id="kubernetes-architecture">Kubernetes Architecture</h3>
<div>
<h4>KUBERNETES CLUSTER</h4>
<div>
<div>CONTROL PLANE</div>
<div>
<div><div>API Server</div></div>
<div><div>Controller</div><div>Manager</div></div>
<div><div>Scheduler</div></div>
<div><div>etcd</div></div>
</div>
</div>
<div>
<div>WORKER NODES</div>
<div>
<div>
<div>Node 1</div>
<div>
<div>Pod 1</div>
<div>Pod 2</div>
</div>
<div>kubelet | kube-proxy</div>
</div>
<div>
<div>Node 2</div>
<div>
<div>Pod 3</div>
<div>Pod 4</div>
</div>
<div>kubelet | kube-proxy</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="10-cicd-pipeline">10. CI/CD Pipeline</h2>
<div>
<h4>MICROSERVICES CI/CD PIPELINE</h4>
<div>
<div>Code</div>
<div>→</div>
<div>Build</div>
<div>→</div>
<div>Test</div>
<div>→</div>
<div>Deploy</div>
<div>→</div>
<div>Monitor</div>
</div>
<div>
<div><div>Git Push</div><div>PR Review</div></div>
<div><div>Docker Build</div><div>Push Registry</div></div>
<div><div>Unit/Integration</div><div>E2E/Contract</div></div>
<div><div>Staging</div><div>Production</div><div>Canary</div></div>
<div><div>Prometheus</div><div>Grafana</div><div>PagerDuty</div></div>
</div>
<div>
<div>TOOLS:</div>
<div>
<span>GitHub Actions</span>
<span>Jenkins</span>
<span>GitLab CI</span>
<span>ArgoCD</span>
<span>Flux</span>
</div>
</div>
</div>
<hr />
<h2 id="component-selection-guide">Component Selection Guide</h2>
<table>
<thead>
<tr>
<th>Need</th>
<th>Recommended Components</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>API Management</strong></td>
<td>Kong + Redis (rate limiting)</td>
</tr>
<tr>
<td><strong>Service Discovery</strong></td>
<td>Consul or Kubernetes DNS</td>
</tr>
<tr>
<td><strong>Messaging</strong></td>
<td>Kafka (events) + RabbitMQ (tasks)</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>Redis Cluster</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Prometheus + Grafana + Jaeger</td>
</tr>
<tr>
<td><strong>Service Mesh</strong></td>
<td>Istio or Linkerd</td>
</tr>
<tr>
<td><strong>Container Orchestration</strong></td>
<td>Kubernetes (EKS/GKE/AKS)</td>
</tr>
<tr>
<td><strong>CI/CD</strong></td>
<td>GitHub Actions + ArgoCD</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<ol>
<li><strong>Start simple</strong> - Don't add components until you need them</li>
<li><strong>Choose managed services</strong> when possible to reduce operational burden</li>
<li><strong>Standardize</strong> on a core set of components across teams</li>
<li><strong>Observability first</strong> - You can't fix what you can't see</li>
<li><strong>Automate everything</strong> - Manual processes don't scale</li>
</ol>
