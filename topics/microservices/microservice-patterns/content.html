<h1 id="essential-microservices-patterns">Essential Microservices Patterns</h1>
<h2 id="overview">Overview</h2>
<p>This comprehensive guide covers the essential design patterns you need to know when working with microservices. These patterns address common challenges like data management, communication, resilience, and observability.</p>
<p><strong>Tags:</strong> Patterns, Architecture, Design, Best Practices</p>
<hr />
<h2 id="pattern-categories">Pattern Categories</h2>
<div>
<h3>Microservices Pattern Categories</h3>
<div>
    <!-- Decomposition -->
<div>
<div>DECOMPOSITION</div>
<div>
<div>- By Business Capability</div>
<div>- By Subdomain (DDD)</div>
<div>- Strangler Fig</div>
</div>
</div>
    <!-- Data Management -->
<div>
<div>DATA MANAGEMENT</div>
<div>
<div>- Database per Service</div>
<div>- Saga Pattern</div>
<div>- CQRS</div>
<div>- Event Sourcing</div>
</div>
</div>
    <!-- Communication -->
<div>
<div>COMMUNICATION</div>
<div>
<div>- API Gateway</div>
<div>- Backend for Frontend</div>
<div>- Async Messaging</div>
<div>- Service Mesh</div>
</div>
</div>
</div>
<div>
    <!-- Resilience -->
<div>
<div>RESILIENCE</div>
<div>
<div>- Circuit Breaker</div>
<div>- Bulkhead</div>
<div>- Retry with Backoff</div>
<div>- Timeout</div>
</div>
</div>
    <!-- Observability -->
<div>
<div>OBSERVABILITY</div>
<div>
<div>- Log Aggregation</div>
<div>- Distributed Tracing</div>
<div>- Health Checks</div>
<div>- Metrics Collection</div>
</div>
</div>
    <!-- Deployment -->
<div>
<div>DEPLOYMENT</div>
<div>
<div>- Blue-Green</div>
<div>- Canary Releases</div>
<div>- Feature Flags</div>
<div>- Sidecar Pattern</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="1-database-per-service-pattern">1. Database Per Service Pattern</h2>
<div>
<h3>PATTERN: DATABASE PER SERVICE</h3>
<div>
<div>PROBLEM:</div>
<div>How to manage data in a microservices architecture while maintaining loose coupling between services?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Each service has its own private database.</div>
</div>
<div>
<div>
<div>
<div>User Service</div>
<div>v</div>
<div><div>PostgreSQL</div><div>(Users)</div></div>
</div>
<div>
<div>Order Service</div>
<div>v</div>
<div><div>MongoDB</div><div>(Orders)</div></div>
</div>
<div>
<div>Product Svc</div>
<div>v</div>
<div><div>Elasticsearch</div><div>(Products)</div></div>
</div>
</div>
<div>
<div>Each service:</div>
<div>- Owns its data exclusively</div>
<div>- Can choose appropriate database type</div>
<div>- Cannot directly access other service's database</div>
</div>
</div>
<div>
<div>
<div>BENEFITS:</div>
<div>
<div>+ Loose coupling</div>
<div>+ Independent scaling</div>
<div>+ Polyglot persistence</div>
<div>+ Fault isolation</div>
</div>
</div>
<div>
<div>DRAWBACKS:</div>
<div>
<div>- No ACID across services</div>
<div>- Complex queries across services</div>
<div>- Data duplication</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="2-saga-pattern">2. Saga Pattern</h2>
<div>
<h3>PATTERN: SAGA</h3>
<div>
<div>PROBLEM:</div>
<div>How to maintain data consistency across services without distributed transactions (2PC)?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Implement a saga - a sequence of local transactions with compensating transactions for rollback.</div>
</div>
<div>TYPE 1: CHOREOGRAPHY (Event-Driven)</div>
<div>
<div>
<div>Order Service</div>
<div>-> order.created -></div>
<div>Inventory Service</div>
<div>-> inventory.reserved -></div>
<div>Payment Service</div>
</div>
<div>v payment.completed</div>
<div>Order Service (updates status to CONFIRMED)</div>
<div>
<div>On FAILURE (e.g., payment fails):</div>
<div>
<div>- Payment Service publishes payment.failed</div>
<div>- Inventory Service compensates: release reserved stock</div>
<div>- Order Service updates status to FAILED</div>
</div>
</div>
</div>
<div>TYPE 2: ORCHESTRATION (Central Coordinator)</div>
<div>
<div>
<div>Saga Orchestrator (Order Saga)</div>
</div>
<div>
<div>v</div>
<div>v</div>
<div>v</div>
</div>
<div>
<div>Inventory<br/>Service</div>
<div>Payment<br/>Service</div>
<div>Order<br/>Service</div>
</div>
<div>
<div>Orchestrator controls the flow:</div>
<div>1. Call Inventory Service -> Reserve stock</div>
<div>2. Call Payment Service -> Process payment</div>
<div>3. On success: Call Order Service -> Confirm order</div>
<div>4. On failure: Call compensating actions in reverse</div>
</div>
</div>
<div>COMPARISON:</div>
<div>
<div>
<div>Choreography</div>
<div>+ Loose coupling</div>
<div>+ Simple services</div>
<div>- Hard to track</div>
<div>- Cyclic dependencies</div>
</div>
<div>
<div>Orchestration</div>
<div>+ Easier to understand</div>
<div>+ Centralized error handling</div>
<div>- Single point of failure</div>
<div>- Tight coupling to orchestrator</div>
</div>
</div>
</div>
<hr />
<h2 id="3-cqrs-command-query-responsibility-segregation">3. CQRS (Command Query Responsibility Segregation)</h2>
<div>
<h3>PATTERN: CQRS</h3>
<div>
<div>PROBLEM:</div>
<div>How to handle complex queries that span multiple services efficiently?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Separate read and write models.</div>
</div>
<div>
<div>
<div>APPLICATION</div>
</div>
<div>v</div>
<div>
<div>
<div>
<div>COMMAND (Write)</div>
<div>CreateOrder<br/>UpdateOrder<br/>CancelOrder</div>
</div>
<div>v</div>
<div>
<div>Write Model</div>
<div>(PostgreSQL)</div>
<div>Normalized<br/>Transactional</div>
</div>
</div>
<div>
<div>Events</div>
<div>-></div>
</div>
<div>
<div>
<div>QUERY (Read)</div>
<div>GetOrders<br/>OrderHistory<br/>OrderStats</div>
</div>
<div>v</div>
<div>
<div>Read Model</div>
<div>(Elasticsearch, Redis)</div>
<div>Denormalized<br/>Fast queries</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>WHEN TO USE:</div>
<div>
<div>+ Read and write workloads have different requirements</div>
<div>+ Complex queries across aggregates</div>
<div>+ Need to scale reads and writes independently</div>
<div>+ Event sourcing is used</div>
</div>
</div>
<div>
<div>WHEN NOT TO USE:</div>
<div>
<div>- Simple CRUD applications</div>
<div>- Strong consistency is required</div>
<div>- Team unfamiliar with eventual consistency</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="4-event-sourcing">4. Event Sourcing</h2>
<div>
<h3>PATTERN: EVENT SOURCING</h3>
<div>
<div>PROBLEM:</div>
<div>How to maintain an audit log of all changes and enable rebuilding state from history?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Store state changes as a sequence of events, not current state.</div>
</div>
<div>
<div>
<div>TRADITIONAL (State Storage):</div>
<div>
<div>orders table:</div>
<div>
<div>id</div>
<div>status</div>
<div>total</div>
<div>updated_at</div>
</div>
<div>
<div>ORD-1</div>
<div>DELIVERED</div>
<div>150.00</div>
<div>2024-01-15</div>
</div>
</div>
<div>Lost information: How did it become DELIVERED?</div>
</div>
<div>
<div>EVENT SOURCING:</div>
<div>
<div>order_events table:</div>
<div>
<div>event_id</div>
<div>aggregate_id</div>
<div>event_type</div>
<div>data</div>
</div>
<div>
<div>1</div><div>ORD-1</div><div>OrderCreated</div><div>{...}</div>
</div>
<div>
<div>2</div><div>ORD-1</div><div>OrderPaid</div><div>{...}</div>
</div>
<div>
<div>3</div><div>ORD-1</div><div>OrderShipped</div><div>{...}</div>
</div>
<div>
<div>4</div><div>ORD-1</div><div>OrderDelivered</div><div>{...}</div>
</div>
</div>
<div>Current state = replay(all events for ORD-1)</div>
</div>
</div>
<div>
<div>Benefits:</div>
<div>
<div>- Complete audit trail</div>
<div>- Natural fit for CQRS</div>
<div>- Can rebuild state at any point in time</div>
<div>- Can derive new read models from existing events</div>
</div>
</div>
<div>EVENT STORE STRUCTURE:</div>
<div>
<div>{</div>
<div><span>"event_id"</span>: <span>"evt-123"</span>,</div>
<div><span>"aggregate_type"</span>: <span>"Order"</span>,</div>
<div><span>"aggregate_id"</span>: <span>"ORD-1"</span>,</div>
<div><span>"event_type"</span>: <span>"OrderShipped"</span>,</div>
<div><span>"version"</span>: <span>3</span>,</div>
<div><span>"timestamp"</span>: <span>"2024-01-15T10:30:00Z"</span>,</div>
<div><span>"data"</span>: { <span>"tracking_number"</span>: <span>"TRK-456"</span>, <span>"carrier"</span>: <span>"FedEx"</span> },</div>
<div><span>"metadata"</span>: { <span>"user_id"</span>: <span>"user-789"</span>, <span>"correlation_id"</span>: <span>"req-abc"</span> }</div>
<div>}</div>
</div>
</div>
<hr />
<h2 id="5-api-gateway-pattern">5. API Gateway Pattern</h2>
<div>
<h3>PATTERN: API GATEWAY</h3>
<div>
<div>PROBLEM:</div>
<div>How should clients access individual microservices?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Single entry point that handles cross-cutting concerns.</div>
</div>
<div>
<div>
<div>CLIENTS</div>
<div>
<div>Web App</div>
<div>Mobile App</div>
<div>Partner API</div>
<div>Admin</div>
</div>
</div>
<div>v</div>
<div>
<div>API GATEWAY</div>
<div>
<div>Auth</div>
<div>Rate Limit</div>
<div>Routing</div>
<div>Cache</div>
<div>Transform</div>
<div>Circuit Breaker</div>
<div>Load Balance</div>
<div>Monitor/Log</div>
</div>
</div>
<div>v</div>
<div>
<div>User Service</div>
<div>Order Service</div>
<div>Product Svc</div>
</div>
</div>
<div>
<div>
<div>RESPONSIBILITIES:</div>
<div>
<div>- Authentication & Authorization</div>
<div>- Rate limiting & Throttling</div>
<div>- Request/Response transformation</div>
<div>- Load balancing</div>
<div>- Caching</div>
<div>- Circuit breaking</div>
<div>- Monitoring & Logging</div>
<div>- API versioning</div>
</div>
</div>
<div>
<div>POPULAR IMPLEMENTATIONS:</div>
<div>
<span>Kong</span>
<span>AWS API Gateway</span>
<span>Nginx</span>
<span>Envoy</span>
<span>Traefik</span>
</div>
</div>
</div>
</div>
<pre><code>---
</code></pre>
<h2 id="6-backend-for-frontend-bff">6. Backend for Frontend (BFF)</h2>
<div>
<h3>PATTERN: BACKEND FOR FRONTEND (BFF)</h3>
<div>
<div>PROBLEM:</div>
<div>Different clients (web, mobile, IoT) have different data needs. A single API is either over-fetching or under-fetching.</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Create separate backend for each frontend type.</div>
</div>
<div>
<div>
<div>
<div>Web App</div>
<div>v</div>
<div>
<div>Web BFF</div>
<div>- Full data<br/>- Rich UI data</div>
</div>
</div>
<div>
<div>Mobile App</div>
<div>v</div>
<div>
<div>Mobile BFF</div>
<div>- Minimal payload<br/>- Offline support</div>
</div>
</div>
<div>
<div>IoT</div>
<div>v</div>
<div>
<div>IoT BFF</div>
<div>- Compact data<br/>- Batch updates</div>
</div>
</div>
</div>
<div>v v v</div>
<div>
<div>User Service</div>
<div>Order Service</div>
<div>Product Svc</div>
</div>
</div>
<div>EXAMPLE: Mobile BFF vs Web BFF</div>
<div>
<div>
<div>Mobile BFF</div>
<div>
<div>- Smaller payload</div>
<div>- Image thumbnails</div>
<div>- Paginated lists</div>
<div>- Offline-first</div>
<div>- Push notif ready</div>
</div>
</div>
<div>
<div>Web BFF</div>
<div>
<div>- Full payload</div>
<div>- High-res images</div>
<div>- Infinite scroll</div>
<div>- Real-time updates</div>
<div>- WebSocket ready</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="7-circuit-breaker-pattern">7. Circuit Breaker Pattern</h2>
<div>
<h3>PATTERN: CIRCUIT BREAKER</h3>
<div>
<div>PROBLEM:</div>
<div>How to prevent cascade failures when a service is unavailable?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Implement a circuit breaker that stops requests when failures exceed a threshold.</div>
</div>
<div>STATE MACHINE:</div>
<div>
<div>
<div>
<div>
<div>CLOSED</div>
<div>(Normal)</div>
</div>
</div>
<div>
<div>failure threshold exceeded</div>
<div>-></div>
</div>
<div>
<div>
<div>OPEN</div>
<div>(Fast fail)</div>
</div>
</div>
<div>
<div>timer expires</div>
<div>-></div>
</div>
<div>
<div>
<div>HALF-OPEN</div>
<div>(Test mode)</div>
</div>
</div>
</div>
<div>
<div><- success -> CLOSED</div>
<div><- failure -> OPEN</div>
</div>
</div>
<div>IMPLEMENTATION EXAMPLE (Go):</div>
<div>
<div><span>breaker</span> := gobreaker.NewCircuitBreaker(gobreaker.Settings{</div>
<div>Name:        <span>"payment-service"</span>,</div>
<div>MaxRequests: <span>5</span>,           <span>// Requests in half-open</span></div>
<div>Interval:    <span>10</span> * time.Second, <span>// Clear counts</span></div>
<div>Timeout:     <span>30</span> * time.Second, <span>// Time in open</span></div>
<div>ReadyToTrip: <span>func</span>(counts) <span>bool</span> { <span>return</span> counts.ConsecutiveFailures> <span>3</span> },</div>
<div>})</div>
<div><span>result</span>, err := breaker.Execute(<span>func</span>() { <span>return</span> paymentClient.ProcessPayment(ctx, payment) })</div>
</div>
<div>CONFIGURATION:</div>
<div>
<div>- Failure threshold: 50% failures in 10 seconds</div>
<div>- Open duration: 30 seconds before trying again</div>
<div>- Half-open: Allow 3 test requests</div>
<div>- Reset: Full reset after 10 consecutive successes</div>
</div>
</div>
<hr />
<h2 id="8-bulkhead-pattern">8. Bulkhead Pattern</h2>
<div>
<h3>PATTERN: BULKHEAD</h3>
<div>
<div>PROBLEM:</div>
<div>How to isolate failures to prevent total system failure?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Partition resources into isolated pools (like ship bulkheads).</div>
</div>
<div>
<div>
<div>WITHOUT BULKHEAD:</div>
<div>
<div>SHARED THREAD POOL (100)</div>
<div>
<div>All requests share same pool</div>
<div>Slow service exhausts all threads</div>
<div>ALL services affected!</div>
</div>
</div>
</div>
<div>
<div>WITH BULKHEAD:</div>
<div>
<div>
<div>User Pool</div>
<div>(30 threads)</div>
<div>If exhausted:<br/>only users affected</div>
</div>
<div>
<div>Order Pool</div>
<div>(40 threads)</div>
<div>If exhausted:<br/>only orders affected</div>
</div>
<div>
<div>Payment Pool</div>
<div>(30 threads)</div>
<div>Isolated</div>
</div>
</div>
</div>
</div>
<div>TYPES OF BULKHEADS:</div>
<div>
<div>
<div>1. Thread Pool Isolation</div>
<div>
<div>- Separate thread pools per dependency</div>
<div>- Slow dependency can't exhaust all threads</div>
</div>
</div>
<div>
<div>2. Semaphore Isolation</div>
<div>
<div>- Limit concurrent calls to dependency</div>
<div>- Lower overhead than thread pools</div>
</div>
</div>
<div>
<div>3. Connection Pool Isolation</div>
<div>
<div>- Separate DB connection pools per service</div>
<div>- Prevents DB connection exhaustion</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="9-sidecar-pattern">9. Sidecar Pattern</h2>
<div>
<h3>PATTERN: SIDECAR</h3>
<div>
<div>PROBLEM:</div>
<div>How to add common functionality (logging, monitoring, proxy) to services without modifying them?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Deploy helper functionality as a separate container alongside the main application container.</div>
</div>
<div>
<div>POD</div>
<div>
<div>
<div>
<div>Application Container</div>
<div>- Business logic<br/>- No infra code</div>
</div>
<div><></div>
<div>
<div>Sidecar Container</div>
<div>- Logging<br/>- Monitoring<br/>- Proxy<br/>- Config sync</div>
</div>
</div>
<div>
<span>Shared:</span> Network namespace (localhost) | Volumes | Lifecycle
</div>
</div>
</div>
<div>COMMON SIDECAR USE CASES:</div>
<div>
<span>Envoy Proxy - Service mesh (Istio)</span>
<span>Fluent Bit - Log forwarding</span>
<span>Vault Agent - Secret injection</span>
<span>CloudSQL Proxy - DB connection</span>
<span>Prometheus Exporter - Metrics</span>
</div>
</div>
<hr />
<h2 id="10-strangler-fig-pattern">10. Strangler Fig Pattern</h2>
<div>
<h3>PATTERN: STRANGLER FIG</h3>
<div>
<div>PROBLEM:</div>
<div>How to migrate from monolith to microservices incrementally?</div>
</div>
<div>
<div>SOLUTION:</div>
<div>Gradually replace monolith functionality with new services, like a strangler fig tree grows around and replaces its host.</div>
</div>
<div>
<div>
<div>PHASE 1: Add Facade</div>
<div>
<div>Clients</div>
<div>v</div>
<div>Facade/Proxy</div>
<div>v</div>
<div>MONOLITH<br/><span>[All functionality]</span></div>
</div>
</div>
<div>
<div>PHASE 2: Extract First Service</div>
<div>
<div>Clients</div>
<div>v</div>
<div>Facade/Proxy</div>
<div>
<div>User Service<br/>(New)</div>
<div>MONOLITH<br/>[Less features]</div>
</div>
</div>
</div>
<div>
<div>PHASE 3: Continue Extraction</div>
<div>
<div>Clients</div>
<div>v</div>
<div>Facade/Proxy</div>
<div>
<div>User</div>
<div>Order</div>
<div>Payment</div>
<div>Legacy</div>
</div>
</div>
</div>
<div>
<div>PHASE 4: Decommission Monolith</div>
<div>
<div>Clients</div>
<div>v</div>
<div>API Gateway</div>
<div>
<div>User</div>
<div>Order</div>
<div>Payment</div>
<div>...</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="pattern-selection-guide">Pattern Selection Guide</h2>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Pattern</th>
<th>When to Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cross-service transactions</td>
<td><strong>Saga</strong></td>
<td>Multiple services need to coordinate</td>
</tr>
<tr>
<td>Complex queries</td>
<td><strong>CQRS</strong></td>
<td>Read/write patterns differ significantly</td>
</tr>
<tr>
<td>Audit trail needed</td>
<td><strong>Event Sourcing</strong></td>
<td>Need complete history of changes</td>
</tr>
<tr>
<td>Client-specific APIs</td>
<td><strong>BFF</strong></td>
<td>Different clients have different needs</td>
</tr>
<tr>
<td>Prevent cascade failures</td>
<td><strong>Circuit Breaker</strong></td>
<td>Service dependencies can fail</td>
</tr>
<tr>
<td>Resource isolation</td>
<td><strong>Bulkhead</strong></td>
<td>Need to contain failures</td>
</tr>
<tr>
<td>Cross-cutting concerns</td>
<td><strong>Sidecar</strong></td>
<td>Add functionality without code changes</td>
</tr>
<tr>
<td>Incremental migration</td>
<td><strong>Strangler Fig</strong></td>
<td>Moving from monolith</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<ol>
<li><strong>No pattern is universally applicable</strong> - Choose based on specific problem</li>
<li><strong>Patterns can be combined</strong> - CQRS + Event Sourcing, Saga + Circuit Breaker</li>
<li><strong>Start simple</strong> - Add patterns as complexity demands</li>
<li><strong>Understand trade-offs</strong> - Every pattern has costs</li>
<li><strong>Team familiarity matters</strong> - Complex patterns need experienced teams</li>
</ol>
