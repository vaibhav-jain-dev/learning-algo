<h1 id="sql-joins-mastery">SQL Joins Mastery</h1>
<h2 id="overview">Overview</h2>
<p>Joins are the cornerstone of relational database queries, allowing you to combine data from multiple tables based on related columns. Understanding joins is essential for working with normalized databases where data is distributed across tables to eliminate redundancy and maintain data integrity.</p>
<p>This comprehensive guide covers all types of SQL joins, from basic INNER JOINs to complex self-joins and multi-table queries. You will learn not just the syntax, but the mental models needed to choose the right join for every situation, along with performance considerations that separate novice from expert SQL developers.</p>
<hr />
<h2 id="why-it-matters">Why It Matters</h2>
<div>
<div>
<div>
<div>Real-World Applications</div>
<ul>
<li>Combining customer data with their orders</li>
<li>Building comprehensive reports from multiple tables</li>
<li>Finding missing or orphaned records</li>
<li>Creating data warehousing transformations</li>
<li>Building complex analytics dashboards</li>
</ul>
</div>
<div>
<div>Interview Significance</div>
<ul>
<li>Most common SQL interview topic</li>
<li>Tests understanding of relational concepts</li>
<li>Differentiates candidates by depth of knowledge</li>
<li>Often combined with aggregation questions</li>
<li>Performance optimization frequently discussed</li>
</ul>
</div>
</div>
</div>
<p>Joins transform isolated tables into meaningful business insights. Without them, relational databases would be nothing more than collections of disconnected spreadsheets. Mastering joins is the gateway to becoming proficient in SQL.</p>
<hr />
<h2 id="visual-guide-to-joins">Visual Guide to Joins</h2>
<div>
<h4>SQL JOIN TYPES VISUALIZED</h4>
<div>
<div>
<div>INNER JOIN</div>
<div>
<div></div>
<div></div>
<div></div>
</div>
<div>Returns only matching rows from both tables</div>
</div>
<div>
<div>LEFT JOIN</div>
<div>
<div></div>
<div></div>
</div>
<div>All from left table + matching from right</div>
</div>
<div>
<div>RIGHT JOIN</div>
<div>
<div></div>
<div></div>
</div>
<div>Matching from left + all from right table</div>
</div>
<div>
<div>FULL OUTER JOIN</div>
<div>
<div></div>
<div></div>
</div>
<div>All rows from both tables combined</div>
</div>
</div>
</div>
<hr />
<h2 id="sample-data">Sample Data</h2>
<p>For all examples, we will use the following tables representing an e-commerce system:</p>
<pre><code class="language-sql">-- Users table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    city VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Orders table
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    total_amount DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);

-- Products table
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    category VARCHAR(50),
    price DECIMAL(10,2)
);

-- Order items table (junction table)
CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER,
    unit_price DECIMAL(10,2)
);

-- Sample data
INSERT INTO users (id, name, email, city) VALUES
    (1, 'Alice', 'alice@example.com', 'New York'),
    (2, 'Bob', 'bob@example.com', 'Los Angeles'),
    (3, 'Charlie', 'charlie@example.com', 'New York'),
    (4, 'Diana', 'diana@example.com', 'Chicago');

INSERT INTO orders (id, user_id, total_amount, status, created_at) VALUES
    (101, 1, 299.99, 'completed', '2024-01-15'),
    (102, 1, 149.50, 'completed', '2024-02-20'),
    (103, 2, 89.99, 'pending', '2024-03-10'),
    (104, NULL, 50.00, 'cancelled', '2024-03-22');

INSERT INTO products (id, name, category, price) VALUES
    (1, 'Laptop', 'Electronics', 999.99),
    (2, 'Mouse', 'Electronics', 29.99),
    (3, 'Desk', 'Furniture', 299.99),
    (4, 'Chair', 'Furniture', 199.99);
</code></pre>
<hr />
<h2 id="inner-join">INNER JOIN</h2>
<p>INNER JOIN returns only rows where there is a match in both tables. This is the most common type of join.</p>
<div>
<h4>INNER JOIN Behavior</h4>
<div>
<div>
<div>Users Table</div>
<div>Alice (id: 1)<br/>Bob (id: 2)<br/>Charlie (id: 3)<br/>Diana (id: 4)</div>
</div>
<div>+</div>
<div>
<div>Orders Table</div>
<div>Order 101 (user_id: 1)<br/>Order 102 (user_id: 1)<br/>Order 103 (user_id: 2)<br/>Order 104 (user_id: NULL)</div>
</div>
</div>
<div>
    Result: 3 rows (Alice with 2 orders, Bob with 1 order). Charlie, Diana, and Order 104 excluded.
</div>
</div>
<pre><code class="language-sql">-- Basic INNER JOIN
SELECT
    users.name,
    users.email,
    orders.id AS order_id,
    orders.total_amount,
    orders.status
FROM users
INNER JOIN orders ON users.id = orders.user_id;

-- Result:
-- | name  | email             | order_id | total_amount | status    |
-- |-------|-------------------|----------|--------------|-----------|
-- | Alice | alice@example.com | 101      | 299.99       | completed |
-- | Alice | alice@example.com | 102      | 149.50       | completed |
-- | Bob   | bob@example.com   | 103      | 89.99        | pending   |

-- Using table aliases (preferred for readability)
SELECT
    u.name,
    u.email,
    o.id AS order_id,
    o.total_amount
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.status = 'completed';
</code></pre>
<h3 id="when-to-use-inner-join">When to Use INNER JOIN</h3>
<ul>
<li>When you only want records that exist in both tables</li>
<li>When NULL foreign keys should be excluded from results</li>
<li>For creating reports where incomplete data is not useful</li>
</ul>
<hr />
<h2 id="left-join-left-outer-join">LEFT JOIN (LEFT OUTER JOIN)</h2>
<p>LEFT JOIN returns all rows from the left table and matching rows from the right table. Non-matching rows get NULL for right table columns.</p>
<pre><code class="language-sql">-- LEFT JOIN shows all users, even those without orders
SELECT
    u.name,
    u.email,
    o.id AS order_id,
    o.total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;

-- Result:
-- | name    | email               | order_id | total_amount |
-- |---------|---------------------|----------|--------------|
-- | Alice   | alice@example.com   | 101      | 299.99       |
-- | Alice   | alice@example.com   | 102      | 149.50       |
-- | Bob     | bob@example.com     | 103      | 89.99        |
-- | Charlie | charlie@example.com | NULL     | NULL         |
-- | Diana   | diana@example.com   | NULL     | NULL         |
</code></pre>
<h3 id="finding-non-matching-records-anti-join-pattern">Finding Non-Matching Records (Anti-Join Pattern)</h3>
<div>
<div>Anti-Join: Finding Missing Records</div>
<div>LEFT JOIN + WHERE NULL is a powerful pattern to find records in one table that have no corresponding records in another.</div>
</div>
<pre><code class="language-sql">-- Find users who have NEVER placed an order
SELECT
    u.id,
    u.name,
    u.email
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;

-- Result:
-- | id | name    | email               |
-- |----|---------|---------------------|
-- | 3  | Charlie | charlie@example.com |
-- | 4  | Diana   | diana@example.com   |

-- Find products that have never been ordered
SELECT p.id, p.name
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE oi.id IS NULL;
</code></pre>
<hr />
<h2 id="right-join-right-outer-join">RIGHT JOIN (RIGHT OUTER JOIN)</h2>
<p>RIGHT JOIN returns all rows from the right table and matching rows from the left table. It is essentially the mirror of LEFT JOIN.</p>
<pre><code class="language-sql">-- RIGHT JOIN shows all orders, even those without users
SELECT
    u.name,
    o.id AS order_id,
    o.total_amount,
    o.status
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;

-- Result:
-- | name  | order_id | total_amount | status    |
-- |-------|----------|--------------|-----------|
-- | Alice | 101      | 299.99       | completed |
-- | Alice | 102      | 149.50       | completed |
-- | Bob   | 103      | 89.99        | pending   |
-- | NULL  | 104      | 50.00        | cancelled |
</code></pre>
<div>
<div>Pro Tip: RIGHT JOIN Equivalence</div>
<div>RIGHT JOIN is rarely used in practice. You can always rewrite it as LEFT JOIN by swapping the table order. Most developers prefer LEFT JOIN for consistency and readability.</div>
</div>
<pre><code class="language-sql">-- These two queries produce identical results:

-- Using RIGHT JOIN
SELECT u.name, o.total_amount
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;

-- Equivalent LEFT JOIN (preferred)
SELECT u.name, o.total_amount
FROM orders o
LEFT JOIN users u ON u.id = o.user_id;
</code></pre>
<hr />
<h2 id="full-outer-join">FULL OUTER JOIN</h2>
<p>FULL OUTER JOIN returns all rows from both tables. Rows without a match get NULL for columns from the other table.</p>
<pre><code class="language-sql">-- FULL OUTER JOIN shows all users and all orders
SELECT
    u.name,
    o.id AS order_id,
    o.total_amount
FROM users u
FULL OUTER JOIN orders o ON u.id = o.user_id;

-- Result:
-- | name    | order_id | total_amount |
-- |---------|----------|--------------|
-- | Alice   | 101      | 299.99       |
-- | Alice   | 102      | 149.50       |
-- | Bob     | 103      | 89.99        |
-- | Charlie | NULL     | NULL         |
-- | Diana   | NULL     | NULL         |
-- | NULL    | 104      | 50.00        |

-- Find ALL unmatched records from both tables
SELECT
    u.name,
    o.id AS order_id
FROM users u
FULL OUTER JOIN orders o ON u.id = o.user_id
WHERE u.id IS NULL OR o.user_id IS NULL;
</code></pre>
<hr />
<h2 id="cross-join">CROSS JOIN</h2>
<p>CROSS JOIN produces the Cartesian product - every possible combination of rows from both tables.</p>
<div>
<div>Warning: Cartesian Products</div>
<div>CROSS JOIN multiplies the row counts. Joining tables with 1,000 and 1,000 rows produces 1,000,000 result rows! Use with extreme caution.</div>
</div>
<pre><code class="language-sql">-- Create all combinations of sizes and colors
CREATE TABLE sizes (name VARCHAR(20));
CREATE TABLE colors (name VARCHAR(20));

INSERT INTO sizes VALUES ('Small'), ('Medium'), ('Large');
INSERT INTO colors VALUES ('Red'), ('Blue'), ('Green');

SELECT
    s.name AS size,
    c.name AS color
FROM sizes s
CROSS JOIN colors c;

-- Result: 9 rows (3 sizes x 3 colors)
-- | size   | color |
-- |--------|-------|
-- | Small  | Red   |
-- | Small  | Blue  |
-- | Small  | Green |
-- | Medium | Red   |
-- | Medium | Blue  |
-- | Medium | Green |
-- | Large  | Red   |
-- | Large  | Blue  |
-- | Large  | Green |

-- Practical use: Generate a date calendar
SELECT
    generate_series('2024-01-01'::date, '2024-12-31'::date, '1 day') AS date
CROSS JOIN (SELECT DISTINCT category FROM products) categories;
</code></pre>
<hr />
<h2 id="self-join">SELF JOIN</h2>
<p>A self join joins a table with itself. This is useful for hierarchical data or comparing rows within the same table.</p>
<div>
<h4>Self Join Use Cases</h4>
<div>
<div>
<div>Organizational Hierarchies</div>
<div>Connect employees to their managers in the same table</div>
</div>
<div>
<div>Comparing Rows</div>
<div>Find users from the same city or products in the same price range</div>
</div>
</div>
</div>
<pre><code class="language-sql">-- Employees and their managers (hierarchical data)
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    manager_id INTEGER REFERENCES employees(id)
);

INSERT INTO employees (id, name, manager_id) VALUES
    (1, 'CEO', NULL),
    (2, 'CTO', 1),
    (3, 'CFO', 1),
    (4, 'Dev Lead', 2),
    (5, 'Developer', 4);

-- Find employees with their manager names
SELECT
    e.name AS employee,
    m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- Result:
-- | employee  | manager  |
-- |-----------|----------|
-- | CEO       | NULL     |
-- | CTO       | CEO      |
-- | CFO       | CEO      |
-- | Dev Lead  | CTO      |
-- | Developer | Dev Lead |

-- Find pairs of users from the same city
SELECT
    u1.name AS user1,
    u2.name AS user2,
    u1.city
FROM users u1
JOIN users u2 ON u1.city = u2.city AND u1.id &lt; u2.id;

-- Note: u1.id &lt; u2.id prevents duplicate pairs and self-matching
</code></pre>
<hr />
<h2 id="multiple-table-joins">Multiple Table Joins</h2>
<p>Real-world queries often join three or more tables together.</p>
<div>
<h4>Join Chain Visualization</h4>
<div>
<div>users</div>
<span>---JOIN---</span>
<div>orders</div>
<span>---JOIN---</span>
<div>order_items</div>
<span>---JOIN---</span>
<div>products</div>
</div>
</div>
<pre><code class="language-sql">-- Complete order details with user, items, and product info
SELECT
    u.name AS customer,
    o.id AS order_id,
    o.created_at AS order_date,
    p.name AS product,
    oi.quantity,
    oi.unit_price,
    (oi.quantity * oi.unit_price) AS line_total
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.status = 'completed'
ORDER BY o.created_at DESC, u.name;

-- Sales report by category with user info
SELECT
    p.category,
    COUNT(DISTINCT u.id) AS unique_customers,
    COUNT(DISTINCT o.id) AS total_orders,
    SUM(oi.quantity) AS units_sold,
    SUM(oi.quantity * oi.unit_price) AS total_revenue
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
JOIN users u ON o.user_id = u.id
WHERE o.status = 'completed'
GROUP BY p.category
ORDER BY total_revenue DESC;
</code></pre>
<hr />
<h2 id="join-conditions-on-vs-where">Join Conditions: ON vs WHERE</h2>
<p>Understanding when to put conditions in ON vs WHERE is crucial, especially with outer joins.</p>
<div>
<h4>ON vs WHERE with LEFT JOIN</h4>
<div>
<div>
<div>Condition in ON</div>
<div>Filters right table BEFORE joining. Left table rows still appear with NULL.</div>
<div>
  SELECT u.name, o.total<br/>
  FROM users u<br/>
  LEFT JOIN orders o<br/>
<span>ON u.id = o.user_id</span><br/>
<span>AND o.total> 100</span>;
</div>
</div>
<div>
<div>Condition in WHERE</div>
<div>Filters final result AFTER joining. Removes rows that do not match.</div>
<div>
  SELECT u.name, o.total<br/>
  FROM users u<br/>
  LEFT JOIN orders o<br/>
  ON u.id = o.user_id<br/>
<span>WHERE o.total> 100</span>;
</div>
</div>
</div>
</div>
<pre><code class="language-sql">-- Condition in ON: Shows ALL users, but only orders &gt; 100
SELECT u.name, o.id AS order_id, o.total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.total_amount &gt; 100;

-- Result includes users without qualifying orders (NULL values)
-- | name    | order_id | total_amount |
-- |---------|----------|--------------|
-- | Alice   | 101      | 299.99       |
-- | Alice   | 102      | 149.50       |
-- | Bob     | NULL     | NULL         |  -- Bob's order was &lt; 100
-- | Charlie | NULL     | NULL         |
-- | Diana   | NULL     | NULL         |

-- Condition in WHERE: Excludes users without orders &gt; 100
SELECT u.name, o.id AS order_id, o.total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.total_amount &gt; 100;

-- Result excludes non-matching users
-- | name  | order_id | total_amount |
-- |-------|----------|--------------|
-- | Alice | 101      | 299.99       |
-- | Alice | 102      | 149.50       |
</code></pre>
<hr />
<h2 id="query-patterns">Query Patterns</h2>
<h3 id="find-orphaned-records">Find Orphaned Records</h3>
<pre><code class="language-sql">-- Orders that reference non-existent users (data integrity check)
SELECT o.*
FROM orders o
LEFT JOIN users u ON o.user_id = u.id
WHERE o.user_id IS NOT NULL AND u.id IS NULL;

-- Products never ordered
SELECT p.id, p.name, p.category
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE oi.id IS NULL;
</code></pre>
<h3 id="aggregate-with-joins">Aggregate with Joins</h3>
<pre><code class="language-sql">-- Total spent per customer (including those with $0)
SELECT
    u.id,
    u.name,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.total_amount), 0) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'
GROUP BY u.id, u.name
ORDER BY total_spent DESC;

-- Category performance with product details
SELECT
    p.category,
    COUNT(DISTINCT p.id) AS products,
    COUNT(oi.id) AS times_ordered,
    COALESCE(SUM(oi.quantity * oi.unit_price), 0) AS revenue
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 'completed'
GROUP BY p.category;
</code></pre>
<h3 id="latest-record-per-group">Latest Record per Group</h3>
<pre><code class="language-sql">-- Latest order for each user using subquery
SELECT u.name, o.*
FROM users u
JOIN orders o ON o.id = (
    SELECT o2.id
    FROM orders o2
    WHERE o2.user_id = u.id
    ORDER BY o2.created_at DESC
    LIMIT 1
);

-- Alternative using ROW_NUMBER (often more efficient)
WITH ranked_orders AS (
    SELECT
        o.*,
        ROW_NUMBER() OVER (
            PARTITION BY user_id
            ORDER BY created_at DESC
        ) AS rn
    FROM orders o
)
SELECT u.name, ro.*
FROM users u
JOIN ranked_orders ro ON u.id = ro.user_id AND ro.rn = 1;
</code></pre>
<hr />
<h2 id="performance-tips">Performance Tips</h2>
<div>
<h4>Join Performance Optimization</h4>
<div>
<div>
<div>1. Always Index Join Columns</div>
<div>Foreign keys should always have indexes. This is the most important join optimization.</div>
<code>CREATE INDEX idx_orders_user_id ON orders(user_id);</code>
</div>
<div>
<div>2. Filter Early, Join Later</div>
<div>Use subqueries or CTEs to filter data before joining to reduce the number of rows processed.</div>
</div>
<div>
<div>3. Select Only Needed Columns</div>
<div>Avoid SELECT * in production. Specify exact columns to reduce memory and I/O.</div>
</div>
<div>
<div>4. Use EXPLAIN ANALYZE</div>
<div>Always verify your join strategy with execution plans. Look for Nested Loop vs Hash Join vs Merge Join.</div>
</div>
<div>
<div>5. Avoid Joining on Functions</div>
<div>Joining on LOWER(email) or DATE(created_at) prevents index usage. Pre-compute or use expression indexes.</div>
</div>
</div>
</div>
<pre><code class="language-sql">-- Filter before joining (more efficient)
SELECT u.name, filtered_orders.total_amount
FROM users u
JOIN (
    SELECT user_id, total_amount
    FROM orders
    WHERE status = 'completed'
      AND created_at &gt; '2024-01-01'
) filtered_orders ON u.id = filtered_orders.user_id;

-- Check execution plan
EXPLAIN ANALYZE
SELECT u.name, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 'completed';
</code></pre>
<hr />
<h2 id="interview-questions">Interview Questions</h2>
<div>
<div>
<div>Easy</div>
<ul>
<li><strong>What is the difference between INNER JOIN and LEFT JOIN?</strong><br/>
<span>INNER JOIN returns only matching rows; LEFT JOIN returns all left table rows plus matches.</span></li>
<li><strong>Can you draw a Venn diagram for each join type?</strong><br/>
<span>Be prepared to visualize INNER, LEFT, RIGHT, and FULL OUTER joins.</span></li>
<li><strong>What happens to NULL values in join conditions?</strong><br/>
<span>NULL never equals anything, so NULL foreign keys will not match.</span></li>
</ul>
</div>
<div>
<div>Medium</div>
<ul>
<li><strong>How do you find records with no match using LEFT JOIN?</strong><br/>
<span>LEFT JOIN + WHERE right_table.pk IS NULL</span></li>
<li><strong>When would you put a condition in ON vs WHERE with LEFT JOIN?</strong><br/>
<span>ON filters before join (preserves left rows); WHERE filters after (removes rows).</span></li>
<li><strong>What is a self join and when would you use it?</strong><br/>
<span>Joining a table to itself, used for hierarchies or comparing rows.</span></li>
</ul>
</div>
<div>
<div>Hard</div>
<ul>
<li><strong>How do you get the latest record per group using joins?</strong><br/>
<span>Use a self-join with a subquery: <code>SELECT t1.* FROM table t1 JOIN (SELECT group_col, MAX(date_col) AS max_date FROM table GROUP BY group_col) t2 ON t1.group_col = t2.group_col AND t1.date_col = t2.max_date</code>. Alternatively, use ROW_NUMBER() window function with a CTE.</span></li>
<li><strong>Explain Hash Join vs Nested Loop Join vs Merge Join.</strong><br/>
<span>Nested Loop: O(n*m), best for small tables or indexed inner table. Hash Join: O(n+m), builds hash table on smaller table, best for equality joins on medium-large tables. Merge Join: O(n log n + m log m), requires sorted input, efficient for pre-sorted data or range joins.</span></li>
<li><strong>How would you optimize a query joining 5+ tables?</strong><br/>
<span>Ensure all join columns are indexed. Filter rows early with WHERE before joins. Check statistics are up to date (run ANALYZE). Consider join order - start with most selective filters. Use EXPLAIN ANALYZE to identify slow join operations. Consider denormalization or materialized views for frequently run queries.</span></li>
</ul>
</div>
</div>
<hr />
<h2 id="practice-problems">Practice Problems</h2>
<h3 id="problem-1-customer-order-summary">Problem 1: Customer Order Summary</h3>
<pre><code class="language-sql">-- For each user, show: name, total orders, total spent, average order value
-- Include users with no orders (show 0s)

SELECT
    u.name,
    COUNT(o.id) AS total_orders,
    COALESCE(SUM(o.total_amount), 0) AS total_spent,
    COALESCE(ROUND(AVG(o.total_amount), 2), 0) AS avg_order_value
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'
GROUP BY u.id, u.name
ORDER BY total_spent DESC;
</code></pre>
<h3 id="problem-2-products-never-ordered">Problem 2: Products Never Ordered</h3>
<pre><code class="language-sql">-- Find all products that have never been ordered

SELECT p.id, p.name, p.category, p.price
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE oi.id IS NULL
ORDER BY p.category, p.name;
</code></pre>
<h3 id="problem-3-users-from-same-city">Problem 3: Users From Same City</h3>
<pre><code class="language-sql">-- Find all pairs of users who live in the same city
-- Avoid duplicates (Alice-Bob should not appear as Bob-Alice too)

SELECT
    u1.name AS user1,
    u2.name AS user2,
    u1.city
FROM users u1
JOIN users u2 ON u1.city = u2.city AND u1.id &lt; u2.id
ORDER BY u1.city, u1.name;
</code></pre>
<h3 id="problem-4-complete-order-details">Problem 4: Complete Order Details</h3>
<pre><code class="language-sql">-- Show complete order details: customer name, order date,
-- product name, quantity, unit price, line total, order total

SELECT
    u.name AS customer,
    o.id AS order_id,
    o.created_at::date AS order_date,
    p.name AS product,
    oi.quantity,
    oi.unit_price,
    (oi.quantity * oi.unit_price) AS line_total,
    o.total_amount AS order_total
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
ORDER BY o.created_at DESC, u.name, p.name;
</code></pre>
<h3 id="problem-5-category-performance-report">Problem 5: Category Performance Report</h3>
<pre><code class="language-sql">-- For each category, show:
-- - Number of products
-- - Number of orders containing products from this category
-- - Total units sold
-- - Total revenue
-- - Average order value for this category

SELECT
    p.category,
    COUNT(DISTINCT p.id) AS num_products,
    COUNT(DISTINCT o.id) AS num_orders,
    COALESCE(SUM(oi.quantity), 0) AS total_units,
    COALESCE(SUM(oi.quantity * oi.unit_price), 0) AS total_revenue,
    COALESCE(
        ROUND(AVG(oi.quantity * oi.unit_price), 2),
        0
    ) AS avg_line_total
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 'completed'
GROUP BY p.category
ORDER BY total_revenue DESC;
</code></pre>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<div>
<div>
<div>
<h4>Join Types</h4>
<div>
<strong>INNER JOIN</strong> - Only matching rows<br/>
<strong>LEFT JOIN</strong> - All left + matching right<br/>
<strong>RIGHT JOIN</strong> - Matching left + all right<br/>
<strong>FULL OUTER</strong> - All rows from both<br/>
<strong>CROSS JOIN</strong> - Cartesian product<br/>
<strong>SELF JOIN</strong> - Table joined to itself
</div>
</div>
<div>
<h4>Common Patterns</h4>
<div>
<strong>Anti-join:</strong> LEFT JOIN + WHERE pk IS NULL<br/>
<strong>Semi-join:</strong> EXISTS with correlated subquery<br/>
<strong>Latest per group:</strong> ROW_NUMBER + join<br/>
<strong>Hierarchy:</strong> Self join with parent_id<br/>
<strong>Filter early:</strong> Subquery then join
</div>
</div>
</div>
</div>
<hr />
<h2 id="related-topics">Related Topics</h2>
<ul>
<li><a href="/topic/sql-learning/sql-fundamentals">SQL Fundamentals</a> - SELECT, WHERE, GROUP BY basics</li>
<li><a href="/topic/sql-learning/subqueries-ctes">Subqueries and CTEs</a> - Modular query composition</li>
<li><a href="/topic/sql-learning/window-functions">Window Functions</a> - Analytics without grouping</li>
<li><a href="/topic/sql-learning/indexing-deep-dive">Database Indexing</a> - Optimize join performance</li>
<li><a href="/topic/sql-learning/query-optimization">Query Optimization</a> - Make joins faster</li>
</ul>
