<h1 id="dynamic-programming---interview-mastery-guide">Dynamic Programming - Interview Mastery Guide</h1>
<h2 id="category-overview">Category Overview</h2>
<p>Dynamic Programming (DP) is an algorithmic paradigm that solves complex problems by breaking them into simpler overlapping subproblems. It stores the results of subproblems to avoid redundant computation, transforming exponential time complexity into polynomial time. DP is one of the most powerful techniques in algorithmic problem-solving and a favorite topic in technical interviews.</p>
<p>The key insight of DP is the <strong>optimal substructure</strong> property: the optimal solution to a problem can be constructed from optimal solutions of its subproblems. Combined with <strong>overlapping subproblems</strong>, DP can dramatically reduce computational complexity.</p>
<div>
<h3>Two Approaches to DP</h3>
<div>
<ul>
<li><strong>Top-Down (Memoization)</strong>: Start from the main problem, recursively solve subproblems, cache results</li>
<li><strong>Bottom-Up (Tabulation)</strong>: Start from smallest subproblems, iteratively build up to the main problem</li>
</ul>
<table>
<tr>
<th>Aspect</th>
<th>Top-Down</th>
<th>Bottom-Up</th>
</tr>
<tr>
<td>Implementation</td>
<td>Recursion + Cache</td>
<td>Iteration + Table</td>
</tr>
<tr>
<td>Pros</td>
<td>More intuitive, only computes needed states</td>
<td>No recursion overhead, can optimize space</td>
</tr>
<tr>
<td>Cons</td>
<td>Stack overflow risk, function call overhead</td>
<td>Must compute all states, order matters</td>
</tr>
</table>
</div>
</div>
<p><strong>Interview Frequency</strong>: DP problems appear in <strong>20-25%</strong> of coding interviews, especially at Google, Amazon, Meta, and quantitative trading firms. They test algorithmic thinking, optimization skills, and ability to identify patterns.</p>
<h2 id="key-patterns">Key Patterns</h2>
<div>
<h3>DP Pattern Recognition Guide</h3>
<pre>
+------------------------+-------------------------------+---------------------------+
|       Pattern          |        Characteristics        |     Example Problems      |
+------------------------+-------------------------------+---------------------------+
| 1D DP                  | Linear sequence, choices at   | Fibonacci, Climbing Stairs|
|                        | each position                 | House Robber, Coin Change |
+------------------------+-------------------------------+---------------------------+
| 2D DP                  | Two sequences/dimensions,     | LCS, Edit Distance,       |
|                        | grid problems                 | Unique Paths, Knapsack    |
+------------------------+-------------------------------+---------------------------+
| Interval DP            | Optimal way to merge/split    | Matrix Chain, Burst       |
|                        | intervals                     | Balloons, Palindrome Part |
+------------------------+-------------------------------+---------------------------+
| State Machine DP       | Finite states with            | Stock Trading, Best Team, |
|                        | transitions                   | Paint House               |
+------------------------+-------------------------------+---------------------------+
| Knapsack Variants      | Select items with constraint  | 0/1 Knapsack, Unbounded,  |
|                        | (weight/capacity)             | Subset Sum, Target Sum    |
+------------------------+-------------------------------+---------------------------+
| String DP              | Pattern matching, string      | Regex Match, Wildcard,    |
|                        | transformations               | Distinct Subsequences     |
+------------------------+-------------------------------+---------------------------+
</pre>
</div>
<h3 id="pattern-1-1d-dynamic-programming">Pattern 1: 1D Dynamic Programming</h3>
<div>
<h4>1D DP Visualization - Climbing Stairs</h4>
<pre>
Problem: Count ways to climb n stairs, taking 1 or 2 steps at a time.
<p>Recurrence: dp[i] = dp[i-1] + dp[i-2]<br />
(ways to reach step i from step i-1 OR step i-2)</p>
<p>Stairs:  0    1    2    3    4    5<br />
Ways:    1    1    2    3    5    8<br />
|    |    |    |<br />
|    |    |    |<br />
|    |    |    +-- dp[3] + dp[4] = 3 + 5<br />
|    |    +------ dp[2] + dp[3] = 2 + 3<br />
|    +---------- dp[1] + dp[2] = 1 + 2<br />
+-------------- dp[0] + dp[1] = 1 + 1</p>
<p>Visualization of paths to step 4:<br />
From step 3 (3 ways): +1 each = 3 ways ending with 1-step<br />
From step 2 (2 ways): +2 each = 2 ways ending with 2-step<br />
Total: 5 ways<br />
</pre></p>
</div>
<h3 id="pattern-2-2d-dp---grid-problems">Pattern 2: 2D DP - Grid Problems</h3>
<div>
<h4>2D DP Visualization - Unique Paths</h4>
<pre>
Problem: Count paths from top-left to bottom-right (only right/down moves)
<p>Grid (m=3, n=4):<br />
+-----+-----+-----+-----+<br />
|  1  |  1  |  1  |  1  |<br />
+-----+-----+-----+-----+<br />
|  1  |  2  |  3  |  4  |<br />
+-----+-----+-----+-----+<br />
|  1  |  3  |  6  | 10  |  &lt;- Answer: 10<br />
+-----+-----+-----+-----+</p>
<p>Recurrence: dp[i][j] = dp[i-1][j] + dp[i][j-1]<br />
(paths from above + paths from left)</p>
<p>dp[2][3] = dp[1][3] + dp[2][2] = 4 + 6 = 10</p>
<p>Key: First row and column are all 1s (only one way to reach)<br />
</pre></p>
</div>
<h3 id="pattern-3-longest-common-subsequence-lcs">Pattern 3: Longest Common Subsequence (LCS)</h3>
<div>
<h4>LCS Table Visualization</h4>
<pre>
Strings: "ABCDE" and "ACE"
<p>&quot;&quot;   A   C   E<br />
+----+---+---+---+<br />
&quot;&quot; |  0 | 0 | 0 | 0 |<br />
+----+---+---+---+<br />
A |  0 | 1 | 1 | 1 |  &lt;- A matches A<br />
+----+---+---+---+<br />
B |  0 | 1 | 1 | 1 |<br />
+----+---+---+---+<br />
C |  0 | 1 | 2 | 2 |  &lt;- C matches C<br />
+----+---+---+---+<br />
D |  0 | 1 | 2 | 2 |<br />
+----+---+---+---+<br />
E |  0 | 1 | 2 | 3 |  &lt;- E matches E, LCS = 3<br />
+----+---+---+---+</p>
<p>Recurrence:<br />
If chars match: dp[i][j] = dp[i-1][j-1] + 1<br />
Else:          dp[i][j] = max(dp[i-1][j], dp[i][j-1])</p>
<p>LCS = &quot;ACE&quot; (length 3)<br />
</pre></p>
</div>
<h2 id="must-know-problems-with-solutions">Must-Know Problems with Solutions</h2>
<h3 id="problem-1-maximum-subarray-kadanes-algorithm">Problem 1: Maximum Subarray (Kadane's Algorithm)</h3>
<p><strong>Problem</strong>: Find the contiguous subarray with the largest sum.</p>
<pre><code class="language-python">def max_subarray(nums):
    &quot;&quot;&quot;
    Time: O(n) | Space: O(1)

    State: dp[i] = max subarray sum ending at index i
    Transition: dp[i] = max(nums[i], dp[i-1] + nums[i])
    Decision: Start fresh or extend previous subarray
    &quot;&quot;&quot;
    max_sum = nums[0]
    current_sum = nums[0]

    for i in range(1, len(nums)):
        # Either start new subarray or extend existing
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)

    return max_sum

# Example
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray(nums))  # 6 ([4, -1, 2, 1])
</code></pre>
<hr />
<h3 id="problem-2-longest-increasing-subsequence-lis">Problem 2: Longest Increasing Subsequence (LIS)</h3>
<p><strong>Problem</strong>: Find the length of the longest strictly increasing subsequence.</p>
<div>
<h4>LIS Approaches</h4>
<pre>
Array: [10, 9, 2, 5, 3, 7, 101, 18]
<p>O(n^2) DP Approach:<br />
dp[i] = length of LIS ending at index i<br />
dp[0] = 1 (just 10)<br />
dp[1] = 1 (just 9)<br />
dp[2] = 1 (just 2)<br />
dp[3] = 2 (2, 5)<br />
dp[4] = 2 (2, 3)<br />
dp[5] = 3 (2, 5, 7) or (2, 3, 7)<br />
dp[6] = 4 (2, 5, 7, 101) or (2, 3, 7, 101)<br />
dp[7] = 4 (2, 5, 7, 18) or (2, 3, 7, 18)</p>
<p>Answer: max(dp) = 4</p>
<p>O(n log n) Binary Search Approach:<br />
Maintain smallest tail for LIS of each length<br />
tails = [2, 3, 7, 18]<br />
Length = 4<br />
</pre></p>
</div>
<pre><code class="language-python">def lis_dp(nums):
    &quot;&quot;&quot;
    O(n^2) DP Solution
    dp[i] = length of LIS ending at nums[i]
    &quot;&quot;&quot;
    if not nums:
        return 0

    n = len(nums)
    dp = [1] * n  # Each element is an LIS of length 1

    for i in range(1, n):
        for j in range(i):
            if nums[j] &lt; nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

def lis_binary_search(nums):
    &quot;&quot;&quot;
    O(n log n) Binary Search Solution
    tails[i] = smallest ending element for LIS of length i+1
    &quot;&quot;&quot;
    from bisect import bisect_left

    tails = []
    for num in nums:
        pos = bisect_left(tails, num)
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num

    return len(tails)

# Example
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(lis_dp(nums))  # 4
print(lis_binary_search(nums))  # 4
</code></pre>
<hr />
<h3 id="problem-3-01-knapsack">Problem 3: 0/1 Knapsack</h3>
<p><strong>Problem</strong>: Given items with weights and values, find maximum value that fits in capacity.</p>
<div>
<h4>Knapsack Table Visualization</h4>
<pre>
Items: [(weight=1, value=1), (w=2, v=4), (w=3, v=5), (w=2, v=3)]
Capacity: 5
<p>Capacity<br />
0   1   2   3   4   5<br />
+---+---+---+---+---+---+<br />
Item 0 | 0 | 1 | 1 | 1 | 1 | 1 |<br />
+---+---+---+---+---+---+<br />
Item 1 | 0 | 1 | 4 | 5 | 5 | 5 |<br />
+---+---+---+---+---+---+<br />
Item 2 | 0 | 1 | 4 | 5 | 6 | 9 |<br />
+---+---+---+---+---+---+<br />
Item 3 | 0 | 1 | 4 | 5 | 7 | 9 |  &lt;- Max value: 9<br />
+---+---+---+---+---+---+</p>
<p>Recurrence:<br />
dp[i][w] = max(<br />
dp[i-1][w],                    // Don't take item i<br />
dp[i-1][w-weight[i]] + value[i] // Take item i (if fits)<br />
)</p>
<p>Answer: 9 (items 1 and 2: value=4+5, weight=2+3=5)<br />
</pre></p>
</div>
<pre><code class="language-python">def knapsack_01(values, weights, capacity):
    &quot;&quot;&quot;
    Time: O(n * capacity) | Space: O(n * capacity)

    dp[i][c] = max value using items 0..i with capacity c
    &quot;&quot;&quot;
    n = len(values)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for c in range(capacity + 1):
            # Don't take item i
            dp[i][c] = dp[i-1][c]

            # Take item i (if it fits)
            if weights[i-1] &lt;= c:
                dp[i][c] = max(dp[i][c],
                               dp[i-1][c - weights[i-1]] + values[i-1])

    return dp[n][capacity]

def knapsack_01_optimized(values, weights, capacity):
    &quot;&quot;&quot;
    Space-Optimized: O(capacity)
    Process backwards to avoid using updated values
    &quot;&quot;&quot;
    dp = [0] * (capacity + 1)

    for i in range(len(values)):
        for c in range(capacity, weights[i] - 1, -1):  # Backward!
            dp[c] = max(dp[c], dp[c - weights[i]] + values[i])

    return dp[capacity]

# Example
values = [1, 4, 5, 3]
weights = [1, 2, 3, 2]
print(knapsack_01(values, weights, 5))  # 9
</code></pre>
<hr />
<h3 id="problem-4-coin-change">Problem 4: Coin Change</h3>
<p><strong>Problem</strong>: Find minimum coins needed to make a target amount.</p>
<pre><code class="language-python">def coin_change(coins, amount):
    &quot;&quot;&quot;
    Time: O(amount * len(coins)) | Space: O(amount)

    dp[a] = minimum coins needed for amount a
    Unbounded knapsack variant (can use coins multiple times)
    &quot;&quot;&quot;
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # 0 coins needed for amount 0

    for a in range(1, amount + 1):
        for coin in coins:
            if coin &lt;= a and dp[a - coin] != float('inf'):
                dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

def coin_change_ways(coins, amount):
    &quot;&quot;&quot;
    Count number of ways to make change (order doesn't matter)
    &quot;&quot;&quot;
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:  # Process by coin first to avoid counting permutations
        for a in range(coin, amount + 1):
            dp[a] += dp[a - coin]

    return dp[amount]

# Examples
print(coin_change([1, 2, 5], 11))  # 3 (5+5+1)
print(coin_change_ways([1, 2, 5], 5))  # 4 ways
</code></pre>
<hr />
<h3 id="problem-5-edit-distance-levenshtein">Problem 5: Edit Distance (Levenshtein)</h3>
<p><strong>Problem</strong>: Find minimum operations (insert, delete, replace) to transform one string to another.</p>
<div>
<h4>Edit Distance Table</h4>
<pre>
Strings: "abc" -> "yabd"
<p>&quot;&quot;   y   a   b   d<br />
+----+---+---+---+---+<br />
&quot;&quot; |  0 | 1 | 2 | 3 | 4 |  &lt;- Insert all<br />
+----+---+---+---+---+<br />
a |  1 | 1 | 1 | 2 | 3 |  &lt;- a matches a at [1][2]<br />
+----+---+---+---+---+<br />
b |  2 | 2 | 2 | 1 | 2 |  &lt;- b matches b at [2][3]<br />
+----+---+---+---+---+<br />
c |  3 | 3 | 3 | 2 | 2 |  &lt;- c != d, min of ops + 1<br />
+----+---+---+---+---+</p>
<p>Recurrence:<br />
If chars match: dp[i][j] = dp[i-1][j-1]<br />
Else: dp[i][j] = 1 + min(<br />
dp[i-1][j],    // Delete from str1<br />
dp[i][j-1],    // Insert into str1<br />
dp[i-1][j-1]   // Replace in str1<br />
)</p>
<p>Answer: 2 (insert 'y' at start, replace 'c' with 'd')<br />
</pre></p>
</div>
<pre><code class="language-python">def edit_distance(str1, str2):
    &quot;&quot;&quot;
    Time: O(m * n) | Space: O(m * n)

    dp[i][j] = min operations to convert str1[0:i] to str2[0:j]
    &quot;&quot;&quot;
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Base cases
    for i in range(m + 1):
        dp[i][0] = i  # Delete all from str1
    for j in range(n + 1):
        dp[0][j] = j  # Insert all to str1

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],    # Delete
                    dp[i][j-1],    # Insert
                    dp[i-1][j-1]   # Replace
                )

    return dp[m][n]

# Example
print(edit_distance(&quot;abc&quot;, &quot;yabd&quot;))  # 2
</code></pre>
<hr />
<h3 id="problem-6-longest-common-subsequence">Problem 6: Longest Common Subsequence</h3>
<pre><code class="language-python">def longest_common_subsequence(str1, str2):
    &quot;&quot;&quot;
    Time: O(m * n) | Space: O(m * n)

    dp[i][j] = LCS length of str1[0:i] and str2[0:j]
    &quot;&quot;&quot;
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

def get_lcs_string(str1, str2):
    &quot;&quot;&quot;Also reconstruct the actual LCS&quot;&quot;&quot;
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    # Backtrack to find LCS
    lcs = []
    i, j = m, n
    while i &gt; 0 and j &gt; 0:
        if str1[i-1] == str2[j-1]:
            lcs.append(str1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] &gt; dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    return ''.join(reversed(lcs))

# Example
print(longest_common_subsequence(&quot;ABCDE&quot;, &quot;ACE&quot;))  # 3
print(get_lcs_string(&quot;ABCDE&quot;, &quot;ACE&quot;))  # &quot;ACE&quot;
</code></pre>
<h2 id="complexity-analysis-summary">Complexity Analysis Summary</h2>
<div>
<h3>DP Problems Complexity Reference</h3>
<table>
<tr>
<th>Problem</th>
<th>Time</th>
<th>Space</th>
<th>Optimized Space</th>
</tr>
<tr>
<td>Fibonacci</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>LIS</td>
<td>O(n^2) / O(n log n)</td>
<td>O(n)</td>
<td>-</td>
</tr>
<tr>
<td>0/1 Knapsack</td>
<td>O(n * W)</td>
<td>O(n * W)</td>
<td>O(W)</td>
</tr>
<tr>
<td>Coin Change</td>
<td>O(n * amount)</td>
<td>O(amount)</td>
<td>-</td>
</tr>
<tr>
<td>LCS</td>
<td>O(m * n)</td>
<td>O(m * n)</td>
<td>O(min(m, n))</td>
</tr>
<tr>
<td>Edit Distance</td>
<td>O(m * n)</td>
<td>O(m * n)</td>
<td>O(min(m, n))</td>
</tr>
</table>
</div>
<h2 id="common-mistakes">Common Mistakes</h2>
<div>
<h3>Pitfalls to Avoid</h3>
<div>
<ol>
<li>
<p><strong>Wrong Base Case</strong>: Forgetting to initialize dp[0] properly - causes cascading errors</p>
</li>
<li>
<p><strong>Off-by-One in Indices</strong>: String problems often use 1-indexed dp with 0 as base case</p>
</li>
<li>
<p><strong>Wrong Iteration Order</strong>:</p>
<ul>
<li>Bottom-up: Must process dependencies first</li>
<li>Space optimization: May need reverse iteration</li>
</ul>
</li>
<li>
<p><strong>Not Recognizing DP</strong>: Signs: optimal substructure, overlapping subproblems, counting/min/max</p>
</li>
<li>
<p><strong>Overcounting</strong>: In coin change for combinations (not permutations), iterate coins first</p>
</li>
<li>
<p><strong>Unbounded vs Bounded</strong>: 0/1 Knapsack (each item once) vs Unbounded (unlimited use)</p>
</li>
<li>
<p><strong>Memoization Key Errors</strong>: Using mutable objects or missing state in cache key</p>
</li>
<li>
<p><strong>Not Considering All States</strong>: Missing dimensions in state (e.g., &quot;last element used&quot;)</p>
</li>
</ol>
</div>
</div>
<h2 id="interview-tips">Interview Tips</h2>
<div>
<h4>DP Problem-Solving Framework</h4>
<pre>
Step 1: Identify DP applicability
  - Can problem be broken into subproblems?
  - Do subproblems overlap?
  - Is there optimal substructure?
<p>Step 2: Define state</p>
<ul>
<li>What information do I need at each step?</li>
<li>What does dp[i] or dp[i][j] represent?</li>
<li>Make state as small as possible</li>
</ul>
<p>Step 3: Define recurrence</p>
<ul>
<li>How do I get dp[i] from smaller subproblems?</li>
<li>What are my choices at each step?</li>
<li>Write the recurrence relation</li>
</ul>
<p>Step 4: Identify base cases</p>
<ul>
<li>What are the smallest subproblems?</li>
<li>What do I know without computation?</li>
</ul>
<p>Step 5: Determine iteration order</p>
<ul>
<li>What must be computed before what?</li>
<li>Can I optimize space by reusing?</li>
</ul>
<p>Time Allocation (45-min problem):<br />
0-5 min:  Understand, identify as DP<br />
5-15 min: Define state, recurrence, base cases<br />
15-35 min: Implement solution<br />
35-45 min: Test, optimize if needed<br />
</pre></p>
</div>
<h3 id="key-communication-phrases">Key Communication Phrases</h3>
<ul>
<li>&quot;This has optimal substructure because the optimal solution uses optimal solutions to subproblems...&quot;</li>
<li>&quot;I'll define dp[i] as... and the recurrence is...&quot;</li>
<li>&quot;The base case is dp[0] = ... because...&quot;</li>
<li>&quot;I can optimize space because I only need the previous row/state...&quot;</li>
<li>&quot;Let me trace through a small example to verify the recurrence...&quot;</li>
</ul>
<h2 id="practice-problems">Practice Problems</h2>
<h3 id="easy">Easy</h3>
<ol>
<li>Fibonacci</li>
<li>Climbing Stairs</li>
<li>Maximum Subarray (Kadane's)</li>
<li>House Robber</li>
</ol>
<h3 id="medium">Medium</h3>
<ol start="5">
<li>Coin Change</li>
<li>Longest Increasing Subsequence</li>
<li>Longest Common Subsequence</li>
<li>0/1 Knapsack</li>
<li>Min Number of Coins for Change</li>
<li>Unique Paths</li>
<li>Edit Distance</li>
<li>Max Subset Sum No Adjacent</li>
</ol>
<h3 id="hard">Hard</h3>
<ol start="13">
<li>Max Sum Increasing Subsequence</li>
<li>Longest Palindromic Subsequence</li>
<li>Water Area</li>
<li>Knapsack Problem</li>
<li>Disk Stacking</li>
</ol>
<h3 id="very-hard">Very Hard</h3>
<ol start="18">
<li>Longest String Chain</li>
<li>Square of Zeroes</li>
<li>Palindrome Partitioning Min Cuts</li>
</ol>
<div>
<h3>Quick Reference - Common Recurrences</h3>
<pre>
Fibonacci:    dp[i] = dp[i-1] + dp[i-2]
<p>LIS:          dp[i] = max(dp[j] + 1) for j &lt; i where arr[j] &lt; arr[i]</p>
<p>0/1 Knapsack: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])</p>
<p>Unbounded:    dp[w] = max(dp[w], dp[w-wt[i]] + val[i])</p>
<p>LCS:          dp[i][j] = dp[i-1][j-1] + 1        if match<br />
= max(dp[i-1][j], dp[i][j-1]) otherwise</p>
<p>Edit Dist:    dp[i][j] = dp[i-1][j-1]            if match<br />
= 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])</p>
<p>Unique Paths: dp[i][j] = dp[i-1][j] + dp[i][j-1]</p>
<p>Space Optimization Pattern:</p>
<ul>
<li>If only need previous row: use 2 rows, alternate</li>
<li>If only need previous element: use single variable</li>
<li>Process backward for 0/1 choices (prevent double-use)<br />
</pre></li>
</ul>
</div>
