<h1 id="famous-algorithms">Famous Algorithms</h1>
<h2 id="overview">Overview</h2>
<p>These are fundamental algorithms that every programmer should know. They solve common problems efficiently and form the building blocks for more complex solutions.</p>
<h2 id="key-concepts--terminology">Key Concepts &amp; Terminology</h2>
<h3 id="algorithm-categories">Algorithm Categories</h3>
<table>
<thead>
<tr>
<th>Category</th>
<th>Algorithms</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search</td>
<td>Binary Search, DFS, BFS</td>
</tr>
<tr>
<td>Sort</td>
<td>Quick Sort, Merge Sort, Heap Sort</td>
</tr>
<tr>
<td>Graph</td>
<td>Dijkstra, Topological Sort, MST</td>
</tr>
<tr>
<td>String</td>
<td>KMP, Rabin-Karp</td>
</tr>
<tr>
<td>Data Structures</td>
<td>Union-Find, Trie, Segment Tree</td>
</tr>
</tbody>
</table>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Algorithm Categories and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Algorithm Categories and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Algorithm Categories?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Algorithm Categories provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Algorithm Categories?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Algorithm Categories from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="core-techniques">Core Techniques</h3>
<ul>
<li><strong>Greedy</strong>: Make locally optimal choices</li>
<li><strong>Divide &amp; Conquer</strong>: Split, solve, combine</li>
<li><strong>Dynamic Programming</strong>: Optimal substructure + overlapping subproblems</li>
<li><strong>Backtracking</strong>: Try all possibilities with pruning</li>
</ul>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Core Techniques and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Core Techniques and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Core Techniques?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Core Techniques provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Core Techniques?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Core Techniques from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="problems">Problems</h2>
<h3 id="1-kadanes-algorithm">1. Kadane's Algorithm</h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Problem Statement:</strong><br />
Find the maximum sum contiguous subarray.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4]
Output: 19 (subarray: [1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1])
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Track current sum and maximum sum</li>
<li>Reset current sum if it goes negative</li>
<li>At each position: extend current or start new</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">def kadanesAlgorithm(array):
    &quot;&quot;&quot;
    Time Complexity: O(n)
    Space Complexity: O(1)
    &quot;&quot;&quot;
    max_sum = array[0]
    current_sum = array[0]

    for i in range(1, len(array)):
        # Either extend current subarray or start new
        current_sum = max(array[i], current_sum + array[i])
        max_sum = max(max_sum, current_sum)

    return max_sum

# With index tracking
def kadanesWithIndices(array):
    max_sum = array[0]
    current_sum = array[0]
    start = end = temp_start = 0

    for i in range(1, len(array)):
        if array[i] &gt; current_sum + array[i]:
            current_sum = array[i]
            temp_start = i
        else:
            current_sum += array[i]

        if current_sum &gt; max_sum:
            max_sum = current_sum
            start = temp_start
            end = i

    return max_sum, start, end

# Test
array = [3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4]
print(kadanesAlgorithm(array))  # 19
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func kadanesAlgorithm(array []int) int {
    maxSum := array[0]
    currentSum := array[0]

    for i := 1; i &lt; len(array); i++ {
        if array[i] &gt; currentSum+array[i] {
            currentSum = array[i]
        } else {
            currentSum += array[i]
        }

        if currentSum &gt; maxSum {
            maxSum = currentSum
        }
    }

    return maxSum
}

func main() {
    array := []int{3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4}
    fmt.Println(kadanesAlgorithm(array)) // 19
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Maximum Product Subarray</strong> - Product instead of sum</li>
<li><strong>Maximum Circular Subarray</strong> - Circular array</li>
<li><strong>Best Time to Buy and Sell Stock</strong> - Profit maximization</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 1. Kadane's Algorithm?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 1. Kadane's Algorithm in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 1. Kadane's Algorithm?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 1. Kadane's Algorithm provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 1. Kadane's Algorithm?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 1. Kadane's Algorithm from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="2-union-find">2. Union Find</h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Problem Statement:</strong><br />
Implement Union-Find (Disjoint Set Union) with union by rank and path compression.</p>
<p><strong>Example:</strong></p>
<pre><code>UnionFind(5)  # 5 elements: 0, 1, 2, 3, 4
union(0, 1)   # {0, 1}, {2}, {3}, {4}
union(2, 3)   # {0, 1}, {2, 3}, {4}
union(0, 3)   # {0, 1, 2, 3}, {4}
find(0) == find(3)  # True
find(0) == find(4)  # False
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>parent[i] = parent of element i</li>
<li>Find: follow parents to root with path compression</li>
<li>Union: connect roots, use rank to keep balanced</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">class UnionFind:
    &quot;&quot;&quot;
    Time Complexity:
    - Find: O(α(n)) ≈ O(1) amortized
    - Union: O(α(n)) ≈ O(1) amortized
    Space Complexity: O(n)
    &quot;&quot;&quot;
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        &quot;&quot;&quot;Find root with path compression&quot;&quot;&quot;
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        &quot;&quot;&quot;Union by rank&quot;&quot;&quot;
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x == root_y:
            return False  # Already connected

        # Attach smaller tree under larger tree
        if self.rank[root_x] &lt; self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] &gt; self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1

        return True

    def connected(self, x, y):
        return self.find(x) == self.find(y)

# Test
uf = UnionFind(5)
uf.union(0, 1)
uf.union(2, 3)
uf.union(0, 3)
print(uf.connected(0, 3))  # True
print(uf.connected(0, 4))  # False
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type UnionFind struct {
    parent []int
    rank   []int
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }
    return &amp;UnionFind{
        parent: parent,
        rank:   make([]int, n),
    }
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX := uf.Find(x)
    rootY := uf.Find(y)

    if rootX == rootY {
        return false
    }

    if uf.rank[rootX] &lt; uf.rank[rootY] {
        uf.parent[rootX] = rootY
    } else if uf.rank[rootX] &gt; uf.rank[rootY] {
        uf.parent[rootY] = rootX
    } else {
        uf.parent[rootY] = rootX
        uf.rank[rootX]++
    }

    return true
}

func main() {
    uf := NewUnionFind(5)
    uf.Union(0, 1)
    uf.Union(2, 3)
    uf.Union(0, 3)
    fmt.Println(uf.Find(0) == uf.Find(3)) // true
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Number of Connected Components</strong> - Count components</li>
<li><strong>Redundant Connection</strong> - Find cycle edge</li>
<li><strong>Accounts Merge</strong> - Merge by common element</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 2. Union Find?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 2. Union Find in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 2. Union Find?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 2. Union Find provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 2. Union Find?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 2. Union Find from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="3-dijkstras-algorithm">3. Dijkstra's Algorithm</h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Problem Statement:</strong><br />
Find shortest paths from a source vertex to all other vertices in a weighted graph with non-negative edges.</p>
<p><strong>Example:</strong></p>
<pre><code>edges = [
    [[1, 7]],          # 0 -&gt; 1 (weight 7)
    [[2, 6], [3, 20], [4, 3]],  # 1 -&gt; 2,3,4
    [[3, 14]],         # 2 -&gt; 3
    [[4, 2]],          # 3 -&gt; 4
    [],
    []
]
start = 0
Output: [0, 7, 13, 27, 10, -1]
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Use min-heap to always process closest unvisited vertex</li>
<li>Relax edges: if new_dist &lt; known_dist, update</li>
<li>Greedy: once a vertex is visited, its distance is final</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">import heapq

def dijkstrasAlgorithm(start, edges):
    &quot;&quot;&quot;
    Time Complexity: O((V + E) log V)
    Space Complexity: O(V)
    &quot;&quot;&quot;
    n = len(edges)
    distances = [float('inf')] * n
    distances[start] = 0

    # Min heap: (distance, vertex)
    heap = [(0, start)]
    visited = set()

    while heap:
        dist, vertex = heapq.heappop(heap)

        if vertex in visited:
            continue

        visited.add(vertex)

        for neighbor, weight in edges[vertex]:
            if neighbor not in visited:
                new_dist = dist + weight
                if new_dist &lt; distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(heap, (new_dist, neighbor))

    # Replace infinity with -1
    return [-1 if d == float('inf') else d for d in distances]

# Test
edges = [
    [[1, 7]],
    [[2, 6], [3, 20], [4, 3]],
    [[3, 14]],
    [[4, 2]],
    [],
    []
]
print(dijkstrasAlgorithm(0, edges))  # [0, 7, 13, 27, 10, -1]
</code></pre>
<pre><code class="language-go">package main

import (
    &quot;container/heap&quot;
    &quot;fmt&quot;
)

type Item struct {
    vertex   int
    distance int
}

type MinHeap []Item

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i].distance &lt; h[j].distance }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(Item))
}

func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    item := old[n-1]
    *h = old[0 : n-1]
    return item
}

func dijkstrasAlgorithm(start int, edges [][][]int) []int {
    n := len(edges)
    distances := make([]int, n)
    for i := range distances {
        distances[i] = 1&lt;&lt;31 - 1
    }
    distances[start] = 0

    visited := make(map[int]bool)
    h := &amp;MinHeap{{start, 0}}
    heap.Init(h)

    for h.Len() &gt; 0 {
        item := heap.Pop(h).(Item)
        vertex, dist := item.vertex, item.distance

        if visited[vertex] {
            continue
        }
        visited[vertex] = true

        for _, edge := range edges[vertex] {
            neighbor, weight := edge[0], edge[1]
            if !visited[neighbor] {
                newDist := dist + weight
                if newDist &lt; distances[neighbor] {
                    distances[neighbor] = newDist
                    heap.Push(h, Item{neighbor, newDist})
                }
            }
        }
    }

    for i := range distances {
        if distances[i] == 1&lt;&lt;31-1 {
            distances[i] = -1
        }
    }

    return distances
}

func main() {
    edges := [][][]int{
        {{1, 7}},
        {{2, 6}, {3, 20}, {4, 3}},
        {{3, 14}},
        {{4, 2}},
        {},
        {},
    }
    fmt.Println(dijkstrasAlgorithm(0, edges))
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Network Delay Time</strong> - LeetCode Dijkstra</li>
<li><strong>Cheapest Flights Within K Stops</strong> - Modified Dijkstra</li>
<li><strong>Path with Maximum Probability</strong> - Max probability path</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 3. Dijkstra's Algorithm?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 3. Dijkstra's Algorithm in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 3. Dijkstra's Algorithm?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 3. Dijkstra's Algorithm provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 3. Dijkstra's Algorithm?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 3. Dijkstra's Algorithm from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="4-topological-sort">4. Topological Sort</h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Problem Statement:</strong><br />
Find a valid ordering of vertices in a DAG such that for every edge u→v, u comes before v.</p>
<p><strong>Example:</strong></p>
<pre><code>jobs = [1, 2, 3, 4]
deps = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]
Output: [1, 4, 3, 2] or [4, 1, 3, 2]
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Build adjacency list and in-degree count</li>
<li>Start with vertices having in-degree 0</li>
<li>BFS: remove vertex, reduce in-degree of neighbors</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">from collections import deque

def topologicalSort(jobs, deps):
    &quot;&quot;&quot;
    Time Complexity: O(V + E)
    Space Complexity: O(V + E)
    &quot;&quot;&quot;
    # Build graph
    graph = {job: [] for job in jobs}
    in_degree = {job: 0 for job in jobs}

    for prereq, job in deps:
        graph[prereq].append(job)
        in_degree[job] += 1

    # Start with jobs having no prerequisites
    queue = deque([job for job in jobs if in_degree[job] == 0])
    result = []

    while queue:
        job = queue.popleft()
        result.append(job)

        for dependent in graph[job]:
            in_degree[dependent] -= 1
            if in_degree[dependent] == 0:
                queue.append(dependent)

    # Check for cycle
    if len(result) != len(jobs):
        return []

    return result

# DFS approach
def topologicalSortDFS(jobs, deps):
    graph = {job: [] for job in jobs}
    for prereq, job in deps:
        graph[prereq].append(job)

    WHITE, GRAY, BLACK = 0, 1, 2
    colors = {job: WHITE for job in jobs}
    result = []

    def dfs(job):
        if colors[job] == GRAY:
            return False  # Cycle detected
        if colors[job] == BLACK:
            return True

        colors[job] = GRAY
        for dependent in graph[job]:
            if not dfs(dependent):
                return False
        colors[job] = BLACK
        result.append(job)
        return True

    for job in jobs:
        if colors[job] == WHITE:
            if not dfs(job):
                return []

    return result[::-1]

# Test
jobs = [1, 2, 3, 4]
deps = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]
print(topologicalSort(jobs, deps))  # [1, 4, 3, 2] or similar valid order
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func topologicalSort(jobs []int, deps [][]int) []int {
    graph := make(map[int][]int)
    inDegree := make(map[int]int)

    for _, job := range jobs {
        graph[job] = []int{}
        inDegree[job] = 0
    }

    for _, dep := range deps {
        prereq, job := dep[0], dep[1]
        graph[prereq] = append(graph[prereq], job)
        inDegree[job]++
    }

    queue := []int{}
    for _, job := range jobs {
        if inDegree[job] == 0 {
            queue = append(queue, job)
        }
    }

    result := []int{}
    for len(queue) &gt; 0 {
        job := queue[0]
        queue = queue[1:]
        result = append(result, job)

        for _, dependent := range graph[job] {
            inDegree[dependent]--
            if inDegree[dependent] == 0 {
                queue = append(queue, dependent)
            }
        }
    }

    if len(result) != len(jobs) {
        return []int{}
    }

    return result
}

func main() {
    jobs := []int{1, 2, 3, 4}
    deps := [][]int{{1, 2}, {1, 3}, {3, 2}, {4, 2}, {4, 3}}
    fmt.Println(topologicalSort(jobs, deps))
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Course Schedule II</strong> - LeetCode version</li>
<li><strong>Alien Dictionary</strong> - Order from sorted words</li>
<li><strong>Sequence Reconstruction</strong> - Verify unique order</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 4. Topological Sort?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 4. Topological Sort in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 4. Topological Sort?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 4. Topological Sort provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 4. Topological Sort?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 4. Topological Sort from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="5-8-more-hardvery-hard-algorithms">5-8. More Hard/Very Hard Algorithms</h3>
<details>
<summary><strong>Kruskal's Algorithm (MST)</strong></summary>
<p>Find Minimum Spanning Tree using Union-Find.</p>
<pre><code class="language-python">def kruskalsAlgorithm(edges, n):
    &quot;&quot;&quot;
    Time: O(E log E)
    edges: [(u, v, weight), ...]
    &quot;&quot;&quot;
    # Sort edges by weight
    edges.sort(key=lambda x: x[2])

    uf = UnionFind(n)
    mst = []
    total_weight = 0

    for u, v, weight in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight

            if len(mst) == n - 1:
                break

    return mst, total_weight
</code></pre>
</details>
<details>
<summary><strong>Prim's Algorithm (MST)</strong></summary>
<p>Find MST using min-heap.</p>
<pre><code class="language-python">import heapq

def primsAlgorithm(graph, n):
    &quot;&quot;&quot;
    Time: O(E log V)
    graph: adjacency list with weights
    &quot;&quot;&quot;
    visited = set()
    mst = []
    heap = [(0, 0, -1)]  # (weight, vertex, from)

    while heap and len(visited) &lt; n:
        weight, vertex, from_vertex = heapq.heappop(heap)

        if vertex in visited:
            continue

        visited.add(vertex)
        if from_vertex != -1:
            mst.append((from_vertex, vertex, weight))

        for neighbor, edge_weight in graph[vertex]:
            if neighbor not in visited:
                heapq.heappush(heap, (edge_weight, neighbor, vertex))

    return mst
</code></pre>
</details>
<details>
<summary><strong>KMP Algorithm (String Matching)</strong></summary>
<p>Pattern matching in O(n + m) time.</p>
<pre><code class="language-python">def knuthMorrisPratt(text, pattern):
    &quot;&quot;&quot;
    Time: O(n + m)
    Returns: starting index of match or -1
    &quot;&quot;&quot;
    if not pattern:
        return 0

    # Build failure function
    lps = [0] * len(pattern)
    length = 0
    i = 1

    while i &lt; len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        elif length &gt; 0:
            length = lps[length - 1]
        else:
            lps[i] = 0
            i += 1

    # Search
    i = j = 0
    while i &lt; len(text):
        if text[i] == pattern[j]:
            i += 1
            j += 1
            if j == len(pattern):
                return i - j  # Match found
        elif j &gt; 0:
            j = lps[j - 1]
        else:
            i += 1

    return -1
</code></pre>
</details>
<details>
<summary><strong>A* Algorithm (Pathfinding)</strong></summary>
<p>Optimal pathfinding with heuristic.</p>
<pre><code class="language-python">import heapq

def aStarAlgorithm(start, end, graph, heuristic):
    &quot;&quot;&quot;
    Time: O(E log V) with good heuristic
    heuristic: function(node) -&gt; estimated distance to end
    &quot;&quot;&quot;
    open_set = [(heuristic(start), 0, start, [start])]
    visited = set()

    while open_set:
        _, g_score, current, path = heapq.heappop(open_set)

        if current == end:
            return path

        if current in visited:
            continue

        visited.add(current)

        for neighbor, weight in graph[current]:
            if neighbor not in visited:
                new_g = g_score + weight
                f_score = new_g + heuristic(neighbor)
                heapq.heappush(open_set, (f_score, new_g, neighbor, path + [neighbor]))

    return None  # No path found
</code></pre>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are 5-8. More Hard/Very Hard Algorithms and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of 5-8. More Hard/Very Hard Algorithms and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 5-8. More Hard/Very Hard Algorithms?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 5-8. More Hard/Very Hard Algorithms provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 5-8. More Hard/Very Hard Algorithms?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 5-8. More Hard/Very Hard Algorithms from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="algorithm-selection-guide">Algorithm Selection Guide</h2>
<table>
<thead>
<tr>
<th>Problem Type</th>
<th>Best Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>Max contiguous sum</td>
<td>Kadane's</td>
</tr>
<tr>
<td>Dynamic connectivity</td>
<td>Union-Find</td>
</tr>
<tr>
<td>Shortest path (positive weights)</td>
<td>Dijkstra</td>
</tr>
<tr>
<td>Shortest path (negative weights)</td>
<td>Bellman-Ford</td>
</tr>
<tr>
<td>All pairs shortest</td>
<td>Floyd-Warshall</td>
</tr>
<tr>
<td>Minimum Spanning Tree</td>
<td>Kruskal/Prim</td>
</tr>
<tr>
<td>Dependency ordering</td>
<td>Topological Sort</td>
</tr>
<tr>
<td>Pattern matching</td>
<td>KMP</td>
</tr>
<tr>
<td>Grid pathfinding</td>
<td>A*</td>
</tr>
</tbody>
</table>
