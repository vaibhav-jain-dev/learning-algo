<h1 id="linked-lists">Linked Lists</h1>
<h2 id="overview">Overview</h2>
<p>A Linked List is a linear data structure where elements are stored in nodes, each pointing to the next. Unlike arrays, elements are not contiguous in memory, allowing efficient insertions and deletions.</p>
<h2 id="key-concepts--terminology">Key Concepts &amp; Terminology</h2>
<h3 id="types-of-linked-lists">Types of Linked Lists</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Singly Linked</td>
<td>Each node points to next</td>
</tr>
<tr>
<td>Doubly Linked</td>
<td>Nodes point to next and previous</td>
</tr>
<tr>
<td>Circular</td>
<td>Last node points to first</td>
</tr>
</tbody>
</table>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Types of Linked Lists and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Types of Linked Lists and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Types of Linked Lists?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Types of Linked Lists provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Types of Linked Lists?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Types of Linked Lists from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="time-complexities">Time Complexities</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Array</th>
<th>Linked List</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access by index</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Insert at head</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Insert at tail</td>
<td>O(1)*</td>
<td>O(n) or O(1)**</td>
</tr>
<tr>
<td>Delete at head</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>*Amortized for dynamic arrays<br />
**O(1) if tail pointer maintained</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Time Complexities and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Time Complexities and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Time Complexities?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Time Complexities provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Time Complexities?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Time Complexities from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="common-patterns">Common Patterns</h3>
<ol>
<li><strong>Two Pointers</strong>: Fast/slow for cycle detection, middle finding</li>
<li><strong>Dummy Head</strong>: Simplifies edge cases</li>
<li><strong>Reverse</strong>: In-place pointer manipulation</li>
<li><strong>Merge</strong>: Combine sorted lists</li>
</ol>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is the Common Patterns and when should you use it?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>The Common Patterns addresses a specific category of problems. Think about the conditions that make this pattern valuable - what symptoms in your code suggest you need it? Also consider what alternatives exist and why you might choose this approach over others.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Common Patterns?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Common Patterns provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Common Patterns?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Common Patterns from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="boundary-conditions">Boundary Conditions</h3>
<ol>
<li>Empty list (head is null)</li>
<li>Single node</li>
<li>Two nodes</li>
<li>Cycle detection</li>
<li>Update head/tail when modifying</li>
</ol>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Boundary Conditions and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Boundary Conditions and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Boundary Conditions?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Boundary Conditions provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Boundary Conditions?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Boundary Conditions from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="problems">Problems</h2>
<h3 id="1-remove-duplicates">1. Remove Duplicates</h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Problem Statement:</strong><br />
Remove duplicates from a sorted linked list.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 1 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 6
Output: 1 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Since sorted, duplicates are adjacent</li>
<li>Compare current with next</li>
<li>Skip nodes with same value</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

def removeDuplicatesFromLinkedList(linkedList):
    &quot;&quot;&quot;
    Time Complexity: O(n)
    Space Complexity: O(1)
    &quot;&quot;&quot;
    current = linkedList

    while current is not None:
        # Skip all duplicates
        next_distinct = current.next
        while next_distinct is not None and next_distinct.value == current.value:
            next_distinct = next_distinct.next

        current.next = next_distinct
        current = next_distinct

    return linkedList

# Test helper
def print_list(head):
    values = []
    while head:
        values.append(str(head.value))
        head = head.next
    print(&quot; -&gt; &quot;.join(values))

# Test
head = LinkedList(1)
head.next = LinkedList(1)
head.next.next = LinkedList(3)
head.next.next.next = LinkedList(4)
head.next.next.next.next = LinkedList(4)

removeDuplicatesFromLinkedList(head)
print_list(head)  # 1 -&gt; 3 -&gt; 4
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type LinkedList struct {
    Value int
    Next  *LinkedList
}

func removeDuplicatesFromLinkedList(linkedList *LinkedList) *LinkedList {
    current := linkedList

    for current != nil {
        nextDistinct := current.Next
        for nextDistinct != nil &amp;&amp; nextDistinct.Value == current.Value {
            nextDistinct = nextDistinct.Next
        }
        current.Next = nextDistinct
        current = nextDistinct
    }

    return linkedList
}

func main() {
    head := &amp;LinkedList{Value: 1}
    head.Next = &amp;LinkedList{Value: 1}
    head.Next.Next = &amp;LinkedList{Value: 3}

    removeDuplicatesFromLinkedList(head)
    for head != nil {
        fmt.Print(head.Value, &quot; &quot;)
        head = head.Next
    }
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Remove Duplicates II</strong> - Remove all nodes with duplicates</li>
<li><strong>Remove Duplicates from Unsorted List</strong> - Use hash set</li>
<li><strong>Delete Nodes Having Greater Value on Right</strong></li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are 1. Remove Duplicates and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of 1. Remove Duplicates and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 1. Remove Duplicates?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 1. Remove Duplicates provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 1. Remove Duplicates?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 1. Remove Duplicates from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="2-middle-node">2. Middle Node</h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Problem Statement:</strong><br />
Find the middle node of a linked list. For even length, return the second middle.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
Output: 3

Input: 1 -&gt; 2 -&gt; 3 -&gt; 4
Output: 3 (second middle)
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Use fast and slow pointers</li>
<li>Fast moves 2 steps, slow moves 1 step</li>
<li>When fast reaches end, slow is at middle</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

def middleNode(linkedList):
    &quot;&quot;&quot;
    Time Complexity: O(n)
    Space Complexity: O(1)
    &quot;&quot;&quot;
    slow = fast = linkedList

    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next

    return slow

# Test
head = LinkedList(1)
head.next = LinkedList(2)
head.next.next = LinkedList(3)
head.next.next.next = LinkedList(4)
head.next.next.next.next = LinkedList(5)

middle = middleNode(head)
print(middle.value)  # 3
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type LinkedList struct {
    Value int
    Next  *LinkedList
}

func middleNode(linkedList *LinkedList) *LinkedList {
    slow := linkedList
    fast := linkedList

    for fast != nil &amp;&amp; fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    return slow
}

func main() {
    head := &amp;LinkedList{Value: 1}
    head.Next = &amp;LinkedList{Value: 2}
    head.Next.Next = &amp;LinkedList{Value: 3}
    head.Next.Next.Next = &amp;LinkedList{Value: 4}
    head.Next.Next.Next.Next = &amp;LinkedList{Value: 5}

    middle := middleNode(head)
    fmt.Println(middle.Value) // 3
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Detect Cycle</strong> - Fast/slow pointer</li>
<li><strong>Find Cycle Start</strong> - Floyd's algorithm</li>
<li><strong>Reorder List</strong> - Use middle finding</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 2. Middle Node?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 2. Middle Node in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 2. Middle Node?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 2. Middle Node provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 2. Middle Node?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 2. Middle Node from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="3-linked-list-construction">3. Linked List Construction</h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Problem Statement:</strong><br />
Implement a doubly linked list with insert, remove, search operations.</p>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">class Node:
    def __init__(self, value):
        self.value = value
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def setHead(self, node):
        if self.head is None:
            self.head = node
            self.tail = node
            return
        self.insertBefore(self.head, node)

    def setTail(self, node):
        if self.tail is None:
            self.setHead(node)
            return
        self.insertAfter(self.tail, node)

    def insertBefore(self, node, nodeToInsert):
        if nodeToInsert == self.head and nodeToInsert == self.tail:
            return
        self.remove(nodeToInsert)
        nodeToInsert.prev = node.prev
        nodeToInsert.next = node
        if node.prev is None:
            self.head = nodeToInsert
        else:
            node.prev.next = nodeToInsert
        node.prev = nodeToInsert

    def insertAfter(self, node, nodeToInsert):
        if nodeToInsert == self.head and nodeToInsert == self.tail:
            return
        self.remove(nodeToInsert)
        nodeToInsert.prev = node
        nodeToInsert.next = node.next
        if node.next is None:
            self.tail = nodeToInsert
        else:
            node.next.prev = nodeToInsert
        node.next = nodeToInsert

    def insertAtPosition(self, position, nodeToInsert):
        if position == 1:
            self.setHead(nodeToInsert)
            return
        node = self.head
        currentPosition = 1
        while node is not None and currentPosition != position:
            node = node.next
            currentPosition += 1
        if node is not None:
            self.insertBefore(node, nodeToInsert)
        else:
            self.setTail(nodeToInsert)

    def removeNodesWithValue(self, value):
        node = self.head
        while node is not None:
            nodeToRemove = node
            node = node.next
            if nodeToRemove.value == value:
                self.remove(nodeToRemove)

    def remove(self, node):
        if node == self.head:
            self.head = self.head.next
        if node == self.tail:
            self.tail = self.tail.prev
        self.removeNodeBindings(node)

    def removeNodeBindings(self, node):
        if node.prev is not None:
            node.prev.next = node.next
        if node.next is not None:
            node.next.prev = node.prev
        node.prev = None
        node.next = None

    def containsNodeWithValue(self, value):
        node = self.head
        while node is not None:
            if node.value == value:
                return True
            node = node.next
        return False
</code></pre>
<pre><code class="language-go">package main

type Node struct {
    Value int
    Prev  *Node
    Next  *Node
}

type DoublyLinkedList struct {
    Head *Node
    Tail *Node
}

func (dll *DoublyLinkedList) SetHead(node *Node) {
    if dll.Head == nil {
        dll.Head = node
        dll.Tail = node
        return
    }
    dll.InsertBefore(dll.Head, node)
}

func (dll *DoublyLinkedList) SetTail(node *Node) {
    if dll.Tail == nil {
        dll.SetHead(node)
        return
    }
    dll.InsertAfter(dll.Tail, node)
}

func (dll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {
    if nodeToInsert == dll.Head &amp;&amp; nodeToInsert == dll.Tail {
        return
    }
    dll.Remove(nodeToInsert)
    nodeToInsert.Prev = node.Prev
    nodeToInsert.Next = node
    if node.Prev == nil {
        dll.Head = nodeToInsert
    } else {
        node.Prev.Next = nodeToInsert
    }
    node.Prev = nodeToInsert
}

func (dll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {
    if nodeToInsert == dll.Head &amp;&amp; nodeToInsert == dll.Tail {
        return
    }
    dll.Remove(nodeToInsert)
    nodeToInsert.Prev = node
    nodeToInsert.Next = node.Next
    if node.Next == nil {
        dll.Tail = nodeToInsert
    } else {
        node.Next.Prev = nodeToInsert
    }
    node.Next = nodeToInsert
}

func (dll *DoublyLinkedList) Remove(node *Node) {
    if node == dll.Head {
        dll.Head = dll.Head.Next
    }
    if node == dll.Tail {
        dll.Tail = dll.Tail.Prev
    }
    dll.removeNodeBindings(node)
}

func (dll *DoublyLinkedList) removeNodeBindings(node *Node) {
    if node.Prev != nil {
        node.Prev.Next = node.Next
    }
    if node.Next != nil {
        node.Next.Prev = node.Prev
    }
    node.Prev = nil
    node.Next = nil
}
</code></pre>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 3. Linked List Construction?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 3. Linked List Construction in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 3. Linked List Construction?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 3. Linked List Construction provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 3. Linked List Construction?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 3. Linked List Construction from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="4-remove-kth-node-from-end">4. Remove Kth Node From End</h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Problem Statement:</strong><br />
Remove the kth node from the end of a linked list.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9, k = 4
Output: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 7 -&gt; 8 -&gt; 9 (6 removed)
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Use two pointers with k-gap</li>
<li>Move first pointer k nodes ahead</li>
<li>Move both until first reaches end</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

def removeKthNodeFromEnd(head, k):
    &quot;&quot;&quot;
    Time Complexity: O(n)
    Space Complexity: O(1)
    &quot;&quot;&quot;
    first = head
    second = head

    # Move first k nodes ahead
    for _ in range(k):
        first = first.next

    # Special case: remove head
    if first is None:
        head.value = head.next.value
        head.next = head.next.next
        return

    # Move both until first reaches end
    while first.next is not None:
        first = first.next
        second = second.next

    # Remove node after second
    second.next = second.next.next

# Test
head = LinkedList(0)
current = head
for i in range(1, 10):
    current.next = LinkedList(i)
    current = current.next

removeKthNodeFromEnd(head, 4)
# Print result
</code></pre>
<pre><code class="language-go">package main

type LinkedList struct {
    Value int
    Next  *LinkedList
}

func removeKthNodeFromEnd(head *LinkedList, k int) {
    first := head
    second := head

    for i := 0; i &lt; k; i++ {
        first = first.Next
    }

    if first == nil {
        head.Value = head.Next.Value
        head.Next = head.Next.Next
        return
    }

    for first.Next != nil {
        first = first.Next
        second = second.Next
    }

    second.Next = second.Next.Next
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Remove Nth Node From End</strong> - LeetCode version</li>
<li><strong>Get Kth Node From End</strong> - Just find, don't remove</li>
<li><strong>Rotate List</strong> - Rotate by k positions</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a 4. Remove Kth Node From End?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about 4. Remove Kth Node From End in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 4. Remove Kth Node From End?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 4. Remove Kth Node From End provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 4. Remove Kth Node From End?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 4. Remove Kth Node From End from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="5-sum-of-linked-lists">5. Sum Of Linked Lists</h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Problem Statement:</strong><br />
Add two numbers represented as linked lists (digits in reverse order).</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 2 -&gt; 4 -&gt; 7 -&gt; 1 (1742)
       9 -&gt; 4 -&gt; 5      (549)
Output: 1 -&gt; 9 -&gt; 2 -&gt; 2 (2291)
</code></pre>
<details>
<summary><strong>Hints</strong></summary>
<ol>
<li>Add digit by digit with carry</li>
<li>Handle different lengths</li>
<li>Don't forget final carry</li>
</ol>
</details>
<details>
<summary><strong>Solution</strong></summary>
<pre><code class="language-python">class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

def sumOfLinkedLists(linkedListOne, linkedListTwo):
    &quot;&quot;&quot;
    Time Complexity: O(max(n, m))
    Space Complexity: O(max(n, m))
    &quot;&quot;&quot;
    dummy = LinkedList(0)
    current = dummy
    carry = 0

    node1 = linkedListOne
    node2 = linkedListTwo

    while node1 is not None or node2 is not None or carry &gt; 0:
        val1 = node1.value if node1 else 0
        val2 = node2.value if node2 else 0

        total = val1 + val2 + carry
        carry = total // 10
        digit = total % 10

        current.next = LinkedList(digit)
        current = current.next

        node1 = node1.next if node1 else None
        node2 = node2.next if node2 else None

    return dummy.next

# Test
list1 = LinkedList(2)
list1.next = LinkedList(4)
list1.next.next = LinkedList(7)
list1.next.next.next = LinkedList(1)

list2 = LinkedList(9)
list2.next = LinkedList(4)
list2.next.next = LinkedList(5)

result = sumOfLinkedLists(list1, list2)
# Print: 1 -&gt; 9 -&gt; 2 -&gt; 2
</code></pre>
<pre><code class="language-go">package main

type LinkedList struct {
    Value int
    Next  *LinkedList
}

func sumOfLinkedLists(l1, l2 *LinkedList) *LinkedList {
    dummy := &amp;LinkedList{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry &gt; 0 {
        val1, val2 := 0, 0
        if l1 != nil {
            val1 = l1.Value
            l1 = l1.Next
        }
        if l2 != nil {
            val2 = l2.Value
            l2 = l2.Next
        }

        total := val1 + val2 + carry
        carry = total / 10
        digit := total % 10

        current.Next = &amp;LinkedList{Value: digit}
        current = current.Next
    }

    return dummy.Next
}
</code></pre>
</details>
<details>
<summary><strong>Similar Problems</strong></summary>
<ol>
<li><strong>Add Two Numbers</strong> - LeetCode version</li>
<li><strong>Add Two Numbers II</strong> - Most significant first</li>
<li><strong>Multiply Strings</strong> - Multiplication instead</li>
</ol>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are 5. Sum Of Linked Lists and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of 5. Sum Of Linked Lists and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply 5. Sum Of Linked Lists?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where 5. Sum Of Linked Lists provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 5. Sum Of Linked Lists?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 5. Sum Of Linked Lists from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="6-10-more-mediumhard-problems">6-10. More Medium/Hard Problems</h3>
<details>
<summary><strong>Find Loop</strong></summary>
<p>Find the node where a cycle begins.</p>
<pre><code class="language-python">def findLoop(head):
    &quot;&quot;&quot;Floyd's Cycle Detection&quot;&quot;&quot;
    slow = fast = head

    # Find meeting point
    while True:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break

    # Find cycle start
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next

    return slow
</code></pre>
<p><strong>Similar</strong>: Linked List Cycle II, Happy Number</p>
</details>
<details>
<summary><strong>Reverse Linked List</strong></summary>
<p>Reverse a linked list in-place.</p>
<pre><code class="language-python">def reverseLinkedList(head):
    &quot;&quot;&quot;
    Time: O(n), Space: O(1)
    &quot;&quot;&quot;
    prev = None
    current = head

    while current is not None:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node

    return prev
</code></pre>
<p><strong>Similar</strong>: Reverse in K-Groups, Reverse Between</p>
</details>
<details>
<summary><strong>Merge Linked Lists</strong></summary>
<p>Find intersection point of two lists.</p>
<pre><code class="language-python">def mergingLinkedLists(headOne, headTwo):
    &quot;&quot;&quot;
    Get lengths, align starts, find meeting point
    &quot;&quot;&quot;
    len1 = getLength(headOne)
    len2 = getLength(headTwo)

    diff = abs(len1 - len2)

    if len1 &gt; len2:
        for _ in range(diff):
            headOne = headOne.next
    else:
        for _ in range(diff):
            headTwo = headTwo.next

    while headOne != headTwo:
        headOne = headOne.next
        headTwo = headTwo.next

    return headOne
</code></pre>
</details>
<details>
<summary><strong>LRU Cache (Very Hard)</strong></summary>
<p>Implement Least Recently Used cache.</p>
<pre><code class="language-python">class LRUCache:
    def __init__(self, maxSize):
        self.maxSize = maxSize or 1
        self.cache = {}
        self.head = Node(None, None)  # Dummy head (most recent)
        self.tail = Node(None, None)  # Dummy tail (least recent)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        if key not in self.cache:
            return None
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key, value):
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
        else:
            if len(self.cache) == self.maxSize:
                self.removeLRU()
            node = Node(key, value)
            self.cache[key] = node
            self.addToHead(node)

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def addToHead(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def removeLRU(self):
        lru = self.tail.prev
        self.removeNode(lru)
        del self.cache[lru.key]
</code></pre>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are 6-10. More Medium/Hard Problems and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of 6-10. More Medium/Hard Problems and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: How would you approach solving a problem related to 6-10. More Medium/Hard Problems?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Start by clearly defining the problem constraints and requirements. Consider what makes this problem challenging and what techniques apply. Think about how you would break it down into smaller subproblems. Remember that recognizing the problem pattern is often the hardest part.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using 6-10. More Medium/Hard Problems?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider 6-10. More Medium/Hard Problems from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="practice-tips">Practice Tips</h2>
<h3 id="common-patterns-1">Common Patterns</h3>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>Two Pointers</td>
<td>Middle, cycle, kth from end</td>
</tr>
<tr>
<td>Dummy Head</td>
<td>Simplify insertions/deletions</td>
</tr>
<tr>
<td>Prev/Curr/Next</td>
<td>Reversing, rearranging</td>
</tr>
<tr>
<td>Hash Map</td>
<td>O(1) node lookup</td>
</tr>
</tbody>
</table>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is the Common Patterns and when should you use it?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>The Common Patterns addresses a specific category of problems. Think about the conditions that make this pattern valuable - what symptoms in your code suggest you need it? Also consider what alternatives exist and why you might choose this approach over others.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Common Patterns?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Common Patterns provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Common Patterns?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Common Patterns from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="common-mistakes">Common Mistakes</h3>
<ol>
<li>Losing reference to head</li>
<li>Not handling null pointers</li>
<li>Forgetting to update tail</li>
<li>Infinite loops in cycles</li>
</ol>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Common Mistakes and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Common Mistakes and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Common Mistakes?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Common Mistakes provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Common Mistakes?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Common Mistakes from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
