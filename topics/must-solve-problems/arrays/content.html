<h1 id="arrays---interview-mastery-guide">Arrays - Interview Mastery Guide</h1>
<h2 id="category-overview">Category Overview</h2>
<p>Arrays are the most fundamental data structure in computer science, serving as the building blocks for nearly every other data structure and algorithm. An array stores elements in contiguous memory locations, enabling O(1) random access by index. This simple yet powerful structure appears in approximately <strong>40-50% of all coding interview questions</strong>, making it the most frequently tested topic.</p>
<p>Understanding arrays deeply means understanding memory layout, cache efficiency, and how modern CPUs optimize sequential access patterns. Arrays provide the foundation for stacks, queues, heaps, hash tables, and even more complex structures like segment trees and suffix arrays.</p>
<div>
<h3>Why Arrays Dominate Interviews</h3>
<div>
<ul>
<li><strong>Universal Foundation</strong>: Every programmer knows arrays, creating equal footing</li>
<li><strong>Multiple Solutions</strong>: Most problems have brute force to optimal progressions</li>
<li><strong>Pattern Recognition</strong>: Tests ability to identify and apply known techniques</li>
<li><strong>Optimization Skills</strong>: Shows how candidates improve time/space complexity</li>
<li><strong>Edge Case Handling</strong>: Reveals attention to boundary conditions</li>
</ul>
</div>
</div>
<p><strong>Companies that heavily test arrays</strong>: Google (sliding window, two pointers), Amazon (subarray problems), Meta (optimization), Microsoft (matrix operations), Apple (in-place modifications).</p>
<h2 id="key-patterns">Key Patterns</h2>
<p>Mastering array problems requires recognizing these fundamental patterns:</p>
<div>
<h3>Pattern Recognition Guide</h3>
<div>
<!-- Two Pointers -->
<div>
<div>Two Pointers</div>
<div>Sorted arrays, pairs, partitioning</div>
<div><span>Two Sum</span> <span>Three Sum</span> <span>Container With Most Water</span></div>
</div>
<!-- Sliding Window -->
<div>
<div>Sliding Window</div>
<div>Contiguous subarrays, fixed/variable window</div>
<div><span>Max Subarray Sum</span> <span>Longest Substring</span></div>
</div>
<!-- Hash Map/Set -->
<div>
<div>Hash Map/Set</div>
<div>Finding pairs, counting duplicates, lookups</div>
<div><span>Two Sum</span> <span>First Duplicate</span> <span>Subarray Sum Equals K</span></div>
</div>
<!-- Prefix Sum -->
<div>
<div>Prefix Sum</div>
<div>Range queries, subarray sums, cumulative ops</div>
<div><span>Zero Sum Subarray</span> <span>Contiguous Array</span></div>
</div>
<!-- Binary Search -->
<div>
<div>Binary Search</div>
<div>Sorted arrays, finding boundaries, rotated</div>
<div><span>Search Insert Position</span> <span>Find First and Last</span></div>
</div>
<!-- In-Place Modify -->
<div>
<div>In-Place Modify</div>
<div>O(1) space constraint, marking visited</div>
<div><span>Move Zeroes</span> <span>Dutch Flag</span> <span>First Duplicate Value</span></div>
</div>
</div>
</div>
<h3 id="pattern-1-two-pointers">Pattern 1: Two Pointers</h3>
<p>The two-pointer technique uses two indices that move toward each other or in the same direction. It transforms O(n^2) brute force into O(n) solutions.</p>
<div>
<h4>Two Pointers Visualization</h4>
<div>Finding pair with target sum = <span>13</span> in sorted array:</div>
<!-- Step 1 -->
<div>
<div>
<span>Step 1</span>
</div>
<div>
<span>L:1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>6</span>
<span>8</span>
<span>9</span>
<span>14</span>
<span>R:15</span>
</div>
<div>Sum = 1 + 15 = <span>16 &gt; 13</span>, move R left</div>
</div>
<!-- Step 3 -->
<div>
<div>
<span>Step 3</span>
</div>
<div>
<span>L:1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>6</span>
<span>8</span>
<span>R:9</span>
<span>14</span>
<span>15</span>
</div>
<div>Sum = 1 + 9 = <span>10 &lt; 13</span>, move L right</div>
</div>
<!-- Step 6 - FOUND -->
<div>
<div>
<span>Step 6 - FOUND!</span>
</div>
<div>
<span>1</span>
<span>2</span>
<span>3</span>
<span>L:4</span>
<span>6</span>
<span>8</span>
<span>R:9</span>
<span>14</span>
<span>15</span>
</div>
<div>Sum = 4 + 9 = 13 = target!</div>
</div>
<!-- Key Insight -->
<div>
<strong>Key Insight:</strong>
<span> Each step eliminates either the smallest or largest remaining element, guaranteeing O(n) time complexity.</span>
</div>
</div>
<h3 id="pattern-2-sliding-window">Pattern 2: Sliding Window</h3>
<p>Sliding window maintains a contiguous subset of elements, expanding or shrinking based on conditions. It's optimal for substring and subarray problems.</p>
<div>
<h4>Sliding Window Visualization</h4>
<div>Find maximum sum of subarray with size <span>k=3</span></div>
<div>
<!-- Window 1 -->
<div>
<div>
<span>Window 1</span>
<span>Sum = 8</span>
</div>
<div>
<span>2</span>
<span>1</span>
<span>5</span>
<span>1</span>
<span>3</span>
<span>2</span>
</div>
</div>
<!-- Window 2 -->
<div>
<div>
<span>Window 2</span>
<span>Sum = 7</span>
<span>(remove 2, add 1)</span>
</div>
<div>
<span>2</span>
<span>1</span>
<span>5</span>
<span>1</span>
<span>3</span>
<span>2</span>
</div>
</div>
<!-- Window 3 - MAX -->
<div>
<div>
<span>Window 3 - MAX!</span>
<span>Sum = 9</span>
<span>(remove 1, add 3)</span>
</div>
<div>
<span>2</span>
<span>1</span>
<span>5</span>
<span>1</span>
<span>3</span>
<span>2</span>
</div>
</div>
<!-- Window 4 -->
<div>
<div>
<span>Window 4</span>
<span>Sum = 6</span>
<span>(remove 5, add 2)</span>
</div>
<div>
<span>2</span>
<span>1</span>
<span>5</span>
<span>1</span>
<span>3</span>
<span>2</span>
</div>
</div>
</div>
<!-- Answer and Optimization -->
<div>
<div>
<strong>Answer: 9</strong>
</div>
<div>
<strong>Optimization:</strong>
<span> Slide window by subtracting left, adding right O(1). Total: O(n) instead of O(n*k)</span>
</div>
</div>
</div>
<h3 id="pattern-3-prefix-sum">Pattern 3: Prefix Sum</h3>
<p>Prefix sums precompute cumulative totals, enabling O(1) range sum queries after O(n) preprocessing.</p>
<div>
<h4>Prefix Sum Visualization</h4>
<!-- Original Array -->
<div>
<div>
<span>Original:</span>
<div>
<span>3</span>
<span>1</span>
<span>2</span>
<span>5</span>
<span>4</span>
</div>
</div>
<div>
<span>Index:</span>
<div>
<span>0</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
</div>
</div>
<div>
<span>Prefix Sum:</span>
<div>
<span>3</span>
<span>4</span>
<span>6</span>
<span>11</span>
<span>15</span>
</div>
</div>
</div>
<!-- Range Sum Query -->
<div>
<div>Range Sum Query: sum(index 1 to 3)</div>
<div>
<div>= prefix[3] - prefix[0]</div>
<div>= <span>11</span> - <span>3</span> = <span>8</span></div>
<div>Verify: 1 + 2 + 5 = 8 &#10003;</div>
</div>
</div>
<!-- Zero-Sum Subarray Detection -->
<div>
<div>Zero-Sum Subarray Detection:</div>
<div>
<span>Array:</span>
<div>
<span>4</span>
<span>2</span>
<span>-3</span>
<span>1</span>
<span>6</span>
</div>
</div>
<div>
<span>Prefix Sum:</span>
<div>
<span>4</span>
<span>6</span>
<span>3</span>
<span>4</span>
<span>10</span>
</div>
</div>
<div>Same prefix sum (<span>4</span>) at index 0 and 3!</div>
<div>Subarray <span>[2, -3, 1]</span> between indices 1-3 sums to 0.</div>
</div>
<!-- Key Insight -->
<div>
<strong>Key Insight:</strong>
<span> If prefix[i] == prefix[j], then sum(i+1, j) = 0</span>
</div>
</div>
<h2 id="must-know-problems-with-solutions">Must-Know Problems with Solutions</h2>
<h3 id="problem-1-two-number-sum">Problem 1: Two Number Sum</h3>
<p><strong>Problem</strong>: Find two numbers in an array that add up to a target sum.</p>
<p><strong>Approaches</strong>:</p>
<ol>
<li><strong>Brute Force</strong>: Check all pairs - O(n^2) time, O(1) space</li>
<li><strong>Hash Set</strong>: Store complements - O(n) time, O(n) space</li>
<li><strong>Two Pointers</strong>: If sorted - O(n log n) time, O(1) space</li>
</ol>
<pre><code class="language-python">def two_number_sum(array, target_sum):
    &quot;&quot;&quot;
    Hash Set Approach
    Time: O(n) | Space: O(n)
    &quot;&quot;&quot;
    seen = set()
    for num in array:
        complement = target_sum - num
        if complement in seen:
            return [complement, num]
        seen.add(num)
    return []

def two_number_sum_sorted(array, target_sum):
    &quot;&quot;&quot;
    Two Pointers (requires sorted array)
    Time: O(n) | Space: O(1)
    &quot;&quot;&quot;
    array.sort()  # O(n log n) if not already sorted
    left, right = 0, len(array) - 1

    while left &lt; right:
        current_sum = array[left] + array[right]
        if current_sum == target_sum:
            return [array[left], array[right]]
        elif current_sum &lt; target_sum:
            left += 1
        else:
            right -= 1
    return []

# Example
array = [3, 5, -4, 8, 11, 1, -1, 6]
print(two_number_sum(array, 10))  # [-1, 11]
</code></pre>
<hr />
<h3 id="problem-2-three-number-sum">Problem 2: Three Number Sum</h3>
<p><strong>Problem</strong>: Find all unique triplets that sum to a target value.</p>
<p><strong>Approach</strong>: Sort array, fix first element, use two pointers for remaining two.</p>
<pre><code class="language-python">def three_number_sum(array, target_sum):
    &quot;&quot;&quot;
    Time: O(n^2) | Space: O(n) for output
    &quot;&quot;&quot;
    array.sort()
    triplets = []

    for i in range(len(array) - 2):
        # Skip duplicates for first element
        if i &gt; 0 and array[i] == array[i-1]:
            continue

        left = i + 1
        right = len(array) - 1

        while left &lt; right:
            current_sum = array[i] + array[left] + array[right]

            if current_sum == target_sum:
                triplets.append([array[i], array[left], array[right]])
                # Skip duplicates
                while left &lt; right and array[left] == array[left + 1]:
                    left += 1
                while left &lt; right and array[right] == array[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif current_sum &lt; target_sum:
                left += 1
            else:
                right -= 1

    return triplets

# Example
array = [12, 3, 1, 2, -6, 5, -8, 6]
print(three_number_sum(array, 0))  # [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]
</code></pre>
<hr />
<h3 id="problem-3-maximum-subarray-kadanes-algorithm">Problem 3: Maximum Subarray (Kadane's Algorithm)</h3>
<p><strong>Problem</strong>: Find the contiguous subarray with the largest sum.</p>
<p><strong>Approach</strong>: Track running sum, reset when it becomes negative.</p>
<div>
<h4>Kadane's Algorithm Visualization</h4>
<pre>
Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
<p>Index:   0   1   2   3   4   5   6   7   8<br />
Value:  -2   1  -3   4  -1   2   1  -5   4<br />
Current:-2   1  -2   4   3   5   6   1   5<br />
MaxSum: -2   1   1   4   4   5   6   6   6<br />
↑           ↑<br />
Reset to 4    Maximum found!</p>
<p>Decision at each step:</p>
<ul>
<li>Current = max(array[i], current + array[i])</li>
<li>&quot;Should I extend the previous subarray or start fresh?&quot;</li>
</ul>
<p>Answer: 6 (subarray [4, -1, 2, 1])<br />
</pre></p>
</div>
<pre><code class="language-python">def max_subarray_sum(array):
    &quot;&quot;&quot;
    Kadane's Algorithm
    Time: O(n) | Space: O(1)
    &quot;&quot;&quot;
    if not array:
        return 0

    max_sum = array[0]
    current_sum = array[0]

    for i in range(1, len(array)):
        # Either extend current subarray or start new one
        current_sum = max(array[i], current_sum + array[i])
        max_sum = max(max_sum, current_sum)

    return max_sum

def max_subarray_with_indices(array):
    &quot;&quot;&quot;Extended version that returns the subarray indices&quot;&quot;&quot;
    max_sum = array[0]
    current_sum = array[0]
    start = end = 0
    temp_start = 0

    for i in range(1, len(array)):
        if array[i] &gt; current_sum + array[i]:
            current_sum = array[i]
            temp_start = i
        else:
            current_sum += array[i]

        if current_sum &gt; max_sum:
            max_sum = current_sum
            start = temp_start
            end = i

    return max_sum, start, end

# Example
array = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(array))  # 6
</code></pre>
<hr />
<h3 id="problem-4-merge-overlapping-intervals">Problem 4: Merge Overlapping Intervals</h3>
<p><strong>Problem</strong>: Given a collection of intervals, merge all overlapping intervals.</p>
<div>
<h4>Interval Merging Visualization</h4>
<pre>
Input intervals (sorted by start):
[1,2]  [3,5]  [4,7]  [6,8]  [9,10]
<p>Timeline:<br />
1---2     No overlap with previous<br />
3-----5<br />
4--------7  Overlaps! Merge [3,5] + [4,7] = [3,7]<br />
6--------8  Overlaps! Merge [3,7] + [6,8] = [3,8]<br />
9---10  No overlap</p>
<p>Result: [1,2], [3,8], [9,10]</p>
<p>Merge Logic:</p>
<ul>
<li>Sort by start time</li>
<li>If current.start &lt;= last.end: extend last.end</li>
<li>Otherwise: add new interval<br />
</pre></li>
</ul>
</div>
<pre><code class="language-python">def merge_overlapping_intervals(intervals):
    &quot;&quot;&quot;
    Time: O(n log n) | Space: O(n)
    &quot;&quot;&quot;
    if not intervals:
        return []

    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for current in intervals[1:]:
        last = merged[-1]

        if current[0] &lt;= last[1]:  # Overlapping
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)

    return merged

# Example
intervals = [[1, 2], [3, 5], [4, 7], [6, 8], [9, 10]]
print(merge_overlapping_intervals(intervals))  # [[1, 2], [3, 8], [9, 10]]
</code></pre>
<hr />
<h3 id="problem-5-first-duplicate-value">Problem 5: First Duplicate Value</h3>
<p><strong>Problem</strong>: Find the first duplicate value in an array containing integers 1 to n.</p>
<p><strong>Approach</strong>: Use array values as indices, negate to mark visited.</p>
<pre><code class="language-python">def first_duplicate_value(array):
    &quot;&quot;&quot;
    Time: O(n) | Space: O(1)
    Uses the array itself as a hash map
    &quot;&quot;&quot;
    for value in array:
        abs_value = abs(value)
        index = abs_value - 1  # Convert 1-indexed to 0-indexed

        if array[index] &lt; 0:  # Already visited
            return abs_value

        array[index] *= -1  # Mark as visited

    return -1

# Example
array = [2, 1, 5, 2, 3, 3, 4]
print(first_duplicate_value(array))  # 2
</code></pre>
<hr />
<h3 id="problem-6-spiral-matrix-traversal">Problem 6: Spiral Matrix Traversal</h3>
<p><strong>Problem</strong>: Return all elements of a matrix in spiral order.</p>
<div>
<h4>Spiral Traversal Pattern</h4>
<div>
<p>Matrix with Spiral Direction:</p>
<div>
<div>
<div>
<span>START</span>
<span>&#8594;&#8594;&#8594;</span>
</div>
<div>
<div>1</div>
<div>2</div>
<div>3</div>
<div>4</div>
<div>12</div>
<div>13</div>
<div>14</div>
<div>5</div>
<div>11</div>
<div>16</div>
<div>15</div>
<div>6</div>
<div>10</div>
<div>9</div>
<div>8</div>
<div>7</div>
</div>
<div>
<span>&#8592;&#8592;&#8592;</span>
</div>
</div>
</div>
<div>
<div><span></span><span>Outer spiral</span></div>
<div><span></span><span>Left/Bottom</span></div>
<div><span></span><span>Inner spiral</span></div>
</div>
<p><strong>Order:</strong> 1 &#8594; 2 &#8594; 3 &#8594; 4 &#8594; 5 &#8594; 6 &#8594; 7 &#8594; 8 &#8594; 9 &#8594; 10 &#8594; 11 &#8594; 12 &#8594; 13 &#8594; 14 &#8594; 15 &#8594; 16</p>
<p><strong>Boundaries:</strong> top (row), bottom (row), left (col), right (col)</p>
<p><strong>After each direction:</strong> Right: top++ | Down: right-- | Left: bottom-- | Up: left++</p>
</div>
</div>
<pre><code class="language-python">def spiral_traverse(matrix):
    &quot;&quot;&quot;
    Time: O(n) | Space: O(n)
    &quot;&quot;&quot;
    if not matrix:
        return []

    result = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1

    while top &lt;= bottom and left &lt;= right:
        # Traverse right
        for col in range(left, right + 1):
            result.append(matrix[top][col])
        top += 1

        # Traverse down
        for row in range(top, bottom + 1):
            result.append(matrix[row][right])
        right -= 1

        # Traverse left (check if rows remain)
        if top &lt;= bottom:
            for col in range(right, left - 1, -1):
                result.append(matrix[bottom][col])
            bottom -= 1

        # Traverse up (check if columns remain)
        if left &lt;= right:
            for row in range(bottom, top - 1, -1):
                result.append(matrix[row][left])
            left += 1

    return result

# Example
matrix = [
    [1, 2, 3, 4],
    [12, 13, 14, 5],
    [11, 16, 15, 6],
    [10, 9, 8, 7]
]
print(spiral_traverse(matrix))  # [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
</code></pre>
<h2 id="complexity-analysis-summary">Complexity Analysis Summary</h2>
<div>
<h3>Time and Space Complexity Reference</h3>
<table>
<tr>
<th>Problem</th>
<th>Time</th>
<th>Space</th>
<th>Key Technique</th>
</tr>
<tr>
<td>Two Sum</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Hash Set</td>
</tr>
<tr>
<td>Three Sum</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>Sort + Two Pointers</td>
</tr>
<tr>
<td>Max Subarray</td>
<td>O(n)</td>
<td>O(1)</td>
<td>Kadane's Algorithm</td>
</tr>
<tr>
<td>Merge Intervals</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>Sort + Greedy Merge</td>
</tr>
<tr>
<td>First Duplicate</td>
<td>O(n)</td>
<td>O(1)</td>
<td>Index as Hash</td>
</tr>
<tr>
<td>Spiral Matrix</td>
<td>O(m*n)</td>
<td>O(m*n)</td>
<td>Boundary Tracking</td>
</tr>
</table>
</div>
<h2 id="common-mistakes">Common Mistakes</h2>
<div>
<h3>Pitfalls to Avoid</h3>
<div>
<ol>
<li><strong>Off-by-One Errors</strong>: Arrays are 0-indexed; <code>array[len(array)]</code> causes IndexError</li>
<li><strong>Empty Array Handling</strong>: Always check <code>if not array</code> before accessing elements</li>
<li><strong>Modifying While Iterating</strong>: Use indices or iterate over a copy</li>
<li><strong>Integer Overflow</strong>: Large sums may overflow in languages without arbitrary precision</li>
<li><strong>Forgetting to Sort</strong>: Two-pointer on unsorted arrays doesn't work correctly</li>
<li><strong>Negative Numbers</strong>: Affects min/max logic, especially in Kadane's algorithm</li>
<li><strong>Wrong Comparison Operators</strong>: <code>&lt;=</code> vs <code>&lt;</code> in boundary conditions changes behavior</li>
<li><strong>Not Handling Duplicates</strong>: Three Sum needs duplicate skipping for unique triplets</li>
</ol>
</div>
</div>
<h2 id="interview-tips">Interview Tips</h2>
<h3 id="problem-solving-framework">Problem-Solving Framework</h3>
<div>
<h4>The UMPIRE Method</h4>
<pre>
U - Understand the problem (ask clarifying questions)
M - Match to known patterns (two pointers? sliding window?)
P - Plan your approach (pseudocode)
I - Implement the solution
R - Review and test with examples
E - Evaluate complexity (time and space)
<p>Time Allocation (45-minute interview):<br />
0-5 min:  Understand problem, ask questions<br />
5-10 min: Discuss approaches, identify pattern<br />
10-35 min: Implement solution<br />
35-45 min: Test with examples, optimize if time<br />
</pre></p>
</div>
<h3 id="communication-phrases">Communication Phrases</h3>
<ul>
<li>&quot;Let me start with the brute force approach to establish a baseline...&quot;</li>
<li>&quot;I notice the array is sorted, so two pointers might optimize this...&quot;</li>
<li>&quot;To improve from O(n^2) to O(n), I can trade space for time with a hash map...&quot;</li>
<li>&quot;Let me trace through this example to verify my logic...&quot;</li>
<li>&quot;The edge cases I need to handle are: empty array, single element, all duplicates...&quot;</li>
</ul>
<h2 id="practice-problems">Practice Problems</h2>
<h3 id="easy">Easy</h3>
<ol>
<li>Two Number Sum</li>
<li>Validate Subsequence</li>
<li>Sorted Squared Array</li>
<li>Tournament Winner</li>
<li>Non-Constructible Change</li>
</ol>
<h3 id="medium">Medium</h3>
<ol start="6">
<li>Three Number Sum</li>
<li>Smallest Difference</li>
<li>Move Element To End</li>
<li>Monotonic Array</li>
<li>Spiral Traverse</li>
<li>Longest Peak</li>
<li>Array Of Products</li>
<li>First Duplicate Value</li>
<li>Merge Overlapping Intervals</li>
<li>Zero Sum Subarray</li>
</ol>
<h3 id="hard">Hard</h3>
<ol start="16">
<li>Four Number Sum</li>
<li>Subarray Sort</li>
<li>Largest Range</li>
<li>Min Rewards</li>
<li>Zigzag Traverse</li>
<li>Longest Subarray With Sum</li>
</ol>
<h3 id="very-hard">Very Hard</h3>
<ol start="22">
<li>Apartment Hunting</li>
<li>Calendar Matching</li>
<li>Waterfall Streams</li>
<li>Minimum Area Rectangle</li>
</ol>
<div>
<h3>Quick Reference Formulas</h3>
<pre>
Kadane's Algorithm:
  current = max(arr[i], current + arr[i])
<p>Prefix Sum:<br />
prefix[i] = prefix[i-1] + arr[i]</p>
<p>Range Sum Query:<br />
sum(i, j) = prefix[j] - prefix[i-1]</p>
<p>Two Pointers (sorted):<br />
if sum &lt; target: left++<br />
if sum &gt; target: right--</p>
<p>Sliding Window (fixed size k):<br />
window_sum = window_sum - arr[i-k] + arr[i]<br />
</pre></p>
</div>
