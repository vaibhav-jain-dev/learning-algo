<h1 id="design-amazon-e-commerce-platform">Design Amazon (E-Commerce Platform)</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>Design a large-scale e-commerce platform like Amazon that handles product catalog, search, shopping cart, checkout, payments, order management, and delivery tracking.</p>
<div>
<h3 id="core-requirements">Core Requirements</h3>
<ul>
<li><strong>Product Catalog</strong>: Millions of products with categories, attributes, images</li>
<li><strong>Search &amp; Discovery</strong>: Full-text search, filters, recommendations</li>
<li><strong>Shopping Cart</strong>: Persistent cart across sessions/devices</li>
<li><strong>Checkout &amp; Payments</strong>: Multiple payment methods, fraud detection</li>
<li><strong>Order Management</strong>: Order lifecycle, tracking, returns</li>
<li><strong>Inventory Management</strong>: Real-time stock across warehouses</li>
</ul>
</div>
<hr />
<h2 id="functional-requirements">Functional Requirements</h2>
<div>
<div>
<h4>Customer</h4>
<ul>
<li>Browse/search products</li>
<li>View product details</li>
<li>Add to cart/wishlist</li>
<li>Checkout & pay</li>
<li>Track orders</li>
<li>Write reviews</li>
</ul>
</div>
<div>
<h4>Seller</h4>
<ul>
<li>List products</li>
<li>Manage inventory</li>
<li>Process orders</li>
<li>Handle returns</li>
<li>View analytics</li>
<li>Manage pricing</li>
</ul>
</div>
<div>
<h4>System</h4>
<ul>
<li>Inventory sync</li>
<li>Payment processing</li>
<li>Fraud detection</li>
<li>Recommendation engine</li>
<li>Warehouse routing</li>
<li>Delivery optimization</li>
</ul>
</div>
</div>
<hr />
<h2 id="non-functional-requirements">Non-Functional Requirements</h2>
<div>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Target</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Availability</strong></td>
<td>99.99%</td>
<td>Critical for revenue</td>
</tr>
<tr>
<td><strong>Latency</strong></td>
<td>&lt; 200ms page load</td>
<td>User experience</td>
</tr>
<tr>
<td><strong>Throughput</strong></td>
<td>100K orders/minute (peak)</td>
<td>Black Friday/Prime Day</td>
</tr>
<tr>
<td><strong>Consistency</strong></td>
<td>Eventually consistent reads</td>
<td>Strong for payments</td>
</tr>
<tr>
<td><strong>Scale</strong></td>
<td>500M+ products, 300M+ users</td>
<td>Global operation</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h2 id="high-level-architecture">High-Level Architecture</h2>
<div>
<h3>AMAZON E-COMMERCE ARCHITECTURE</h3>
<div>
<pre><code>&lt;!-- CDN Layer --&gt;
</code></pre>
<div>
<strong>CloudFront (CDN)</strong>
</div>
<div>↓</div>
<pre><code>&lt;!-- Client Apps --&gt;
</code></pre>
<div>
<div>
<strong>Web App</strong><br><span>(React/Next)</span>
</div>
<div>
<strong>Mobile API</strong><br><span>Gateway</span>
</div>
<div>
<strong>Seller API</strong><br><span>Gateway</span>
</div>
</div>
<div>↓</div>
  <!-- API Gateway -->
<div>
<strong>API Gateway</strong><br><span>Rate Limiting, Auth, Routing</span>
</div>
<div>↓</div>
  <!-- Microservices Layer -->
<div>
<div>SERVICE MESH (Envoy/Istio)</div>
<div>
<div><strong>Product</strong><br><span>Service</span></div>
<div><strong>Search</strong><br><span>Service</span></div>
<div><strong>Cart</strong><br><span>Service</span></div>
<div><strong>Order</strong><br><span>Service</span></div>
<div><strong>Payment</strong><br><span>Service</span></div>
</div>
<div>
<div><strong>Inventory</strong><br><span>Service</span></div>
<div><strong>User</strong><br><span>Service</span></div>
<div><strong>Notification</strong><br><span>Service</span></div>
<div><strong>Shipping</strong><br><span>Service</span></div>
<div><strong>Review</strong><br><span>Service</span></div>
</div>
<div>MICROSERVICES LAYER</div>
</div>
<div>↓</div>
  <!-- Event Streaming Layer -->
<div>
<strong>MESSAGE BUS (Kafka)</strong>
<div>EVENT STREAMING LAYER</div>
</div>
<div>↓</div>
  <!-- Data Layer -->
<div>
<div>
<div><strong>DynamoDB</strong><br><span>(Catalog)</span></div>
<div><strong>Aurora</strong><br><span>(Orders)</span></div>
<div><strong>Elasticsearch</strong><br><span>(Search)</span></div>
<div><strong>Redis</strong><br><span>(Cache)</span></div>
<div><strong>S3</strong><br><span>(Images)</span></div>
</div>
<div>DATA LAYER</div>
</div>
</div>
</div>
<hr />
<h2 id="phase-1-starting-phase-low-budget">Phase 1: Starting Phase (Low Budget)</h2>
<div>
<div>
<h3 id="assumptions">Assumptions</h3>
<pre><code>                                      - **Users**: 1,000 - 50,000 monthly active users
                                      - **Products**: 10,000 - 100,000 SKUs
                                      - **Orders**: 100 - 1,000 orders/day
                                      - **Budget**: $500 - $3,000/month
                                      - **Team**: 3-8 developers
</code></pre>
<h3 id="monolithic-architecture">Monolithic Architecture</h3>
<div>
<div>
  <!-- Monolith Container -->
<div>
<h4>E-COMMERCE MONOLITH</h4>
  <!-- Presentation Layer -->
<div>
<div>PRESENTATION LAYER</div>
<div>
<div><strong>Web Pages</strong><br><span>(Templates)</span></div>
<div><strong>REST API</strong><br><span>(JSON)</span></div>
<div><strong>Admin Panel</strong><br><span>(Dashboard)</span></div>
</div>
</div>
  <!-- Business Logic Layer -->
<div>
<div>BUSINESS LOGIC LAYER</div>
<div>
<div><strong>Products</strong></div>
<div><strong>Cart</strong></div>
<div><strong>Orders</strong></div>
</div>
<div>
<div><strong>Users</strong></div>
<div><strong>Payments</strong></div>
<div><strong>Inventory</strong></div>
</div>
<div>
<div><strong>Search</strong></div>
<div><strong>Reviews</strong></div>
</div>
</div>
  <!-- Data Access Layer -->
<div>
<strong>DATA ACCESS LAYER</strong><br>
<span>(ORM: Django ORM / SQLAlchemy / TypeORM)</span>
</div>
</div>
<div>↓</div>
  <!-- Databases -->
<div>
<div>
<strong>PostgreSQL</strong>
</div>
<div>
<strong>Redis</strong><br><span>(Cache/Sessions)</span>
</div>
<div>
<strong>S3</strong><br><span>(Images)</span>
</div>
</div>
</div>
</div>
<h4 id="tech-stack">Tech Stack</h4>
<pre><code>                                                  - **Backend**: Django/Rails/Laravel or Node.js
                                                  - **Database**: PostgreSQL (all data)
                                                  - **Cache**: Redis (sessions, cart)
                                                  - **Storage**: S3 (product images)
                                                  - **Search**: PostgreSQL full-text search
                                                  - **Payments**: Stripe/Razorpay integration
                                                  - **Hosting**: Single EC2 or Heroku
</code></pre>
<h4 id="abstract-code-structure">Abstract Code Structure</h4>
<pre><code>                                                  ```python
                                                  # Django-style monolith structure
                                                  # apps/products/models.py
                                                  class Product(models.Model):
                                                  name = models.CharField(max_length=255)
                                                  description = models.TextField()
                                                  price = models.DecimalField(max_digits=10, decimal_places=2)
                                                  category = models.ForeignKey(Category, on_delete=models.CASCADE)
                                                  inventory_count = models.IntegerField(default=0)

                                                  # apps/cart/services.py
                                                  class CartService:
                                                  def add_item(self, user_id, product_id, quantity):
                                                  cart = self.get_or_create_cart(user_id)
                                                  product = Product.objects.get(id=product_id)

                                                  if product.inventory_count &lt; quantity:
                                                  raise InsufficientInventoryError()

                                                  cart_item, created = CartItem.objects.get_or_create(
                                                  cart=cart, product=product
                                                  )
                                                  cart_item.quantity += quantity
                                                  cart_item.save()

                                                  # Invalidate cache
                                                  cache.delete(f&quot;cart:{user_id}&quot;)
                                                  return cart

                                                  # apps/orders/services.py
                                                  class OrderService:
                                                  def create_order(self, user_id, payment_method):
                                                  with transaction.atomic():
                                                  cart = CartService().get_cart(user_id)

                                                  # Validate inventory
                                                  for item in cart.items.all():
                                                  if item.product.inventory_count &lt; item.quantity:
                                                  raise InsufficientInventoryError()

                                                  # Create order
                                                  order = Order.objects.create(
                                                  user_id=user_id,
                                                  total=cart.total,
                                                  status='pending'
                                                  )

                                                  # Process payment
                                                  payment = PaymentService().charge(
                                                  user_id, cart.total, payment_method
                                                  )

                                                  # Update inventory
                                                  for item in cart.items.all():
                                                  item.product.inventory_count -= item.quantity
                                                  item.product.save()

                                                  OrderItem.objects.create(
                                                  order=order,
                                                  product=item.product,
                                                  quantity=item.quantity,
                                                  price=item.product.price
                                                  )

                                                  # Clear cart
                                                  cart.items.all().delete()

                                                  # Send confirmation (sync in Phase 1)
                                                  EmailService().send_order_confirmation(order)

                                                  return order
                                                  ```
</code></pre>
<h3 id="simple-microservices-phase-1">Simple Microservices (Phase 1)</h3>
<div>
<p><strong>Not Recommended:</strong> At this scale, stick with monolith. If team insists:</p>
<pre><code>                                                    ```
                                                    ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
                                                    │  Web/Mobile  │────▶│  API Gateway │────▶│  Backend     │
                                                    │   Clients    │     │  (Nginx)     │     │  (Monolith)  │
                                                    └──────────────┘     └──────────────┘     └──────┬───────┘
                                                    │
                                                    ┌─────────────────────┼─────────────────────┐
                                                    ▼                     ▼                     ▼
                                                    ┌───────────┐         ┌───────────┐         ┌───────────┐
                                                    │ PostgreSQL│         │   Redis   │         │    S3     │
                                                    └───────────┘         └───────────┘         └───────────┘

                                                    Only split if you have VERY different scaling needs (e.g., image processing)
                                                    ```
</code></pre>
</div>
</div>
</div>
<hr />
<h2 id="phase-2-medium-user-phase">Phase 2: Medium User Phase</h2>
<div>
<div>
<h3 id="assumptions-1">Assumptions</h3>
<pre><code>                                                  - **Users**: 500,000 - 5M monthly active users
                                                  - **Products**: 1M - 10M SKUs
                                                  - **Orders**: 10,000 - 100,000 orders/day
                                                  - **Budget**: $20,000 - $100,000/month
                                                  - **Team**: 20-50 developers
</code></pre>
<h3 id="modular-monolith-architecture">Modular Monolith Architecture</h3>
<div>
<pre><code>                                                    ```
                                                    ┌─────────────────────┐
                                                    │    Load Balancer    │
                                                    │    (AWS ALB)        │
                                                    └──────────┬──────────┘
                                                    │
                                                    ┌────────────────────┼────────────────────┐
                                                    ▼                    ▼                    ▼
                                                    ┌────────────┐       ┌────────────┐       ┌────────────┐
                                                    │ App Node 1 │       │ App Node 2 │       │ App Node N │
                                                    └─────┬──────┘       └─────┬──────┘       └─────┬──────┘
                                                    │                    │                    │
                                                    └────────────────────┼────────────────────┘
                                                    │
                                                    ┌─────────────────────────────┼─────────────────────────────┐
                                                    │                             │                             │
                                                    ▼                             ▼                             ▼
                                                    ┌─────────────┐           ┌─────────────┐           ┌─────────────┐
                                                    │  Aurora     │           │   Redis     │           │Elasticsearch│
                                                    │  Primary    │           │   Cluster   │           │   Cluster   │
                                                    │  + Replicas │           │             │           │             │
                                                    └─────────────┘           └─────────────┘           └─────────────┘
                                                    │
                                                    ▼
                                                    ┌─────────────┐           ┌─────────────┐           ┌─────────────┐
                                                    │  SQS/       │           │   S3        │           │  CloudFront │
                                                    │  RabbitMQ   │           │   + Images  │           │    (CDN)    │
                                                    └─────────────┘           └─────────────┘           └─────────────┘
                                                    ```
</code></pre>
</div>
<h3 id="microservices-architecture">Microservices Architecture</h3>
<div>
<h4>DOMAIN-DRIVEN MICROSERVICES</h4>
<pre><code>                                                    ```
                                                    ┌────────────────────┐
                                                    │    API Gateway     │
                                                    │   (Kong/APIGW)     │
                                                    └─────────┬──────────┘
                                                    │
                                                    ┌──────────────────────────────┼──────────────────────────────┐
                                                    │                              │                              │
                                                    ▼                              ▼                              ▼
                                                    ┌───────────────┐            ┌───────────────┐            ┌───────────────┐
                                                    │   PRODUCT     │            │    SEARCH     │            │     USER      │
                                                    │   DOMAIN      │            │    DOMAIN     │            │    DOMAIN     │
                                                    │               │            │               │            │               │
                                                    │ ┌───────────┐ │            │ ┌───────────┐ │            │ ┌───────────┐ │
                                                    │ │ Catalog   │ │───────────▶│ │  Search   │ │            │ │  Auth     │ │
                                                    │ │ Service   │ │  (events)  │ │  Service  │ │            │ │  Service  │ │
                                                    │ └───────────┘ │            │ └───────────┘ │            │ └───────────┘ │
                                                    │ ┌───────────┐ │            │               │            │ ┌───────────┐ │
                                                    │ │ Inventory │ │            │ Elasticsearch │            │ │  Profile  │ │
                                                    │ │ Service   │ │            │               │            │ │  Service  │ │
                                                    │ └───────────┘ │            └───────────────┘            │ └───────────┘ │
                                                    │               │                                          │               │
                                                    │  DynamoDB     │                                          │  PostgreSQL   │
                                                    └───────────────┘                                          └───────────────┘
                                                    │                              │                              │
                                                    └──────────────────────────────┼──────────────────────────────┘
                                                    │
                                                    ┌───────▼───────┐
                                                    │    Kafka      │
                                                    │  Event Bus    │
                                                    └───────┬───────┘
                                                    │
                                                    ┌──────────────────────────────┼──────────────────────────────┐
                                                    │                              │                              │
                                                    ▼                              ▼                              ▼
                                                    ┌───────────────┐            ┌───────────────┐            ┌───────────────┐
                                                    │    CART       │            │    ORDER      │            │   PAYMENT     │
                                                    │   DOMAIN      │            │    DOMAIN     │            │   DOMAIN      │
                                                    │               │            │               │            │               │
                                                    │ ┌───────────┐ │            │ ┌───────────┐ │            │ ┌───────────┐ │
                                                    │ │   Cart    │ │───────────▶│ │  Order    │ │───────────▶│ │  Payment  │ │
                                                    │ │  Service  │ │  checkout  │ │  Service  │ │  payment   │ │  Service  │ │
                                                    │ └───────────┘ │            │ └───────────┘ │            │ └───────────┘ │
                                                    │               │            │ ┌───────────┐ │            │               │
                                                    │    Redis      │            │ │ Fulfillment│ │            │   Stripe/    │
                                                    │               │            │ │  Service  │ │            │   Razorpay   │
                                                    └───────────────┘            │ └───────────┘ │            └───────────────┘
                                                    │               │
                                                    │   Aurora      │
                                                    └───────────────┘
                                                    ```
</code></pre>
</div>
<h4 id="service-communication-patterns">Service Communication Patterns</h4>
<div>
<div>
<h5>Synchronous (REST/gRPC)</h5>
<ul>
<li>Cart → Inventory (check stock)</li>
<li>Order → Payment (process)</li>
<li>User → Auth (validate token)</li>
</ul>
</div>
<div>
<h5>Asynchronous (Kafka)</h5>
<ul>
<li>Order placed → Inventory update</li>
<li>Order placed → Send emails</li>
<li>Product updated → Reindex search</li>
</ul>
</div>
</div>
</div>
</div>
<hr />
<h2 id="phase-3-high-user-base-phase">Phase 3: High User Base Phase</h2>
<div>
<div>
<h3 id="assumptions-2">Assumptions</h3>
<pre><code>                                                  - **Users**: 300M+ monthly active users
                                                  - **Products**: 500M+ SKUs
                                                  - **Orders**: 10M+ orders/day (100K+/min peak)
                                                  - **Budget**: $5M+/month
                                                  - **Team**: 1000+ engineers
</code></pre>
<h3 id="global-architecture">Global Architecture</h3>
<div>
<pre><code>                                                    ```
                                                    GLOBAL INFRASTRUCTURE
                                                    ┌────────────────────────────────────────────────────────────────────┐
                                                    │                                                                    │
                                                    │                         ┌──────────────┐                           │
                                                    │                         │   Route 53   │                           │
                                                    │                         │ (GeoDNS LB)  │                           │
                                                    │                         └──────┬───────┘                           │
                                                    │                                │                                   │
                                                    │         ┌──────────────────────┼──────────────────────┐           │
                                                    │         ▼                      ▼                      ▼           │
                                                    │  ┌────────────┐         ┌────────────┐         ┌────────────┐    │
                                                    │  │ CloudFront │         │ CloudFront │         │ CloudFront │    │
                                                    │  │   US Edge  │         │   EU Edge  │         │  APAC Edge │    │
                                                    │  └─────┬──────┘         └─────┬──────┘         └─────┬──────┘    │
                                                    │        │                      │                      │            │
                                                    │        ▼                      ▼                      ▼            │
                                                    │  ┌──────────────────────────────────────────────────────────┐    │
                                                    │  │                    REGIONAL DEPLOYMENTS                   │    │
                                                    │  │                                                           │    │
                                                    │  │   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐    │    │
                                                    │  │   │  US-EAST    │   │  EU-WEST    │   │  AP-SOUTH   │    │    │
                                                    │  │   │  Region     │   │  Region     │   │  Region     │    │    │
                                                    │  │   │             │   │             │   │             │    │    │
                                                    │  │   │ ┌─────────┐ │   │ ┌─────────┐ │   │ ┌─────────┐ │    │    │
                                                    │  │   │ │   EKS   │ │   │ │   EKS   │ │   │ │   EKS   │ │    │    │
                                                    │  │   │ │ Cluster │ │   │ │ Cluster │ │   │ │ Cluster │ │    │    │
                                                    │  │   │ └─────────┘ │   │ └─────────┘ │   │ └─────────┘ │    │    │
                                                    │  │   │             │   │             │   │             │    │    │
                                                    │  │   │ ┌─────────┐ │   │ ┌─────────┐ │   │ ┌─────────┐ │    │    │
                                                    │  │   │ │ Aurora  │ │   │ │ Aurora  │ │   │ │ Aurora  │ │    │    │
                                                    │  │   │ │ Global  │◀┼───┼▶│ Replica │◀┼───┼▶│ Replica │ │    │    │
                                                    │  │   │ └─────────┘ │   │ └─────────┘ │   │ └─────────┘ │    │    │
                                                    │  │   │             │   │             │   │             │    │    │
                                                    │  │   └─────────────┘   └─────────────┘   └─────────────┘    │    │
                                                    │  │                                                           │    │
                                                    │  └──────────────────────────────────────────────────────────┘    │
                                                    │                                                                    │
                                                    └────────────────────────────────────────────────────────────────────┘
                                                    ```
</code></pre>
</div>
<h3 id="data-partitioning-strategy">Data Partitioning Strategy</h3>
<div>
<h4>SHARDING STRATEGIES</h4>
<div>
<div>
<h5>Products (DynamoDB)</h5>
<pre><code>                                                        ```
                                                        Partition Key: product_id
                                                        Sort Key: version

                                                        Sharding: Automatic (DynamoDB)

                                                        GSI:
                                                        - category_id + price
                                                        - seller_id + created_at

                                                        Benefits:
                                                        - Single-digit ms latency
                                                        - Auto-scaling
                                                        - No shard management
                                                        ```
</code></pre>
</div>
<div>
<h5>Orders (Aurora)</h5>
<pre><code>                                                        ```
                                                        Shard Key: user_id % 256

                                                        Sharding Strategy:
                                                        - Hash-based sharding
                                                        - 256 logical shards
                                                        - 16 physical clusters

                                                        Cross-shard queries:
                                                        - Scatter-gather pattern
                                                        - Async aggregation
                                                        ```
</code></pre>
</div>
</div>
</div>
<h3 id="checkout-flow-high-scale">Checkout Flow (High Scale)</h3>
<div>
<h4>SAGA PATTERN FOR DISTRIBUTED CHECKOUT</h4>
<pre><code>                                                    ```
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │                     CHECKOUT SAGA ORCHESTRATOR                   │
                                                    └──────────────────────────────┬──────────────────────────────────┘
                                                    │
                                                    Step 1                         ▼
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │  RESERVE INVENTORY                                               │
                                                    │  ┌──────────────┐    success    ┌───────────────────────────┐   │
                                                    │  │ Inventory    │──────────────▶│ Inventory Reserved        │   │
                                                    │  │ Service      │               │ TTL: 15 minutes           │   │
                                                    │  └──────────────┘    failure    └───────────────────────────┘   │
                                                    │         │                                                        │
                                                    │         └───────────────────────▶ SAGA FAILED (no compensation) │
                                                    └─────────────────────────────────────────────────────────────────┘
                                                    │
                                                    Step 2                         ▼
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │  PROCESS PAYMENT                                                 │
                                                    │  ┌──────────────┐    success    ┌───────────────────────────┐   │
                                                    │  │ Payment      │──────────────▶│ Payment Authorized        │   │
                                                    │  │ Service      │               │                           │   │
                                                    │  └──────────────┘    failure    └───────────────────────────┘   │
                                                    │         │                                                        │
                                                    │         └───────────────────────▶ COMPENSATE: Release Inventory │
                                                    └─────────────────────────────────────────────────────────────────┘
                                                    │
                                                    Step 3                         ▼
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │  CREATE ORDER                                                    │
                                                    │  ┌──────────────┐    success    ┌───────────────────────────┐   │
                                                    │  │ Order        │──────────────▶│ Order Created             │   │
                                                    │  │ Service      │               │                           │   │
                                                    │  └──────────────┘    failure    └───────────────────────────┘   │
                                                    │         │                                                        │
                                                    │         └───────▶ COMPENSATE: Refund Payment, Release Inventory │
                                                    └─────────────────────────────────────────────────────────────────┘
                                                    │
                                                    Step 4                         ▼
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │  CONFIRM INVENTORY DEDUCTION                                     │
                                                    │  ┌──────────────┐    success    ┌───────────────────────────┐   │
                                                    │  │ Inventory    │──────────────▶│ ORDER COMPLETE            │   │
                                                    │  │ Service      │               │ Send Confirmation         │   │
                                                    │  └──────────────┘               └───────────────────────────┘   │
                                                    └─────────────────────────────────────────────────────────────────┘
                                                    ```
</code></pre>
</div>
<h3 id="recommendation-engine">Recommendation Engine</h3>
<div>
<pre><code>                                                    ```
                                                    RECOMMENDATION PIPELINE

                                                    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
                                                    │ User        │     │ Product     │     │ Order       │
                                                    │ Events      │     │ Catalog     │     │ History     │
                                                    └──────┬──────┘     └──────┬──────┘     └──────┬──────┘
                                                    │                   │                   │
                                                    └───────────────────┼───────────────────┘
                                                    ▼
                                                    ┌─────────────────────┐
                                                    │   Kinesis Firehose  │
                                                    │   (Data Ingestion)  │
                                                    └──────────┬──────────┘
                                                    │
                                                    ▼
                                                    ┌─────────────────────┐
                                                    │        EMR          │
                                                    │  (Spark Processing) │
                                                    └──────────┬──────────┘
                                                    │
                                                    ┌────────────────┼────────────────┐
                                                    ▼                ▼                ▼
                                                    ┌───────────┐    ┌───────────┐    ┌───────────┐
                                                    │Collaborative│  │ Content   │    │ Real-time │
                                                    │ Filtering  │   │  Based    │    │ Trending  │
                                                    └───────────┘    └───────────┘    └───────────┘
                                                    │                │                │
                                                    └────────────────┼────────────────┘
                                                    ▼
                                                    ┌─────────────────────┐
                                                    │   SageMaker         │
                                                    │   (ML Models)       │
                                                    └──────────┬──────────┘
                                                    │
                                                    ▼
                                                    ┌─────────────────────┐
                                                    │   DynamoDB          │
                                                    │   (Recommendations) │
                                                    └─────────────────────┘
                                                    ```
</code></pre>
</div>
</div>
</div>
<hr />
<h2 id="aws-technologies--alternatives">AWS Technologies &amp; Alternatives</h2>
<div>
<table>
<thead>
<tr>
<th>Component</th>
<th>AWS Service</th>
<th>Alternative</th>
<th>Trade-offs</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Product Catalog</strong></td>
<td>DynamoDB</td>
<td>MongoDB Atlas</td>
<td>DynamoDB: Better scaling, MongoDB: Flexible queries</td>
</tr>
<tr>
<td><strong>Orders DB</strong></td>
<td>Aurora PostgreSQL</td>
<td>CockroachDB</td>
<td>Aurora: AWS integration, Cockroach: Multi-region</td>
</tr>
<tr>
<td><strong>Search</strong></td>
<td>OpenSearch</td>
<td>Algolia</td>
<td>OpenSearch: Control, Algolia: Managed + faster</td>
</tr>
<tr>
<td><strong>Cache</strong></td>
<td>ElastiCache Redis</td>
<td>Redis Enterprise</td>
<td>ElastiCache: Managed, Enterprise: Better clustering</td>
</tr>
<tr>
<td><strong>CDN</strong></td>
<td>CloudFront</td>
<td>Fastly</td>
<td>CloudFront: AWS integration, Fastly: Edge compute</td>
</tr>
<tr>
<td><strong>Message Queue</strong></td>
<td>MSK (Kafka)</td>
<td>Confluent Cloud</td>
<td>MSK: Cost, Confluent: Features + support</td>
</tr>
<tr>
<td><strong>Container</strong></td>
<td>EKS</td>
<td>GKE</td>
<td>EKS: AWS integration, GKE: Better K8s experience</td>
</tr>
<tr>
<td><strong>Recommendations</strong></td>
<td>SageMaker</td>
<td>Vertex AI</td>
<td>SageMaker: AWS ecosystem, Vertex: AutoML</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h2 id="distributed-systems-considerations">Distributed Systems Considerations</h2>
<div>
<h3 id="1-inventory-consistency">1. Inventory Consistency</h3>
<div>
<div>
<h5>Problem: Overselling</h5>
<p>Multiple users buying last item simultaneously</p>
</div>
<div>
<h5>Solution: Optimistic Locking</h5>
<pre><code>                                                    ```python
                                                    # DynamoDB conditional update
                                                    dynamodb.update_item(
                                                    TableName='inventory',
                                                    Key={'product_id': id},
                                                    UpdateExpression='SET quantity = quantity - :qty',
                                                    ConditionExpression='quantity &gt;= :qty',
                                                    ExpressionAttributeValues={':qty': order_qty}
                                                    )
                                                    ```
</code></pre>
</div>
</div>
<h3 id="2-cart-consistency-across-devices">2. Cart Consistency Across Devices</h3>
<pre><code>                                                ```
                                                Device A                    Device B
                                                │                           │
                                                │  Add Item X               │
                                                │  ───────▶ Redis           │
                                                │           │               │
                                                │           │  Pub/Sub      │
                                                │           │  ─────────────▶ Update Cart View
                                                │           │               │
                                                │           │               │  Add Item Y
                                                │  Update   │  ◀────────────│
                                                │  Cart     │               │
                                                │           │               │

                                                Strategy: Redis + WebSocket for real-time sync
                                                ```
</code></pre>
<h3 id="3-search-index-consistency">3. Search Index Consistency</h3>
<div>
<pre><code>                                                  ```
                                                  Product Update Flow:

                                                  1. Update DynamoDB (source of truth)
                                                  2. DynamoDB Stream triggers Lambda
                                                  3. Lambda publishes to Kafka
                                                  4. Search Indexer consumes from Kafka
                                                  5. Update OpenSearch index

                                                  Eventual consistency: ~1-5 seconds lag
                                                  ```
</code></pre>
</div>
<h3 id="4-rate-limiting-strategy">4. Rate Limiting Strategy</h3>
<pre><code>                                                ```
                                                ┌─────────────────────────────────────────────────────┐
                                                │                 RATE LIMITING TIERS                  │
                                                ├─────────────────────────────────────────────────────┤
                                                │ Anonymous Users:     100 requests/minute             │
                                                │ Logged-in Users:     1000 requests/minute           │
                                                │ Prime Members:       5000 requests/minute           │
                                                │ Seller API:          10000 requests/minute          │
                                                │                                                      │
                                                │ Implementation: Token Bucket with Redis              │
                                                │ Scope: Per user + per IP + per endpoint             │
                                                └─────────────────────────────────────────────────────┘
                                                ```
</code></pre>
</div>
<hr />
<h2 id="interview-deep-dive-questions">Interview Deep Dive Questions</h2>
<div>
<p>Interviewers use these probing questions to test your depth of understanding. Here are the questions, what they're really probing, and how to answer effectively.</p>
</div>
<div>
<h3 id="1-why-dynamodb-for-cart-instead-of-redis">1. &quot;Why DynamoDB for cart instead of Redis?&quot;</h3>
<div>
<div>
<h5>What They're Probing</h5>
<ul>
<li>Do you understand persistence vs. cache trade-offs?</li>
<li>Can you reason about data durability requirements?</li>
<li>Do you know when "fast" isn't the only consideration?</li>
</ul>
</div>
<div>
<h5>Strong Answer</h5>
<p>"At Amazon scale, carts represent potential revenue. Redis is faster but volatile - a Redis cluster restart loses carts. DynamoDB gives us durability with single-digit ms latency. We use Redis as a read-through cache in front of DynamoDB for hot carts. For checkout, we need the guarantee that the cart survives infrastructure failures."</p>
</div>
</div>
<div>
<h5>When Simpler Works</h5>
<p>"At < 10K DAU, Redis with AOF persistence is fine. Cart loss is annoying but not catastrophic. You can even use PostgreSQL with a `carts` table - it handles 1000s of concurrent carts easily."</p>
</div>
<hr />
<h3 id="2-how-do-you-prevent-overselling-during-flash-sales">2. &quot;How do you prevent overselling during flash sales?&quot;</h3>
<div>
<div>
<h5>What They're Probing</h5>
<ul>
<li>Understanding of race conditions in distributed systems</li>
<li>Knowledge of pessimistic vs. optimistic locking</li>
<li>Ability to design for high-contention scenarios</li>
</ul>
</div>
<div>
<h5>Strong Answer</h5>
<p>"Three-layer approach: (1) Pre-sale queue with virtual waiting room to control concurrent requests, (2) Redis atomic decrement with Lua script for inventory - `DECR` returns new value atomically, reject if < 0, (3) DynamoDB conditional write as final check with `ConditionExpression: quantity>= :requested`. For ultra-hot items, we pre-shard inventory across multiple keys and aggregate."</p>
</div>
</div>
<div>
<h5>When Simpler Works</h5>
<p>"At 1000 orders/day, PostgreSQL `SELECT FOR UPDATE` with a short transaction is sufficient. You won't hit lock contention. Even simpler: just let occasional oversells happen and handle via customer service - it's cheaper than engineering complexity."</p>
</div>
<hr />
<h3 id="3-why-not-just-use-postgresql-for-everything">3. &quot;Why not just use PostgreSQL for everything?&quot;</h3>
<div>
<div>
<h5>What They're Probing</h5>
<ul>
<li>Do you understand polyglot persistence?</li>
<li>Can you articulate when relational breaks down?</li>
<li>Do you have experience with real scaling challenges?</li>
</ul>
</div>
<div>
<h5>Strong Answer</h5>
<p>"For orders, PostgreSQL is perfect - ACID transactions, complex joins for reporting. But product catalog has different access patterns: 500M products, read-heavy (1000:1 read/write), needs single-digit ms latency, flexible schemas per category. DynamoDB handles this natively. PostgreSQL at this scale requires manual sharding, which is operationally complex. Search needs inverted indices - Elasticsearch does this 100x better than PostgreSQL's full-text search at scale."</p>
</div>
</div>
<div>
<h5>When Simpler Works</h5>
<p>"Under 1M products and 100K users, PostgreSQL handles everything beautifully. Use JSONB columns for flexible product attributes, `tsvector` for search, and you're set for years. I've seen $10M/year e-commerce sites run on a single well-tuned PostgreSQL instance."</p>
</div>
<hr />
<h3 id="4-how-would-you-handle-prime-day-traffic-100x-spike">4. &quot;How would you handle Prime Day traffic (100x spike)?&quot;</h3>
<div>
<div>
<h5>What They're Probing</h5>
<ul>
<li>Understanding of capacity planning and load testing</li>
<li>Knowledge of graceful degradation patterns</li>
<li>Experience with auto-scaling and caching strategies</li>
</ul>
</div>
<div>
<h5>Strong Answer</h5>
<p>"Multi-pronged: (1) Pre-warm everything - EC2, Lambda, DynamoDB provisioned capacity 24h before, (2) Aggressive CDN caching - product pages become static HTML for 60s, (3) Queue non-critical work - email confirmations, analytics go to SQS, (4) Circuit breakers on recommendations - if ML service is slow, show trending instead, (5) Virtual waiting rooms for checkout to control database load. We practice with 'GameDay' load tests monthly."</p>
</div>
</div>
<div>
<h5>When Simpler Works</h5>
<p>"For a 10x spike (typical holiday rush for SMB e-commerce), just over-provision 3x during sale period. A $200/month server becoming $600/month for a week is nothing compared to engineering complexity. Use Cloudflare in front for DDoS and caching."</p>
</div>
<hr />
<h3 id="5-why-kafka-for-order-events-instead-of-sqs">5. &quot;Why Kafka for order events instead of SQS?&quot;</h3>
<div>
<div>
<h5>What They're Probing</h5>
<ul>
<li>Understanding of event streaming vs. message queues</li>
<li>Knowledge of event sourcing and replay capabilities</li>
<li>Ability to choose appropriate tools for requirements</li>
</ul>
</div>
<div>
<h5>Strong Answer</h5>
<p>"Kafka provides event log semantics - we can replay order events to rebuild search indices, recalculate analytics, or debug issues. Multiple consumers read the same events (search indexer, email service, analytics, fraud detection) without coordination. SQS deletes after consumption. For checkout specifically, we actually use SQS - it's simpler, and we don't need replay. Kafka is for the event backbone where history matters."</p>
</div>
</div>
<div>
<h5>When Simpler Works</h5>
<p>"You don't need Kafka for checkout - a simple SQS queue or even synchronous processing works fine under 10K orders/day. Kafka adds operational complexity (ZooKeeper, partition management). Start with SQS/RabbitMQ and migrate to Kafka only when you need event replay or high fan-out."</p>
</div>
</div>
<hr />
<h2 id="why-this-technology">Why This Technology?</h2>
<div>
<p>Understanding <strong>why</strong> specific technologies are chosen demonstrates architectural maturity. Interviewers want to see you can reason about trade-offs, not just list technologies.</p>
</div>
<h3 id="decision-matrix">Decision Matrix</h3>
<div>
<table>
<thead>
<tr>
<th>Component</th>
<th>Technology</th>
<th>Why This?</th>
<th>Alternative</th>
<th>When Alternative Wins</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Product Catalog</strong></td>
<td>DynamoDB</td>
<td>Single-digit ms at any scale, flexible schema per category, auto-sharding</td>
<td>MongoDB</td>
<td>Need complex queries, aggregations, or $lookup joins</td>
</tr>
<tr>
<td><strong>Orders</strong></td>
<td>Aurora PostgreSQL</td>
<td>ACID for money, complex reporting queries, familiar SQL</td>
<td>CockroachDB</td>
<td>Multi-region active-active writes required</td>
</tr>
<tr>
<td><strong>Cart</strong></td>
<td>DynamoDB + Redis</td>
<td>Durability (DynamoDB) + Speed (Redis cache)</td>
<td>Redis only</td>
<td>Cart loss acceptable, &lt; 50K users</td>
</tr>
<tr>
<td><strong>Search</strong></td>
<td>OpenSearch</td>
<td>Full-text, facets, relevance tuning, integrates with product catalog</td>
<td>Algolia</td>
<td>Need instant search, smaller catalog &lt; 1M</td>
</tr>
<tr>
<td><strong>CDN</strong></td>
<td>CloudFront</td>
<td>AWS integration, Lambda@Edge, cost-effective</td>
<td>Fastly</td>
<td>Need edge compute, real-time purging</td>
</tr>
<tr>
<td><strong>Events</strong></td>
<td>Kafka (MSK)</td>
<td>Event replay, multiple consumers, high throughput</td>
<td>SQS</td>
<td>Simple queue needed, no replay requirement</td>
</tr>
<tr>
<td><strong>Cache</strong></td>
<td>ElastiCache Redis</td>
<td>Sub-ms latency, rich data structures, pub/sub</td>
<td>Memcached</td>
<td>Simple key-value only, multi-threaded needed</td>
</tr>
</tbody>
</table>
</div>
<h3 id="deep-dive-critical-decisions">Deep Dive: Critical Decisions</h3>
<div>
<div>
<h4>DynamoDB for Product Catalog</h4>
<div>
<h5>Pros</h5>
<ul>
<li>Consistent single-digit ms latency at any scale</li>
<li>No capacity planning - auto-scales</li>
<li>Flexible attributes per category (JSONB-like)</li>
<li>Global tables for multi-region</li>
</ul>
</div>
<div>
<h5>Cons</h5>
<ul>
<li>No joins - denormalization required</li>
<li>GSI limits (20 per table)</li>
<li>Query patterns must be known upfront</li>
<li>Cost at very high throughput</li>
</ul>
</div>
<div>
<h5>Mitigation</h5>
<p>Use OpenSearch for complex queries. Denormalize seller info into product records. Cache GSI results in Redis.</p>
</div>
</div>
<div>
<h4>Aurora for Orders</h4>
<div>
<h5>Pros</h5>
<ul>
<li>ACID transactions for payment integrity</li>
<li>Complex queries for analytics/reporting</li>
<li>15 read replicas for scaling reads</li>
<li>Point-in-time recovery</li>
</ul>
</div>
<div>
<h5>Cons</h5>
<ul>
<li>Write scaling limited (vertical primarily)</li>
<li>Cross-region writes need careful handling</li>
<li>Cost higher than RDS PostgreSQL</li>
<li>Sharding requires application logic</li>
</ul>
</div>
<div>
<h5>Mitigation</h5>
<p>Shard by user_id at scale. Use read replicas for analytics. Consider Aurora Serverless v2 for variable load.</p>
</div>
</div>
</div>
<div>
<div>
<h4>Kafka for Event Streaming</h4>
<div>
<h5>Pros</h5>
<ul>
<li>Event replay for rebuilding state</li>
<li>Multiple consumers without duplication</li>
<li>High throughput (millions/sec)</li>
<li>Durable log with configurable retention</li>
</ul>
</div>
<div>
<h5>Cons</h5>
<ul>
<li>Operational complexity (ZooKeeper/KRaft)</li>
<li>Partition rebalancing can cause delays</li>
<li>No built-in dead letter queue</li>
<li>Requires expertise to tune</li>
</ul>
</div>
<div>
<h5>Mitigation</h5>
<p>Use MSK for managed operations. Implement custom DLQ with separate topic. Start with fewer partitions and scale up.</p>
</div>
</div>
<div>
<h4>Microservices Architecture</h4>
<div>
<h5>Pros</h5>
<ul>
<li>Independent deployment and scaling</li>
<li>Technology flexibility per service</li>
<li>Team autonomy and ownership</li>
<li>Fault isolation</li>
</ul>
</div>
<div>
<h5>Cons</h5>
<ul>
<li>Network latency and failures</li>
<li>Distributed transaction complexity</li>
<li>Operational overhead (observability)</li>
<li>Data consistency challenges</li>
</ul>
</div>
<div>
<h5>Mitigation</h5>
<p>Start with modular monolith. Use service mesh for observability. Implement saga pattern for distributed transactions. Invest in good CI/CD.</p>
</div>
</div>
</div>
<hr />
<h2 id="when-simpler-solutions-work">When Simpler Solutions Work</h2>
<div>
<div>
<div>
<h4>The $500/month E-Commerce Platform</h4>
<p>A real architecture that handles $2M/year in revenue:</p>
<pre><code>                                                    ```
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │                    PRACTICAL SMB ARCHITECTURE                    │
                                                    │                                                                  │
                                                    │   Cloudflare (Free/Pro)           DigitalOcean Droplet ($48/mo) │
                                                    │   ┌───────────────────┐           ┌─────────────────────────┐   │
                                                    │   │ CDN + DDoS + Cache│──────────▶│  Django/Rails/Laravel   │   │
                                                    │   │ + Free SSL        │           │  + PostgreSQL           │   │
                                                    │   └───────────────────┘           │  + Redis (same box)     │   │
                                                    │                                   └─────────────────────────┘   │
                                                    │                                              │                   │
                                                    │   ┌───────────────────┐           ┌─────────────────────────┐   │
                                                    │   │  Stripe           │◀──────────│  S3 ($10/mo images)     │   │
                                                    │   │  (payments)       │           │  + Backblaze B2 backup  │   │
                                                    │   └───────────────────┘           └─────────────────────────┘   │
                                                    │                                                                  │
                                                    │   Total: ~$100/month for 10K+ products, 1000 orders/day         │
                                                    └─────────────────────────────────────────────────────────────────┘
                                                    ```
</code></pre>
</div>
<h3 id="when-mongodb-alone-is-enough">When MongoDB Alone is Enough</h3>
<div>
<p><strong>Use MongoDB as your single database when:</strong><br />
- &lt; 100K products with variable attributes<br />
- &lt; 5K orders/day (MongoDB transactions work fine)<br />
- Need flexible schema for product variations<br />
- Team knows MongoDB well<br />
- Don't need complex SQL reporting</p>
<pre><code>                                                    ```javascript
                                                    // MongoDB handles products AND orders just fine at this scale
                                                    db.products.find({
                                                    category: &quot;electronics&quot;,
                                                    &quot;attributes.brand&quot;: &quot;Apple&quot;,
                                                    price: { $lt: 1000 }
                                                    }).sort({ sales_rank: 1 })

                                                    // Even transactions work for checkout
                                                    session.withTransaction(async () =&gt; {
                                                    await db.inventory.updateOne(
                                                    { sku: &quot;ABC123&quot;, quantity: { $gte: 1 } },
                                                    { $inc: { quantity: -1 } }
                                                    );
                                                    await db.orders.insertOne({ ... });
                                                    });
                                                    ```
</code></pre>
</div>
<h3 id="when-you-dont-need-elasticsearch">When You Don't Need Elasticsearch</h3>
<div>
<p><strong>PostgreSQL full-text search handles:</strong><br />
- &lt; 1M products easily<br />
- Basic text search with ranking<br />
- Category filtering with GIN indexes<br />
- Most e-commerce search needs</p>
<pre><code>                                                    ```sql
                                                    -- PostgreSQL full-text search is surprisingly capable
                                                    CREATE INDEX idx_product_search ON products
                                                    USING GIN (to_tsvector('english', name || ' ' || description));

                                                    SELECT *, ts_rank(
                                                    to_tsvector('english', name || ' ' || description),
                                                    plainto_tsquery('english', 'wireless headphones')
                                                    ) as rank
                                                    FROM products
                                                    WHERE to_tsvector('english', name || ' ' || description)
                                                    @@ plainto_tsquery('english', 'wireless headphones')
                                                    ORDER BY rank DESC, sales_count DESC
                                                    LIMIT 20;

                                                    -- Add filters with regular WHERE clauses
                                                    -- This handles 90% of e-commerce search use cases
                                                    ```
</code></pre>
<p><strong>Only add Elasticsearch when you need:</strong><br />
- Fuzzy matching and typo tolerance<br />
- Complex faceted navigation (10+ filters)<br />
- Real-time search suggestions<br />
- &gt; 1M products with sub-100ms response</p>
</div>
<h3 id="simpler-alternatives-table">Simpler Alternatives Table</h3>
<div>
<table>
<thead>
<tr>
<th>Complex Solution</th>
<th>Simpler Alternative</th>
<th>Use Simpler When</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Kafka + multiple services</strong></td>
<td>SQS + Lambda</td>
<td>&lt; 10K orders/day, no event replay needed</td>
</tr>
<tr>
<td><strong>DynamoDB + OpenSearch</strong></td>
<td>PostgreSQL + pg_trgm</td>
<td>&lt; 1M products, &lt; 100K DAU</td>
</tr>
<tr>
<td><strong>Microservices</strong></td>
<td>Modular monolith</td>
<td>&lt; 20 developers, single deployment unit OK</td>
</tr>
<tr>
<td><strong>Redis cluster</strong></td>
<td>Single Redis instance</td>
<td>&lt; 50K concurrent users, &lt; 100GB cache</td>
</tr>
<tr>
<td><strong>Kubernetes (EKS)</strong></td>
<td>ECS or even EC2 + Docker Compose</td>
<td>&lt; 10 services, predictable load</td>
</tr>
<tr>
<td><strong>Aurora Global</strong></td>
<td>Aurora single-region + read replicas</td>
<td>Users in one geography</td>
</tr>
<tr>
<td><strong>Custom ML recommendations</strong></td>
<td>Algolia Recommend or simple &quot;also bought&quot;</td>
<td>&lt; 100K products</td>
</tr>
<tr>
<td><strong>Event sourcing</strong></td>
<td>Simple CRUD with audit log</td>
<td>Don't need to replay history</td>
</tr>
</tbody>
</table>
</div>
<h3 id="scale-thresholds---when-to-upgrade">Scale Thresholds - When to Upgrade</h3>
<div>
<pre><code>                                                    ```
                                                    ┌─────────────────────────────────────────────────────────────────┐
                                                    │                    COMPLEXITY TRIGGER POINTS                     │
                                                    ├─────────────────────────────────────────────────────────────────┤
                                                    │                                                                  │
                                                    │  ORDERS/DAY        ARCHITECTURE RECOMMENDATION                   │
                                                    │  ───────────       ─────────────────────────────                │
                                                    │  &lt; 1,000           Single server, PostgreSQL, sync processing   │
                                                    │  1K - 10K          Add Redis cache, async emails via Celery     │
                                                    │  10K - 50K         Read replicas, message queue, CDN            │
                                                    │  50K - 100K        Consider service extraction, search cluster  │
                                                    │  &gt; 100K            Microservices, event streaming, multi-region │
                                                    │                                                                  │
                                                    │  PRODUCTS          SEARCH RECOMMENDATION                         │
                                                    │  ────────          ─────────────────────                        │
                                                    │  &lt; 100K            PostgreSQL full-text search                  │
                                                    │  100K - 1M         PostgreSQL + pg_trgm, or Algolia             │
                                                    │  1M - 10M          Elasticsearch/OpenSearch cluster             │
                                                    │  &gt; 10M             Sharded Elasticsearch + vector search        │
                                                    │                                                                  │
                                                    │  TEAM SIZE         ARCHITECTURE RECOMMENDATION                   │
                                                    │  ─────────         ─────────────────────────────                │
                                                    │  1-5 devs          Monolith, single database                    │
                                                    │  5-15 devs         Modular monolith, maybe 2-3 services         │
                                                    │  15-50 devs        Domain-based services, shared libraries      │
                                                    │  &gt; 50 devs         Full microservices, platform team            │
                                                    │                                                                  │
                                                    └─────────────────────────────────────────────────────────────────┘
                                                    ```
</code></pre>
</div>
</div>
</div>
<hr />
<h2 id="trade-off-analysis--mitigation">Trade-off Analysis &amp; Mitigation</h2>
<div>
<p>Every architectural decision has costs. Here's how to acknowledge and manage them.</p>
<div>
<div>
<h4>CON: Eventual Consistency in Catalog</h4>
<p><strong>The Problem:</strong> Product updates in DynamoDB take 1-5 seconds to appear in OpenSearch. User might see stale prices or inventory.</p>
<div>
<h5>Mitigation Strategies</h5>
<ul>
<li>Always fetch price/inventory from source at checkout (not cache)</li>
<li>Show "prices may vary" disclaimer on search results</li>
<li>For critical updates (out of stock), use synchronous write-through</li>
<li>Display "last updated" timestamp on product pages</li>
</ul>
</div>
</div>
<div>
<h4>CON: Microservices Network Latency</h4>
<p><strong>The Problem:</strong> Product page requires 5 service calls (product, inventory, reviews, recommendations, seller). Network adds 50-100ms.</p>
<div>
<h5>Mitigation Strategies</h5>
<ul>
<li>Parallel calls with Promise.all() / asyncio.gather()</li>
<li>BFF (Backend for Frontend) pattern - aggregate in one API call</li>
<li>Cache aggregated product view in Redis (5-minute TTL)</li>
<li>Async load non-critical data (reviews, recommendations)</li>
<li>Service mesh with connection pooling (Envoy, Linkerd)</li>
</ul>
</div>
</div>
<div>
<h4>CON: Distributed Transaction Complexity</h4>
<p><strong>The Problem:</strong> Checkout spans inventory, payment, order services. Payment succeeds but order creation fails - now what?</p>
<div>
<h5>Mitigation Strategies</h5>
<ul>
<li>Saga pattern with compensation actions (refund payment, release inventory)</li>
<li>Idempotency keys on all operations for safe retry</li>
<li>Reserve inventory with TTL, confirm/release explicitly</li>
<li>Payment authorization (not capture) until order confirmed</li>
<li>Dedicated saga orchestrator service with state machine</li>
</ul>
</div>
</div>
<div>
<h4>CON: Kafka Operational Complexity</h4>
<p><strong>The Problem:</strong> Consumer lag, partition rebalancing during deploys, no built-in DLQ, requires dedicated expertise.</p>
<div>
<h5>Mitigation Strategies</h5>
<ul>
<li>Use MSK (managed Kafka) to avoid ZooKeeper management</li>
<li>Implement custom DLQ topic with retry logic</li>
<li>Use static partition assignment to avoid rebalancing</li>
<li>Monitor consumer lag with Prometheus/Grafana alerts</li>
<li>Consider Kafka Connect for standard integrations</li>
</ul>
</div>
</div>
<div>
<h4>CON: Multi-Region Data Consistency</h4>
<p><strong>The Problem:</strong> US user places order, immediately checks from EU - order not visible due to replication lag.</p>
<div>
<h5>Mitigation Strategies</h5>
<ul>
<li>Route user to primary region for writes, read from local replica</li>
<li>Sticky sessions - user stays in same region for session duration</li>
<li>Read-your-writes: include version/timestamp in response, check before reading</li>
<li>For critical reads (order confirmation), query primary</li>
<li>Aurora Global Database with write forwarding</li>
</ul>
</div>
</div>
</div>
</div>
<hr />
<h2 id="interview-tips">Interview Tips</h2>
<div>
<h3 id="key-discussion-points">Key Discussion Points</h3>
<ol>
<li><strong>Start with requirements clarification</strong> - Is this B2C or B2B? What's the product type? What geography?</li>
<li><strong>State your scale assumptions explicitly</strong> - &quot;I'm designing for 10M DAU, 500M products&quot;</li>
<li><strong>Discuss trade-offs proactively</strong> - &quot;DynamoDB gives us latency but costs us query flexibility&quot;</li>
<li><strong>Address hot partitions</strong> - Popular products need caching strategies</li>
<li><strong>Payment reliability</strong> - Idempotency, exactly-once semantics, PCI compliance</li>
<li><strong>Search relevance</strong> - How to rank products, personalization, handling typos</li>
</ol>
<h3 id="common-follow-ups">Common Follow-ups</h3>
<pre><code>                                                - How would you handle Prime Day traffic (100x spike)?
                                                - How do you ensure inventory accuracy across warehouses?
                                                - How would you implement product recommendations at scale?
                                                - How do you handle fraudulent orders?
                                                - What happens if the payment service is down during checkout?
</code></pre>
</div>
<div>
<div>
<h4>Red Flags - Avoid These</h4>
<ul>
<li>"We need microservices because Amazon uses them" (cargo culting)</li>
<li>Jumping to complex solutions without discussing scale requirements</li>
<li>Not mentioning caching when discussing product pages</li>
<li>Ignoring the consistency vs. availability trade-off</li>
<li>"Kafka for everything" without justifying why not SQS</li>
<li>Not discussing how to handle payment failures</li>
<li>Forgetting about mobile clients and API design</li>
<li>No mention of observability (logging, tracing, metrics)</li>
<li>Designing multi-region for a startup with 1000 users</li>
<li>"We'll just use blockchain for inventory" (seriously, people say this)</li>
</ul>
</div>
<div>
<h4>Impressive Statements</h4>
<ul>
<li>"At 1000 orders/day, a monolith with PostgreSQL is the right choice"</li>
<li>"We'd use optimistic locking with DynamoDB conditional writes for inventory"</li>
<li>"The product page should be cacheable at CDN for 60 seconds with stale-while-revalidate"</li>
<li>"Payments need idempotency keys to handle retries safely"</li>
<li>"We'd use a saga pattern for checkout with compensation actions"</li>
<li>"Search results can be eventually consistent, but checkout must read from source of truth"</li>
<li>"I'd start with a modular monolith and extract services based on team/scaling needs"</li>
<li>"For Prime Day, we pre-warm capacity and implement circuit breakers on non-critical services"</li>
<li>"You don't need Kafka for checkout - SQS works fine under 100K orders/day"</li>
<li>"PostgreSQL handles 1M products with full-text search - we'd add Elasticsearch only when we see latency issues"</li>
</ul>
</div>
</div>
<div>
<h3 id="the-perfect-interview-flow">The Perfect Interview Flow</h3>
<pre><code>                                                ```
                                                1. CLARIFY (2-3 min)
                                                &quot;What scale are we designing for? B2C or marketplace?
                                                What's the read/write ratio? Which geography?&quot;

                                                2. HIGH-LEVEL DESIGN (5-7 min)
                                                Draw the main components. Explain WHY each exists.
                                                &quot;Products in DynamoDB because of scale and latency requirements...&quot;

                                                3. DEEP DIVE (15-20 min)
                                                Pick 2-3 areas and go deep. Interviewer will guide you.
                                                - Checkout flow with saga pattern
                                                - Search indexing pipeline
                                                - Inventory consistency

                                                4. SCALE &amp; FAILURE MODES (5-10 min)
                                                &quot;For Prime Day, we'd pre-warm, add circuit breakers, queue non-critical work...&quot;
                                                &quot;If payment service is down, we show a friendly error and retry with exponential backoff&quot;

                                                5. WRAP UP (2-3 min)
                                                &quot;Given more time, I'd add fraud detection ML,
                                                real-time inventory across warehouses, and A/B testing for recommendations&quot;
                                                ```
</code></pre>
</div>
<div>
<h4>Final Tip: Show Pragmatism</h4>
<p>The best candidates demonstrate they know when NOT to use complex solutions. Saying "At this scale, we don't need Kafka - SQS is simpler and sufficient" is more impressive than always reaching for the most complex tool. Interviewers want to hire engineers who can ship products, not architects who over-engineer everything.</p>
</div>
