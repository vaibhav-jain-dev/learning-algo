<style>
/* Mobile-specific styles for iPhone 15 and similar devices */
@media screen and (max-width: 480px) {
    /* Force all grid layouts to single column */
    [style*="grid-template-columns"] {
        display: block !important;
    }
    [style*="grid-template-columns"] > div {
        margin-bottom: 16px !important;
    }
    /* Adjust padding for mobile */
    [style*="padding: 32px"],
    [style*="padding: 24px"] {
        padding: 16px !important;
    }
    /* Smaller headings */
    h4[style*="font-size: 18px"],
    h4[style*="font-size: 16px"] {
        font-size: 15px !important;
    }
    /* Readable font sizes */
    [style*="font-size: 13px"],
    [style*="font-size: 12px"],
    [style*="font-size: 11px"],
    [style*="font-size: 10px"] {
        font-size: 13px !important;
        line-height: 1.6 !important;
    }
    /* Flex containers stack vertically */
    [style*="display: flex"][style*="gap"] {
        flex-direction: column !important;
    }
    /* Better spacing for nested content */
    [style*="padding-left: 64px"],
    [style*="padding-left: 48px"],
    [style*="padding-left: 40px"] {
        padding-left: 16px !important;
    }
    /* Code blocks */
    pre {
        font-size: 12px !important;
        padding: 12px !important;
        overflow-x: auto !important;
    }
    pre code {
        font-size: 12px !important;
    }
    /* Tables */
    table {
        font-size: 12px !important;
        display: block !important;
        overflow-x: auto !important;
    }
    th, td {
        padding: 8px !important;
        font-size: 12px !important;
    }
}
</style>
<h1 id="design-airbnb">Design Airbnb</h1>
<nav class="toc" style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 24px; margin: 20px 0">
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#problem-statement">Problem Statement</a></li>
<li><a href="#high-level-architecture">High-Level Architecture</a></li>
<li><a href="#search-system">Search System</a></li>
<li><a href="#scale-strategy">Scale Strategy</a>
<ul>
<li><a href="#phase-1-starting-phase">Phase 1: Starting Phase</a></li>
<li><a href="#phase-2-medium-scale">Phase 2: Medium Scale</a></li>
<li><a href="#phase-3-airbnb-scale">Phase 3: Airbnb Scale</a></li>
</ul>
</li>
<li><a href="#edge-cases-failure-modes">Edge Cases &amp; Failure Modes</a></li>
<li><a href="#aws-technologies-alternatives">AWS Technologies &amp; Alternatives</a></li>
<li><a href="#distributed-systems-considerations">Distributed Systems Considerations</a></li>
<li><a href="#interview-deep-dive-questions">Interview Deep Dive Questions</a></li>
<li><a href="#why-this-technology">Why This Technology?</a></li>
<li><a href="#when-simpler-solutions-work">When Simpler Solutions Work</a></li>
<li><a href="#trade-off-analysis-mitigation">Trade-off Analysis &amp; Mitigation</a></li>
<li><a href="#interview-tips">Interview Tips</a></li>
</ul>
</nav>
<hr />
<h2 id="problem-statement-problem-statement">Problem Statement {#problem-statement}</h2>
<p>Design a vacation rental marketplace that connects hosts with guests for property bookings.</p>
<div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-radius: 16px; padding: 24px; margin: 20px 0">
<h3 id="core-requirements-core-requirements">Core Requirements {#core-requirements}</h3>
<ul>
<li><strong>Listings</strong>: Property creation, photos, amenities, pricing</li>
<li><strong>Search</strong>: Location, dates, filters, map view</li>
<li><strong>Booking</strong>: Availability, reservation, payments</li>
<li><strong>Reviews</strong>: Two-way rating system</li>
<li><strong>Messaging</strong>: Host-guest communication</li>
<li><strong>Host Tools</strong>: Calendar, pricing, analytics</li>
</ul>
</div>
<hr />
<h2 id="high-level-architecture-high-level-architecture">High-Level Architecture {#high-level-architecture}</h2>
<div class="diagram-container">
<div class="flow-diagram">
<h3 style="color: #1d4ed8; text-align: center; margin: 0 0 24px 0">AIRBNB SYSTEM ARCHITECTURE</h3>
<!-- Clients -->
<div class="flow-box success" style="padding: 16px 32px">
<div class="flow-box-title">CLIENTS</div>
<div class="flow-box-subtitle">Web | iOS | Android</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- API Gateway -->
<div class="flow-box primary" style="width: 80%; max-width: 500px; padding: 16px 48px">
<div class="flow-box-title">API GATEWAY</div>
<div class="flow-box-subtitle">Rate Limiting | Auth | Routing</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Services Row -->
<div class="flow-row" style="width: 100%">
<!-- Listing Service -->
<div class="flow-box orange" style="flex: 1; min-width: 180px; max-width: 220px">
<div class="flow-box-title" style="font-size: 13px">LISTING SERVICE</div>
<div style="color: inherit; font-size: 11px; line-height: 1.6; text-align: left; opacity: 0.85">
&#8226; CRUD Operations<br/>
&#8226; Photo Management<br/>
&#8226; Amenities & Pricing
</div>
</div>
<!-- Search Service -->
<div class="flow-box info" style="flex: 1; min-width: 180px; max-width: 220px">
<div class="flow-box-title" style="font-size: 13px">SEARCH SERVICE</div>
<div style="color: inherit; font-size: 11px; line-height: 1.6; text-align: left; opacity: 0.85">
&#8226; Geo-spatial Queries<br/>
&#8226; Faceted Filters<br/>
&#8226; ML-based Rankings
</div>
</div>
<!-- Booking Service -->
<div class="flow-box purple" style="flex: 1; min-width: 180px; max-width: 220px">
<div class="flow-box-title" style="font-size: 13px">BOOKING SERVICE</div>
<div style="color: inherit; font-size: 11px; line-height: 1.6; text-align: left; opacity: 0.85">
&#8226; Reservations<br/>
&#8226; Availability Checks<br/>
&#8226; Payment Processing
</div>
</div>
</div>
<!-- Pricing Service -->
<div class="flow-box success" style="width: 200px">
<div class="flow-box-title" style="font-size: 13px">PRICING SERVICE</div>
<div class="flow-box-subtitle">Dynamic | Seasonal | Demand-based</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Kafka -->
<div class="flow-box error" style="padding: 14px 40px">
<div class="flow-box-title" style="font-size: 13px">KAFKA EVENT BUS</div>
<div class="flow-box-subtitle">Async Communication | Event Sourcing</div>
</div>
</div>
</div>
<hr />
<h2 id="search-system-search-system">Search System {#search-system}</h2>
<div class="diagram-container">
<div class="flow-diagram">
<h4 style="color: #f97316; text-align: center; margin: 0 0 24px 0">LISTING SEARCH PIPELINE</h4>
<!-- Search Query Input -->
<div class="flow-box primary" style="width: 100%; max-width: 500px">
<div class="flow-box-title">Search Query: "Paris, Dec 15-20, 2 guests"</div>
</div>
<!-- Pipeline Steps -->
<div style="display: flex; flex-direction: column; gap: 12px; width: 100%">
<!-- Step 1: Geo Filter -->
<div class="data-card data-card-accent orange">
<div class="data-card-content">
<div class="data-card-header">
<div class="data-card-title" style="color: #f97316">STEP 1: GEO FILTER</div>
<span class="diagram-badge orange">50,000 listings</span>
</div>
<div class="data-card-description">
&#8226; Parse "Paris" to bounding box / polygon coordinates<br/>
&#8226; Filter listings within geographic area using spatial index<br/>
&#8226; Use Elasticsearch <code style="background: #f1f5f9; padding: 2px 6px; border-radius: 4px; color: #3b82f6">geo_shape</code> query
</div>
</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Step 2: Availability Filter -->
<div class="data-card data-card-accent info">
<div class="data-card-content">
<div class="data-card-header">
<div class="data-card-title" style="color: #3b82f6">STEP 2: AVAILABILITY FILTER</div>
<span class="diagram-badge info">15,000 listings</span>
</div>
<div class="data-card-description">
&#8226; Check calendar for Dec 15-20 date range<br/>
&#8226; Exclude listings with existing bookings or host blocks<br/>
&#8226; Consider minimum stay requirements (e.g., 3-night minimum)
</div>
</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Step 3: Capacity + Filters -->
<div class="data-card data-card-accent purple">
<div class="data-card-content">
<div class="data-card-header">
<div class="data-card-title" style="color: #8b5cf6">STEP 3: CAPACITY + FILTERS</div>
<span class="diagram-badge purple">5,000 listings</span>
</div>
<div class="data-card-description">
&#8226; Filter: <code style="background: #f1f5f9; padding: 2px 6px; border-radius: 4px; color: #3b82f6">guests >= 2</code><br/>
&#8226; Apply price range, property type, amenities filters<br/>
&#8226; Apply Instant Book, Superhost, accessibility filters
</div>
</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Step 4: Ranking -->
<div class="data-card data-card-accent success">
<div class="data-card-content">
<div class="data-card-header">
<div class="data-card-title" style="color: #10b981">STEP 4: RANKING</div>
<span class="diagram-badge success">Top 100 ranked</span>
</div>
<div class="data-card-description">
<div style="background: #f1f5f9; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 11px; color: #475569">
Ranking Score = w1 * quality_score<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ w2 * review_score<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ w3 * response_rate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ w4 * price_competitiveness<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ w5 * booking_likelihood (ML)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ w6 * freshness_boost
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="scale-strategy-scale-strategy">Scale Strategy {#scale-strategy}</h2>
<p>This section outlines how the architecture evolves from startup to Airbnb scale, with specific triggers for when to add complexity.</p>
<h3 id="phase-1-starting-phase-phase-1-starting-phase">Phase 1: Starting Phase {#phase-1-starting-phase}</h3>
<div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-radius: 12px; padding: 4px; margin: 20px 0">
<div style="background: #f8fafc; border-radius: 10px; padding: 24px">
<h4 id="assumptions-phase1-assumptions">Assumptions {#phase1-assumptions}</h4>
<ul>
<li><strong>Listings</strong>: 1,000 - 50,000</li>
<li><strong>Users</strong>: 10,000 - 100,000</li>
<li><strong>Bookings</strong>: 100 - 1,000/day</li>
<li><strong>Budget</strong>: $3,000 - $15,000/month</li>
</ul>
<h4 id="monolithic-architecture-phase1-architecture">Monolithic Architecture {#phase1-architecture}</h4>
<pre><code class="language-python">class BookingService:
    def create_booking(self, guest_id, listing_id, check_in, check_out, guests):
        with transaction.atomic():
            listing = Listing.objects.select_for_update().get(id=listing_id)

            # Check availability
            if not self.is_available(listing_id, check_in, check_out):
                raise NotAvailableError()

            # Calculate total price
            nights = (check_out - check_in).days
            price = self.calculate_price(listing, check_in, check_out)
            service_fee = price * 0.12
            total = price + service_fee

            # Create booking
            booking = Booking.objects.create(
                listing=listing,
                guest_id=guest_id,
                check_in=check_in,
                check_out=check_out,
                guests=guests,
                total_price=total,
                status='pending'
            )

            # Block calendar
            self.block_dates(listing_id, check_in, check_out, booking.id)

            # Process payment
            payment = PaymentService().authorize(guest_id, total)
            booking.payment_id = payment.id
            booking.status = 'confirmed'
            booking.save()

            # Notify host
            NotificationService().notify_host_booking(booking)

            return booking

    def is_available(self, listing_id, check_in, check_out):
        blocked = CalendarBlock.objects.filter(
            listing_id=listing_id,
            date__gte=check_in,
            date__lt=check_out
        ).exists()
        return not blocked
</code></pre>
</div>
</div>
<hr />
<h3 id="phase-2-medium-scale-phase-2-medium-scale">Phase 2: Medium Scale {#phase-2-medium-scale}</h3>
<div style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); border-radius: 12px; padding: 4px; margin: 20px 0">
<div style="background: #f8fafc; border-radius: 10px; padding: 24px">
<h4 id="assumptions-phase2-assumptions">Assumptions {#phase2-assumptions}</h4>
<ul>
<li><strong>Listings</strong>: 50,000 - 500,000</li>
<li><strong>Users</strong>: 100,000 - 5,000,000</li>
<li><strong>Bookings</strong>: 1,000 - 50,000/day</li>
<li><strong>Budget</strong>: $15,000 - $100,000/month</li>
</ul>
<h4 id="availability-calendar-availability-calendar">Availability Calendar {#availability-calendar}</h4>
<div class="diagram-container">
<div class="flow-diagram" style="align-items: stretch">
<h4 style="color: #3b82f6; margin: 0 0 16px 0; text-align: center">Calendar Storage Strategy</h4>
<!-- Option 1: Date-based rows -->
<div style="margin-bottom: 24px; width: 100%">
<div style="color: #f97316; font-weight: bold; font-size: 13px; margin-bottom: 12px">Option 1: Date-based rows (Simple)</div>
<div style="overflow-x: auto">
<table style="width: 100%; border-collapse: collapse; font-size: 12px">
<thead>
<tr style="background: linear-gradient(135deg, #e2e8f0 0%, #f1f5f9 100%)">
<th style="padding: 10px; color: #475569; text-align: left">listing_id</th>
<th style="padding: 10px; color: #475569; text-align: left">date</th>
<th style="padding: 10px; color: #475569; text-align: left">available</th>
<th style="padding: 10px; color: #475569; text-align: left">price</th>
<th style="padding: 10px; color: #475569; text-align: left">min_nights</th>
</tr>
</thead>
<tbody>
<tr style="background: #f8fafc">
<td style="padding: 10px; color: #64748b">L1</td>
<td style="padding: 10px; color: #64748b">2024-12-15</td>
<td style="padding: 10px; color: #ef4444">false</td>
<td style="padding: 10px; color: #64748b">$150</td>
<td style="padding: 10px; color: #64748b">2</td>
</tr>
<tr style="background: #ffffff">
<td style="padding: 10px; color: #64748b">L1</td>
<td style="padding: 10px; color: #64748b">2024-12-16</td>
<td style="padding: 10px; color: #ef4444">false</td>
<td style="padding: 10px; color: #64748b">$150</td>
<td style="padding: 10px; color: #64748b">2</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 10px; color: #64748b">L1</td>
<td style="padding: 10px; color: #64748b">2024-12-17</td>
<td style="padding: 10px; color: #10b981">true</td>
<td style="padding: 10px; color: #64748b">$175</td>
<td style="padding: 10px; color: #64748b">2</td>
</tr>
</tbody>
</table>
</div>
</div>
<!-- Option 2: Range-based -->
<div style="margin-bottom: 24px; width: 100%">
<div style="color: #10b981; font-weight: bold; font-size: 13px; margin-bottom: 12px">Option 2: Range-based (Better for queries)</div>
<div style="overflow-x: auto">
<table style="width: 100%; border-collapse: collapse; font-size: 12px">
<thead>
<tr style="background: linear-gradient(135deg, #e2e8f0 0%, #f1f5f9 100%)">
<th style="padding: 10px; color: #475569; text-align: left">listing_id</th>
<th style="padding: 10px; color: #475569; text-align: left">start_date</th>
<th style="padding: 10px; color: #475569; text-align: left">end_date</th>
<th style="padding: 10px; color: #475569; text-align: left">type</th>
<th style="padding: 10px; color: #475569; text-align: left">booking_id</th>
</tr>
</thead>
<tbody>
<tr style="background: #f8fafc">
<td style="padding: 10px; color: #64748b">L1</td>
<td style="padding: 10px; color: #64748b">2024-12-15</td>
<td style="padding: 10px; color: #64748b">2024-12-17</td>
<td style="padding: 10px; color: #ef4444">booked</td>
<td style="padding: 10px; color: #3b82f6">B123</td>
</tr>
<tr style="background: #ffffff">
<td style="padding: 10px; color: #64748b">L1</td>
<td style="padding: 10px; color: #64748b">2024-12-20</td>
<td style="padding: 10px; color: #64748b">2024-12-25</td>
<td style="padding: 10px; color: #f97316">blocked</td>
<td style="padding: 10px; color: #94a3b8">null</td>
</tr>
</tbody>
</table>
</div>
</div>
<!-- Query Example -->
<div style="background: #f1f5f9; border-radius: 8px; padding: 16px; width: 100%">
<div style="color: #8b5cf6; font-weight: bold; font-size: 12px; margin-bottom: 8px">Query: Available Dec 15-20?</div>
<pre style="margin: 0; color: #475569; font-size: 11px; overflow-x: auto"><code>SELECT NOT EXISTS(
  SELECT 1 FROM calendar_blocks
  WHERE listing_id = L1
  AND start_date < '2024-12-20'
  AND end_date > '2024-12-15'
)</code></pre>
</div>
</div>
</div>
<h4 id="dynamic-pricing-dynamic-pricing">Dynamic Pricing {#dynamic-pricing}</h4>
<pre><code class="language-python">class PricingService:
    def calculate_price(self, listing, check_in, check_out):
        base_price = listing.base_price
        total = 0

        for date in date_range(check_in, check_out):
            daily_price = base_price

            # Seasonal adjustment
            season_multiplier = self.get_season_multiplier(listing.location, date)
            daily_price *= season_multiplier

            # Day of week adjustment
            if date.weekday() in [4, 5]:  # Fri, Sat
                daily_price *= 1.2

            # Demand-based adjustment
            demand = self.get_demand(listing.location, date)
            if demand &gt; 0.8:  # High demand
                daily_price *= 1.15

            # Apply custom pricing if set
            custom = listing.custom_pricing.get(date)
            if custom:
                daily_price = custom

            total += daily_price

        return total
</code></pre>
</div>
</div>
<hr />
<h3 id="phase-3-airbnb-scale-phase-3-airbnb-scale">Phase 3: Airbnb Scale {#phase-3-airbnb-scale}</h3>
<div style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border-radius: 12px; padding: 4px; margin: 20px 0">
<div style="background: #f8fafc; border-radius: 10px; padding: 24px">
<h4 id="assumptions-phase3-assumptions">Assumptions {#phase3-assumptions}</h4>
<ul>
<li><strong>Listings</strong>: 7M+ active</li>
<li><strong>Users</strong>: 150M+</li>
<li><strong>Bookings</strong>: 500K+/day</li>
<li><strong>Searches</strong>: 50M+/day</li>
</ul>
<h4 id="booking-flow-at-scale-booking-flow-scale">Booking Flow at Scale {#booking-flow-scale}</h4>
<div class="diagram-container">
<div class="flow-diagram">
<h4 style="color: #ef4444; text-align: center; margin: 0 0 20px 0">DOUBLE-BOOKING PREVENTION</h4>
<div class="data-card data-card-accent error" style="width: 100%; max-width: 500px">
<div class="data-card-content">
<div class="data-card-title" style="color: #ef4444">Problem Statement</div>
<div class="data-card-description">Two guests try to book same listing for same dates simultaneously</div>
</div>
</div>
<!-- Two Guests -->
<div class="flow-row">
<div class="flow-box success">
<div class="flow-box-title">Guest A</div>
<div class="flow-box-subtitle">Book Dec 15-20</div>
</div>
<div class="flow-box primary">
<div class="flow-box-title">Guest B</div>
<div class="flow-box-subtitle">Book Dec 15-20</div>
</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595; &#8595;</div>
<!-- Booking Service -->
<div class="flow-box purple" style="width: 80%; max-width: 400px">
<div class="flow-box-title">BOOKING SERVICE</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Redis Lock -->
<div class="flow-box error" style="padding: 20px; width: 90%; max-width: 500px">
<div class="flow-box-title">Distributed Lock (Redis)</div>
<div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; text-align: center; margin: 10px 0">
<code style="color: #fef3c7; font-size: 11px">SETNX lock:listing:L1:2024-12-15-20</code>
</div>
<div class="flow-box-subtitle">First request wins, second waits or fails fast</div>
</div>
<!-- Arrow -->
<div class="flow-arrow">&#8595;</div>
<!-- Results -->
<div class="flow-row">
<div class="flow-box success" style="flex: 1; max-width: 200px">
<div class="flow-box-title" style="font-size: 12px">Guest A - SUCCESS</div>
<div style="font-size: 10px; line-height: 1.6; text-align: left; opacity: 0.9">
&#10003; Lock acquired<br/>
&#10003; Check availability<br/>
&#10003; Create booking<br/>
&#10003; Block dates<br/>
&#10003; Release lock
</div>
</div>
<div class="flow-box neutral" style="flex: 1; max-width: 200px">
<div class="flow-box-title" style="font-size: 12px; color: #ef4444">Guest B - DENIED</div>
<div style="font-size: 10px; line-height: 1.6; text-align: left; opacity: 0.9">
&#10007; Lock denied<br/>
&#10007; Return: "Not available"<br/>
&nbsp;&nbsp;&nbsp;or retry after TTL
</div>
</div>
</div>
</div>
</div>
<h4 id="search-sharding-search-sharding">Search Sharding {#search-sharding}</h4>
<div class="diagram-container">
<div class="flow-diagram">
<h4 style="color: #3b82f6; text-align: center; margin: 0 0 20px 0">GEO-BASED SEARCH SHARDING</h4>
<div style="color: #64748b; font-size: 12px; text-align: center; margin-bottom: 20px">Elasticsearch Cluster per Region</div>
<!-- Regional Clusters -->
<div class="flow-row" style="margin-bottom: 24px">
<div class="flow-box info" style="min-width: 150px">
<div class="flow-box-title">US Cluster</div>
<div class="flow-box-subtitle">US listings</div>
<div style="font-weight: bold; margin-top: 4px">2M docs</div>
</div>
<div class="flow-box success" style="min-width: 150px">
<div class="flow-box-title">EU Cluster</div>
<div class="flow-box-subtitle">EU listings</div>
<div style="font-weight: bold; margin-top: 4px">3M docs</div>
</div>
<div class="flow-box purple" style="min-width: 150px">
<div class="flow-box-title">APAC Cluster</div>
<div class="flow-box-subtitle">APAC listings</div>
<div style="font-weight: bold; margin-top: 4px">2M docs</div>
</div>
</div>
<!-- Query Routing & Benefits -->
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; width: 100%">
<div class="data-card data-card-accent orange">
<div class="data-card-content">
<div class="data-card-title" style="color: #f97316">Query Routing</div>
<div class="data-card-description">
&#8226; Parse search location from query<br/>
&#8226; Route to appropriate regional cluster<br/>
&#8226; Cross-region queries handled separately
</div>
</div>
</div>
<div class="data-card data-card-accent success">
<div class="data-card-content">
<div class="data-card-title" style="color: #10b981">Benefits</div>
<div class="data-card-description">
&#8226; Reduced index size per cluster<br/>
&#8226; Lower latency for regional searches<br/>
&#8226; Independent scaling per region
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="edge-cases--failure-modes-edge-cases-failure-modes">Edge Cases &amp; Failure Modes {#edge-cases-failure-modes}</h2>
<div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-radius: 16px; padding: 32px; margin: 20px 0">
<h3 id="critical-edge-cases-critical-edge-cases">Critical Edge Cases {#critical-edge-cases}</h3>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; margin: 20px 0">
<div class="data-card data-card-accent error">
<div class="data-card-content">
<div class="data-card-title" style="color: #ef4444">Double-Booking Race Condition</div>
<div class="data-card-description">
<strong>Scenario:</strong> Two guests book same dates within milliseconds<br/>
<strong>Solution:</strong> Distributed lock + database unique constraint + idempotency keys<br/>
<strong>Fallback:</strong> If all else fails, database UNIQUE constraint rejects second booking
</div>
</div>
</div>
<div class="data-card data-card-accent warning">
<div class="data-card-content">
<div class="data-card-title" style="color: #f59e0b">Payment Failure Mid-Booking</div>
<div class="data-card-description">
<strong>Scenario:</strong> Calendar blocked but payment fails<br/>
<strong>Solution:</strong> Saga pattern with compensation - unblock calendar on payment failure<br/>
<strong>Timeout:</strong> Auto-release blocked dates after 10 minutes if payment incomplete
</div>
</div>
</div>
<div class="data-card data-card-accent info">
<div class="data-card-content">
<div class="data-card-title" style="color: #3b82f6">Stale Search Results</div>
<div class="data-card-description">
<strong>Scenario:</strong> Guest clicks listing that was just booked<br/>
<strong>Solution:</strong> Real-time availability check on listing detail page<br/>
<strong>UX:</strong> Show "Dates no longer available" with alternative suggestions
</div>
</div>
</div>
<div class="data-card data-card-accent purple">
<div class="data-card-content">
<div class="data-card-title" style="color: #8b5cf6">Host Cancellation</div>
<div class="data-card-description">
<strong>Scenario:</strong> Host cancels confirmed booking<br/>
<strong>Solution:</strong> Penalty system, automatic refund, rebooking assistance<br/>
<strong>Prevention:</strong> Superhost status tied to low cancellation rate
</div>
</div>
</div>
</div>
<h3 id="failure-mode-handling-failure-mode-handling">Failure Mode Handling {#failure-mode-handling}</h3>
<div class="diagram-container">
<div class="flow-diagram" style="align-items: stretch">
<table>
<thead>
<tr>
<th>Failure</th>
<th>Detection</th>
<th>Recovery</th>
<th>User Impact</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Redis Down</strong></td>
<td>Health check fails</td>
<td>Fall back to DB locks</td>
<td>+50ms latency</td>
</tr>
<tr>
<td><strong>ES Cluster Down</strong></td>
<td>Query timeout</td>
<td>Serve cached results</td>
<td>Stale data (acceptable)</td>
</tr>
<tr>
<td><strong>Payment Gateway</strong></td>
<td>API timeout</td>
<td>Retry with exponential backoff</td>
<td>&quot;Please try again&quot;</td>
</tr>
<tr>
<td><strong>Kafka Lag</strong></td>
<td>Consumer lag metrics</td>
<td>Scale consumers</td>
<td>Delayed notifications</td>
</tr>
<tr>
<td><strong>DB Primary Down</strong></td>
<td>Connection failure</td>
<td>Promote replica</td>
<td>~30s downtime</td>
</tr>
</tbody>
</table>
</div>
</div>
<h3 id="idempotency-handling-idempotency-handling">Idempotency Handling {#idempotency-handling}</h3>
<pre><code class="language-python">class BookingService:
    def create_booking(self, idempotency_key, guest_id, listing_id, dates):
        # Check for duplicate request
        cached = redis.get(f'booking:idempotency:{idempotency_key}')
        if cached:
            return json.loads(cached)  # Return cached response

        try:
            booking = self._do_create_booking(guest_id, listing_id, dates)

            # Cache successful response for 24 hours
            redis.setex(
                f'booking:idempotency:{idempotency_key}',
                86400,
                json.dumps(booking.to_dict())
            )
            return booking

        except BookingConflictError:
            # Also cache error responses to prevent retries
            redis.setex(
                f'booking:idempotency:{idempotency_key}',
                86400,
                json.dumps({'error': 'conflict', 'message': 'Dates unavailable'})
            )
            raise
</code></pre>
<h3 id="circuit-breaker-pattern-circuit-breaker">Circuit Breaker Pattern {#circuit-breaker}</h3>
<pre><code class="language-python">class PaymentCircuitBreaker:
    def __init__(self):
        self.failure_count = 0
        self.failure_threshold = 5
        self.recovery_timeout = 30  # seconds
        self.state = 'CLOSED'
        self.last_failure_time = None

    def call(self, payment_request):
        if self.state == 'OPEN':
            if time.time() - self.last_failure_time &gt; self.recovery_timeout:
                self.state = 'HALF_OPEN'
            else:
                raise CircuitOpenError(&quot;Payment service unavailable&quot;)

        try:
            result = payment_gateway.process(payment_request)
            self._on_success()
            return result
        except PaymentError as e:
            self._on_failure()
            raise

    def _on_success(self):
        self.failure_count = 0
        self.state = 'CLOSED'

    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        if self.failure_count &gt;= self.failure_threshold:
            self.state = 'OPEN'
</code></pre>
</div>
<hr />
<h2 id="aws-technologies--alternatives-aws-technologies-alternatives">AWS Technologies &amp; Alternatives {#aws-technologies-alternatives}</h2>
<div class="diagram-container">
<table>
<thead>
<tr>
<th>Component</th>
<th>AWS Service</th>
<th>Alternative</th>
<th>Trade-offs</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Search</strong></td>
<td>OpenSearch</td>
<td>Elasticsearch</td>
<td>OpenSearch: Managed</td>
</tr>
<tr>
<td><strong>Listings DB</strong></td>
<td>Aurora</td>
<td>Vitess</td>
<td>Aurora: Simpler</td>
</tr>
<tr>
<td><strong>Bookings</strong></td>
<td>DynamoDB</td>
<td>PostgreSQL</td>
<td>DynamoDB: Scale</td>
</tr>
<tr>
<td><strong>Photos</strong></td>
<td>S3 + CloudFront</td>
<td>Cloudflare Images</td>
<td>S3: Ecosystem</td>
</tr>
<tr>
<td><strong>Payments</strong></td>
<td>-</td>
<td>Stripe</td>
<td>Standard choice</td>
</tr>
<tr>
<td><strong>Maps</strong></td>
<td>Location Service</td>
<td>Mapbox, Google</td>
<td>Mapbox: Flexibility</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h2 id="distributed-systems-considerations-distributed-systems-considerations">Distributed Systems Considerations {#distributed-systems-considerations}</h2>
<div class="diagram-container">
<h3 id="1-consistency-for-bookings-consistency-bookings">1. Consistency for Bookings {#consistency-bookings}</h3>
<div class="flow-row" style="margin: 16px 0">
<div class="flow-box success" style="flex: 1; min-width: 200px">
<div class="flow-box-title" style="font-size: 12px">Strong Consistency Required</div>
<div style="font-size: 11px; line-height: 1.7; text-align: left; opacity: 0.9">
&#8226; Availability checks<br/>
&#8226; Booking creation<br/>
&#8226; Payment processing
</div>
</div>
<div class="flow-box neutral" style="flex: 1; min-width: 200px">
<div class="flow-box-title" style="font-size: 12px">Eventual Consistency OK</div>
<div style="font-size: 11px; line-height: 1.7; text-align: left; opacity: 0.9">
&#8226; Search results<br/>
&#8226; Reviews display<br/>
&#8226; Analytics data
</div>
</div>
</div>
<h3 id="2-overbooking-prevention-overbooking-prevention">2. Overbooking Prevention {#overbooking-prevention}</h3>
<pre><code class="language-python"># Idempotent booking with optimistic locking
class BookingService:
    def book(self, request_id, listing_id, dates):
        # Check for duplicate request
        existing = self.cache.get(f'booking_req:{request_id}')
        if existing:
            return existing

        with self.lock(f'listing:{listing_id}'):
            # Re-check availability
            if not self.is_available(listing_id, dates):
                raise NotAvailable()

            # Optimistic lock with version
            listing = Listing.get(listing_id)
            version = listing.calendar_version

            # Create booking
            booking = self.create_booking(listing_id, dates)

            # Update calendar with version check
            updated = Calendar.update(
                listing_id=listing_id,
                block_dates=dates,
                where_version=version
            )

            if not updated:
                # Concurrent modification - retry
                raise ConcurrentModification()

            # Cache result
            self.cache.setex(f'booking_req:{request_id}', booking, ttl=86400)

            return booking
</code></pre>
</div>
<hr />
<h2 id="interview-deep-dive-questions-interview-deep-dive-questions">Interview Deep Dive Questions {#interview-deep-dive-questions}</h2>
<div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-radius: 16px; padding: 24px; margin: 20px 0">
<h3 id="1-how-do-you-prevent-double-booking-question-double-booking">1. &quot;How do you prevent double-booking?&quot; {#question-double-booking}</h3>
<p><strong>What They're Probing</strong>: Understanding of race conditions, distributed locking, and consistency guarantees in concurrent systems.</p>
<p><strong>Strong Answer</strong>:</p>
<blockquote>
<p>&quot;Double-booking prevention requires a defense-in-depth approach with multiple layers working together. Let me walk through the complete flow with a concrete scenario:</p>
<p><strong>Scenario</strong>: Guest A and Guest B both click 'Book Now' on the same Paris apartment for July 4th weekend (July 3-6) within 50 milliseconds of each other.</p>
<p><strong>Layer 1 - Distributed Lock (Redis)</strong>:</p>
<ul>
<li>Both requests hit the Booking Service simultaneously</li>
<li>Service attempts to acquire a Redis lock: <code>SETNX lock:listing:L12345:2024-07-03-06 {request_id} EX 5</code></li>
<li>Guest A's request arrives 12ms earlier, acquires the lock</li>
<li>Guest B's request gets <code>nil</code> response - lock already held</li>
<li>Guest B immediately receives HTTP 409 'Dates no longer available' (fail-fast pattern)</li>
<li>Lock has 5-second TTL to prevent deadlocks if Guest A's service crashes</li>
</ul>
<p><strong>Layer 2 - Database Row-Level Locking</strong>:</p>
<ul>
<li>Guest A's service now executes within the lock: <code>SELECT * FROM calendar WHERE listing_id = 'L12345' AND date BETWEEN '2024-07-03' AND '2024-07-06' FOR UPDATE</code></li>
<li>This locks the 4 calendar rows at the database level</li>
<li>Even if Redis lock somehow failed, the database provides a second barrier</li>
<li>We verify all 4 dates show <code>available = true</code> and <code>booking_id IS NULL</code></li>
</ul>
<p><strong>Layer 3 - Optimistic Locking with Version Numbers</strong>:</p>
<ul>
<li>Each listing has a <code>calendar_version</code> field (starts at 1, increments on any calendar change)</li>
<li>Before starting: read <code>calendar_version = 47</code></li>
<li>After creating booking: <code>UPDATE listings SET calendar_version = calendar_version + 1 WHERE id = 'L12345' AND calendar_version = 47</code></li>
<li>If this updates 0 rows, someone else modified the calendar concurrently - we rollback and retry</li>
</ul>
<p><strong>Layer 4 - Database Constraints (The Safety Net)</strong>:</p>
<ul>
<li>Table has constraint: <code>UNIQUE(listing_id, date) WHERE booking_id IS NOT NULL</code></li>
<li>If all other layers fail, the database will reject duplicate bookings with a constraint violation</li>
<li>This is the absolute last line of defense - we should never reach it, but it's there</li>
</ul>
<p><strong>Layer 5 - Idempotency Keys</strong>:</p>
<ul>
<li>Client sends <code>X-Idempotency-Key: booking_req_abc123</code> header</li>
<li>Before processing, we check Redis: <code>GET idempotency:booking_req_abc123</code></li>
<li>If found, return cached response (handles client retries due to network issues)</li>
<li>After successful booking, store: <code>SETEX idempotency:booking_req_abc123 86400 {booking_response}</code></li>
</ul>
<p><strong>Failure Scenarios</strong>:</p>
<ul>
<li><em>Redis is down</em>: Fall back to database-only locking with <code>SELECT FOR UPDATE</code>. Higher contention but still safe.</li>
<li><em>Lock expires mid-transaction</em>: Optimistic locking version check will catch it. We rollback and return 'Please try again'.</li>
<li><em>Service crashes after lock acquired</em>: TTL expires, next request can proceed. Incomplete booking is cleaned up by background job.</li>
<li><em>Network partition during payment</em>: Booking created in 'pending' state, payment handled asynchronously with compensation logic.&quot;</li>
</ul>
</blockquote>
<p><strong>When Simpler Works</strong>:<br />
For &lt; 100 bookings/day on a regional vacation rental site, a simple database transaction with <code>SELECT FOR UPDATE</code> is sufficient. The distributed lock adds value only when you have multiple service instances and high concurrency (&gt;10 simultaneous booking attempts per second). A local bike rental shop doesn't need Redis locks - PostgreSQL ACID guarantees are enough.</p>
<hr />
<h3 id="2-why-elasticsearch-for-search-over-postgresql-full-text-question-elasticsearch">2. &quot;Why Elasticsearch for search over PostgreSQL full-text?&quot; {#question-elasticsearch}</h3>
<p><strong>What They're Probing</strong>: Understanding of search technology trade-offs, when specialized tools matter, and avoiding over-engineering.</p>
<p><strong>Strong Answer</strong>:</p>
<blockquote>
<p>&quot;The decision hinges on query complexity, scale, and ranking requirements. Let me walk through a real search scenario:</p>
<p><strong>Scenario</strong>: Guest searches 'Paris, July 4th weekend, 2 guests, $100-200/night, entire place, wifi, kitchen, Superhost only'</p>
<p><strong>Why Elasticsearch Wins at Scale</strong>:</p>
<ol>
<li>
<p><strong>Combined Geo + Text + Filters (The Killer Feature)</strong>:</p>
<ul>
<li>Single query combines: <code>geo_distance</code> (within 25km of Paris center), <code>range</code> (price $100-200), <code>terms</code> (amenities: ['wifi', 'kitchen']), <code>bool</code> (Superhost = true)</li>
<li>Elasticsearch handles this in 40-80ms across 3 million EU listings</li>
<li>PostgreSQL can do this with PostGIS + GIN indexes, but query planning becomes unpredictable with 6+ filters</li>
</ul>
</li>
<li>
<p><strong>Custom Relevance Scoring</strong>:</p>
<ul>
<li>We use Elasticsearch's <code>function_score</code> to compute:
<pre><code>base_score = BM25(query, listing_description)
decay_score = exp(-distance_to_center / 10km)
quality_score = (review_count * avg_rating) / 1000
booking_likelihood = ML_model_prediction (0-1)
freshness = 1 / (days_since_last_booking + 1)

final_score = 0.2*base_score + 0.15*decay_score + 0.25*quality_score + 0.3*booking_likelihood + 0.1*freshness
</code></pre>
</li>
<li>PostgreSQL has no equivalent to <code>function_score</code> - you'd need to compute in application layer</li>
</ul>
</li>
<li>
<p><strong>Faceted Aggregations in Same Query</strong>:</p>
<ul>
<li>Single query returns: results + 'Property Type' counts + 'Price Range' histogram + 'Amenities' counts</li>
<li>Powers the filter sidebar showing '234 Entire homes, 89 Private rooms, 12 Shared rooms'</li>
<li>PostgreSQL requires multiple queries or complex CTEs</li>
</ul>
</li>
<li>
<p><strong>Fuzzy Matching and Synonyms</strong>:</p>
<ul>
<li>'Jacuzzi' matches 'hot tub', 'whirlpool', 'spa bath'</li>
<li>'Centre of Paris' matches 'Center of Paris'</li>
<li>Built-in analyzers handle accents: 'cafe' matches 'caf'</li>
</ul>
</li>
</ol>
<p><strong>The Numbers</strong>:</p>
<ul>
<li>7M total listings, 3M in EU cluster</li>
<li>50M searches/day globally</li>
<li>P50 latency: 45ms, P99: 180ms</li>
<li>PostgreSQL equivalent: P50 ~200ms, P99 ~800ms (tested)</li>
</ul>
<p><strong>When PostgreSQL is Fine</strong>:</p>
<ul>
<li>&lt; 10K listings: <code>ts_vector</code> + GIN index handles full-text, PostGIS handles geo</li>
<li>Simple filters (location + dates + price): Well-indexed queries return in &lt;50ms</li>
<li>Vrbo ran on PostgreSQL for years before adding Elasticsearch</li>
<li>A 5,000-listing 'Beach Houses in Outer Banks' site doesn't need Elasticsearch</li>
</ul>
<p><strong>The Real Trade-off</strong>:</p>
<ul>
<li>Elasticsearch adds operational complexity: cluster management, memory tuning, reindexing during schema changes, eventual consistency with primary database</li>
<li>If your search is 'location + dates + a few filters', PostgreSQL with proper indexes is simpler and cheaper</li>
<li>Add Elasticsearch when: query latency exceeds 200ms, you need ML-based ranking, or faceted search becomes a requirement&quot;</li>
</ul>
</blockquote>
<p><strong>When Simpler Works</strong>:<br />
Vrbo's early architecture used PostgreSQL with careful indexing. For a regional vacation rental site with 5,000 listings, a well-indexed PostgreSQL query with <code>ts_vector</code> and PostGIS can return results in &lt; 50ms. Elasticsearch adds operational complexity (cluster management, reindexing) that isn't justified until you hit 50K+ listings with complex ranking needs.</p>
<hr />
<h3 id="3-how-do-you-handle-availability-calendars-at-scale-question-availability">3. &quot;How do you handle availability calendars at scale?&quot; {#question-availability}</h3>
<p><strong>What They're Probing</strong>: Data modeling decisions, storage trade-offs, and understanding of query patterns.</p>
<p><strong>Strong Answer</strong>:</p>
<blockquote>
<p>&quot;Calendar storage is a fascinating trade-off between storage efficiency, query performance, and update complexity. Let me walk through the options with real numbers:</p>
<p><strong>Option 1: Date-Per-Row (Simple but Storage-Heavy)</strong></p>
<p>Schema:</p>
<pre><code class="language-sql">CREATE TABLE calendar (
    listing_id UUID,
    date DATE,
    available BOOLEAN,
    price DECIMAL,
    min_nights INT,
    booking_id UUID,
    PRIMARY KEY (listing_id, date)
);
</code></pre>
<p>Numbers for Airbnb Scale:</p>
<ul>
<li>7M listings x 365 days x 2 years forward visibility = <strong>5.1 billion rows</strong></li>
<li>Each row ~50 bytes = <strong>255 GB</strong> just for calendar data</li>
<li>Query 'Is Dec 15-20 available?' = Check 5 rows, fast with index</li>
<li>Update on booking = Update 5 rows, still fast</li>
</ul>
<p><strong>Option 2: Range-Based (Compact but Complex)</strong></p>
<p>Schema:</p>
<pre><code class="language-sql">CREATE TABLE calendar_blocks (
    id UUID PRIMARY KEY,
    listing_id UUID,
    start_date DATE,
    end_date DATE,
    block_type ENUM('booked', 'host_blocked', 'maintenance'),
    booking_id UUID
);
CREATE INDEX idx_availability ON calendar_blocks (listing_id, start_date, end_date);
</code></pre>
<p>Numbers:</p>
<ul>
<li>Average listing has ~20 blocks/year (bookings + host blocks)</li>
<li>7M listings x 20 blocks = <strong>140 million rows</strong></li>
<li>Storage: ~10 GB (25x smaller!)</li>
<li>Query 'Is Dec 15-20 available?' = <code>NOT EXISTS (SELECT 1 WHERE start_date &lt; '2024-12-20' AND end_date &gt; '2024-12-15')</code></li>
</ul>
<p>Complications:</p>
<ul>
<li>'Get calendar for December' requires computing availability by subtracting blocks from date range</li>
<li>Overlapping blocks need careful handling</li>
<li>Updates can require block splitting (guest books days 15-17 of a block covering 15-20)</li>
</ul>
<p><strong>Option 3: Hybrid with Redis Bitmaps (Airbnb Scale)</strong></p>
<p>Architecture:</p>
<ul>
<li><strong>PostgreSQL</strong>: Source of truth with range-based calendar_blocks table</li>
<li><strong>Redis</strong>: Availability bitmaps for fast search filtering</li>
</ul>
<p>Redis Bitmap Structure:</p>
<pre><code>Key: availability:listing:L12345:2024
Value: 365 bits, one per day (bit 0 = Jan 1, bit 364 = Dec 31)
Size: 46 bytes per listing per year
Total: 7M listings x 46 bytes = 322 MB (fits in memory!)
</code></pre>
<p>Query 'Find available listings in Paris for Dec 15-20':</p>
<ol>
<li>Elasticsearch returns 50,000 listing IDs matching Paris geo-filter</li>
<li>For each listing, Redis: <code>GETBIT availability:L12345:2024 349</code> through <code>GETBIT ... 354</code> (days 349-354)</li>
<li>Filter to listings where all 6 bits are 1 (available)</li>
<li>This batch operation completes in ~5ms for 50,000 listings!</li>
</ol>
<p>Update Flow:</p>
<ol>
<li>Booking created in PostgreSQL (source of truth)</li>
<li>Kafka event: <code>{listing_id: L12345, dates: [2024-12-15, 2024-12-20], available: false}</code></li>
<li>Consumer updates Redis bitmap: <code>SETBIT availability:L12345:2024 349 0</code> through day 354</li>
<li>Eventual consistency: 50-200ms delay between booking and search index update (acceptable)</li>
</ol>
<p><strong>Real Scenario - Preventing Oversell</strong>:</p>
<p>Guest searches Paris for July 4th weekend at 10:00:00.000:</p>
<ul>
<li>Search returns listing L12345 as available (based on Redis bitmap)</li>
<li>Guest clicks 'Book Now' at 10:00:05.000</li>
<li>Meanwhile, another guest booked L12345 at 10:00:03.000</li>
<li>Redis bitmap updated at 10:00:03.150 (150ms later)</li>
<li>Guest A's booking attempt at 10:00:05.000 hits Booking Service</li>
<li>Booking Service checks PostgreSQL (source of truth), finds dates blocked</li>
<li>Returns 'Sorry, these dates were just booked' - no oversell!</li>
</ul>
<p><strong>The Key Insight</strong>: Search can be eventually consistent (we accept showing slightly stale results), but booking MUST check the source of truth (PostgreSQL) before confirming.&quot;</p>
</blockquote>
<p><strong>When Simpler Works</strong>:<br />
Vrbo uses simple calendar tables - no fancy availability system. For &lt; 50K listings, a straightforward date-per-row table with composite index on <code>(listing_id, date)</code> handles everything. Pre-optimization here is the enemy of shipping.</p>
<hr />
<h3 id="4-how-would-you-implement-dynamic-pricing-question-dynamic-pricing">4. &quot;How would you implement dynamic pricing?&quot; {#question-dynamic-pricing}</h3>
<p><strong>What They're Probing</strong>: Understanding of pricing strategies, ML integration, and balancing host control with optimization.</p>
<p><strong>Strong Answer</strong>:</p>
<blockquote>
<p>&quot;Dynamic pricing is a multi-layered system that balances revenue optimization with host trust and guest experience. Let me walk through the complete implementation:</p>
<p><strong>Layer 1: Rule-Based Pricing (Everyone Starts Here)</strong></p>
<pre><code class="language-python">def calculate_base_multiplier(listing, date):
    multiplier = 1.0

    # Day of week: Fri-Sat premium
    if date.weekday() in [4, 5]:  # Friday, Saturday
        multiplier *= 1.20  # +20%

    # Seasonal: Paris in summer vs winter
    season = get_season(listing.location, date)
    season_multipliers = {
        'high': 1.35,      # July-August, Christmas
        'shoulder': 1.10,  # May-June, September
        'low': 0.85        # January-February
    }
    multiplier *= season_multipliers[season]

    # Local events
    events = get_local_events(listing.location, date)
    if 'olympics' in events:
        multiplier *= 2.5  # Paris Olympics 2024
    elif 'major_conference' in events:
        multiplier *= 1.4
    elif 'local_festival' in events:
        multiplier *= 1.2

    return multiplier
</code></pre>
<p><strong>Layer 2: Demand-Based Adjustment</strong></p>
<p>Real-time demand signals:</p>
<ul>
<li><strong>Search-to-view ratio</strong>: 'Paris July 4th' searched 50,000 times yesterday, only 5,000 clicked through = oversupply, reduce prices</li>
<li><strong>View-to-book ratio</strong>: 100 people viewed listing L12345 last week, 0 booked = price too high</li>
<li><strong>Days until check-in</strong>: 60+ days out = standard price, 14-30 days = slight increase if high demand, &lt;7 days = discount if unsold</li>
<li><strong>Competitor pricing</strong>: Similar listings in area priced $20 lower = adjust to stay competitive</li>
</ul>
<pre><code class="language-python">def get_demand_multiplier(listing, date):
    days_out = (date - today()).days
    local_demand = get_demand_score(listing.location, date)  # 0-1

    if days_out &gt; 60:
        # Far out: standard pricing
        return 1.0 + (local_demand - 0.5) * 0.2  # +/- 10%
    elif days_out &gt; 14:
        # Medium term: respond to demand
        if local_demand &gt; 0.8:
            return 1.15  # High demand: +15%
        elif local_demand &lt; 0.3:
            return 0.90  # Low demand: -10%
    else:
        # Last minute: fill or discount
        if listing.booked_rate_30d &gt; 0.8:
            return 1.10  # Popular listing, hold price
        else:
            return 0.80  # Need to fill, discount
</code></pre>
<p><strong>Layer 3: ML-Based Optimization (Airbnb Scale)</strong></p>
<p>Model inputs:</p>
<ul>
<li>Historical booking data (what price actually converts?)</li>
<li>Listing attributes (photos quality score, review sentiment, response time)</li>
<li>Competitive set pricing</li>
<li>Seasonality patterns</li>
<li>Local demand signals</li>
</ul>
<p>Model output: <strong>Optimal price point that maximizes expected revenue</strong></p>
<pre><code>Expected Revenue = Price * P(booking at Price)

Example for listing L12345 on July 4th:
- At $150/night: 80% booking probability = $120 expected revenue
- At $180/night: 60% booking probability = $108 expected revenue
- At $200/night: 40% booking probability = $80 expected revenue

Recommendation: $150/night (highest expected revenue)
</code></pre>
<p><strong>Layer 4: Host Control and Trust</strong></p>
<p>Critical design decisions:</p>
<ul>
<li><strong>Minimum price</strong>: Host sets floor, system never goes below</li>
<li><strong>Maximum price</strong>: Host sets ceiling (avoid PR disasters)</li>
<li><strong>Suggested vs. automatic</strong>: 'Smart Pricing' shows suggestion, host approves</li>
<li><strong>Gradual adjustment</strong>: Never change price more than 20% in a single day</li>
<li><strong>Transparency</strong>: Show host why price was adjusted ('Local demand +15%')</li>
</ul>
<p><strong>Real Example - Paris July 4th Weekend</strong>:</p>
<pre><code>Listing: Cozy Marais Apartment, Base price: $120/night

Rule-based:
  - Weekend: +20% = $144
  - High season: +35% = $194

Demand-based:
  - 45 days out, demand score 0.85 (high)
  - Demand multiplier: +15% = $223

ML adjustment:
  - Similar listings booking at $200-250
  - This listing's conversion rate drops above $230
  - Optimal price: $219

Final suggestion: $219/night (host sees breakdown)
Host can: Accept, modify, or disable Smart Pricing
</code></pre>
<p><strong>Failure Scenarios and Guardrails</strong>:</p>
<ul>
<li><strong>Price spike during tragedy</strong>: Manual override to disable surge during natural disasters</li>
<li><strong>Race to bottom</strong>: Minimum price floor prevents destructive competition</li>
<li><strong>ML model drift</strong>: A/B test continuously, human review of outliers</li>
<li><strong>Guest backlash</strong>: Cap automatic increases at +50%, larger changes need host approval&quot;</li>
</ul>
</blockquote>
<p><strong>When Simpler Works</strong>:<br />
For a small property management company, a simple seasonal pricing table (high/medium/low season multipliers) plus weekend premiums covers 80% of the value. The ML complexity is only justified when you have enough historical data (10K+ bookings) to train meaningful models.</p>
<hr />
<h3 id="5-how-do-you-ensure-search-results-stay-fresh-when-listings-change-question-search-freshness">5. &quot;How do you ensure search results stay fresh when listings change?&quot; {#question-search-freshness}</h3>
<p><strong>What They're Probing</strong>: Understanding of data synchronization, eventual consistency, and cache invalidation strategies.</p>
<p><strong>Strong Answer</strong>:</p>
<blockquote>
<p>&quot;Search freshness is a classic consistency vs. performance trade-off. Let me walk through the complete data flow and the decisions at each layer:</p>
<p><strong>The Core Problem</strong>:</p>
<ul>
<li>Host blocks December 15-20 at 10:00:00.000</li>
<li>Guest searches 'Paris December 15-20' at 10:00:00.500</li>
<li>Will guest see the now-unavailable listing?</li>
</ul>
<p><strong>Data Flow Architecture</strong>:</p>
<pre><code>Host Action (Block Dates)
    |
    v
Listing Service (PostgreSQL) -- Source of Truth
    |
    v
Kafka Event: {listing_id: L12345, event: 'availability_changed', dates: [...]}
    |
    +---&gt; Search Indexer --&gt; Elasticsearch (50-200ms delay)
    |
    +---&gt; Cache Invalidator --&gt; Redis Bitmap (20-50ms delay)
    |
    +---&gt; Notification Service --&gt; Push to guests with wishlists
</code></pre>
<p><strong>Layer 1: Event Publishing (The Source)</strong></p>
<p>Every listing change publishes to Kafka:</p>
<pre><code class="language-python">def block_dates(listing_id, start_date, end_date, reason):
    # Write to PostgreSQL (source of truth)
    CalendarBlock.objects.create(
        listing_id=listing_id,
        start_date=start_date,
        end_date=end_date,
        block_type=reason
    )

    # Publish event for downstream consumers
    kafka.publish('listing-changes', {
        'event_type': 'availability_changed',
        'listing_id': listing_id,
        'dates_blocked': date_range(start_date, end_date),
        'timestamp': now(),
        'version': listing.calendar_version
    })
</code></pre>
<p><strong>Layer 2: Search Index Update (Elasticsearch)</strong></p>
<p>Consumer processes events and updates search index:</p>
<pre><code class="language-python">@kafka_consumer('listing-changes')
def update_search_index(event):
    listing = fetch_listing_with_calendar(event['listing_id'])

    # Compute availability for next 365 days
    availability_bitmap = compute_availability_bitmap(listing)

    # Update Elasticsearch document
    es.update(
        index='listings',
        id=event['listing_id'],
        body={
            'doc': {
                'availability_bitmap': availability_bitmap,
                'last_updated': now()
            }
        }
    )
</code></pre>
<p>Latency breakdown:</p>
<ul>
<li>Kafka consumer lag: 10-50ms</li>
<li>Fetch listing data: 5-20ms</li>
<li>Compute availability: 1-5ms</li>
<li>Elasticsearch update: 20-100ms</li>
<li><strong>Total: 50-200ms</strong> (acceptable for search)</li>
</ul>
<p><strong>Layer 3: Staleness Windows by Feature</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Acceptable Staleness</th>
<th>Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search results</td>
<td>30-60 seconds</td>
<td>ES index + Kafka</td>
</tr>
<tr>
<td>Listing detail page</td>
<td>5 seconds</td>
<td>Redis cache, short TTL</td>
</tr>
<tr>
<td>Availability calendar view</td>
<td>0 seconds</td>
<td>Direct PostgreSQL query</td>
</tr>
<tr>
<td>Booking confirmation</td>
<td>0 seconds</td>
<td>PostgreSQL with locks</td>
</tr>
</tbody>
</table>
<p><strong>Layer 4: The Safety Net (Booking Time Re-Check)</strong></p>
<p>Even with 60-second search staleness, bookings are safe:</p>
<pre><code class="language-python">def create_booking(guest_id, listing_id, dates):
    # ALWAYS check source of truth, never trust cached data
    with db.transaction():
        availability = CalendarBlock.objects.filter(
            listing_id=listing_id,
            start_date__lt=dates.end,
            end_date__gt=dates.start
        ).select_for_update()  # Lock rows

        if availability.exists():
            raise DatesNoLongerAvailable(
                &quot;Sorry, these dates were just booked or blocked&quot;
            )

        # Proceed with booking...
</code></pre>
<p><strong>Real Scenario - The 'Ghost Listing' Problem</strong>:</p>
<p>Timeline:</p>
<ul>
<li>10:00:00.000 - Listing L12345 gets booked by Guest A</li>
<li>10:00:00.100 - Kafka event published</li>
<li>10:00:00.150 - Guest B searches, Elasticsearch still shows L12345 as available</li>
<li>10:00:00.200 - Elasticsearch index updated (L12345 now shows unavailable)</li>
<li>10:00:00.300 - Guest B clicks on L12345 from stale search results</li>
<li>10:00:00.350 - Listing detail page shows 'Dates no longer available' (Redis cache updated, or direct DB check)</li>
</ul>
<p>Result: <strong>No double-booking, minor UX friction</strong> (guest sees listing in search, but detail page shows unavailable)</p>
<p><strong>Optimization: Optimistic UI with Reconciliation</strong></p>
<pre><code class="language-javascript">// Client-side
function onSearchResults(results) {
    // Show results immediately (may be slightly stale)
    renderResults(results);

    // Background refresh availability for visible listings
    const visibleIds = results.slice(0, 20).map(r =&gt; r.id);
    const freshAvailability = await api.checkBulkAvailability(visibleIds, dates);

    // Update UI to mark any newly-unavailable listings
    freshAvailability.forEach(item =&gt; {
        if (!item.available) {
            markAsUnavailable(item.id);
        }
    });
}
</code></pre>
<p><strong>Monitoring and Alerting</strong>:</p>
<ul>
<li>Track Kafka consumer lag - alert if &gt; 5 seconds</li>
<li>Monitor search-to-booking 'sorry, not available' rate - should be &lt; 2%</li>
<li>If rate spikes, investigate indexing delays&quot;</li>
</ul>
</blockquote>
<p><strong>When Simpler Works</strong>:<br />
For &lt; 10K listings, skip Kafka entirely. Direct database queries with proper indexing give you real-time accuracy. The complexity of event-driven sync is only justified when query volume makes direct DB access a bottleneck (typically &gt; 1,000 searches/minute).</p>
</div>
<hr />
<h2 id="why-this-technology-why-this-technology">Why This Technology? {#why-this-technology}</h2>
<div class="diagram-container">
<h3 id="technology-decision-matrix-technology-decision-matrix">Technology Decision Matrix {#technology-decision-matrix}</h3>
<table>
<thead>
<tr>
<th>Decision Point</th>
<th>Technology</th>
<th>Why This Choice</th>
<th>When to Reconsider</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Search Engine</strong></td>
<td>Elasticsearch</td>
<td>Geo queries + facets + custom scoring</td>
<td>&lt; 10K listings: PostgreSQL + PostGIS</td>
</tr>
<tr>
<td><strong>Primary DB</strong></td>
<td>PostgreSQL</td>
<td>ACID for bookings, mature ecosystem</td>
<td>&gt; 100K writes/sec: Consider Vitess</td>
</tr>
<tr>
<td><strong>Calendar Store</strong></td>
<td>PostgreSQL + Redis</td>
<td>Source of truth + fast availability bitmaps</td>
<td>&lt; 50K listings: PostgreSQL only</td>
</tr>
<tr>
<td><strong>Distributed Lock</strong></td>
<td>Redis</td>
<td>Sub-ms latency, battle-tested SETNX</td>
<td>&lt; 10 concurrent bookings: DB locks</td>
</tr>
<tr>
<td><strong>Event Bus</strong></td>
<td>Kafka</td>
<td>Durability, replay, high throughput</td>
<td>&lt; 1K events/sec: PostgreSQL NOTIFY or Redis Pub/Sub</td>
</tr>
<tr>
<td><strong>Image Storage</strong></td>
<td>S3 + CloudFront</td>
<td>Infinite scale, global CDN</td>
<td>&lt; 100K images: Cloudflare R2 (cheaper)</td>
</tr>
<tr>
<td><strong>Payments</strong></td>
<td>Stripe</td>
<td>Marketplace payouts, escrow, compliance</td>
<td>Regional: Local PSP might be required</td>
</tr>
</tbody>
</table>
<h3 id="key-decision-drivers-key-decision-drivers">Key Decision Drivers {#key-decision-drivers}</h3>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; margin-top: 16px">
<div class="data-card data-card-accent info">
<div class="data-card-content">
<div class="data-card-title" style="color: #3b82f6">Elasticsearch over PostgreSQL Full-Text</div>
<div class="data-card-description">
&#9679; Geo-spatial + text + filters combined: ES wins<br/>
&#9679; Custom relevance scoring: ES has function_score<br/>
&#9679; Synonyms, fuzzy matching: ES built-in<br/>
&#9679; < 10K docs with simple queries: PostgreSQL fine<br/>
&#9679; Operational simplicity priority: PostgreSQL wins
</div>
</div>
</div>
<div class="data-card data-card-accent error">
<div class="data-card-content">
<div class="data-card-title" style="color: #ef4444">Redis for Locking over Database Locks</div>
<div class="data-card-description">
&#9679; Multiple service instances: Redis required<br/>
&#9679; Lock with TTL (prevent deadlocks): Redis native<br/>
&#9679; Single monolith: SELECT FOR UPDATE sufficient<br/>
&#9679; < 100 concurrent requests: Database locks fine
</div>
</div>
</div>
<div class="data-card data-card-accent success">
<div class="data-card-content">
<div class="data-card-title" style="color: #10b981">Kafka over Simpler Queues</div>
<div class="data-card-description">
&#9679; Event replay for debugging: Kafka required<br/>
&#9679; Multiple consumers per event: Kafka excels<br/>
&#9679; Exactly-once semantics needed: Kafka Streams<br/>
&#9679; Simple job queue: Redis + Bull sufficient<br/>
&#9679; < 1K msgs/min: PostgreSQL-backed queue fine
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="when-simpler-solutions-work-when-simpler-solutions-work">When Simpler Solutions Work {#when-simpler-solutions-work}</h2>
<div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-radius: 12px; padding: 4px; margin: 20px 0">
<div style="background: #f8fafc; border-radius: 10px; padding: 24px">
<h3 id="the-400month-rental-platform-architecture-simple-architecture">The &quot;$400/month Rental Platform&quot; Architecture {#simple-architecture}</h3>
<p>For a regional vacation rental platform (think: &quot;Cabins in Vermont&quot; or &quot;Beach houses in Outer Banks&quot;):</p>
<div class="diagram-container">
<div class="flow-diagram" style="align-items: stretch">
<h4 style="color: #64748b; margin: 0 0 16px 0; text-align: center">Reality Check</h4>
<div class="flow-row" style="margin-bottom: 20px">
<div class="flow-box primary" style="flex: 1; min-width: 100px">
<div style="font-size: 18px; font-weight: bold">500-5,000</div>
<div class="flow-box-subtitle">listings</div>
</div>
<div class="flow-box success" style="flex: 1; min-width: 100px">
<div style="font-size: 18px; font-weight: bold">50-500</div>
<div class="flow-box-subtitle">bookings/day</div>
</div>
<div class="flow-box warning" style="flex: 1; min-width: 100px">
<div style="font-size: 18px; font-weight: bold">10,000</div>
<div class="flow-box-subtitle">monthly users</div>
</div>
<div class="flow-box purple" style="flex: 1; min-width: 100px">
<div style="font-size: 18px; font-weight: bold">$400-800</div>
<div class="flow-box-subtitle">infra/month</div>
</div>
</div>
<h4 style="color: #10b981; margin: 0 0 16px 0; text-align: center">What You Actually Need</h4>
<!-- Vercel/Railway -->
<div class="flow-box info" style="width: 100%; max-width: 400px">
<div style="display: flex; justify-content: space-between; align-items: center; width: 100%">
<div style="text-align: left">
<div class="flow-box-title">Vercel / Railway</div>
<div class="flow-box-subtitle">Next.js App</div>
</div>
<span class="diagram-badge info">$20/month</span>
</div>
</div>
<div class="flow-arrow">&#8595;</div>
<!-- PostgreSQL -->
<div class="flow-box success" style="width: 100%; max-width: 400px">
<div style="display: flex; justify-content: space-between; align-items: center; width: 100%">
<div style="text-align: left">
<div class="flow-box-title">PostgreSQL (Supabase)</div>
</div>
<span class="diagram-badge success">$25/month</span>
</div>
<div style="font-size: 11px; line-height: 1.6; text-align: left; margin-top: 10px; opacity: 0.9">
&#8226; Listings table with PostGIS for geo queries<br/>
&#8226; Calendar table (date-per-row, it's fine!)<br/>
&#8226; GIN index for amenities JSONB<br/>
&#8226; Full-text search with ts_vector
</div>
</div>
<div class="flow-arrow">&#8595;</div>
<!-- Stripe + Cloudflare -->
<div class="flow-box purple" style="width: 100%; max-width: 400px">
<div style="display: flex; justify-content: space-between; align-items: center; width: 100%">
<div style="text-align: left">
<div class="flow-box-title">Stripe + Cloudflare</div>
<div class="flow-box-subtitle">Payments + Image CDN + R2 Storage</div>
</div>
<span class="diagram-badge purple">~$50/month</span>
</div>
</div>
<div class="flow-box success" style="width: 100%; max-width: 400px; margin-top: 16px">
<div class="flow-box-title">Total: ~$100/month (scales to 10K listings easily)</div>
</div>
</div>
</div>
<h3 id="when-you-dont-need-elasticsearch-when-no-elasticsearch">When You DON'T Need Elasticsearch {#when-no-elasticsearch}</h3>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>PostgreSQL Solution</th>
<th>Performance</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 10K listings</td>
<td><code>WHERE</code> clauses + B-tree indexes</td>
<td>&lt; 50ms</td>
</tr>
<tr>
<td>Geo search</td>
<td>PostGIS <code>ST_DWithin</code></td>
<td>&lt; 100ms</td>
</tr>
<tr>
<td>Full-text</td>
<td><code>ts_vector</code> + GIN index</td>
<td>&lt; 50ms</td>
</tr>
<tr>
<td>Faceted filters</td>
<td>JSONB + GIN + partial indexes</td>
<td>&lt; 100ms</td>
</tr>
<tr>
<td>20+ filters</td>
<td>Composite indexes + query planning</td>
<td>&lt; 200ms</td>
</tr>
</tbody>
</table>
<p><strong>Real example</strong>: A 5,000-listing platform queries:</p>
<pre><code class="language-sql">SELECT * FROM listings
WHERE ST_DWithin(location, ST_MakePoint(-73.9, 40.7)::geography, 50000)
  AND available_dates @&gt; '[2024-12-15, 2024-12-20]'::daterange
  AND guests &gt;= 4
  AND amenities @&gt; '[&quot;wifi&quot;, &quot;parking&quot;]'
ORDER BY rating DESC
LIMIT 20;
-- Execution time: 45ms with proper indexes
</code></pre>
<h3 id="when-you-dont-need-distributed-locking-when-no-distributed-locking">When You DON'T Need Distributed Locking {#when-no-distributed-locking}</h3>
<div class="diagram-container">
<div style="color: #f97316; font-weight: bold; font-size: 13px; margin-bottom: 16px">Question: Do I need Redis for double-booking prevention?</div>
<div style="display: flex; flex-direction: column; gap: 8px">
<div style="display: flex; align-items: center; gap: 12px">
<span style="color: #10b981; font-size: 16px">&#10003;</span>
<span style="color: #64748b; font-size: 12px"><strong style="color: #0f172a">Single database instance?</strong> SELECT FOR UPDATE is enough</span>
</div>
<div style="display: flex; align-items: center; gap: 12px">
<span style="color: #10b981; font-size: 16px">&#10003;</span>
<span style="color: #64748b; font-size: 12px"><strong style="color: #0f172a">< 10 concurrent booking attempts/second?</strong> Database locks fine</span>
</div>
<div style="display: flex; align-items: center; gap: 12px">
<span style="color: #10b981; font-size: 16px">&#10003;</span>
<span style="color: #64748b; font-size: 12px"><strong style="color: #0f172a">Monolithic application?</strong> Transaction isolation handles it</span>
</div>
<div style="display: flex; align-items: center; gap: 12px">
<span style="color: #f97316; font-size: 16px">&#9888;</span>
<span style="color: #64748b; font-size: 12px"><strong style="color: #0f172a">Multiple service instances writing?</strong> Now consider Redis</span>
</div>
<div style="display: flex; align-items: center; gap: 12px">
<span style="color: #ef4444; font-size: 16px">&#9679;</span>
<span style="color: #64748b; font-size: 12px"><strong style="color: #0f172a">Global distribution with latency concerns?</strong> Redis + careful design</span>
</div>
</div>
</div>
<h3 id="when-you-dont-need-kafka-when-no-kafka">When You DON'T Need Kafka {#when-no-kafka}</h3>
<table>
<thead>
<tr>
<th>Use Case</th>
<th>Simpler Alternative</th>
<th>Why It's Fine</th>
</tr>
</thead>
<tbody>
<tr>
<td>Booking notifications</td>
<td>Synchronous calls + retry queue</td>
<td>&lt; 1K/day doesn't need durability</td>
</tr>
<tr>
<td>Search index updates</td>
<td>PostgreSQL triggers + pg_notify</td>
<td>Real-time, no separate infra</td>
</tr>
<tr>
<td>Analytics events</td>
<td>Direct insert to analytics DB</td>
<td>Batch processing overnight</td>
</tr>
<tr>
<td>Email sending</td>
<td>Redis + Bull queue</td>
<td>Simple job queue pattern</td>
</tr>
</tbody>
</table>
<h3 id="the-vrbo-reality-check-vrbo-reality-check">The Vrbo Reality Check {#vrbo-reality-check}</h3>
<blockquote>
<p>&quot;Vrbo (formerly HomeAway) scaled to millions of listings using relatively simple calendar tables - no fancy availability bitmaps, no Redis caching, no Elasticsearch until much later. Their original architecture was PostgreSQL-heavy with careful indexing. The complexity came when they needed real-time pricing optimization and sub-second search across 2M+ listings.&quot;</p>
</blockquote>
</div>
</div>
<hr />
<h2 id="trade-off-analysis--mitigation-trade-off-analysis-mitigation">Trade-off Analysis &amp; Mitigation {#trade-off-analysis-mitigation}</h2>
<div style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border-radius: 12px; padding: 4px; margin: 20px 0">
<div style="background: #f8fafc; border-radius: 10px; padding: 24px">
<h3 id="consistency-vs-availability-trade-offs-consistency-availability-tradeoffs">Consistency vs. Availability Trade-offs {#consistency-availability-tradeoffs}</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Consistency Level</th>
<th>Trade-off</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Booking Creation</strong></td>
<td>Strong (CP)</td>
<td>Blocks during network partition</td>
<td>Fail fast, show &quot;try again&quot;</td>
</tr>
<tr>
<td><strong>Availability Check</strong></td>
<td>Strong (CP)</td>
<td>Higher latency</td>
<td>Cache recent checks for 10s</td>
</tr>
<tr>
<td><strong>Search Results</strong></td>
<td>Eventual (AP)</td>
<td>Stale listings shown</td>
<td>&quot;Check availability&quot; on detail page</td>
</tr>
<tr>
<td><strong>Reviews</strong></td>
<td>Eventual (AP)</td>
<td>Delay in appearing</td>
<td>Show &quot;pending&quot; state</td>
</tr>
<tr>
<td><strong>Pricing Updates</strong></td>
<td>Eventual (AP)</td>
<td>Price mismatch possible</td>
<td>Lock price at booking start</td>
</tr>
</tbody>
</table>
<h3 id="search-latency-vs-accuracy-trade-offs-search-latency-accuracy">Search Latency vs. Accuracy Trade-offs {#search-latency-accuracy}</h3>
<div class="diagram-container">
<div class="flow-diagram">
<h4 style="color: #3b82f6; text-align: center; margin: 0 0 20px 0">SEARCH FRESHNESS SPECTRUM</h4>
<div class="flow-row">
<div class="flow-box success" style="flex: 1; min-width: 140px">
<div class="flow-box-title" style="font-size: 12px">Real-time (0s)</div>
<div style="font-size: 20px; font-weight: bold; margin: 4px 0">Direct ES</div>
<div class="flow-box-subtitle">100ms latency</div>
<div class="flow-box-subtitle">Always accurate</div>
</div>
<div class="flow-box primary" style="flex: 1; min-width: 140px">
<div class="flow-box-title" style="font-size: 12px">Cached (5min)</div>
<div style="font-size: 20px; font-weight: bold; margin: 4px 0">Redis Cache</div>
<div class="flow-box-subtitle">5ms latency</div>
<div class="flow-box-subtitle">Mostly accurate</div>
</div>
<div class="flow-box neutral" style="flex: 1; min-width: 140px">
<div class="flow-box-title" style="font-size: 12px">Stale</div>
<div style="font-size: 20px; font-weight: bold; margin: 4px 0">CDN Cache</div>
<div class="flow-box-subtitle">1ms latency</div>
<div class="flow-box-subtitle">Often stale</div>
</div>
</div>
<div class="data-card data-card-accent success" style="width: 100%; margin-top: 16px">
<div class="data-card-content">
<div class="data-card-title" style="color: #10b981">Recommendation</div>
<div class="data-card-description">
&#8226; Search listing page: 30s Redis cache (acceptable stale)<br/>
&#8226; Listing detail: Real-time availability check<br/>
&#8226; Booking flow: No cache, strong consistency
</div>
</div>
</div>
</div>
</div>
<h3 id="double-booking-prevention-defense-in-depth-defense-in-depth">Double-Booking Prevention: Defense in Depth {#defense-in-depth}</h3>
<div style="display: flex; flex-direction: column; gap: 12px; margin: 16px 0">
<div class="data-card data-card-accent error">
<div class="data-card-content">
<div class="data-card-title" style="color: #ef4444">Layer 1: Distributed Lock (Redis)</div>
<div class="data-card-description">
&#8226; SETNX with TTL prevents concurrent attempts<br/>
&#8226; <span style="color: #f97316">Failure mode:</span> Lock expires before completion<br/>
&#8226; <span style="color: #10b981">Mitigation:</span> Short TTL (5s) + optimistic locking
</div>
</div>
</div>
<div class="data-card data-card-accent success">
<div class="data-card-content">
<div class="data-card-title" style="color: #10b981">Layer 2: Database Constraints</div>
<div class="data-card-description">
&#8226; UNIQUE constraint on (listing_id, date, type='booked')<br/>
&#8226; <span style="color: #f97316">Failure mode:</span> None - database rejects duplicates<br/>
&#8226; <span style="color: #10b981">Mitigation:</span> This is your safety net
</div>
</div>
</div>
<div class="data-card data-card-accent info">
<div class="data-card-content">
<div class="data-card-title" style="color: #3b82f6">Layer 3: Optimistic Locking</div>
<div class="data-card-description">
&#8226; Version number on calendar, check-and-set<br/>
&#8226; <span style="color: #f97316">Failure mode:</span> Retry on version mismatch<br/>
&#8226; <span style="color: #10b981">Mitigation:</span> Exponential backoff, max 3 retries
</div>
</div>
</div>
<div class="data-card data-card-accent purple">
<div class="data-card-content">
<div class="data-card-title" style="color: #8b5cf6">Layer 4: Idempotency Keys</div>
<div class="data-card-description">
&#8226; Client sends unique booking_request_id<br/>
&#8226; <span style="color: #f97316">Failure mode:</span> Duplicate bookings from retries<br/>
&#8226; <span style="color: #10b981">Mitigation:</span> Check for existing booking with same key
</div>
</div>
</div>
</div>
<h3 id="cost-vs-performance-trade-offs-cost-performance-tradeoffs">Cost vs. Performance Trade-offs {#cost-performance-tradeoffs}</h3>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Cost Increase</th>
<th>Performance Gain</th>
<th>When Worth It</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis cache layer</td>
<td>+$50/month</td>
<td>10x faster reads</td>
<td>&gt; 1K searches/min</td>
</tr>
<tr>
<td>Elasticsearch cluster</td>
<td>+$300/month</td>
<td>Complex queries possible</td>
<td>&gt; 50K listings</td>
</tr>
<tr>
<td>CDN for images</td>
<td>+$100/month</td>
<td>5x faster load times</td>
<td>&gt; 10K daily users</td>
</tr>
<tr>
<td>Read replicas</td>
<td>+$200/month</td>
<td>2x read capacity</td>
<td>&gt; 100K daily queries</td>
</tr>
<tr>
<td>Regional deployment</td>
<td>+$500/month</td>
<td>50% latency reduction</td>
<td>Global user base</td>
</tr>
</tbody>
</table>
</div>
</div>
<hr />
<h2 id="interview-tips-interview-tips">Interview Tips {#interview-tips}</h2>
<div style="background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); border-radius: 12px; padding: 24px; margin: 20px 0; color: #e2e8f0">
<h3 id="key-discussion-points-key-discussion-points">Key Discussion Points {#key-discussion-points}</h3>
<ol>
<li><strong>Search ranking</strong>: Balancing relevance, quality, revenue - mention that Airbnb optimizes for booking likelihood, not just relevance</li>
<li><strong>Availability</strong>: Calendar storage trade-offs (date-per-row vs. range-based) - know both approaches</li>
<li><strong>Double booking</strong>: Distributed locking + database constraints as safety net</li>
<li><strong>Dynamic pricing</strong>: Start with rules, add ML when you have data</li>
<li><strong>Trust &amp; Safety</strong>: Verification, fraud detection, review authenticity</li>
</ol>
<h3 id="common-follow-ups-common-followups">Common Follow-ups {#common-followups}</h3>
<ul>
<li>How do you handle last-minute cancellations? (Refund policies, rebooking assistance, host protection)</li>
<li>How do you verify listing photos? (ML-based comparison, guest feedback loop, periodic re-verification)</li>
<li>How do you implement instant book vs request? (Trust score thresholds, host preferences, guest verification level)</li>
</ul>
<hr />
<h3 id="red-flags-what-not-to-say-red-flags">Red Flags (What NOT to Say) {#red-flags}</h3>
<div style="background: rgba(248, 81, 73, 0.1);padding: 16px; margin: 16px 0; border-radius: 0 8px 8px 0">
<table>
<thead>
<tr>
<th>Red Flag Statement</th>
<th>Why It's Bad</th>
<th>Better Alternative</th>
</tr>
</thead>
<tbody>
<tr>
<td>&quot;We need microservices from day one&quot;</td>
<td>Over-engineering for a new platform</td>
<td>&quot;Start monolithic, extract services when we hit specific pain points&quot;</td>
</tr>
<tr>
<td>&quot;Elasticsearch is required for search&quot;</td>
<td>Shows lack of understanding of scale</td>
<td>&quot;For &lt; 10K listings, PostgreSQL with proper indexes works great&quot;</td>
</tr>
<tr>
<td>&quot;We'll use Kafka for all communication&quot;</td>
<td>Unnecessary complexity</td>
<td>&quot;Kafka adds value at high throughput; we'd start with simpler queues&quot;</td>
</tr>
<tr>
<td>&quot;Distributed locks solve double-booking&quot;</td>
<td>Incomplete understanding</td>
<td>&quot;Distributed locks help, but database constraints are the real safety net&quot;</td>
</tr>
<tr>
<td>&quot;We need real-time search updates&quot;</td>
<td>Ignores practical trade-offs</td>
<td>&quot;30-second staleness is acceptable for search; real-time check on booking&quot;</td>
</tr>
<tr>
<td>&quot;Let's shard the database immediately&quot;</td>
<td>Premature optimization</td>
<td>&quot;Single PostgreSQL handles millions of rows; shard when we need it&quot;</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h3 id="impressive-statements-what-to-say-impressive-statements">Impressive Statements (What TO Say) {#impressive-statements}</h3>
<div style="background: rgba(59, 130, 246, 0.1);padding: 16px; margin: 16px 0; border-radius: 0 8px 8px 0">
<table>
<thead>
<tr>
<th>Impressive Statement</th>
<th>Why It Works</th>
</tr>
</thead>
<tbody>
<tr>
<td>&quot;For &lt; 10K listings, PostgreSQL with GIN indexes handles search fine - Elasticsearch adds operational overhead we don't need yet&quot;</td>
<td>Shows you understand when NOT to use fancy tech</td>
</tr>
<tr>
<td>&quot;Vrbo scaled to millions of listings with simple calendar tables before adding complexity&quot;</td>
<td>Demonstrates industry knowledge beyond Airbnb</td>
</tr>
<tr>
<td>&quot;I'd use SELECT FOR UPDATE for a monolith, Redis locks only when we have multiple service instances&quot;</td>
<td>Shows nuanced understanding of when to add complexity</td>
</tr>
<tr>
<td>&quot;The availability bitmap in Redis is an optimization - PostgreSQL is the source of truth&quot;</td>
<td>Demonstrates cache vs. source-of-truth thinking</td>
</tr>
<tr>
<td>&quot;Strong consistency for bookings, eventual consistency for search - different requirements&quot;</td>
<td>Shows CAP theorem applied practically</td>
</tr>
<tr>
<td>&quot;I'd start with rule-based pricing (weekends +20%, holidays +30%) before ML&quot;</td>
<td>Practical, incremental approach to features</td>
</tr>
<tr>
<td>&quot;The double-booking safety net is a database UNIQUE constraint - locks just reduce contention&quot;</td>
<td>Deep understanding of failure modes</td>
</tr>
<tr>
<td>&quot;For a $400/month budget, Supabase + Vercel + Stripe handles 5,000 listings easily&quot;</td>
<td>Practical cost awareness</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h3 id="scaling-triggers-cheat-sheet-scaling-triggers">Scaling Triggers Cheat Sheet {#scaling-triggers}</h3>
<div style="background: rgba(139, 92, 246, 0.1);padding: 16px; margin: 16px 0; border-radius: 0 8px 8px 0">
<table>
<thead>
<tr>
<th>Trigger</th>
<th>Current Solution</th>
<th>When to Evolve</th>
<th>New Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt; 10K listings</td>
<td>PostgreSQL full-text</td>
<td>Search &gt; 200ms</td>
<td>Add Elasticsearch</td>
</tr>
<tr>
<td>&gt; 100 bookings/sec</td>
<td>SELECT FOR UPDATE</td>
<td>Lock contention &gt; 5%</td>
<td>Add Redis locks</td>
</tr>
<tr>
<td>&gt; 1M calendar rows</td>
<td>Date-per-row table</td>
<td>Query &gt; 100ms</td>
<td>Range-based + bitmap cache</td>
</tr>
<tr>
<td>&gt; 50K images</td>
<td>Single S3 bucket</td>
<td>Upload bottleneck</td>
<td>CloudFront + image optimization</td>
</tr>
<tr>
<td>&gt; 10 service instances</td>
<td>Monolith</td>
<td>Deployment coupling</td>
<td>Extract booking service first</td>
</tr>
<tr>
<td>&gt; 100K daily searches</td>
<td>Direct Elasticsearch</td>
<td>P99 &gt; 500ms</td>
<td>Add Redis cache layer</td>
</tr>
</tbody>
</table>
</div>
</div>
