<h1 id="decorator-pattern">Decorator Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Decorator pattern dynamically attaches additional responsibilities to objects by wrapping them with decorator objects that share the same interface. Unlike subclassing, which creates static behavior extensions at compile time, decoration enables runtime composition of behaviors while preserving the Open/Closed Principle.</p>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #e94560; margin: 0 0 0.75rem 0">Core Insight</h4>
<p style="color: #eee; margin: 0; line-height: 1.6">The Decorator pattern embodies the principle of <strong>composition over inheritance</strong>. Each decorator "has-a" component rather than "is-a" specialized version, enabling unlimited behavioral combinations without exponential class hierarchies.</p>
</div>
<h2 id="structural-architecture">Structural Architecture</h2>
<div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin: 2rem 0; font-family: system-ui, sans-serif">
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 1.25rem 2rem; color: white; text-align: center; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4)">
<div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 0.5rem">Component Interface</div>
<div style="font-size: 0.85rem; opacity: 0.9;padding-top: 0.5rem; font-family: monospace">+ operation(): Result</div>
</div>
<div style="display: flex; align-items: center; gap: 0.5rem; color: #667eea">
<div style="width: 2px; height: 30px; background: #667eea"></div>
</div>
<div style="display: flex; gap: 4rem; align-items: flex-start">
<div style="display: flex; flex-direction: column; align-items: center">
<div style="background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);border-radius: 10px; padding: 1rem 1.5rem; text-align: center">
<div style="color: #4ecdc4; font-weight: 600">ConcreteComponent</div>
<div style="color: #888; font-size: 0.8rem; margin-top: 0.5rem; font-family: monospace">+ operation()</div>
</div>
<div style="color: #888; font-size: 0.75rem; margin-top: 0.5rem; max-width: 150px; text-align: center">Base implementation without decoration</div>
</div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 1rem">
<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border-radius: 10px; padding: 1rem 1.5rem; color: white; text-align: center; box-shadow: 0 4px 15px rgba(17, 153, 142, 0.3)">
<div style="font-weight: 700">BaseDecorator</div>
<div style="font-size: 0.8rem;padding-top: 0.5rem; margin-top: 0.5rem; font-family: monospace">
          - wrappedComponent: Component<br>+ operation(): delegates to wrapped
</div>
</div>
<div style="display: flex; align-items: center; gap: 0.5rem; color: #38ef7d">
<div style="width: 2px; height: 20px; background: #38ef7d"></div>
</div>
<div style="display: flex; gap: 1.5rem">
<div style="background: #1a1a2e;border-radius: 8px; padding: 0.75rem 1rem; text-align: center">
<div style="color: #f093fb; font-size: 0.9rem; font-weight: 600">DecoratorA</div>
<div style="color: #888; font-size: 0.75rem; margin-top: 0.25rem">adds behavior before</div>
</div>
<div style="background: #1a1a2e;border-radius: 8px; padding: 0.75rem 1rem; text-align: center">
<div style="color: #ffd93d; font-size: 0.9rem; font-weight: 600">DecoratorB</div>
<div style="color: #888; font-size: 0.75rem; margin-top: 0.25rem">adds behavior after</div>
</div>
</div>
</div>
</div>
</div>
<hr />
<h2 id="section-1-decorator-vs-inheritance---the-fundamental-trade-off">Section 1: Decorator vs Inheritance - The Fundamental Trade-off</h2>
<h3 id="the-combinatorial-explosion-problem">The Combinatorial Explosion Problem</h3>
<p>Inheritance creates a <strong>static class hierarchy</strong> where each combination of features requires a dedicated class. Consider a notification system with 3 delivery channels and 3 formatting options:</p>
<div style="display: flex; gap: 2rem; margin: 2rem 0; flex-wrap: wrap">
<div style="flex: 1; min-width: 280px; background: linear-gradient(135deg, #ff6b6b22 0%, #ff6b6b11 100%);border-radius: 10px; padding: 1.25rem">
<h4 style="color: #ff6b6b; margin: 0 0 1rem 0">Inheritance Approach</h4>
<div style="color: #ccc; font-size: 0.9rem; line-height: 1.6">
<div style="font-family: monospace; background: #1a1a2e; padding: 0.75rem; border-radius: 6px; margin-bottom: 0.75rem">
  Notifier (base)<br>
  EmailNotifier<br>
  SMSNotifier<br>
  SlackNotifier<br>
  HTMLEmailNotifier<br>
  PlainTextEmailNotifier<br>
  HTMLSMSNotifier<br>
  ... (3 x 3 = 9 classes minimum)
</div>
<div style="color: #ff6b6b">Classes grow multiplicatively: O(n * m * k)</div>
</div>
</div>
<div style="flex: 1; min-width: 280px; background: linear-gradient(135deg, #4ecdc422 0%, #4ecdc411 100%);border-radius: 10px; padding: 1.25rem">
<h4 style="color: #4ecdc4; margin: 0 0 1rem 0">Decorator Approach</h4>
<div style="color: #ccc; font-size: 0.9rem; line-height: 1.6">
<div style="font-family: monospace; background: #1a1a2e; padding: 0.75rem; border-radius: 6px; margin-bottom: 0.75rem">
  Notifier (interface)<br>
  BaseNotifier<br>
  EmailDecorator<br>
  SMSDecorator<br>
  HTMLFormatterDecorator<br>
  ... (3 + 3 = 6 classes total)
</div>
<div style="color: #4ecdc4">Classes grow additively: O(n + m + k)</div>
</div>
</div>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is The Combinatorial Explosion Problem and what problem does it solve?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about The Combinatorial Explosion Problem in terms of its core purpose. Consider what specific problem it was designed to address and how it differs from simpler approaches. Try to explain it as if teaching someone who has never encountered this concept before.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: How would you approach solving a problem related to The Combinatorial Explosion Problem?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Start by clearly defining the problem constraints and requirements. Consider what makes this problem challenging and what techniques apply. Think about how you would break it down into smaller subproblems. Remember that recognizing the problem pattern is often the hardest part.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using The Combinatorial Explosion Problem?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider The Combinatorial Explosion Problem from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="internal-mechanics-how-delegation-chains-work">Internal Mechanics: How Delegation Chains Work</h3>
<pre><code class="language-python">from abc import ABC, abstractmethod
from typing import Protocol, runtime_checkable

@runtime_checkable
class DataSource(Protocol):
&quot;&quot;&quot;Component interface - defines the contract all participants must follow.&quot;&quot;&quot;
def write_data(self, data: str) -&gt; None: ...
def read_data(self) -&gt; str: ...


class FileDataSource:
&quot;&quot;&quot;Concrete component - the core object being decorated.&quot;&quot;&quot;

def __init__(self, filename: str):
self._filename = filename
self._data = &quot;&quot;

def write_data(self, data: str) -&gt; None:
# In production: actual file I/O
self._data = data
print(f&quot;[FileDataSource] Writing {len(data)} bytes to {self._filename}&quot;)

def read_data(self) -&gt; str:
print(f&quot;[FileDataSource] Reading from {self._filename}&quot;)
return self._data


class DataSourceDecorator(ABC):
&quot;&quot;&quot;
Base decorator - maintains reference to wrapped component.

CRITICAL DESIGN DECISION: The decorator stores a reference to the
Component INTERFACE, not a concrete class. This enables decorators
to wrap other decorators transparently.
&quot;&quot;&quot;

def __init__(self, source: DataSource):
# Protected member - accessible to subclass decorators
self._wrapped: DataSource = source

def write_data(self, data: str) -&gt; None:
# Default: pure delegation (no-op decorator)
self._wrapped.write_data(data)

def read_data(self) -&gt; str:
return self._wrapped.read_data()


class EncryptionDecorator(DataSourceDecorator):
&quot;&quot;&quot;Adds encryption behavior before delegation.&quot;&quot;&quot;

def __init__(self, source: DataSource, key: str):
super().__init__(source)
self._key = key

def write_data(self, data: str) -&gt; None:
# PRE-PROCESSING: Transform data before passing down
encrypted = self._encrypt(data)
print(f&quot;[EncryptionDecorator] Encrypted {len(data)} -&gt; {len(encrypted)} bytes&quot;)
self._wrapped.write_data(encrypted)

def read_data(self) -&gt; str:
# POST-PROCESSING: Transform data after receiving from chain
data = self._wrapped.read_data()
decrypted = self._decrypt(data)
print(f&quot;[EncryptionDecorator] Decrypted {len(data)} -&gt; {len(decrypted)} bytes&quot;)
return decrypted

def _encrypt(self, data: str) -&gt; str:
# Simplified XOR encryption for demonstration
return ''.join(chr(ord(c) ^ ord(self._key[i % len(self._key)]))
for i, c in enumerate(data))

def _decrypt(self, data: str) -&gt; str:
return self._encrypt(data)  # XOR is symmetric


class CompressionDecorator(DataSourceDecorator):
&quot;&quot;&quot;Adds compression behavior.&quot;&quot;&quot;

def __init__(self, source: DataSource, level: int = 6):
super().__init__(source)
self._level = level

def write_data(self, data: str) -&gt; None:
import zlib
compressed = zlib.compress(data.encode(), self._level)
print(f&quot;[CompressionDecorator] Compressed {len(data)} -&gt; {len(compressed)} bytes&quot;)
# Store as hex string for compatibility
self._wrapped.write_data(compressed.hex())

def read_data(self) -&gt; str:
import zlib
data = self._wrapped.read_data()
decompressed = zlib.decompress(bytes.fromhex(data)).decode()
print(f&quot;[CompressionDecorator] Decompressed {len(data)} -&gt; {len(decompressed)} bytes&quot;)
return decompressed</code></pre>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #ffd93d; margin: 0 0 0.75rem 0">Key Assumption</h4>
<p style="color: #eee; margin: 0; line-height: 1.6">The Decorator pattern assumes <strong>interface stability</strong>. All decorators must implement the complete Component interface. Adding methods to the interface requires updating ALL decorators - a significant maintenance cost that inheritance avoids through method inheritance.</p>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Internal Mechanics: How Delegation Chains Work?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Internal Mechanics: How Delegation Chains Work in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Internal Mechanics: How Delegation Chains Work?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Internal Mechanics: How Delegation Chains Work provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Internal Mechanics: How Delegation Chains Work?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Internal Mechanics: How Delegation Chains Work from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="trade-off-analysis">Trade-off Analysis</h3>
<table>
<thead>
<tr>
<th>Dimension</th>
<th>Inheritance</th>
<th>Decorator</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Binding Time</strong></td>
<td>Compile-time (static)</td>
<td>Runtime (dynamic)</td>
</tr>
<tr>
<td><strong>Behavior Modification</strong></td>
<td>Must subclass</td>
<td>Wrap existing objects</td>
</tr>
<tr>
<td><strong>Multiple Behaviors</strong></td>
<td>Multiple inheritance issues</td>
<td>Stack decorators freely</td>
</tr>
<tr>
<td><strong>Memory Overhead</strong></td>
<td>Single object</td>
<td>Object per decorator layer</td>
</tr>
<tr>
<td><strong>Method Access</strong></td>
<td>Direct access to protected members</td>
<td>Only interface methods visible</td>
</tr>
<tr>
<td><strong>Type Identity</strong></td>
<td><code>isinstance()</code> reliable</td>
<td>May need <code>unwrap()</code> utilities</td>
</tr>
<tr>
<td><strong>Debugging</strong></td>
<td>Single class to inspect</td>
<td>Chain of objects to traverse</td>
</tr>
</tbody>
</table>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Trade-off Analysis and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Trade-off Analysis and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Trade-off Analysis?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Trade-off Analysis provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What factors should you consider when evaluating Trade-off Analysis?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Every technical decision involves trade-offs across multiple dimensions: time complexity, space complexity, implementation complexity, maintainability, and scalability. Consider how Trade-off Analysis performs across these dimensions and in what contexts each trade-off is acceptable. There is rarely a universally 'best' solution.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-1-foundation">Interview Questions - Level 1 (Foundation)</h3>
<p><strong>Q1.1: Why would you choose Decorator over creating a subclass?</strong></p>
<p><em>Expected Answer:</em> Use Decorator when:<br />
- Behaviors need to be added/removed at runtime<br />
- You need arbitrary combinations without class explosion<br />
- You're working with third-party classes you can't subclass<br />
- The Single Responsibility Principle demands separation of concerns</p>
<p><strong>Q1.2: What's the fundamental structural requirement for Decorator to work?</strong></p>
<p><em>Expected Answer:</em> Both the decorator and the component must share the same interface. The decorator holds a reference to a Component (not a ConcreteComponent), enabling it to wrap either concrete components or other decorators transparently.</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 1 (Foundation) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 1 (Foundation) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 1 (Foundation) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-2-mechanics">Interview Questions - Level 2 (Mechanics)</h3>
<p><strong>Q2.1: How does a decorator chain handle method calls internally?</strong></p>
<p><em>Expected Answer:</em> Each decorator receives the call, optionally performs pre-processing, delegates to its wrapped component (which may be another decorator), receives the result, optionally performs post-processing, and returns. This creates a pipeline where:<br />
- Write operations process data &quot;outside-in&quot; (outermost decorator first)<br />
- Read operations process data &quot;inside-out&quot; (innermost component first, then decorators transform the result)</p>
<p><strong>Q2.2: A decorator adds logging. Another adds caching. Does order matter?</strong></p>
<p><em>Expected Answer:</em> Yes, critically. If Logging wraps Caching: logs show cache hits/misses. If Caching wraps Logging: cache may return stale logged values, and you won't see logs for cached calls. Order determines which behaviors see which data.</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 2 (Mechanics) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 2 (Mechanics) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 2 (Mechanics) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-3-edge-cases--design">Interview Questions - Level 3 (Edge Cases &amp; Design)</h3>
<p><strong>Q3.1: How do you handle decorator-specific methods that aren't in the Component interface?</strong></p>
<p><em>Expected Answer:</em> This is a fundamental tension. Options:</p>
<ol>
<li><strong>Visitor pattern</strong>: External object that knows about specific decorator types</li>
<li><strong>Type checking with unwrapping</strong>: <code>while hasattr(obj, '_wrapped'): if isinstance(obj, SpecificDecorator): ...</code></li>
<li><strong>Extended interface</strong>: Define a richer interface that includes optional capabilities</li>
<li><strong>Avoid it</strong>: Design decorators to only add behavior within interface method calls</li>
</ol>
<p>The cleanest solution often is ensuring all interactions happen through the Component interface, accepting that decorators are transparent wrappers.</p>
<p><strong>Q3.2: A teammate argues that a Decorator holding state (like a cache) violates the pattern. Are they correct?</strong></p>
<p><em>Expected Answer:</em> No, but it requires careful design. Stateful decorators are valid and common (caching, rate limiting, circuit breakers). The concerns are:<br />
- <strong>Thread safety</strong>: The state must be synchronized if shared<br />
- <strong>Lifecycle management</strong>: State may need clearing/resetting<br />
- <strong>Testing</strong>: Stateful decorators are harder to test in isolation<br />
- <strong>Memory leaks</strong>: Long-lived decorators with unbounded state</p>
<p>The pattern doesn't prohibit state; it just focuses on interface conformance and delegation.</p>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 3 (Edge Cases & Design) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 3 (Edge Cases & Design) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 3 (Edge Cases & Design) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="section-2-decorator-stacking---order-composition-and-complexity">Section 2: Decorator Stacking - Order, Composition, and Complexity</h2>
<h3 id="the-mathematics-of-decorator-ordering">The Mathematics of Decorator Ordering</h3>
<p>With <code>n</code> decorators, there are <code>n!</code> (factorial) possible orderings. Each ordering may produce different behavior depending on whether decorators:<br />
- Transform input before delegation (pre-processing)<br />
- Transform output after delegation (post-processing)<br />
- Short-circuit the chain conditionally<br />
- Maintain internal state that affects subsequent calls</p>
<div style="display: flex; flex-direction: column; gap: 1rem; margin: 2rem 0">
<div style="background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); border-radius: 10px; padding: 1rem; color: white">
<div style="font-weight: 700; margin-bottom: 0.5rem">Decorator Stack: Compression -> Encryption -> FileSource</div>
<div style="font-family: monospace; font-size: 0.85rem">
  write("Hello") -> compress("Hello") -> encrypt(compressed) -> store(encrypted)
</div>
</div>
<div style="text-align: center; color: #888; font-size: 1.5rem">vs</div>
<div style="background: linear-gradient(90deg, #11998e 0%, #38ef7d 100%); border-radius: 10px; padding: 1rem; color: white">
<div style="font-weight: 700; margin-bottom: 0.5rem">Decorator Stack: Encryption -> Compression -> FileSource</div>
<div style="font-family: monospace; font-size: 0.85rem">
  write("Hello") -> encrypt("Hello") -> compress(encrypted) -> store(compressed)
</div>
</div>
</div>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #e94560; margin: 0 0 0.75rem 0">Critical Insight: Compression + Encryption Order</h4>
<p style="color: #eee; margin: 0; line-height: 1.6">Compress-then-encrypt is generally correct because compression finds patterns in plaintext. Encrypted data appears random and doesn't compress well. Encrypt-then-compress wastes CPU cycles and may even increase size. This is why the order in decorator chains has <strong>real-world security and performance implications</strong>.</p>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is The Mathematics of Decorator Ordering and what problem does it solve?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about The Mathematics of Decorator Ordering in terms of its core purpose. Consider what specific problem it was designed to address and how it differs from simpler approaches. Try to explain it as if teaching someone who has never encountered this concept before.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply The Mathematics of Decorator Ordering?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where The Mathematics of Decorator Ordering provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using The Mathematics of Decorator Ordering?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider The Mathematics of Decorator Ordering from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="implementing-robust-stacking">Implementing Robust Stacking</h3>
<pre><code class="language-python">from typing import List, Callable, TypeVar, Generic
from functools import wraps
import time

T = TypeVar('T')

class Request:
def __init__(self, path: str, method: str, body: dict = None, headers: dict = None):
self.path = path
self.method = method
self.body = body or {}
self.headers = headers or {}
self.context: dict = {}  # Decorators can add metadata here

class Response:
def __init__(self, status: int, body: dict = None, headers: dict = None):
self.status = status
self.body = body or {}
self.headers = headers or {}

# Type alias for handlers
Handler = Callable[[Request], Response]
Middleware = Callable[[Handler], Handler]


def logging_middleware(logger_name: str = &quot;app&quot;) -&gt; Middleware:
&quot;&quot;&quot;
Creates a logging decorator that wraps handlers.
Demonstrates: factory pattern for configurable decorators.
&quot;&quot;&quot;
def decorator(handler: Handler) -&gt; Handler:
@wraps(handler)
def wrapper(request: Request) -&gt; Response:
start = time.perf_counter()
print(f&quot;[{logger_name}] -&gt; {request.method} {request.path}&quot;)

response = handler(request)

elapsed = (time.perf_counter() - start) * 1000
print(f&quot;[{logger_name}] &lt;- {response.status} ({elapsed:.2f}ms)&quot;)
return response
return wrapper
return decorator


def authentication_middleware(secret_key: str) -&gt; Middleware:
&quot;&quot;&quot;
Validates authentication before allowing request through.
Demonstrates: short-circuit behavior in decorator chain.
&quot;&quot;&quot;
def decorator(handler: Handler) -&gt; Handler:
@wraps(handler)
def wrapper(request: Request) -&gt; Response:
token = request.headers.get(&quot;Authorization&quot;, &quot;&quot;)

if not token.startswith(&quot;Bearer &quot;):
# SHORT-CIRCUIT: Never calls the wrapped handler
return Response(401, {&quot;error&quot;: &quot;Missing bearer token&quot;})

# Simplified validation
if token != f&quot;Bearer {secret_key}&quot;:
return Response(403, {&quot;error&quot;: &quot;Invalid token&quot;})

# Add user info to request context for downstream use
request.context[&quot;authenticated&quot;] = True
request.context[&quot;user_id&quot;] = &quot;user_123&quot;

return handler(request)
return wrapper
return decorator


def rate_limit_middleware(max_requests: int, window_seconds: int) -&gt; Middleware:
&quot;&quot;&quot;
Stateful decorator that tracks request counts.
Demonstrates: shared mutable state across invocations.
&quot;&quot;&quot;
request_counts: dict[str, list[float]] = {}

def decorator(handler: Handler) -&gt; Handler:
@wraps(handler)
def wrapper(request: Request) -&gt; Response:
client_ip = request.headers.get(&quot;X-Forwarded-For&quot;, &quot;unknown&quot;)
now = time.time()

# Clean old entries and count recent requests
if client_ip not in request_counts:
request_counts[client_ip] = []

request_counts[client_ip] = [
ts for ts in request_counts[client_ip]
if now - ts &lt; window_seconds
]

if len(request_counts[client_ip]) &gt;= max_requests:
return Response(429, {
&quot;error&quot;: &quot;Rate limit exceeded&quot;,
&quot;retry_after&quot;: window_seconds
})

request_counts[client_ip].append(now)
return handler(request)
return wrapper
return decorator


def caching_middleware(ttl_seconds: int) -&gt; Middleware:
&quot;&quot;&quot;
Caches responses for GET requests.
Demonstrates: conditional behavior based on request properties.
&quot;&quot;&quot;
cache: dict[str, tuple[Response, float]] = {}

def decorator(handler: Handler) -&gt; Handler:
@wraps(handler)
def wrapper(request: Request) -&gt; Response:
# Only cache GET requests
if request.method != &quot;GET&quot;:
return handler(request)

cache_key = f&quot;{request.method}:{request.path}&quot;
now = time.time()

# Check cache
if cache_key in cache:
response, cached_at = cache[cache_key]
if now - cached_at &lt; ttl_seconds:
response.headers[&quot;X-Cache&quot;] = &quot;HIT&quot;
return response

# Cache miss - call handler
response = handler(request)

# Only cache successful responses
if 200 &lt;= response.status &lt; 300:
cache[cache_key] = (response, now)
response.headers[&quot;X-Cache&quot;] = &quot;MISS&quot;

return response
return wrapper
return decorator


# Composing decorators with explicit ordering
def compose_middleware(*middlewares: Middleware) -&gt; Middleware:
&quot;&quot;&quot;
Composes multiple middleware into a single middleware.
Order: first middleware in list is outermost (runs first on request, last on response).
&quot;&quot;&quot;
def composed(handler: Handler) -&gt; Handler:
for middleware in reversed(middlewares):
handler = middleware(handler)
return handler
return composed


# Example usage showing order dependency
def user_api_handler(request: Request) -&gt; Response:
user_id = request.context.get(&quot;user_id&quot;, &quot;anonymous&quot;)
return Response(200, {&quot;message&quot;: f&quot;Hello, {user_id}!&quot;})


# CORRECT ORDER: Rate limit -&gt; Auth -&gt; Cache -&gt; Logging -&gt; Handler
# - Rate limit first: Prevents DoS before expensive auth
# - Auth before cache: Don't cache responses for different users together
# - Cache before logging: Cached responses still get logged
# - Logging innermost: Accurate timing of actual handler execution

pipeline = compose_middleware(
rate_limit_middleware(100, 60),
authentication_middleware(&quot;secret123&quot;),
caching_middleware(300),
logging_middleware(&quot;api&quot;),
)

decorated_handler = pipeline(user_api_handler)</code></pre>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Implementing Robust Stacking?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Implementing Robust Stacking in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Implementing Robust Stacking?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Implementing Robust Stacking provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Implementing Robust Stacking?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Implementing Robust Stacking from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="the-unwrapping-problem">The Unwrapping Problem</h3>
<p>When decorators are stacked, you sometimes need to access the underlying component or a specific decorator in the chain.</p>
<pre><code class="language-python">class DecoratorChainMixin:
&quot;&quot;&quot;
Mixin providing chain introspection capabilities.
Trade-off: Adds coupling but enables debugging and testing.
&quot;&quot;&quot;

def get_wrapped(self):
&quot;&quot;&quot;Returns the immediately wrapped component.&quot;&quot;&quot;
return getattr(self, '_wrapped', None)

def unwrap_all(self):
&quot;&quot;&quot;Returns the innermost concrete component.&quot;&quot;&quot;
current = self
while hasattr(current, '_wrapped'):
current = current._wrapped
return current

def find_decorator(self, decorator_type: type):
&quot;&quot;&quot;Finds a specific decorator type in the chain.&quot;&quot;&quot;
current = self
while current is not None:
if isinstance(current, decorator_type):
return current
current = getattr(current, '_wrapped', None)
return None

def get_chain_depth(self) -&gt; int:
&quot;&quot;&quot;Returns the number of decorators in the chain.&quot;&quot;&quot;
depth = 0
current = self
while hasattr(current, '_wrapped'):
depth += 1
current = current._wrapped
return depth</code></pre>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is The Unwrapping Problem and what problem does it solve?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about The Unwrapping Problem in terms of its core purpose. Consider what specific problem it was designed to address and how it differs from simpler approaches. Try to explain it as if teaching someone who has never encountered this concept before.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: How would you approach solving a problem related to The Unwrapping Problem?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Start by clearly defining the problem constraints and requirements. Consider what makes this problem challenging and what techniques apply. Think about how you would break it down into smaller subproblems. Remember that recognizing the problem pattern is often the hardest part.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using The Unwrapping Problem?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider The Unwrapping Problem from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-1-foundation-1">Interview Questions - Level 1 (Foundation)</h3>
<p><strong>Q1.1: Given decorators A, B, C, if you write <code>A(B(C(component)))</code>, what's the execution order?</strong></p>
<p><em>Expected Answer:</em> On a method call:</p>
<ol>
<li>A's pre-processing runs first</li>
<li>A delegates to B</li>
<li>B's pre-processing runs</li>
<li>B delegates to C</li>
<li>C's pre-processing runs</li>
<li>C delegates to component</li>
<li>Component executes and returns</li>
<li>C's post-processing runs on result</li>
<li>B's post-processing runs</li>
<li>A's post-processing runs and returns final result</li>
</ol>
<p>Request flows &quot;inward&quot; (A-&gt;B-&gt;C-&gt;component), response flows &quot;outward&quot; (component-&gt;C-&gt;B-&gt;A).</p>
<p><strong>Q1.2: Why would you need to unwrap a decorator chain?</strong></p>
<p><em>Expected Answer:</em> Common reasons include:<br />
- Debugging: Inspecting internal state of specific decorators<br />
- Testing: Verifying decorator configuration<br />
- Serialization: Serializing only the core component<br />
- Identity checks: Comparing underlying components<br />
- Dynamic reconfiguration: Adding/removing decorators at runtime</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 1 (Foundation) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 1 (Foundation) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 1 (Foundation) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-2-mechanics-1">Interview Questions - Level 2 (Mechanics)</h3>
<p><strong>Q2.1: How would you implement a &quot;once-only&quot; decorator that executes the wrapped method only on the first call?</strong></p>
<p><em>Expected Answer:</em><br />
```python<br />
class OnceOnlyDecorator(Decorator):<br />
def <strong>init</strong>(self, wrapped):<br />
super().<strong>init</strong>(wrapped)<br />
self._executed = False<br />
self._cached_result = None</p>
<pre><code>def operation(self):
if not self._executed:
self._cached_result = self._wrapped.operation()
self._executed = True
return self._cached_result
```
</code></pre>
<p>Key considerations: Thread safety (use Lock), memory management (consider WeakRef for cached_result if large), reset capability.</p>
<p><strong>Q2.2: Two decorators both modify the same header field. How do you handle conflicts?</strong></p>
<p><em>Expected Answer:</em> Options include:</p>
<ol>
<li><strong>Last-write-wins</strong>: Accept that outer decorators override inner ones</li>
<li><strong>Merge strategy</strong>: Define how values combine (e.g., append for arrays)</li>
<li><strong>Namespace headers</strong>: Each decorator uses prefixed headers (X-RateLimit-<em>, X-Cache-</em>)</li>
<li><strong>Priority system</strong>: Decorators declare priority, highest priority wins</li>
<li><strong>Validation layer</strong>: Final decorator validates header consistency</li>
</ol>
<p>The decorator pattern doesn't solve this; it's an architectural decision.</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 2 (Mechanics) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 2 (Mechanics) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 2 (Mechanics) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-3-edge-cases--design-1">Interview Questions - Level 3 (Edge Cases &amp; Design)</h3>
<p><strong>Q3.1: How do you test a decorator that depends on decorators above it in the chain?</strong></p>
<p><em>Expected Answer:</em> Integration testing challenge. Strategies:</p>
<ol>
<li>
<p><strong>Mock the wrapped component</strong>: Test decorator in isolation with mock that returns controlled responses</p>
</li>
<li>
<p><strong>Context injection</strong>: Use request.context pattern so decorators can communicate without tight coupling</p>
</li>
<li>
<p><strong>Dependency injection</strong>: Decorator accepts dependencies explicitly rather than assuming chain position</p>
</li>
<li>
<p><strong>Contract testing</strong>: Define interface contracts that decorators must satisfy</p>
</li>
<li>
<p><strong>Chain builder helpers</strong>: Factory that builds valid chains for testing</p>
<pre><code class="language-python">                 # Example: Testing auth decorator that needs rate limit info
                 def test_auth_with_rate_limit_context():
                 mock_handler = Mock(return_value=Response(200, {}))

                 # Simulate rate limit decorator having run
                 request = Request(&quot;/api&quot;, &quot;GET&quot;)
                 request.context[&quot;rate_limit_remaining&quot;] = 50

                 auth_decorated = authentication_middleware(&quot;secret&quot;)(mock_handler)
                 # ... test assertions</code></pre>
</li>
</ol>
<p><strong>Q3.2: A decorator stack has 10 layers. Performance is degrading. How do you diagnose and fix?</strong></p>
<p><em>Expected Answer:</em> Diagnosis:</p>
<ol>
<li><strong>Profile the chain</strong>: Measure time in each decorator</li>
<li><strong>Check for O(n^2) patterns</strong>: Each decorator iterating the full chain</li>
<li><strong>Memory pressure</strong>: Object allocations per request</li>
<li><strong>Lock contention</strong>: Stateful decorators with shared locks</li>
</ol>
<p>Fixes:</p>
<ol>
<li><strong>Flatten common combinations</strong>: Create specialized composite decorators</li>
<li><strong>Short-circuit patterns</strong>: Early-exit decorators should be outermost</li>
<li><strong>Lazy evaluation</strong>: Don't process until necessary</li>
<li><strong>Object pooling</strong>: Reuse decorator instances where safe</li>
<li><strong>Reduce chain depth</strong>: Question if all 10 layers are necessary</li>
</ol>
<p>See also: <a href="/topic/design-patterns/composite">[Composite Pattern]</a> for flattening hierarchies.</p>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 3 (Edge Cases & Design) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 3 (Edge Cases & Design) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 3 (Edge Cases & Design) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="section-3-io-streams---the-classic-decorator-application">Section 3: I/O Streams - The Classic Decorator Application</h2>
<h3 id="javas-io-design-philosophy">Java's I/O Design Philosophy</h3>
<p>Java's <code>java.io</code> package is the canonical real-world Decorator implementation. The design enables mixing and matching stream behaviors:</p>
<div style="display: flex; flex-direction: column; gap: 0.5rem; margin: 2rem 0; font-family: monospace; font-size: 0.9rem">
<div style="display: flex; align-items: center; gap: 1rem">
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 0.75rem 1.5rem; border-radius: 8px; color: white; min-width: 200px; text-align: center">InputStream</div>
<div style="color: #888; flex: 1">Abstract component - defines read(), close(), available()</div>
</div>
<div style="display: flex; align-items: center; gap: 1rem; padding-left: 2rem">
<div style="width: 2px; height: 20px; background: #667eea"></div>
</div>
<div style="display: flex; align-items: center; gap: 1rem; padding-left: 2rem">
<div style="background: #1e3a5f;padding: 0.75rem 1.5rem; border-radius: 8px; color: #4ecdc4; min-width: 200px; text-align: center">FileInputStream</div>
<div style="color: #888; flex: 1">Concrete component - reads from file</div>
</div>
<div style="display: flex; align-items: center; gap: 1rem; padding-left: 2rem">
<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 0.75rem 1.5rem; border-radius: 8px; color: white; min-width: 200px; text-align: center">FilterInputStream</div>
<div style="color: #888; flex: 1">Abstract decorator base - wraps any InputStream</div>
</div>
<div style="display: flex; align-items: center; gap: 1rem; padding-left: 4rem">
<div style="width: 2px; height: 20px; background: #38ef7d"></div>
</div>
<div style="display: flex; flex-wrap: wrap; gap: 0.75rem; padding-left: 4rem">
<div style="background: #1a1a2e;padding: 0.5rem 1rem; border-radius: 6px; color: #f093fb">BufferedInputStream</div>
<div style="background: #1a1a2e;padding: 0.5rem 1rem; border-radius: 6px; color: #ffd93d">DataInputStream</div>
<div style="background: #1a1a2e;padding: 0.5rem 1rem; border-radius: 6px; color: #74b9ff">GZIPInputStream</div>
<div style="background: #1a1a2e;padding: 0.5rem 1rem; border-radius: 6px; color: #a29bfe">CipherInputStream</div>
</div>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a Java's I/O Design Philosophy?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Java's I/O Design Philosophy in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Java's I/O Design Philosophy?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Java's I/O Design Philosophy provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Java's I/O Design Philosophy?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Java's I/O Design Philosophy from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="python-implementation-with-real-world-concerns">Python Implementation with Real-World Concerns</h3>
<pre><code class="language-python">from abc import ABC, abstractmethod
from typing import Optional, Iterator
import io
import gzip
import hashlib
import threading
from contextlib import contextmanager


class Stream(ABC):
&quot;&quot;&quot;
Component interface for streams.

Design Decision: Using context manager protocol for resource safety.
All streams MUST be used with 'with' statements or explicitly closed.
&quot;&quot;&quot;

@abstractmethod
def read(self, size: int = -1) -&gt; bytes:
&quot;&quot;&quot;Read up to size bytes. Returns empty bytes at EOF.&quot;&quot;&quot;
pass

@abstractmethod
def write(self, data: bytes) -&gt; int:
&quot;&quot;&quot;Write data, return bytes written.&quot;&quot;&quot;
pass

@abstractmethod
def close(self) -&gt; None:
&quot;&quot;&quot;Release resources.&quot;&quot;&quot;
pass

def __enter__(self):
return self

def __exit__(self, exc_type, exc_val, exc_tb):
self.close()
return False  # Don't suppress exceptions


class FileStream(Stream):
&quot;&quot;&quot;Concrete component: File-based stream.&quot;&quot;&quot;

def __init__(self, path: str, mode: str = 'rb'):
self._path = path
self._mode = mode
self._file: Optional[io.BufferedIOBase] = None
self._closed = False

def _ensure_open(self):
if self._closed:
raise ValueError(&quot;I/O operation on closed stream&quot;)
if self._file is None:
self._file = open(self._path, self._mode)

def read(self, size: int = -1) -&gt; bytes:
self._ensure_open()
return self._file.read(size)

def write(self, data: bytes) -&gt; int:
self._ensure_open()
return self._file.write(data)

def close(self) -&gt; None:
if not self._closed:
if self._file:
self._file.close()
self._closed = True


class MemoryStream(Stream):
&quot;&quot;&quot;Concrete component: In-memory stream for testing.&quot;&quot;&quot;

def __init__(self, initial_data: bytes = b''):
self._buffer = io.BytesIO(initial_data)
self._closed = False

def read(self, size: int = -1) -&gt; bytes:
if self._closed:
raise ValueError(&quot;I/O operation on closed stream&quot;)
return self._buffer.read(size)

def write(self, data: bytes) -&gt; int:
if self._closed:
raise ValueError(&quot;I/O operation on closed stream&quot;)
return self._buffer.write(data)

def close(self) -&gt; None:
self._closed = True

def get_value(self) -&gt; bytes:
&quot;&quot;&quot;Testing helper: get all written data.&quot;&quot;&quot;
pos = self._buffer.tell()
self._buffer.seek(0)
data = self._buffer.read()
self._buffer.seek(pos)
return data


class StreamDecorator(Stream):
&quot;&quot;&quot;
Base decorator providing delegation and resource management.

CRITICAL: Decorators must properly delegate close() to avoid resource leaks.
The chain of responsibility for cleanup flows inward to the concrete component.
&quot;&quot;&quot;

def __init__(self, wrapped: Stream):
self._wrapped = wrapped

def read(self, size: int = -1) -&gt; bytes:
return self._wrapped.read(size)

def write(self, data: bytes) -&gt; int:
return self._wrapped.write(data)

def close(self) -&gt; None:
# Delegate close to wrapped stream
self._wrapped.close()


class BufferedStream(StreamDecorator):
&quot;&quot;&quot;
Adds buffering to reduce system calls.

Trade-off: Memory usage vs I/O performance.
Default 8KB buffer matches typical filesystem block sizes.
&quot;&quot;&quot;

def __init__(self, wrapped: Stream, buffer_size: int = 8192):
super().__init__(wrapped)
self._buffer_size = buffer_size
self._read_buffer = b''
self._write_buffer = b''

def read(self, size: int = -1) -&gt; bytes:
if size == -1:
# Read all: empty buffer + read rest
result = self._read_buffer + self._wrapped.read(-1)
self._read_buffer = b''
return result

# Read from buffer first
while len(self._read_buffer) &lt; size:
chunk = self._wrapped.read(self._buffer_size)
if not chunk:
break
self._read_buffer += chunk

result = self._read_buffer[:size]
self._read_buffer = self._read_buffer[size:]
return result

def write(self, data: bytes) -&gt; int:
self._write_buffer += data
written = 0

# Flush when buffer exceeds threshold
while len(self._write_buffer) &gt;= self._buffer_size:
chunk = self._write_buffer[:self._buffer_size]
self._wrapped.write(chunk)
self._write_buffer = self._write_buffer[self._buffer_size:]
written += len(chunk)

return len(data)  # Report bytes accepted, not flushed

def flush(self) -&gt; None:
&quot;&quot;&quot;Force write buffer to underlying stream.&quot;&quot;&quot;
if self._write_buffer:
self._wrapped.write(self._write_buffer)
self._write_buffer = b''

def close(self) -&gt; None:
self.flush()  # CRITICAL: Flush before close
super().close()


class CompressingStream(StreamDecorator):
&quot;&quot;&quot;
Adds gzip compression.

Complexity: Compression is stateful - the compressor maintains
dictionary state across writes. Final flush is required.
&quot;&quot;&quot;

def __init__(self, wrapped: Stream, level: int = 6):
super().__init__(wrapped)
self._level = level
self._compressor = None
self._decompressor = None

def write(self, data: bytes) -&gt; int:
if self._compressor is None:
self._compressor = gzip.GzipFile(
fileobj=_WritableWrapper(self._wrapped),
mode='wb',
compresslevel=self._level
)
self._compressor.write(data)
return len(data)

def read(self, size: int = -1) -&gt; bytes:
if self._decompressor is None:
self._decompressor = gzip.GzipFile(
fileobj=_ReadableWrapper(self._wrapped),
mode='rb'
)
return self._decompressor.read(size)

def close(self) -&gt; None:
if self._compressor:
self._compressor.close()
if self._decompressor:
self._decompressor.close()
super().close()


class _WritableWrapper:
&quot;&quot;&quot;Adapter to make Stream compatible with gzip.GzipFile.&quot;&quot;&quot;
def __init__(self, stream: Stream):
self._stream = stream
def write(self, data: bytes) -&gt; int:
return self._stream.write(data)
def flush(self): pass


class _ReadableWrapper:
&quot;&quot;&quot;Adapter to make Stream compatible with gzip.GzipFile.&quot;&quot;&quot;
def __init__(self, stream: Stream):
self._stream = stream
def read(self, size: int = -1) -&gt; bytes:
return self._stream.read(size)


class HashingStream(StreamDecorator):
&quot;&quot;&quot;
Computes hash while streaming data through.

Use case: Verify data integrity without loading entire file into memory.
Common in: Download verification, backup integrity, content addressing.
&quot;&quot;&quot;

def __init__(self, wrapped: Stream, algorithm: str = 'sha256'):
super().__init__(wrapped)
self._hasher = hashlib.new(algorithm)
self._algorithm = algorithm

def read(self, size: int = -1) -&gt; bytes:
data = self._wrapped.read(size)
self._hasher.update(data)
return data

def write(self, data: bytes) -&gt; int:
self._hasher.update(data)
return self._wrapped.write(data)

def get_hash(self) -&gt; str:
&quot;&quot;&quot;Returns hex digest of all data that passed through.&quot;&quot;&quot;
return self._hasher.hexdigest()

def reset_hash(self) -&gt; None:
&quot;&quot;&quot;Reset hash state for new computation.&quot;&quot;&quot;
self._hasher = hashlib.new(self._algorithm)


class ProgressStream(StreamDecorator):
&quot;&quot;&quot;
Reports progress during I/O operations.

Real-world use: Progress bars, upload/download indicators.
&quot;&quot;&quot;

def __init__(self, wrapped: Stream, total_size: int,
callback: callable = None):
super().__init__(wrapped)
self._total = total_size
self._processed = 0
self._callback = callback or self._default_callback

def _default_callback(self, processed: int, total: int):
percent = (processed / total * 100) if total &gt; 0 else 0
print(f&quot;\rProgress: {processed}/{total} bytes ({percent:.1f}%)&quot;, end='')

def read(self, size: int = -1) -&gt; bytes:
data = self._wrapped.read(size)
self._processed += len(data)
self._callback(self._processed, self._total)
return data

def write(self, data: bytes) -&gt; int:
result = self._wrapped.write(data)
self._processed += len(data)
self._callback(self._processed, self._total)
return result


# Real-world composition example
def create_upload_stream(path: str, file_size: int) -&gt; tuple[Stream, HashingStream]:
&quot;&quot;&quot;
Creates a stream stack for file upload with:
- Progress reporting
- Integrity hashing
- Compression
- Buffering

Returns the outer stream and the hashing stream (to retrieve hash later).
&quot;&quot;&quot;
file_stream = FileStream(path, 'rb')
buffered = BufferedStream(file_stream, buffer_size=65536)  # 64KB buffer
hashing = HashingStream(buffered)
compressed = CompressingStream(hashing, level=6)
progress = ProgressStream(compressed, file_size)

return progress, hashing


# Usage
# outer_stream, hasher = create_upload_stream('/path/to/file', file_size)
# with outer_stream:
#     while chunk := outer_stream.read(8192):
#         network.send(chunk)
# print(f&quot;\nFile hash: {hasher.get_hash()}&quot;)</code></pre>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #e94560; margin: 0 0 0.75rem 0">Resource Management Warning</h4>
<p style="color: #eee; margin: 0; line-height: 1.6">Stream decorators MUST propagate <code>close()</code> calls down the chain. Failure to do so causes resource leaks (file handles, network connections). In languages without deterministic destruction, always use try-finally or context managers. Java's try-with-resources and Python's context managers are designed specifically for this pattern.</p>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Python Implementation with Real-World Concerns and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Python Implementation with Real-World Concerns and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: What are the key steps to implement Python Implementation with Real-World Concerns correctly?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Focus on the sequence of operations and critical decisions at each step. Consider what invariants must be maintained throughout the implementation. Think about edge cases and how they should be handled. A correct implementation handles both the common case and the exceptional cases gracefully.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Python Implementation with Real-World Concerns?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Python Implementation with Real-World Concerns from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-1-foundation-2">Interview Questions - Level 1 (Foundation)</h3>
<p><strong>Q1.1: Why does Java use <code>FilterInputStream</code> as the decorator base instead of just extending <code>InputStream</code>?</strong></p>
<p><em>Expected Answer:</em> <code>FilterInputStream</code> provides default delegation behavior, reducing boilerplate. Each concrete decorator only overrides methods it modifies. Without it, every decorator would need to implement all ~10 InputStream methods with delegation code.</p>
<p><strong>Q1.2: What happens if you forget to close a BufferedOutputStream in Java?</strong></p>
<p><em>Expected Answer:</em> Data remaining in the buffer is lost. The buffer may not be flushed to the underlying stream, causing incomplete writes. This is why <code>flush()</code> must be called before <code>close()</code>, and why try-with-resources is essential.</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 1 (Foundation) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 1 (Foundation) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 1 (Foundation) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-2-mechanics-2">Interview Questions - Level 2 (Mechanics)</h3>
<p><strong>Q2.1: How does <code>BufferedInputStream.mark()</code> and <code>reset()</code> work with decorator chaining?</strong></p>
<p><em>Expected Answer:</em> <code>BufferedInputStream</code> overrides <code>mark()</code> to remember position in its buffer and <code>reset()</code> to return to that position. However, it can only reset within the buffer bounds. If you read past the <code>markLimit</code>, the mark becomes invalid.</p>
<p>The complexity: if another decorator wraps BufferedInputStream, mark/reset semantics depend entirely on BufferedInputStream's buffer - outer decorators can't extend the mark capability.</p>
<p><strong>Q2.2: Design a decorator that limits total bytes read (quota enforcement). What edge cases must you handle?</strong></p>
<p><em>Expected Answer:</em><br />
```python<br />
class QuotaStream(StreamDecorator):<br />
def <strong>init</strong>(self, wrapped: Stream, max_bytes: int):<br />
super().<strong>init</strong>(wrapped)<br />
self._remaining = max_bytes</p>
<pre><code>def read(self, size: int = -1) -&gt; bytes:
if self._remaining &lt;= 0:
return b''  # Quota exhausted, simulate EOF

# Limit read size to remaining quota
actual_size = min(size, self._remaining) if size &gt; 0 else self._remaining
data = self._wrapped.read(actual_size)
self._remaining -= len(data)
return data
```
</code></pre>
<p>Edge cases:<br />
- <code>size=-1</code> (read all): Must limit to remaining quota<br />
- Empty reads at quota boundary vs actual EOF<br />
- Thread safety if shared across threads<br />
- Quota accounting for failed reads (if underlying stream throws)</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 2 (Mechanics) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 2 (Mechanics) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 2 (Mechanics) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-3-edge-cases--design-2">Interview Questions - Level 3 (Edge Cases &amp; Design)</h3>
<p><strong>Q3.1: You're debugging: data written through Compression-&gt;Encryption-&gt;File appears corrupted. How do you diagnose?</strong></p>
<p><em>Expected Answer:</em> Systematic approach:</p>
<ol>
<li><strong>Isolate layers</strong>: Test each decorator independently with known inputs</li>
<li><strong>Verify order</strong>: Compression-&gt;Encryption writes compressed-then-encrypted; reading must Decrypt-&gt;Decompress (reverse order)</li>
<li><strong>Check flush/close</strong>: Compression maintains state; incomplete flush corrupts data</li>
<li><strong>Buffer boundaries</strong>: Encryption block sizes (16 bytes for AES) may not align with compression output</li>
<li><strong>Add diagnostic layer</strong>: Insert a TeeStream that writes to a debug file before encryption</li>
</ol>
<p>Common causes:<br />
- Flush not called before close<br />
- Read path doesn't reverse write path order<br />
- Partial block handling in encryption</p>
<p><strong>Q3.2: How would you make stream decorators work with async I/O?</strong></p>
<p><em>Expected Answer:</em> Fundamental redesign needed:<br />
```python<br />
class AsyncStream(ABC):<br />
@abstractmethod<br />
async def read(self, size: int = -1) -&gt; bytes: ...</p>
<pre><code>@abstractmethod
async def write(self, data: bytes) -&gt; int: ...

class AsyncBufferedStream(AsyncStreamDecorator):
async def read(self, size: int = -1) -&gt; bytes:
# Buffer management same as sync
while len(self._buffer) &lt; size:
chunk = await self._wrapped.read(self._buffer_size)  # Await!
if not chunk:
break
self._buffer += chunk
# ...
```
</code></pre>
<p>Challenges:<br />
- Can't mix sync and async decorators transparently<br />
- Cancellation must propagate through chain<br />
- Backpressure handling changes<br />
- Testing requires async test frameworks</p>
<p>See also: <a href="/topic/concurrency/async-await">[Async Patterns]</a> for async composition strategies.</p>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 3 (Edge Cases & Design) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 3 (Edge Cases & Design) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 3 (Edge Cases & Design) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="section-4-middleware-pattern---decorators-in-web-frameworks">Section 4: Middleware Pattern - Decorators in Web Frameworks</h2>
<h3 id="middleware-as-requestresponse-decoration">Middleware as Request/Response Decoration</h3>
<p>Web framework middleware is the Decorator pattern applied to HTTP handling. Each middleware wraps the next handler, creating a pipeline.</p>
<div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin: 2rem 0; flex-wrap: wrap">
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 0.75rem 1rem; border-radius: 8px; color: white; font-size: 0.85rem">Request</div>
<div style="color: #667eea; font-size: 1.5rem">-></div>
<div style="background: #1a1a2e;padding: 0.5rem 0.75rem; border-radius: 6px; color: #f093fb; font-size: 0.8rem">Logging</div>
<div style="color: #888">-></div>
<div style="background: #1a1a2e;padding: 0.5rem 0.75rem; border-radius: 6px; color: #ffd93d; font-size: 0.8rem">Auth</div>
<div style="color: #888">-></div>
<div style="background: #1a1a2e;padding: 0.5rem 0.75rem; border-radius: 6px; color: #74b9ff; font-size: 0.8rem">RateLimit</div>
<div style="color: #888">-></div>
<div style="background: #1a1a2e;padding: 0.5rem 0.75rem; border-radius: 6px; color: #a29bfe; font-size: 0.8rem">CORS</div>
<div style="color: #888">-></div>
<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 0.75rem 1rem; border-radius: 8px; color: white; font-size: 0.85rem">Handler</div>
<div style="color: #38ef7d; font-size: 1.5rem">-></div>
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 0.75rem 1rem; border-radius: 8px; color: white; font-size: 0.85rem">Response</div>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a Middleware as Request/Response Decoration?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Middleware as Request/Response Decoration in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Middleware as Request/Response Decoration?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Middleware as Request/Response Decoration provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Middleware as Request/Response Decoration?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Middleware as Request/Response Decoration from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="go-implementation-with-real-world-patterns">Go Implementation with Real-World Patterns</h3>
<pre><code class="language-go">package main

import (
&quot;context&quot;
&quot;encoding/json&quot;
&quot;fmt&quot;
&quot;log&quot;
&quot;net/http&quot;
&quot;runtime/debug&quot;
&quot;sync&quot;
&quot;time&quot;
)

// ContextKey type for type-safe context values
type ContextKey string

const (
RequestIDKey   ContextKey = &quot;request_id&quot;
UserKey        ContextKey = &quot;user&quot;
StartTimeKey   ContextKey = &quot;start_time&quot;
)

// Middleware signature - takes handler, returns handler
type Middleware func(http.Handler) http.Handler

// ChainMiddleware composes middleware in order (first runs first)
func ChainMiddleware(middlewares ...Middleware) Middleware {
return func(final http.Handler) http.Handler {
// Apply in reverse so first middleware is outermost
for i := len(middlewares) - 1; i &gt;= 0; i-- {
final = middlewares[i](final)
}
return final
}
}

// RequestIDMiddleware adds unique ID to each request
// Demonstrates: Adding context to requests for tracing
func RequestIDMiddleware(generator func() string) Middleware {
return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
requestID := r.Header.Get(&quot;X-Request-ID&quot;)
if requestID == &quot;&quot; {
requestID = generator()
}

// Add to context for downstream middleware/handlers
ctx := context.WithValue(r.Context(), RequestIDKey, requestID)

// Add to response headers for client correlation
w.Header().Set(&quot;X-Request-ID&quot;, requestID)

next.ServeHTTP(w, r.WithContext(ctx))
})
}
}

// LoggingMiddleware logs request details
// Demonstrates: Capturing both request and response information
func LoggingMiddleware(logger *log.Logger) Middleware {
return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
start := time.Now()

// Wrap ResponseWriter to capture status code
wrapped := &amp;responseWrapper{ResponseWriter: w, statusCode: http.StatusOK}

// Store start time in context for other middleware
ctx := context.WithValue(r.Context(), StartTimeKey, start)

requestID, _ := r.Context().Value(RequestIDKey).(string)
logger.Printf(&quot;[%s] -&gt; %s %s&quot;, requestID, r.Method, r.URL.Path)

next.ServeHTTP(wrapped, r.WithContext(ctx))

duration := time.Since(start)
logger.Printf(&quot;[%s] &lt;- %d %s (%v)&quot;,
requestID, wrapped.statusCode, http.StatusText(wrapped.statusCode), duration)
})
}
}

type responseWrapper struct {
http.ResponseWriter
statusCode int
written    bool
}

func (w *responseWrapper) WriteHeader(code int) {
if !w.written {
w.statusCode = code
w.written = true
}
w.ResponseWriter.WriteHeader(code)
}

func (w *responseWrapper) Write(b []byte) (int, error) {
if !w.written {
w.written = true
}
return w.ResponseWriter.Write(b)
}

// RecoveryMiddleware catches panics and returns 500
// Demonstrates: Short-circuit on exceptional conditions
func RecoveryMiddleware(logger *log.Logger) Middleware {
return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
defer func() {
if err := recover(); err != nil {
requestID, _ := r.Context().Value(RequestIDKey).(string)

// Log the panic with stack trace
logger.Printf(&quot;[%s] PANIC: %v\n%s&quot;, requestID, err, debug.Stack())

// Return generic error to client (don't leak internals)
w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
w.WriteHeader(http.StatusInternalServerError)
json.NewEncoder(w).Encode(map[string]string{
&quot;error&quot;:      &quot;Internal server error&quot;,
&quot;request_id&quot;: requestID,
})
}
}()

next.ServeHTTP(w, r)
})
}
}

// RateLimitMiddleware implements token bucket rate limiting
// Demonstrates: Stateful middleware with thread-safe shared state
func RateLimitMiddleware(rps int, burst int) Middleware {
type bucket struct {
tokens    float64
lastCheck time.Time
mu        sync.Mutex
}

buckets := make(map[string]*bucket)
var bucketsLock sync.RWMutex

return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
// Use IP as client identifier (production: use better identification)
clientIP := r.RemoteAddr

bucketsLock.RLock()
b, exists := buckets[clientIP]
bucketsLock.RUnlock()

if !exists {
bucketsLock.Lock()
b = &amp;bucket{tokens: float64(burst), lastCheck: time.Now()}
buckets[clientIP] = b
bucketsLock.Unlock()
}

b.mu.Lock()

// Refill tokens based on time elapsed
now := time.Now()
elapsed := now.Sub(b.lastCheck).Seconds()
b.tokens += elapsed * float64(rps)
if b.tokens &gt; float64(burst) {
b.tokens = float64(burst)
}
b.lastCheck = now

if b.tokens &lt; 1 {
b.mu.Unlock()

w.Header().Set(&quot;Retry-After&quot;, &quot;1&quot;)
w.Header().Set(&quot;X-RateLimit-Remaining&quot;, &quot;0&quot;)
http.Error(w, &quot;Rate limit exceeded&quot;, http.StatusTooManyRequests)
return
}

b.tokens--
remaining := int(b.tokens)
b.mu.Unlock()

w.Header().Set(&quot;X-RateLimit-Remaining&quot;, fmt.Sprintf(&quot;%d&quot;, remaining))
next.ServeHTTP(w, r)
})
}
}

// TimeoutMiddleware enforces request timeout
// Demonstrates: Context cancellation propagation
func TimeoutMiddleware(timeout time.Duration) Middleware {
return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
ctx, cancel := context.WithTimeout(r.Context(), timeout)
defer cancel()

// Channel to signal handler completion
done := make(chan struct{})

go func() {
next.ServeHTTP(w, r.WithContext(ctx))
close(done)
}()

select {
case &lt;-done:
// Handler completed normally
case &lt;-ctx.Done():
// Timeout - note: response may be partially written
// This is a fundamental limitation of HTTP
w.WriteHeader(http.StatusGatewayTimeout)
}
})
}
}

// CORSMiddleware handles Cross-Origin Resource Sharing
// Demonstrates: Conditional short-circuit (OPTIONS) and header decoration
func CORSMiddleware(allowedOrigins []string) Middleware {
originSet := make(map[string]bool)
for _, o := range allowedOrigins {
originSet[o] = true
}

return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
origin := r.Header.Get(&quot;Origin&quot;)

// Check if origin is allowed
if originSet[origin] || originSet[&quot;*&quot;] {
w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, origin)
w.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;)
w.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Authorization, X-Request-ID&quot;)
w.Header().Set(&quot;Access-Control-Expose-Headers&quot;, &quot;X-Request-ID, X-RateLimit-Remaining&quot;)
w.Header().Set(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;)
}

// Handle preflight
if r.Method == http.MethodOptions {
w.WriteHeader(http.StatusNoContent)
return // Short-circuit: don't call next handler
}

next.ServeHTTP(w, r)
})
}
}

// Usage example
func main() {
logger := log.Default()

// Define middleware stack
stack := ChainMiddleware(
RecoveryMiddleware(logger),           // Outermost: catch panics
RequestIDMiddleware(generateUUID),     // Add request ID early
LoggingMiddleware(logger),             // Log with request ID
TimeoutMiddleware(30 * time.Second),   // Enforce timeout
RateLimitMiddleware(100, 10),          // Rate limit
CORSMiddleware([]string{&quot;https://app.example.com&quot;}),
)

// Apply to handlers
http.Handle(&quot;/api/users&quot;, stack(http.HandlerFunc(usersHandler)))
http.Handle(&quot;/api/health&quot;, stack(http.HandlerFunc(healthHandler)))

log.Println(&quot;Server starting on :8080&quot;)
http.ListenAndServe(&quot;:8080&quot;, nil)
}

func generateUUID() string {
// Simplified - use uuid library in production
return fmt.Sprintf(&quot;%d&quot;, time.Now().UnixNano())
}

func usersHandler(w http.ResponseWriter, r *http.Request) {
json.NewEncoder(w).Encode(map[string]string{&quot;status&quot;: &quot;ok&quot;})
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
w.Write([]byte(&quot;healthy&quot;))
}</code></pre>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #4ecdc4; margin: 0 0 0.75rem 0">Design Choice: Handler vs Middleware Responsibility</h4>
<p style="color: #eee; margin: 0; line-height: 1.6">Middleware should handle <strong>cross-cutting concerns</strong>: authentication, logging, rate limiting, CORS. Business logic belongs in handlers. If you find middleware making business decisions (e.g., "admin users skip rate limits"), consider moving that logic to the handler or introducing a policy layer.</p>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is the Go Implementation with Real-World Patterns and when should you use it?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>The Go Implementation with Real-World Patterns addresses a specific category of problems. Think about the conditions that make this pattern valuable - what symptoms in your code suggest you need it? Also consider what alternatives exist and why you might choose this approach over others.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: What are the key steps to implement Go Implementation with Real-World Patterns correctly?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Focus on the sequence of operations and critical decisions at each step. Consider what invariants must be maintained throughout the implementation. Think about edge cases and how they should be handled. A correct implementation handles both the common case and the exceptional cases gracefully.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Go Implementation with Real-World Patterns?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Go Implementation with Real-World Patterns from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="expressjs-pattern-comparison">Express.js Pattern Comparison</h3>
<pre><code class="language-javascript">// Express middleware follows same decorator pattern
// but with (req, res, next) signature

const express = require('express');
const app = express();

// Middleware order matters - defined top to bottom
app.use(requestIdMiddleware);      // Runs first
app.use(loggingMiddleware);        // Runs second
app.use(authenticationMiddleware); // Runs third
app.use(rateLimitMiddleware);      // Runs fourth

// The 'next()' call is the delegation point
function loggingMiddleware(req, res, next) {
const start = Date.now();

// Intercept response finish to log duration
res.on('finish', () =&gt; {
const duration = Date.now() - start;
console.log(`${req.method} ${req.path} ${res.statusCode} ${duration}ms`);
});

next(); // Delegate to next middleware/handler
}

// Short-circuit example
function authenticationMiddleware(req, res, next) {
const token = req.headers.authorization;

if (!validateToken(token)) {
// Don't call next() - short-circuit the chain
return res.status(401).json({ error: 'Unauthorized' });
}

req.user = decodeToken(token);
next(); // Continue to next middleware
}</code></pre>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is the Express.js Pattern Comparison and when should you use it?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>The Express.js Pattern Comparison addresses a specific category of problems. Think about the conditions that make this pattern valuable - what symptoms in your code suggest you need it? Also consider what alternatives exist and why you might choose this approach over others.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Express.js Pattern Comparison?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Express.js Pattern Comparison provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Express.js Pattern Comparison?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Express.js Pattern Comparison from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-1-foundation-3">Interview Questions - Level 1 (Foundation)</h3>
<p><strong>Q1.1: What's the difference between middleware and filters?</strong></p>
<p><em>Expected Answer:</em> Functionally similar, naming varies by framework:<br />
- <strong>Middleware</strong> (Express, Koa, Go): Wraps handlers, controls whether to call next<br />
- <strong>Filters</strong> (Java Servlet, Spring): Same concept, filter chain pattern<br />
- <strong>Interceptors</strong> (Angular, NestJS): Often split into pre/post phases explicitly</p>
<p>All implement the Decorator pattern for HTTP request/response processing.</p>
<p><strong>Q1.2: Why do most frameworks apply middleware in definition order but decorators wrap inside-out?</strong></p>
<p><em>Expected Answer:</em> It's the same thing viewed differently:<br />
- Definition order: <code>[A, B, C, Handler]</code> means A runs first<br />
- Wrapping order: <code>A(B(C(Handler)))</code> - A is outermost, runs first</p>
<p>Frameworks abstract the wrapping, presenting a linear list for developer ergonomics while constructing the decorator chain internally.</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 1 (Foundation) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 1 (Foundation) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 1 (Foundation)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 1 (Foundation) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-2-mechanics-3">Interview Questions - Level 2 (Mechanics)</h3>
<p><strong>Q2.1: How do you share data between middleware without polluting the request object?</strong></p>
<p><em>Expected Answer:</em> Options:</p>
<ol>
<li><strong>Context (Go)</strong>: <code>context.WithValue()</code> - type-safe, immutable chain</li>
<li><strong>Locals (Express)</strong>: <code>res.locals</code> - mutable, scoped to request</li>
<li><strong>Request attributes (Java)</strong>: <code>request.setAttribute()</code> - standard servlet API</li>
<li><strong>AsyncLocalStorage (Node.js)</strong>: Thread-local-like storage for async</li>
</ol>
<p>Go's context is considered cleanest due to immutability and explicit propagation.</p>
<p><strong>Q2.2: Timeout middleware can't truly abort a running handler. Why, and how do you mitigate?</strong></p>
<p><em>Expected Answer:</em> HTTP handlers can't be forcibly interrupted:<br />
- Handler goroutine/thread continues running<br />
- Response may be partially written before timeout<br />
- Database connections may remain open</p>
<p>Mitigations:</p>
<ol>
<li><strong>Check context</strong>: Handler periodically checks <code>ctx.Done()</code></li>
<li><strong>Database timeouts</strong>: Use context-aware database clients</li>
<li><strong>Response wrapper</strong>: Buffer writes, only flush on success</li>
<li><strong>Circuit breaker</strong>: Track slow handlers, shed load earlier</li>
</ol>
<p>See also: <a href="/topic/design-patterns/circuit-breaker">[Circuit Breaker Pattern]</a> for failure handling.</p>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 2 (Mechanics) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 2 (Mechanics) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 2 (Mechanics)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 2 (Mechanics) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions---level-3-edge-cases--design-3">Interview Questions - Level 3 (Edge Cases &amp; Design)</h3>
<p><strong>Q3.1: Design a middleware that retries failed requests. What problems might occur?</strong></p>
<p><em>Expected Answer:</em><br />
```go<br />
func RetryMiddleware(maxRetries int, backoff time.Duration) Middleware {<br />
return func(next http.Handler) http.Handler {<br />
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br />
// Problem 1: Can't retry if body already consumed<br />
// Solution: Buffer body first<br />
body, _ := io.ReadAll(r.Body)</p>
<pre><code>for attempt := 0; attempt &lt;= maxRetries; attempt++ {
// Problem 2: Need to intercept response
recorder := httptest.NewRecorder()
r.Body = io.NopCloser(bytes.NewReader(body))

next.ServeHTTP(recorder, r)

// Problem 3: What errors are retryable?
if recorder.Code &lt; 500 {
// Copy recorded response to actual writer
for k, v := range recorder.Header() {
w.Header()[k] = v
}
w.WriteHeader(recorder.Code)
w.Write(recorder.Body.Bytes())
return
}

time.Sleep(backoff * time.Duration(attempt+1))
}

http.Error(w, &quot;Service unavailable after retries&quot;, 503)
})
}
}
```
</code></pre>
<p>Problems:<br />
- <strong>Idempotency</strong>: Non-idempotent requests (POST) shouldn't be blindly retried<br />
- <strong>Body consumption</strong>: Request body is a stream, can only read once<br />
- <strong>Memory</strong>: Buffering large bodies is expensive<br />
- <strong>Timing</strong>: Retries may exceed client timeout<br />
- <strong>Duplicate effects</strong>: Partial success before failure</p>
<p><strong>Q3.2: How would you implement middleware that works with both HTTP/1.1 and HTTP/2 Server Push?</strong></p>
<p><em>Expected Answer:</em> This exposes a Decorator limitation - HTTP/2 pusher is an optional capability:</p>
<pre><code class="language-go">func PushMiddleware(assets []string) Middleware {
return func(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
// Check if underlying connection supports push
if pusher, ok := w.(http.Pusher); ok {
for _, asset := range assets {
// Push returns error if push not possible
pusher.Push(asset, nil)
}
}

next.ServeHTTP(w, r)
})
}
}</code></pre>
<p>The pattern challenge: <code>ResponseWriter</code> has optional <code>Pusher</code> interface. When we wrap it (e.g., for logging), we lose the <code>Pusher</code> capability unless we explicitly preserve it:</p>
<pre><code class="language-go">type pushableWrapper struct {
http.ResponseWriter
http.Pusher // Embed if available
}</code></pre>
<p>This is the &quot;lost capabilities through decoration&quot; problem - each wrapper must explicitly preserve all optional interfaces.</p>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions - Level 3 (Edge Cases & Design) in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions - Level 3 (Edge Cases & Design) provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions - Level 3 (Edge Cases & Design)?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions - Level 3 (Edge Cases & Design) from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="related-patterns-and-cross-references">Related Patterns and Cross-References</h2>
<pre><code>- [[Proxy Pattern]](/topic/design-patterns/proxy) - Controls access without adding behavior; Decorator adds behavior without controlling access
- [[Adapter Pattern]](/topic/design-patterns/adapter) - Changes interface; Decorator preserves interface
- [[Chain of Responsibility]](/topic/design-patterns/chain-of-responsibility) - Similar chain structure, but CoR handlers decide whether to process; Decorators always delegate
- [[Composite Pattern]](/topic/design-patterns/composite) - Tree structure; Decorator is linear chain
- [[Strategy Pattern]](/topic/design-patterns/strategy) - Changes algorithm entirely; Decorator wraps and extends
</code></pre>
<h2 id="summary-when-to-use-decorator">Summary: When to Use Decorator</h2>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 2rem 0">
<div style="background: linear-gradient(135deg, #4ecdc422 0%, #4ecdc411 100%);border-radius: 10px; padding: 1.25rem">
<h4 style="color: #4ecdc4; margin: 0 0 0.75rem 0">Use Decorator When</h4>
<ul style="color: #ccc; margin: 0; padding-left: 1.25rem; line-height: 1.8">
<li>Adding responsibilities dynamically</li>
<li>Responsibilities can be withdrawn</li>
<li>Subclassing creates class explosion</li>
<li>Need to combine behaviors flexibly</li>
<li>Modifying third-party code behavior</li>
</ul>
</div>
<div style="background: linear-gradient(135deg, #ff6b6b22 0%, #ff6b6b11 100%);border-radius: 10px; padding: 1.25rem">
<h4 style="color: #ff6b6b; margin: 0 0 0.75rem 0">Avoid Decorator When</h4>
<ul style="color: #ccc; margin: 0; padding-left: 1.25rem; line-height: 1.8">
<li>Single fixed behavior needed</li>
<li>Component interface is unstable</li>
<li>Deep chains cause performance issues</li>
<li>Identity/type checking is important</li>
<li>Decorators need to access each other</li>
</ul>
</div>
</div>
