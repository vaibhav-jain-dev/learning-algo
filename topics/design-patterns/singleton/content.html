<style>
/* Mobile-specific styles for iPhone 15 and similar devices */
@media screen and (max-width: 480px) {
    /* Force all grid layouts to single column */
    [style*="grid-template-columns"] {
        display: block !important;
    }
    [style*="grid-template-columns"] > div {
        margin-bottom: 16px !important;
    }
    /* Adjust padding for mobile */
    [style*="padding: 32px"],
    [style*="padding: 24px"] {
        padding: 16px !important;
    }
    /* Smaller headings */
    h4[style*="font-size: 18px"],
    h4[style*="font-size: 16px"] {
        font-size: 15px !important;
    }
    /* Readable font sizes */
    [style*="font-size: 13px"],
    [style*="font-size: 12px"],
    [style*="font-size: 11px"],
    [style*="font-size: 10px"] {
        font-size: 13px !important;
        line-height: 1.6 !important;
    }
    /* Flex containers stack vertically */
    [style*="display: flex"][style*="gap"] {
        flex-direction: column !important;
    }
    /* Better spacing for nested content */
    [style*="padding-left: 64px"],
    [style*="padding-left: 48px"],
    [style*="padding-left: 40px"] {
        padding-left: 16px !important;
    }
    /* Code blocks */
    pre {
        font-size: 12px !important;
        padding: 12px !important;
        overflow-x: auto !important;
    }
    pre code {
        font-size: 12px !important;
    }
    /* Tables */
    table {
        font-size: 12px !important;
        display: block !important;
        overflow-x: auto !important;
    }
    th, td {
        padding: 8px !important;
        font-size: 12px !important;
    }
}
</style>
<h1 id="singleton-pattern">Singleton Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Singleton pattern ensures a class has only one instance and provides a global point of access to it. It solves the problem of <strong>coordinating access to shared resources</strong> that should exist exactly once in a system - like a database connection pool, configuration manager, or logging service.</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<h4 style="margin-top: 0; color: #1e293b; font-size: 18px">Core Equation</h4>
<div style="font-family: 'Courier New', monospace; font-size: 16px; background: #e2e8f0; padding: 16px; border-radius: 8px; text-align: center; color: #1e293b">
    Singleton = Private Constructor + Static Instance + Global Access Point + Thread Safety
</div>
</div>
<p><strong>Difficulty:</strong> Low conceptually, but tricky to implement correctly<br />
<strong>Category:</strong> Creational Pattern<br />
<strong>Gang of Four Classification:</strong> Object Creational</p>
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; color: white">
<div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 0.75rem">Core Insight</div>
<div style="font-size: 0.95rem; line-height: 1.6">
The Singleton pattern is deceptively simple - the challenge isn't creating a single instance, it's ensuring <span style="color: #10b981; font-weight: 600">exactly one instance exists</span> across all threads, class loaders, and serialization boundaries while remaining <span style="color: #10b981; font-weight: 600">testable</span> and not becoming a hidden dependency nightmare.
</div>
</div>
<p><strong>Critical Assumption</strong>: Singleton assumes that a single instance is truly required and that the instance can be safely shared across all consumers. If different contexts need different configurations, Singleton becomes an anti-pattern.</p>
<p><strong>Key Trade-off</strong>: Global access convenience vs. testability and explicit dependencies. This trade-off drives most criticism of the pattern.</p>
<hr />
<h2 id="why-this-matters">Why This Matters</h2>
<p>Singleton is everywhere in production systems. Understanding it helps you work with major frameworks and make better architectural decisions.</p>
<div style="background: #f8fafc; border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0">Real-World Framework Usage</h4>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px">
<div style="background: white; padding: 16px; border-radius: 8px">
<div style="font-weight: 600; color: #1d4ed8; margin-bottom: 8px">Django</div>
<div style="color: #334155; font-size: 14px">Django's settings module is a singleton. Database connections are pooled using singleton connection managers.</div>
<code style="background: #f1f5f9; padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #475569">django.conf.settings</code>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<div style="font-weight: 600; color: #6d28d9; margin-bottom: 8px">React</div>
<div style="color: #334155; font-size: 14px">Redux store is a singleton. React's reconciler maintains a single instance of the virtual DOM tree.</div>
<code style="background: #f1f5f9; padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #475569">createStore()</code>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<div style="font-weight: 600; color: #b45309; margin-bottom: 8px">Node.js</div>
<div style="color: #334155; font-size: 14px">Module caching makes every required module effectively a singleton. Database clients like Mongoose use this pattern.</div>
<code style="background: #f1f5f9; padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #475569">require.cache</code>
</div>
</div>
</div>
<hr />
<h2 id="internal-mechanisms-and-architecture">Internal Mechanisms and Architecture</h2>
<h3 id="the-singleton-guarantee-problem">The Singleton Guarantee Problem</h3>
<p>Creating a singleton seems trivial until you consider what can break it:</p>
<div style="background: #fef2f2;border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #991b1b; margin-top: 0">Ways to Break Singleton Guarantee</h4>
<div style="display: grid; gap: 12px">
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">1. Race Conditions</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Two threads call <code>getInstance()</code> simultaneously, both see <code>instance == null</code>, both create instances. Result: <span style="color: #dc2626; font-weight: 600">two instances exist</span>.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">2. Reflection Attack</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px"><code>Constructor.setAccessible(true)</code> bypasses private constructor. Malicious code or frameworks can create additional instances.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">3. Serialization/Deserialization</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Deserializing a singleton creates a new instance. Without <code>readResolve()</code>, you get multiple instances.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">5. Cloning</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">If singleton implements <code>Cloneable</code>, <code>clone()</code> can create additional instances. Must override and throw exception.</p>
</div>
</div>
</div>
<hr />
<h2 id="python-thread-safe-implementations">Python Thread-Safe Implementations</h2>
<h3 id="metaclass-singleton-most-pythonic">Metaclass Singleton (Most Pythonic)</h3>
<pre><code class="language-python">import threading
from typing import Dict, Any, TypeVar, Type

T = TypeVar('T')


class SingletonMeta(type):
    &quot;&quot;&quot;
    Thread-safe Singleton metaclass.

    How it works:
    1. Metaclass controls class instantiation via __call__
    2. Lock ensures only one thread creates the instance
    3. Double-checked locking pattern for performance

    This is the RECOMMENDED approach for Python singletons.
    &quot;&quot;&quot;
    _instances: Dict[type, Any] = {}
    _lock: threading.Lock = threading.Lock()

    def __call__(cls: Type[T], *args, **kwargs) -&gt; T:
        # First check without lock (fast path)
        if cls not in cls._instances:
            with cls._lock:
                # Second check with lock (thread safety)
                if cls not in cls._instances:
                    instance = super().__call__(*args, **kwargs)
                    cls._instances[cls] = instance
        return cls._instances[cls]


class DatabaseConnection(metaclass=SingletonMeta):
    &quot;&quot;&quot;Example singleton using metaclass.&quot;&quot;&quot;

    def __init__(self, connection_string: str = &quot;default&quot;):
        # __init__ only runs once due to metaclass
        self.connection_string = connection_string
        self._connection = None
        print(f&quot;DatabaseConnection initialized with {connection_string}&quot;)

    def connect(self):
        if self._connection is None:
            # Create actual connection
            self._connection = self._create_connection()
        return self._connection

    def _create_connection(self):
        # Placeholder for actual connection logic
        return f&quot;Connection to {self.connection_string}&quot;


# Usage - all calls return the same instance
db1 = DatabaseConnection(&quot;postgresql://localhost/mydb&quot;)
db2 = DatabaseConnection(&quot;different_string&quot;)  # Args ignored after first call
assert db1 is db2  # True
</code></pre>
<h3 id="module-level-singleton-pythons-natural-pattern">Module-Level Singleton (Python's Natural Pattern)</h3>
<pre><code class="language-python">&quot;&quot;&quot;
config_singleton.py

In Python, modules are naturally singletons.
The module is loaded once and cached in sys.modules.

This is the SIMPLEST approach for Python singletons.
&quot;&quot;&quot;
import threading
from typing import Any, Dict, Optional
import json
import os


class _ConfigManager:
    &quot;&quot;&quot;Internal configuration manager class.&quot;&quot;&quot;

    def __init__(self):
        self._config: Dict[str, Any] = {}
        self._lock = threading.RLock()
        self._loaded = False

    def load(self, config_path: str) -&gt; 'ConfigManager':
        &quot;&quot;&quot;Load configuration from file (thread-safe).&quot;&quot;&quot;
        with self._lock:
            if not self._loaded:
                with open(config_path, 'r') as f:
                    self._config = json.load(f)
                self._loaded = True
        return self

    def get(self, key: str, default: Any = None) -&gt; Any:
        &quot;&quot;&quot;Get configuration value.&quot;&quot;&quot;
        return self._config.get(key, default)

    def set(self, key: str, value: Any) -&gt; None:
        &quot;&quot;&quot;Set configuration value (thread-safe).&quot;&quot;&quot;
        with self._lock:
            self._config[key] = value


# Module-level singleton instance
config = _ConfigManager()


def get_config() -&gt; _ConfigManager:
    &quot;&quot;&quot;Get the singleton config manager.&quot;&quot;&quot;
    return config
</code></pre>
<h3 id="go-synconce-pattern">Go sync.Once Pattern</h3>
<pre><code class="language-go">package singleton

import (
    &quot;sync&quot;
    &quot;database/sql&quot;
)

// ConfigManager is a singleton configuration holder
type ConfigManager struct {
    settings map[string]interface{}
    mu       sync.RWMutex
}

var (
    instance *ConfigManager
    once     sync.Once
)

// GetInstance returns the singleton ConfigManager
// sync.Once guarantees this function body executes exactly once,
// even when called from multiple goroutines simultaneously.
func GetInstance() *ConfigManager {
    once.Do(func() {
        // This block executes exactly once
        instance = &amp;ConfigManager{
            settings: make(map[string]interface{}),
        }
        instance.loadDefaults()
    })
    return instance
}

func (c *ConfigManager) loadDefaults() {
    c.settings[&quot;environment&quot;] = &quot;development&quot;
    c.settings[&quot;debug&quot;] = true
}

// Get retrieves a setting (read-locked)
func (c *ConfigManager) Get(key string) interface{} {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.settings[key]
}

// Set updates a setting (write-locked)
func (c *ConfigManager) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.settings[key] = value
}
</code></pre>
<div style="background: #f0fdf4;padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 0 8px 8px 0">
<div style="font-weight: 700; color: #166534; margin-bottom: 0.5rem">Why sync.Once is Perfect for Go</div>
<div style="color: #14532d; font-size: 0.9rem; line-height: 1.6">
<code>sync.Once</code> is specifically designed for one-time initialization. It uses atomic operations internally and is <span style="color: #10b981; font-weight: 600">wait-free after initialization</span>. The first goroutine to call <code>Do()</code> executes the function; all others wait until it completes, then return immediately. This is the <span style="color: #10b981; font-weight: 600">idiomatic Go approach</span> for singletons.
</div>
</div>
<hr />
<h2 id="testing-challenges-and-solutions">Testing Challenges and Solutions</h2>
<div style="background: #fef2f2;border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #991b1b; margin-top: 0">Why Singletons Are Hard to Test</h4>
<div style="display: grid; gap: 16px">
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">1. Global State Pollution</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Singleton state persists across tests. Test A modifies singleton, Test B sees modified state. Tests become order-dependent and flaky.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">2. Cannot Mock Dependencies</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Code that uses <code>Singleton.getInstance()</code> is tightly coupled. You can't inject a mock - the real singleton is always used.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">3. Hidden Dependencies</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Singleton calls are often buried deep in code. You don't see them in constructor/method signatures, making dependencies invisible.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #991b1b">4. Parallel Test Execution</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Multiple test threads sharing singleton state causes race conditions. Tests pass individually but fail when run together.</p>
</div>
</div>
</div>
<h3 id="solution-1-interface--dependency-injection">Solution 1: Interface + Dependency Injection</h3>
<pre><code class="language-python">"""
Solution: Program to interface, inject dependency

Instead of code calling Singleton.get_instance(),
inject the dependency explicitly.
"""

from abc import ABC, abstractmethod
from typing import Optional


class ConfigService(ABC):
    """Interface for configuration service."""

    @abstractmethod
    def get(self, key: str) -> Optional[str]:
        pass

    @abstractmethod
    def set(self, key: str, value: str) -> None:
        pass


class ConfigServiceImpl(ConfigService):
    """Real implementation (singleton internally)."""

    _instance: Optional['ConfigServiceImpl'] = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._config = {}
        return cls._instance

    def get(self, key: str) -> Optional[str]:
        return self._config.get(key)

    def set(self, key: str, value: str) -> None:
        self._config[key] = value


class OrderService:
    """Code that uses config - receives it via injection."""

    def __init__(self, config: ConfigService):
        self.config = config

    def process_order(self, order):
        max_items = self.config.get("max_items_per_order")
        # ... use config


# In production
service = OrderService(ConfigServiceImpl())

# In tests - inject mock
from unittest.mock import Mock
mock_config = Mock(spec=ConfigService)
mock_config.get.return_value = "100"
test_service = OrderService(mock_config)
</code></pre>
<h3 id="solution-2-reset-method-for-testing">Solution 2: Reset Method for Testing</h3>
<pre><code class="language-python">&quot;&quot;&quot;
Solution: Provide a reset method for tests.
This is a pragmatic approach when refactoring to DI isn't feasible.
&quot;&quot;&quot;
import threading
from typing import Optional


class CacheManager:
    &quot;&quot;&quot;Singleton with test reset capability.&quot;&quot;&quot;

    _instance: Optional['CacheManager'] = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self._initialized = True
        self._cache = {}

    def get(self, key: str):
        return self._cache.get(key)

    def set(self, key: str, value):
        self._cache[key] = value

    @classmethod
    def _reset_for_testing(cls):
        &quot;&quot;&quot;
        Reset singleton state for testing.

        WARNING: Only use in test code!
        Consider using environment variable check:
        if os.environ.get('TESTING') != 'true':
            raise RuntimeError(&quot;_reset_for_testing only allowed in tests&quot;)
        &quot;&quot;&quot;
        with cls._lock:
            cls._instance = None


# In tests
import pytest

@pytest.fixture(autouse=True)
def reset_singleton():
    &quot;&quot;&quot;Reset singleton before each test.&quot;&quot;&quot;
    yield
    CacheManager._reset_for_testing()


def test_cache_set_get():
    cache = CacheManager()
    cache.set(&quot;key&quot;, &quot;value&quot;)
    assert cache.get(&quot;key&quot;) == &quot;value&quot;


def test_cache_empty():
    cache = CacheManager()
    # This would fail without reset - it would see previous test's data
    assert cache.get(&quot;key&quot;) is None
</code></pre>
<h3 id="solution-3-scoped-singletons-per-requestper-thread">Solution 3: Scoped Singletons (Per-Request/Per-Thread)</h3>
<pre><code class="language-python">&quot;&quot;&quot;
Solution: Use scoped singletons instead of global singletons.
Each test gets its own scope, preventing cross-contamination.
&quot;&quot;&quot;
import threading
from contextvars import ContextVar
from typing import TypeVar, Generic, Callable

T = TypeVar('T')


class ScopedSingleton(Generic[T]):
    &quot;&quot;&quot;
    Context-scoped singleton using contextvars.

    Each async context/thread can have its own instance.
    Perfect for web request handling where you want
    &quot;one per request&quot; instead of &quot;one per application&quot;.
    &quot;&quot;&quot;

    def __init__(self, factory: Callable[[], T]):
        self._factory = factory
        self._context_var: ContextVar[T] = ContextVar('scoped_singleton')

    def get(self) -&gt; T:
        &quot;&quot;&quot;Get or create instance for current context.&quot;&quot;&quot;
        try:
            return self._context_var.get()
        except LookupError:
            instance = self._factory()
            self._context_var.set(instance)
            return instance

    def set(self, instance: T) -&gt; None:
        &quot;&quot;&quot;Explicitly set instance (useful for testing).&quot;&quot;&quot;
        self._context_var.set(instance)


# Usage
class RequestContext:
    def __init__(self):
        self.user_id = None
        self.request_id = None

request_context = ScopedSingleton(RequestContext)

# In request handler
ctx = request_context.get()
ctx.user_id = authenticated_user_id

# In tests - each test gets fresh context
def test_something():
    ctx = request_context.get()  # Fresh instance for this test
    assert ctx.user_id is None
</code></pre>
<hr />
<h2 id="interview-deep-dive-thread-safe-implementations">Interview Deep-Dive: Thread-Safe Implementations</h2>
<div style="background: #eff6ff;border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e40af; margin-top: 0">Level 1: What are the main approaches to implement a thread-safe singleton?</h4>
<p style="color: #1e293b; line-height: 1.7"><strong>Answer:</strong> The main approaches depend on the language. For Python: (1) <span style="color: #10b981; font-weight: 600">Module-level singleton</span> - simplest approach, modules are cached. (2) <span style="color: #10b981; font-weight: 600">Metaclass with double-checked locking</span> - control instantiation at metaclass level with thread safety. (3) <span style="color: #10b981; font-weight: 600">Decorator pattern</span> - wrap classes with singleton behavior. For Go: Use <span style="color: #10b981; font-weight: 600">sync.Once</span> - guaranteed one-time initialization with built-in thread safety.</p>
<div style="background: white; border-radius: 8px; padding: 20px; margin-top: 16px">
<h5 style="color: #1e40af; margin-top: 0">Level 2: What are the thread-safety considerations when implementing singletons in Python?</h5>
<p style="color: #1e293b; line-height: 1.7"><strong>Answer:</strong> Python's GIL (Global Interpreter Lock) provides some thread safety, but you still need explicit locking for singleton creation. The race condition occurs when: (1) Thread A checks if instance exists (None), (2) Thread B checks simultaneously (also None), (3) Both threads create instances. Solution: Use double-checked locking with threading.Lock - check instance without lock (fast path), acquire lock only if None, check again inside lock. This pattern minimizes lock contention while ensuring thread safety. The metaclass approach is preferred as it centralizes this logic.</p>
<div style="background: #f8fafc; border-radius: 8px; padding: 16px; margin-top: 12px">
<h6 style="color: #1e40af; margin-top: 0">Level 3: Design a singleton that can be configured with different implementations at startup (like a test mode vs production mode) while maintaining thread safety and singleton guarantees.</h6>
<p style="color: #1e293b; line-height: 1.7; font-size: 14px"><strong>Answer:</strong> Use a configurable holder pattern with interface-based design and environment detection. Create an abstract base class defining the interface, then implement concrete classes for production and test modes. Use a holder module that detects the environment (via environment variables or configuration) during first import and instantiates the appropriate implementation. For runtime configuration, implement a configure() method that must be called before first use - use threading.Lock with a _configured flag to ensure it's only called once. Store the factory function and lazily create the instance on first access. This pattern is used by logging frameworks where you configure the backend at startup. For testing, set the environment variable or call configure() with the test implementation before any code accesses the singleton.</p>
</div>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-testing-challenges">Interview Deep-Dive: Testing Challenges</h2>
<div style="background: #eff6ff;border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e40af; margin-top: 0">Level 1: Why are singletons considered difficult to test?</h4>
<p style="color: #1e293b; line-height: 1.7"><strong>Answer:</strong> Singletons create <span style="color: #10b981; font-weight: 600">hidden dependencies</span> and <span style="color: #10b981; font-weight: 600">global state</span>. Tests cannot run in isolation because the singleton maintains state across tests. You cannot easily substitute a mock implementation because code calls <code>Singleton.getInstance()</code> directly rather than receiving the dependency. Tests become order-dependent - Test A might pass alone but fail after Test B modifies the singleton. Parallel test execution becomes problematic due to shared mutable state.</p>
<div style="background: white; border-radius: 8px; padding: 20px; margin-top: 16px">
<h5 style="color: #1e40af; margin-top: 0">Level 2: How would you refactor existing code that uses singletons to make it testable without a complete rewrite?</h5>
<p style="color: #1e293b; line-height: 1.7"><strong>Answer:</strong> Use the <span style="color: #10b981; font-weight: 600">"Seam" approach</span>: (1) Extract an interface from the singleton class. (2) Make <code>getInstance()</code> return the interface type. (3) Add a package-private <code>setInstance(Interface impl)</code> method for testing. (4) In tests, call <code>setInstance(mockImpl)</code> before the code under test. (5) Reset in <code>@After</code> or use try-finally. This maintains backward compatibility - existing code still calls <code>getInstance()</code> - while allowing test injection. For new code, refactor to constructor injection gradually. Related: See [[dependency-injection]](/topic/design-patterns/dependency-injection) for the full DI pattern.</p>
<div style="background: #f8fafc; border-radius: 8px; padding: 16px; margin-top: 12px">
<h6 style="color: #1e40af; margin-top: 0">Level 3: Design a testing strategy for a system where 50+ classes depend on a DatabaseConnection singleton, some of which need real database access in integration tests while unit tests need mocks.</h6>
<p style="color: #1e293b; line-height: 1.7; font-size: 14px"><strong>Answer:</strong> Implement a <span style="color: #10b981; font-weight: 600">layered singleton with environment-aware initialization</span>:
  <br/><br/>
(1) <strong>Interface Layer:</strong> Define abstract <code>DatabaseConnection</code> base class with all public methods.
  <br/><br/>
(2) <strong>Provider Pattern:</strong> Create <code>DatabaseConnectionProvider</code> singleton that returns the appropriate implementation:
  <br/>
        - In production: returns the real pooled connection
  <br/>
- In unit tests: returns a mock (detect via <code>os.environ.get("TEST_MODE")</code> or pytest detection)
  <br/>
        - In integration tests: returns a test database connection (SQLite in-memory or testcontainers)
  <br/><br/>
(3) <strong>Scoped Instances:</strong> For unit tests, use contextvars scoped instances so parallel tests don't interfere.
  <br/><br/>
(4) <strong>Reset Hooks:</strong> Integration tests get a fresh database state via pytest fixtures that truncate tables or restore from snapshot.
  <br/><br/>
(5) <strong>Gradual Migration:</strong> New code uses constructor injection with the provider as default. Old code continues using <code>get_instance()</code> which delegates to the provider.
  <br/><br/>
This approach lets you run: unit tests (fast, mocked), integration tests (real DB, isolated), and E2E tests (production config) - all with the same codebase and minimal changes to existing code.</p>
</div>
</div>
</div>
<hr />
<h2 id="singleton-in-distributed-systems">Singleton in Distributed Systems</h2>
<div style="background: linear-gradient(135deg, #ea580c 0%, #fb923c 100%); border-radius: 16px; padding: 28px; margin: 24px 0; color: white">
<h4 style="margin-top: 0; color: white">The Distributed Singleton Challenge</h4>
<p style="color: #fed7aa; margin-bottom: 0">In distributed systems, "singleton" becomes a logical concept - you can't have a true JVM singleton across multiple processes. The challenge shifts to ensuring <span style="font-weight: 700">only one logical instance operates at a time</span> across the cluster.</p>
</div>
<div style="background: #f8fafc; border-radius: 16px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0">Distributed Singleton Patterns</h4>
<div style="display: grid; gap: 16px">
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #1e40af">Leader Election</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Use Zookeeper, etcd, or Consul for leader election. Only the leader node runs the singleton logic. On leader failure, another node is elected. See [[distributed-coordination]](/topic/system-design/distributed-systems).</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #166534">Distributed Locks</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Use Redis SETNX or Redlock for distributed locking. Singleton operation acquires lock, processes, releases lock. See [[distributed-locking]](/topic/system-design/distributed-locking).</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #92400e">Database Unique Constraint</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">For ID generation, use database auto-increment or unique constraints. Only one row can have a given ID - the database enforces singleton-like uniqueness.</p>
</div>
<div style="background: white; padding: 16px; border-radius: 8px">
<strong style="color: #6d28d9">Idempotent Operations</strong>
<p style="color: #475569; margin: 8px 0 0 0; font-size: 14px">Design operations to be idempotent - running them multiple times has the same effect as once. This sidesteps the singleton requirement by making duplicates harmless.</p>
</div>
</div>
</div>
<hr />
<h2 id="anti-patterns-and-code-smells">Anti-Patterns and Code Smells</h2>
<div style="background: #fef2f2;border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #991b1b; margin-top: 0">Singleton Anti-Patterns to Avoid</h4>
<div style="margin-bottom: 20px; padding-bottom: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">1. The God Singleton</div>
<div style="color: #7f1d1d; font-size: 14px; line-height: 1.6">
<strong>Problem:</strong> A singleton that does everything - config, logging, caching, database, business logic.
  <br/>
<strong>Solution:</strong> Follow Single Responsibility Principle. Create separate singletons or use [[facade]](/topic/design-patterns/facade) to coordinate them.
</div>
</div>
<div style="margin-bottom: 20px; padding-bottom: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">2. Singleton for Convenience</div>
<div style="color: #7f1d1d; font-size: 14px; line-height: 1.6">
<strong>Problem:</strong> Using singleton just to avoid passing objects around, not because single instance is required.
  <br/>
<strong>Solution:</strong> Use dependency injection. If you need easy access, that's what DI containers are for.
</div>
</div>
<div style="margin-bottom: 20px; padding-bottom: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">3. Mutable Singleton State</div>
<div style="color: #7f1d1d; font-size: 14px; line-height: 1.6">
<strong>Problem:</strong> Singleton that allows arbitrary state modification from anywhere in the codebase.
  <br/>
<strong>Solution:</strong> Prefer immutable singletons or restrict mutation to specific methods with clear semantics.
</div>
</div>
<div style="margin-bottom: 20px; padding-bottom: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">4. User-Specific Data in Singleton</div>
<div style="color: #7f1d1d; font-size: 14px; line-height: 1.6">
<strong>Problem:</strong> Storing user session, preferences, or context in a singleton shared across all users.
  <br/>
<strong>Solution:</strong> Use request-scoped or session-scoped containers. Store user data in thread-locals or context objects.
</div>
</div>
<div>
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">5. Singleton Masking Design Problems</div>
<div style="color: #7f1d1d; font-size: 14px; line-height: 1.6">
<strong>Problem:</strong> Adding a singleton to "fix" a problem caused by poor design elsewhere.
  <br/>
<strong>Solution:</strong> Address the root cause. Often the real problem is missing abstraction or incorrect object ownership.
</div>
</div>
</div>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; color: white">
<div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 1rem">Interview Checklist</div>
<ul style="margin: 0; padding-left: 1.5rem; line-height: 1.8">
<li><strong>Definition:</strong> Ensures exactly one instance with global access point</li>
<li><strong>Thread Safety:</strong> Requires explicit handling with locks or language-specific mechanisms</li>
<li><strong>Best Python Approach:</strong> Module-level instance or metaclass with thread-safe initialization</li>
<li><strong>Best Go Approach:</strong> sync.Once pattern for guaranteed one-time initialization</li>
<li><strong>Testing Strategy:</strong> Interface + DI, or reset methods with caution</li>
<li><strong>Common Pitfall:</strong> Using singleton for convenience instead of necessity</li>
<li><strong>Distributed Systems:</strong> Use leader election, distributed locks, or idempotent design</li>
</ul>
</div>
<div style="background: #f8fafc; border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0; margin-bottom: 12px">Decision Checklist: Should You Use Singleton?</h4>
<div style="display: flex; flex-wrap: wrap; gap: 8px">
<span style="background: #dcfce7; color: #166534; padding: 6px 12px; border-radius: 4px; font-size: 13px">Is exactly ONE instance required?</span>
<span style="background: #dcfce7; color: #166534; padding: 6px 12px; border-radius: 4px; font-size: 13px">Would multiple instances cause problems?</span>
<span style="background: #dcfce7; color: #166534; padding: 6px 12px; border-radius: 4px; font-size: 13px">Is state minimal or read-only?</span>
<span style="background: #fef3c7; color: #92400e; padding: 6px 12px; border-radius: 4px; font-size: 13px">Can you use DI instead?</span>
<span style="background: #fef3c7; color: #92400e; padding: 6px 12px; border-radius: 4px; font-size: 13px">How will you test it?</span>
<span style="background: #fee2e2; color: #991b1b; padding: 6px 12px; border-radius: 4px; font-size: 13px">Is this just for convenience?</span>
</div>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.1rem">Pattern Relationships</div>
<div style="display: grid; gap: 1rem">
<div style="background: #dbeafe; padding: 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #1e40af">[[Factory Method]](/topic/design-patterns/factory-method)</div>
<div style="font-size: 0.9rem; color: #1e40af">Often returns singleton instances. Factory can hide singleton implementation details from clients.</div>
</div>
<div style="background: #dcfce7; padding: 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #166534">[[Abstract Factory]](/topic/design-patterns/abstract-factory)</div>
<div style="font-size: 0.9rem; color: #166534">Frequently implemented as singleton since you typically need only one factory per family of products.</div>
</div>
<div style="background: #fef3c7; padding: 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #92400e">[[Builder]](/topic/design-patterns/builder)</div>
<div style="font-size: 0.9rem; color: #92400e">Can be used to construct complex singleton instances with many configuration options.</div>
</div>
<div style="background: #fce7f3; padding: 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #9d174d">[[Dependency Injection]](/topic/design-patterns/dependency-injection)</div>
<div style="font-size: 0.9rem; color: #9d174d">The modern alternative to singleton. DI containers manage singleton lifecycle while preserving testability.</div>
</div>
<div style="background: #e0e7ff; padding: 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #3730a3">[[Flyweight]](/topic/design-patterns/flyweight)</div>
<div style="font-size: 0.9rem; color: #3730a3">Shares instances but allows multiple flyweights. Singleton is the extreme case of one shared instance.</div>
</div>
<div style="background: #f3e8ff; padding: 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #7c3aed">[[State]](/topic/design-patterns/state)</div>
<div style="font-size: 0.9rem; color: #7c3aed">State objects are often implemented as singletons since they're stateless and can be shared.</div>
</div>
</div>
</div>
