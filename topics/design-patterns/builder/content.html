<h1 id="builder-pattern">Builder Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations. It's essential when creating objects with many optional parameters or multi-step initialization.</p>
<p><strong>Difficulty:</strong> Intermediate<br />
<strong>Category:</strong> Creational Pattern<br />
<strong>First Documented:</strong> GoF (1994)</p>
<hr />
<h2 id="simple-explanation-the-subway-sandwich-analogy">Simple Explanation: The Subway Sandwich Analogy</h2>
<div>
<h3>Think of Building a Subway Sandwich</h3>
<p>
    When you order at Subway, you don't just say "give me a sandwich." Instead, you go through a step-by-step process:
</p>
<div>
<div>
<span>1</span>
<span>Choose bread</span>
</div>
<div>
<span>2</span>
<span>Pick protein</span>
</div>
<div>
<span>3</span>
<span>Add cheese</span>
</div>
<div>
<span>4</span>
<span>Select veggies</span>
</div>
<div>
<span>5</span>
<span>Add sauces</span>
</div>
</div>
<p>
<strong>The sandwich artist (Builder)</strong> follows your instructions step by step.<br>
<strong>You (Director)</strong> specify the configuration.<br>
<strong>The sandwich (Product)</strong> is built piece by piece and given to you at the end.
</p>
<div>
<strong>The Key Insight:</strong>
<span> You can skip steps (no cheese), customize each step (extra pickles), or follow preset recipes (the "Italian BMT" combo) - all using the same construction process.</span>
</div>
</div>
<pre><code>---
</code></pre>
<h2 id="real-company-usage">Real Company Usage</h2>
<div>
<table>
<thead>
<tr>
<th>Company</th>
<th>How They Use Builder Pattern</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Stripe</strong></td>
<td>API request builders for complex payment configurations</td>
</tr>
<tr>
<td><strong>AWS SDK</strong></td>
<td>Service client builders (S3ClientBuilder, DynamoDBClientBuilder)</td>
</tr>
<tr>
<td><strong>Elasticsearch</strong></td>
<td>Query builders for complex search queries</td>
</tr>
<tr>
<td><strong>OkHttp</strong></td>
<td>Request.Builder for HTTP requests with headers, body, timeouts</td>
</tr>
<tr>
<td><strong>Retrofit</strong></td>
<td>Retrofit.Builder for API client configuration</td>
</tr>
<tr>
<td><strong>Protocol Buffers</strong></td>
<td>Message builders for creating complex protobuf messages</td>
</tr>
<tr>
<td><strong>StringBuilder</strong></td>
<td>Classic example in Java/C# for efficient string construction</td>
</tr>
</tbody>
</table>
</div>
<pre><code>---
</code></pre>
<h2 id="pattern-structure">Pattern Structure</h2>
<div>
<h4>Builder Pattern Structure</h4>
<div>
  <!-- Director -->
<div>
<div>Director</div>
<div>
<code>+ construct(builder)</code><br>
<code>+ makePreset()</code>
</div>
</div>
<div>uses &#8595;</div>
  <!-- Builder Interface -->
<div>
<div>Builder (interface)</div>
<div>
<code>+ buildPartA()</code><br>
<code>+ buildPartB()</code><br>
<code>+ buildPartC()</code><br>
<code>+ getResult(): Product</code>
</div>
</div>
<div>&#9651;</div>
  <!-- Concrete Builders -->
<div>
<div>
<div>ConcreteBuilderA</div>
<div>
  Builds ProductA
</div>
</div>
<div>
<div>ConcreteBuilderB</div>
<div>
  Builds ProductB
</div>
</div>
</div>
</div>
<div>
<strong>Flow:</strong>
<span> Director calls builder methods in sequence. Builder accumulates state. Client calls <code>getResult()</code> to get the final product.</span>
</div>
</div>
<hr />
<h2 id="when-to-use-builder-pattern">When to Use Builder Pattern</h2>
<div>
<h3 id="good-use-cases">Good Use Cases</h3>
<ol>
<li><strong>Many Constructor Parameters</strong> - Objects with 4+ parameters, especially optional ones</li>
<li><strong>Immutable Objects</strong> - Build complex immutable objects step by step</li>
<li><strong>Fluent APIs</strong> - Create readable, chainable configuration code</li>
<li><strong>Telescoping Constructor Problem</strong> - Avoid multiple constructor overloads</li>
<li><strong>Complex Object Graphs</strong> - Objects with nested complex structures</li>
<li><strong>Test Data Builders</strong> - Create test fixtures with sensible defaults</li>
</ol>
</div>
<div>
<h3 id="the-telescoping-constructor-problem">The Telescoping Constructor Problem</h3>
<pre><code>          ```python
          # BAD: Telescoping constructors
          class Pizza:
          def __init__(self, size):
          self.size = size
          def __init__(self, size, cheese):
          self.size = size
          self.cheese = cheese
          def __init__(self, size, cheese, pepperoni):
          # ... this gets out of hand quickly!

          # GOOD: Builder pattern
          pizza = (
          PizzaBuilder()
          .size(&quot;large&quot;)
          .cheese(&quot;mozzarella&quot;)
          .pepperoni(True)
          .build()
          )
          ```
</code></pre>
</div>
<hr />
<h2 id="anti-patterns-when-not-to-use">Anti-Patterns: When NOT to Use</h2>
<div>
<h3 id="common-mistakes">Common Mistakes</h3>
<ol>
<li><strong>Simple Objects</strong> - Don't use builder for objects with 2-3 required parameters</li>
<li><strong>Mutable Objects</strong> - If object can be modified after creation, builder adds unnecessary complexity</li>
<li><strong>Over-Engineering</strong> - If you never need different configurations, skip the pattern</li>
<li><strong>When Dataclasses Suffice</strong> - Python dataclasses with defaults often eliminate the need</li>
</ol>
</div>
<pre><code>        ```python
        # OVERKILL: Builder for simple object
        class PointBuilder:  # Don't do this!
        def x(self, x): ...
        def y(self, y): ...
        def build(self): return Point(self._x, self._y)

        # BETTER: Just use the constructor or dataclass
        @dataclass
        class Point:
        x: float
        y: float

        point = Point(10, 20)  # Simple and clear
        ```
</code></pre>
<hr />
<h2 id="python-implementation">Python Implementation</h2>
<h3 id="fluent-builder-most-common">Fluent Builder (Most Common)</h3>
<pre><code>        ```python
        from __future__ import annotations
        from dataclasses import dataclass, field
        from typing import List, Optional, Dict, Any
        from enum import Enum


        class Priority(Enum):
        LOW = &quot;low&quot;
        NORMAL = &quot;normal&quot;
        HIGH = &quot;high&quot;
        URGENT = &quot;urgent&quot;


        @dataclass(frozen=True)  # Immutable product
        class Email:
        sender: str
        recipients: List[str]
        subject: str
        body: str
        cc: List[str] = field(default_factory=list)
        bcc: List[str] = field(default_factory=list)
        attachments: List[str] = field(default_factory=list)
        is_html: bool = False
        priority: Priority = Priority.NORMAL
        headers: Dict[str, str] = field(default_factory=dict)


        class EmailBuilder:
        &quot;&quot;&quot;
        Fluent builder for creating Email objects.
        Returns self from each method to enable chaining.
        &quot;&quot;&quot;

        def __init__(self):
        self._sender: str = &quot;&quot;
        self._recipients: List[str] = []
        self._subject: str = &quot;&quot;
        self._body: str = &quot;&quot;
        self._cc: List[str] = []
        self._bcc: List[str] = []
        self._attachments: List[str] = []
        self._is_html: bool = False
        self._priority: Priority = Priority.NORMAL
        self._headers: Dict[str, str] = {}

        def from_address(self, sender: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Set the sender email address.&quot;&quot;&quot;
        self._sender = sender
        return self

        def to(self, *recipients: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Add one or more recipients.&quot;&quot;&quot;
        self._recipients.extend(recipients)
        return self

        def cc(self, *recipients: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Add CC recipients.&quot;&quot;&quot;
        self._cc.extend(recipients)
        return self

        def bcc(self, *recipients: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Add BCC recipients.&quot;&quot;&quot;
        self._bcc.extend(recipients)
        return self

        def subject(self, subject: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Set the email subject.&quot;&quot;&quot;
        self._subject = subject
        return self

        def body(self, body: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Set plain text body.&quot;&quot;&quot;
        self._body = body
        self._is_html = False
        return self

        def html_body(self, body: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Set HTML body.&quot;&quot;&quot;
        self._body = body
        self._is_html = True
        return self

        def attach(self, *files: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Attach files to the email.&quot;&quot;&quot;
        self._attachments.extend(files)
        return self

        def priority(self, priority: Priority) -&gt; EmailBuilder:
        &quot;&quot;&quot;Set email priority.&quot;&quot;&quot;
        self._priority = priority
        return self

        def header(self, name: str, value: str) -&gt; EmailBuilder:
        &quot;&quot;&quot;Add a custom header.&quot;&quot;&quot;
        self._headers[name] = value
        return self

        def build(self) -&gt; Email:
        &quot;&quot;&quot;
        Build and validate the Email object.
        Raises ValueError if required fields are missing.
        &quot;&quot;&quot;
        # Validation
        if not self._sender:
        raise ValueError(&quot;Sender is required&quot;)
        if not self._recipients:
        raise ValueError(&quot;At least one recipient is required&quot;)
        if not self._subject:
        raise ValueError(&quot;Subject is required&quot;)

        return Email(
        sender=self._sender,
        recipients=list(self._recipients),
        subject=self._subject,
        body=self._body,
        cc=list(self._cc),
        bcc=list(self._bcc),
        attachments=list(self._attachments),
        is_html=self._is_html,
        priority=self._priority,
        headers=dict(self._headers)
        )


        # Usage - fluent and readable
        email = (
        EmailBuilder()
        .from_address(&quot;noreply@company.com&quot;)
        .to(&quot;user@example.com&quot;, &quot;manager@example.com&quot;)
        .cc(&quot;team@company.com&quot;)
        .subject(&quot;Q4 Report Ready&quot;)
</code></pre>
<p>.html_body(&quot;<h1>Report</h1><p>The Q4 report is attached.</p>&quot;)<br />
.attach(&quot;q4_report.pdf&quot;, &quot;charts.xlsx&quot;)<br />
.priority(Priority.HIGH)<br />
.header(&quot;X-Campaign-ID&quot;, &quot;q4-2024&quot;)<br />
.build()<br />
)</p>
<pre><code>        print(f&quot;Sending to {len(email.recipients)} recipients&quot;)
        print(f&quot;Subject: {email.subject}&quot;)
        print(f&quot;Priority: {email.priority.value}&quot;)
        ```
</code></pre>
<h3 id="builder-with-director">Builder with Director</h3>
<pre><code>        ```python
        from abc import ABC, abstractmethod
        from dataclasses import dataclass
        from typing import List, Optional


        @dataclass
        class Computer:
        &quot;&quot;&quot;Product - the complex object being built.&quot;&quot;&quot;
        cpu: str = &quot;&quot;
        ram_gb: int = 0
        storage_gb: int = 0
        gpu: Optional[str] = None
        os: str = &quot;&quot;
        peripherals: List[str] = None

        def __post_init__(self):
        if self.peripherals is None:
        self.peripherals = []

        def specs(self) -&gt; str:
        specs = [
        f&quot;CPU: {self.cpu}&quot;,
        f&quot;RAM: {self.ram_gb}GB&quot;,
        f&quot;Storage: {self.storage_gb}GB&quot;,
        f&quot;OS: {self.os}&quot;
        ]
        if self.gpu:
        specs.append(f&quot;GPU: {self.gpu}&quot;)
        if self.peripherals:
        specs.append(f&quot;Peripherals: {', '.join(self.peripherals)}&quot;)
        return &quot; | &quot;.join(specs)


        class ComputerBuilder(ABC):
        &quot;&quot;&quot;Abstract builder interface.&quot;&quot;&quot;

        def __init__(self):
        self._computer = Computer()

        @abstractmethod
        def set_cpu(self) -&gt; 'ComputerBuilder':
        pass

        @abstractmethod
        def set_ram(self) -&gt; 'ComputerBuilder':
        pass

        @abstractmethod
        def set_storage(self) -&gt; 'ComputerBuilder':
        pass

        def set_gpu(self) -&gt; 'ComputerBuilder':
        &quot;&quot;&quot;Optional step - default does nothing.&quot;&quot;&quot;
        return self

        @abstractmethod
        def set_os(self) -&gt; 'ComputerBuilder':
        pass

        def add_peripherals(self) -&gt; 'ComputerBuilder':
        &quot;&quot;&quot;Optional step - default does nothing.&quot;&quot;&quot;
        return self

        def get_result(self) -&gt; Computer:
        return self._computer


        class GamingPCBuilder(ComputerBuilder):
        &quot;&quot;&quot;Concrete builder for gaming PCs.&quot;&quot;&quot;

        def set_cpu(self) -&gt; 'GamingPCBuilder':
        self._computer.cpu = &quot;Intel i9-13900K&quot;
        return self

        def set_ram(self) -&gt; 'GamingPCBuilder':
        self._computer.ram_gb = 64
        return self

        def set_storage(self) -&gt; 'GamingPCBuilder':
        self._computer.storage_gb = 2000  # 2TB NVMe
        return self

        def set_gpu(self) -&gt; 'GamingPCBuilder':
        self._computer.gpu = &quot;NVIDIA RTX 4090&quot;
        return self

        def set_os(self) -&gt; 'GamingPCBuilder':
        self._computer.os = &quot;Windows 11 Pro&quot;
        return self

        def add_peripherals(self) -&gt; 'GamingPCBuilder':
        self._computer.peripherals = [
        &quot;Mechanical Keyboard&quot;,
        &quot;Gaming Mouse&quot;,
        &quot;27\&quot; 4K Monitor&quot;
        ]
        return self


        class OfficePCBuilder(ComputerBuilder):
        &quot;&quot;&quot;Concrete builder for office workstations.&quot;&quot;&quot;

        def set_cpu(self) -&gt; 'OfficePCBuilder':
        self._computer.cpu = &quot;Intel i5-13400&quot;
        return self

        def set_ram(self) -&gt; 'OfficePCBuilder':
        self._computer.ram_gb = 16
        return self

        def set_storage(self) -&gt; 'OfficePCBuilder':
        self._computer.storage_gb = 512
        return self

        def set_os(self) -&gt; 'OfficePCBuilder':
        self._computer.os = &quot;Windows 11 Business&quot;
        return self

        def add_peripherals(self) -&gt; 'OfficePCBuilder':
        self._computer.peripherals = [
        &quot;Standard Keyboard&quot;,
        &quot;Optical Mouse&quot;,
        &quot;24\&quot; Monitor&quot;
        ]
        return self


        class ServerBuilder(ComputerBuilder):
        &quot;&quot;&quot;Concrete builder for servers.&quot;&quot;&quot;

        def set_cpu(self) -&gt; 'ServerBuilder':
        self._computer.cpu = &quot;AMD EPYC 9654 (96 cores)&quot;
        return self

        def set_ram(self) -&gt; 'ServerBuilder':
        self._computer.ram_gb = 512
        return self

        def set_storage(self) -&gt; 'ServerBuilder':
        self._computer.storage_gb = 10000  # 10TB RAID
        return self

        def set_os(self) -&gt; 'ServerBuilder':
        self._computer.os = &quot;Ubuntu Server 22.04 LTS&quot;
        return self


        class ComputerDirector:
        &quot;&quot;&quot;
        Director - knows HOW to build specific configurations.
        Encapsulates construction algorithms.
        &quot;&quot;&quot;

        def __init__(self, builder: ComputerBuilder):
        self._builder = builder

        def build_minimal(self) -&gt; Computer:
        &quot;&quot;&quot;Build with only required components.&quot;&quot;&quot;
        return (
        self._builder
        .set_cpu()
        .set_ram()
        .set_storage()
        .set_os()
        .get_result()
        )

        def build_full(self) -&gt; Computer:
        &quot;&quot;&quot;Build with all optional components.&quot;&quot;&quot;
        return (
        self._builder
        .set_cpu()
        .set_ram()
        .set_storage()
        .set_gpu()
        .set_os()
        .add_peripherals()
        .get_result()
        )


        # Usage with Director
        gaming_builder = GamingPCBuilder()
        director = ComputerDirector(gaming_builder)

        gaming_pc = director.build_full()
        print(f&quot;Gaming PC: {gaming_pc.specs()}&quot;)

        office_builder = OfficePCBuilder()
        director = ComputerDirector(office_builder)

        office_pc = director.build_minimal()
        print(f&quot;Office PC: {office_pc.specs()}&quot;)

        # Direct builder usage (without director)
        server = (
        ServerBuilder()
        .set_cpu()
        .set_ram()
        .set_storage()
        .set_os()
        .get_result()
        )
        print(f&quot;Server: {server.specs()}&quot;)
        ```
</code></pre>
<h3 id="production-grade-http-request-builder">Production-Grade: HTTP Request Builder</h3>
<pre><code>        ```python
        from dataclasses import dataclass, field
        from typing import Dict, Any, Optional, Callable
        from enum import Enum
        import json


        class HttpMethod(Enum):
        GET = &quot;GET&quot;
        POST = &quot;POST&quot;
        PUT = &quot;PUT&quot;
        PATCH = &quot;PATCH&quot;
        DELETE = &quot;DELETE&quot;


        @dataclass(frozen=True)
        class HttpRequest:
        &quot;&quot;&quot;Immutable HTTP request object.&quot;&quot;&quot;
        method: HttpMethod
        url: str
        headers: Dict[str, str]
        query_params: Dict[str, str]
        body: Optional[bytes]
        timeout_seconds: int
        retry_count: int
        auth: Optional[tuple]


        class HttpRequestBuilder:
        &quot;&quot;&quot;
        Production-grade HTTP request builder.

        Features:
        - Fluent interface
        - Sensible defaults
        - Validation
        - Common presets
        &quot;&quot;&quot;

        def __init__(self):
        self._method: HttpMethod = HttpMethod.GET
        self._url: str = &quot;&quot;
        self._headers: Dict[str, str] = {}
        self._query_params: Dict[str, str] = {}
        self._body: Optional[bytes] = None
        self._timeout: int = 30
        self._retry_count: int = 0
        self._auth: Optional[tuple] = None

        # HTTP Methods
        def get(self, url: str) -&gt; 'HttpRequestBuilder':
        self._method = HttpMethod.GET
        self._url = url
        return self

        def post(self, url: str) -&gt; 'HttpRequestBuilder':
        self._method = HttpMethod.POST
        self._url = url
        return self

        def put(self, url: str) -&gt; 'HttpRequestBuilder':
        self._method = HttpMethod.PUT
        self._url = url
        return self

        def delete(self, url: str) -&gt; 'HttpRequestBuilder':
        self._method = HttpMethod.DELETE
        self._url = url
        return self

        # Headers
        def header(self, name: str, value: str) -&gt; 'HttpRequestBuilder':
        self._headers[name] = value
        return self

        def headers(self, headers: Dict[str, str]) -&gt; 'HttpRequestBuilder':
        self._headers.update(headers)
        return self

        def content_type(self, content_type: str) -&gt; 'HttpRequestBuilder':
        return self.header(&quot;Content-Type&quot;, content_type)

        def accept(self, accept: str) -&gt; 'HttpRequestBuilder':
        return self.header(&quot;Accept&quot;, accept)

        def bearer_token(self, token: str) -&gt; 'HttpRequestBuilder':
        return self.header(&quot;Authorization&quot;, f&quot;Bearer {token}&quot;)

        # Query Parameters
        def query(self, name: str, value: str) -&gt; 'HttpRequestBuilder':
        self._query_params[name] = value
        return self

        def query_params(self, params: Dict[str, str]) -&gt; 'HttpRequestBuilder':
        self._query_params.update(params)
        return self

        # Body
        def body_raw(self, data: bytes) -&gt; 'HttpRequestBuilder':
        self._body = data
        return self

        def body_text(self, text: str) -&gt; 'HttpRequestBuilder':
        self._body = text.encode('utf-8')
        return self.content_type(&quot;text/plain&quot;)

        def body_json(self, data: Any) -&gt; 'HttpRequestBuilder':
        self._body = json.dumps(data).encode('utf-8')
        return self.content_type(&quot;application/json&quot;)

        def body_form(self, data: Dict[str, str]) -&gt; 'HttpRequestBuilder':
        from urllib.parse import urlencode
        self._body = urlencode(data).encode('utf-8')
        return self.content_type(&quot;application/x-www-form-urlencoded&quot;)

        # Configuration
        def timeout(self, seconds: int) -&gt; 'HttpRequestBuilder':
        self._timeout = seconds
        return self

        def retries(self, count: int) -&gt; 'HttpRequestBuilder':
        self._retry_count = count
        return self

        def basic_auth(self, username: str, password: str) -&gt; 'HttpRequestBuilder':
        self._auth = (username, password)
        return self

        # Presets for common scenarios
        def json_api(self) -&gt; 'HttpRequestBuilder':
        &quot;&quot;&quot;Preset for JSON APIs.&quot;&quot;&quot;
        return (
        self
        .content_type(&quot;application/json&quot;)
        .accept(&quot;application/json&quot;)
        )

        def with_retry(self) -&gt; 'HttpRequestBuilder':
        &quot;&quot;&quot;Preset for resilient requests.&quot;&quot;&quot;
        return self.retries(3).timeout(10)

        # Build
        def build(self) -&gt; HttpRequest:
        &quot;&quot;&quot;Build the immutable request object.&quot;&quot;&quot;
        if not self._url:
        raise ValueError(&quot;URL is required&quot;)

        # Add default headers
        headers = {&quot;User-Agent&quot;: &quot;MyApp/1.0&quot;}
        headers.update(self._headers)

        return HttpRequest(
        method=self._method,
        url=self._url,
        headers=headers,
        query_params=dict(self._query_params),
        body=self._body,
        timeout_seconds=self._timeout,
        retry_count=self._retry_count,
        auth=self._auth
        )


        # Usage Examples
        # Simple GET request
        get_request = (
        HttpRequestBuilder()
        .get(&quot;https://api.example.com/users&quot;)
        .query(&quot;page&quot;, &quot;1&quot;)
        .query(&quot;limit&quot;, &quot;10&quot;)
        .bearer_token(&quot;abc123&quot;)
        .build()
        )

        # POST with JSON body
        post_request = (
        HttpRequestBuilder()
        .post(&quot;https://api.example.com/users&quot;)
        .json_api()
        .body_json({&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;})
        .bearer_token(&quot;abc123&quot;)
        .with_retry()
        .build()
        )

        # Form submission
        form_request = (
        HttpRequestBuilder()
        .post(&quot;https://example.com/login&quot;)
        .body_form({&quot;username&quot;: &quot;alice&quot;, &quot;password&quot;: &quot;secret&quot;})
        .timeout(5)
        .build()
        )

        print(f&quot;GET: {get_request.method.value} {get_request.url}&quot;)
        print(f&quot;POST: {post_request.method.value} {post_request.url}&quot;)
        print(f&quot;Form: {form_request.method.value} {form_request.url}&quot;)
        ```
</code></pre>
<hr />
<h2 id="builder-vs-related-patterns">Builder vs Related Patterns</h2>
<div>
<div>
<div>
<h4>Builder</h4>
<p>Step-by-step construction of complex objects.</p>
<div>
<strong>Focus:</strong> <span>Construction process</span><br>
<strong>Returns:</strong> <span>One complex product</span>
</div>
</div>
<div>
<h4>Factory Method</h4>
<p>Single-step creation with subclass decisions.</p>
<div>
<strong>Focus:</strong> <span>Which class to instantiate</span><br>
<strong>Returns:</strong> <span>One simple product</span>
</div>
</div>
<div>
<h4>Abstract Factory</h4>
<p>Creates families of related objects.</p>
<div>
<strong>Focus:</strong> <span>Product families</span><br>
<strong>Returns:</strong> <span>Multiple related products</span>
</div>
</div>
</div>
</div>
<hr />
<h2 id="interview-questions">Interview Questions</h2>
<div>
<h3 id="conceptual-questions">Conceptual Questions</h3>
<details>
<summary>Q1: When would you use Builder over a constructor with default parameters?</summary>
<div>
  Use Builder when:
<ul>
<li><strong>Many optional parameters:</strong> 4+ parameters become hard to remember</li>
<li><strong>Complex validation:</strong> Builder can validate in build() before creating object</li>
<li><strong>Immutable objects:</strong> Builder collects state, then creates frozen object</li>
<li><strong>Readable code:</strong> <code>.timeout(30).retries(3)</code> is clearer than positional args</li>
<li><strong>Different representations:</strong> Same process creates different products</li>
</ul>
  Use constructor with defaults when:
<ul>
<li>Object has few parameters (2-3)</li>
<li>Most parameters are required</li>
<li>Simple objects with straightforward construction</li>
</ul>
</div>
</details>
<details>
<summary>Q2: What's the role of the Director in the Builder pattern?</summary>
<div>
  The Director encapsulates construction algorithms:
<ul>
<li><strong>Knows the steps:</strong> Which builder methods to call and in what order</li>
<li><strong>Defines presets:</strong> build_gaming_pc(), build_office_pc()</li>
<li><strong>Optional:</strong> Client can use builder directly without director</li>
</ul>
<pre>
# With Director - encapsulated knowledge
  director.build_gaming_pc()
<h1 id="without-director---client-knows-the-steps">Without Director - client knows the steps</h1>
<p>builder.set_cpu().set_gpu().set_ram().build()<br />
</pre><br />
<strong>In practice:</strong> Modern fluent builders often skip the Director, letting clients chain methods directly.</p>
</div>
</details>
<details>
<summary>Q3: How do you make a Builder thread-safe?</summary>
<div>
<strong>Best practice:</strong> Create a new builder instance per thread.
  <br><br>
<strong>If sharing is needed:</strong>
<ul>
<li>Make builder immutable (each method returns a new builder)</li>
<li>Use locks (not recommended - defeats fluent purpose)</li>
<li>Use thread-local storage</li>
</ul>
<pre>
# Immutable builder approach
  class ImmutableBuilder:
  def __init__(self, **kwargs):
  self._values = kwargs
<p>def with_name(self, name):<br />
return ImmutableBuilder(**self._values, name=name)</p>
<p>def with_age(self, age):<br />
return ImmutableBuilder(**self._values, age=age)<br />
</pre></p>
</div>
</details>
<h3 id="coding-questions">Coding Questions</h3>
<details>
<summary>Q4: Implement a SQL Query Builder</summary>
<div>
<pre>
  class QueryBuilder:
  def __init__(self):
  self._select = ["*"]
  self._from = ""
  self._where = []
  self._order_by = []
  self._limit = None
<p>def select(self, *columns):<br />
self._select = list(columns)<br />
return self</p>
<p>def from_table(self, table):<br />
self._from = table<br />
return self</p>
<p>def where(self, condition):<br />
self._where.append(condition)<br />
return self</p>
<p>def order_by(self, column, direction=&quot;ASC&quot;):<br />
self._order_by.append(f&quot;{column} {direction}&quot;)<br />
return self</p>
<p>def limit(self, count):<br />
self._limit = count<br />
return self</p>
<p>def build(self):<br />
if not self._from:<br />
raise ValueError(&quot;FROM clause required&quot;)</p>
<p>query = f&quot;SELECT {', '.join(self._select)}&quot;<br />
query += f&quot; FROM {self._from}&quot;</p>
<p>if self._where:<br />
query += f&quot; WHERE {' AND '.join(self._where)}&quot;<br />
if self._order_by:<br />
query += f&quot; ORDER BY {', '.join(self._order_by)}&quot;<br />
if self._limit:<br />
query += f&quot; LIMIT {self._limit}&quot;</p>
<p>return query</p>
<h1 id="usage">Usage</h1>
<p>query = (<br />
QueryBuilder()<br />
.select(&quot;id&quot;, &quot;name&quot;, &quot;email&quot;)<br />
.from_table(&quot;users&quot;)<br />
.where(&quot;status = 'active'&quot;)<br />
.where(&quot;age &gt; 18&quot;)<br />
.order_by(&quot;created_at&quot;, &quot;DESC&quot;)<br />
.limit(10)<br />
.build()<br />
)<br />
</pre></p>
</div>
</details>
<details>
<summary>Q5: How would you add validation to a Builder?</summary>
<div>
<strong>Two approaches:</strong>
  <br><br>
<strong>1. Validate in build() - Recommended:</strong>
<pre>
  def build(self):
  errors = []
  if not self._url:
  errors.append("URL is required")
  if self._timeout < 0:
  errors.append("Timeout must be positive")
  if errors:
  raise ValueError(f"Invalid config: {errors}")
  return Request(...)
</pre>
<p><strong>2. Validate eagerly in setters:</strong></p>
<pre>
  def timeout(self, seconds):
  if seconds < 0:
  raise ValueError("Timeout must be positive")
  self._timeout = seconds
  return self
</pre>
<p><strong>Best practice:</strong> Validate in build() for interdependent validations, in setters for simple constraints.</p>
</div>
</details>
</div>
<hr />
<h2 id="common-mistakes-1">Common Mistakes</h2>
<div>
<h3 id="mistake-1-forgetting-to-reset-builder-state">Mistake 1: Forgetting to Reset Builder State</h3>
<pre><code>                        ```python
                        # BAD: Reusing builder without reset
                        builder = EmailBuilder()
                        email1 = builder.to(&quot;a@example.com&quot;).subject(&quot;Hi&quot;).build()
                        email2 = builder.to(&quot;b@example.com&quot;).build()  # Still has &quot;a@example.com&quot;!

                        # GOOD: Create new builder or add reset method
                        email1 = EmailBuilder().to(&quot;a@example.com&quot;).subject(&quot;Hi&quot;).build()
                        email2 = EmailBuilder().to(&quot;b@example.com&quot;).subject(&quot;Hello&quot;).build()
                        ```
</code></pre>
<h3 id="mistake-2-returning-mutable-internal-state">Mistake 2: Returning Mutable Internal State</h3>
<pre><code>                        ```python
                        # BAD: Exposing internal list
                        def build(self):
                        return Product(items=self._items)  # Caller can modify!

                        # GOOD: Return copy
                        def build(self):
                        return Product(items=list(self._items))  # Defensive copy
                        ```
</code></pre>
<h3 id="mistake-3-not-validating-required-fields">Mistake 3: Not Validating Required Fields</h3>
<pre><code>                        ```python
                        # BAD: Silent failures
                        def build(self):
                        return User(name=self._name)  # What if name is empty?

                        # GOOD: Validate in build()
                        def build(self):
                        if not self._name:
                        raise ValueError(&quot;Name is required&quot;)
                        return User(name=self._name)
                        ```
</code></pre>
</div>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<div>
<ol>
<li>
<p><strong>Builder separates construction from representation</strong> - Same process can create different objects</p>
</li>
<li>
<p><strong>Fluent interface is key</strong> - Return <code>self</code> from each method for readable chaining</p>
</li>
<li>
<p><strong>Validate in build()</strong> - Ensure object is valid before returning</p>
</li>
<li>
<p><strong>Director is optional</strong> - Modern builders often skip it for simplicity</p>
</li>
<li>
<p><strong>Don't over-engineer</strong> - If a simple constructor works, use it</p>
</li>
<li>
<p><strong>Create immutable products</strong> - Builder collects mutable state, product is frozen</p>
</li>
</ol>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<pre><code>                      - [Factory Method](/topic/design-patterns/factory-method) - Single-step creation
                      - [Abstract Factory](/topic/design-patterns/abstract-factory) - Product families
                      - [Prototype](/topic/design-patterns/prototype) - Clone existing objects
                      - [Composite](/topic/design-patterns/composite) - Build tree structures with Builder
</code></pre>
