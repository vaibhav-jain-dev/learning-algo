<style>
/* Mobile-specific styles for iPhone 15 and similar devices */
@media screen and (max-width: 480px) {
    /* Force all grid layouts to single column */
    [style*="grid-template-columns"] {
        display: block !important;
    }
    [style*="grid-template-columns"] > div {
        margin-bottom: 16px !important;
    }
    /* Adjust padding for mobile */
    [style*="padding: 32px"],
    [style*="padding: 24px"] {
        padding: 16px !important;
    }
    /* Smaller headings */
    h4[style*="font-size: 18px"],
    h4[style*="font-size: 16px"] {
        font-size: 15px !important;
    }
    /* Readable font sizes */
    [style*="font-size: 13px"],
    [style*="font-size: 12px"],
    [style*="font-size: 11px"],
    [style*="font-size: 10px"] {
        font-size: 13px !important;
        line-height: 1.6 !important;
    }
    /* Flex containers stack vertically */
    [style*="display: flex"][style*="gap"] {
        flex-direction: column !important;
    }
    /* Better spacing for nested content */
    [style*="padding-left: 64px"],
    [style*="padding-left: 48px"],
    [style*="padding-left: 40px"] {
        padding-left: 16px !important;
    }
    /* Code blocks */
    pre {
        font-size: 12px !important;
        padding: 12px !important;
        overflow-x: auto !important;
    }
    pre code {
        font-size: 12px !important;
    }
    /* Tables */
    table {
        font-size: 12px !important;
        display: block !important;
        overflow-x: auto !important;
    }
    th, td {
        padding: 8px !important;
        font-size: 12px !important;
    }
}
</style>
<h1 id="mediator-pattern">Mediator Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Mediator pattern defines an object that encapsulates how a set of objects interact. It promotes loose coupling by preventing objects from referring to each other explicitly, centralizing complex communication logic in a single place. Instead of objects talking directly to each other (many-to-many), they communicate through a mediator (many-to-one-to-many).</p>
<p><strong>Difficulty:</strong> Intermediate<br />
<strong>Category:</strong> Behavioral Pattern<br />
<strong>Also Known As:</strong> Controller, Coordinator</p>
<hr />
<h2 id="simple-explanation-the-air-traffic-control-analogy">Simple Explanation: The Air Traffic Control Analogy</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<div style="font-size: 2.5rem; text-align: center; margin-bottom: 16px">&#9992;</div>
<div style="font-size: 1.3rem; font-weight: 700; color: #1e293b; text-align: center; margin-bottom: 12px">Think of Air Traffic Control</div>
<div style="color: #334155; font-size: 1rem; line-height: 1.7">
    Imagine an airport with 50 planes. If every pilot had to coordinate directly with every other pilot, you'd have 2,450 possible communication channels - pure chaos! Instead, all pilots talk to one Air Traffic Controller (ATC). The ATC receives requests, makes decisions, and coordinates everyone. Pilots don't know about each other; they only know the tower. This is the Mediator pattern - a central coordinator that manages complex interactions.
</div>
<div style="margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px">
<div style="background: #dbeafe; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #1e40af; font-weight: 600">Pilots</div>
<div style="color: #3b82f6; font-size: 0.85rem">Colleagues (participants)</div>
</div>
<div style="background: #dcfce7; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #166534; font-weight: 600">Control Tower</div>
<div style="color: #22c55e; font-size: 0.85rem">Mediator (coordinator)</div>
</div>
<div style="background: #fef3c7; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #92400e; font-weight: 600">Radio Messages</div>
<div style="color: #f59e0b; font-size: 0.85rem">Communication Protocol</div>
</div>
<div style="background: #fce7f3; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #9d174d; font-weight: 600">Runways</div>
<div style="color: #ec4899; font-size: 0.85rem">Shared Resources</div>
</div>
</div>
</div>
<h3 id="the-expert-insight">The Expert Insight</h3>
<p><strong>Novice thinks:</strong> &quot;Mediator just centralizes all the logic - it's like a god object!&quot;</p>
<p><strong>Expert knows:</strong> &quot;Mediator trades <strong>coupling complexity</strong> for <strong>mediator complexity</strong>. The key is knowing when this trade-off is worth it. In UI frameworks, form validation, and workflow orchestration, the centralized control is exactly what you need. But if your mediator grows too large, you need multiple specialized mediators.&quot;</p>
<hr />
<h2 id="real-world-company-usage">Real-World Company Usage</h2>
<div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 12px">Industry Applications</div>
<ul style="color: #334155; margin: 0; padding-left: 20px; line-height: 1.8">
<li><strong>React/Redux:</strong> Store acts as mediator between components - they dispatch actions, store coordinates state</li>
<li><strong>Kubernetes:</strong> API Server mediates between controllers, nodes, and pods</li>
<li><strong>Message Brokers (RabbitMQ, Kafka):</strong> Mediate between producers and consumers</li>
<li><strong>Chat Applications (Slack, Discord):</strong> Server mediates all user communications</li>
<li><strong>Operating Systems:</strong> Kernel mediates between user processes and hardware</li>
<li><strong>MVC Frameworks:</strong> Controller mediates between Model and View</li>
<li><strong>Microservices API Gateway:</strong> Mediates requests between clients and services</li>
</ul>
</div>
<hr />
<h2 id="pattern-structure">Pattern Structure</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<div style="font-weight: 700; color: #1e293b; text-align: center; margin-bottom: 24px; font-size: 1.2rem">Mediator Pattern Architecture</div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 20px">
    <!-- Mediator Interface -->
<div style="background: #f1f5f9;border-radius: 12px; padding: 16px 32px; text-align: center">
<div style="font-weight: 600; color: #475569; font-style: italic">Mediator (interface)</div>
<div style="font-size: 0.85rem; color: #64748b; margin-top: 8px; font-family: monospace">+ notify(sender, event)</div>
</div>
<div style="color: #64748b">implements</div>
<div style="color: #64748b; font-size: 1.5rem">&#8595;</div>
    <!-- Concrete Mediator -->
<div style="background: #dcfce7;border-radius: 12px; padding: 20px 40px; text-align: center">
<div style="font-weight: 700; color: #166534; font-size: 1.1rem">ConcreteMediator</div>
<div style="font-size: 0.8rem; color: #15803d; margin-top: 8px; font-family: monospace">- colleagueA<br/>- colleagueB<br/>- colleagueC<br/>+ notify(sender, event)</div>
</div>
    <!-- Arrows to colleagues -->
<div style="display: flex; align-items: center; gap: 8px; color: #64748b">
<span>&#8601;</span>
<span>coordinates</span>
<span>&#8600;</span>
</div>
    <!-- Colleagues Row -->
<div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center">
<div style="background: #dbeafe;border-radius: 10px; padding: 14px 20px; text-align: center; min-width: 120px">
<div style="font-weight: 600; color: #1e40af">ColleagueA</div>
<div style="font-size: 0.75rem; color: #3b82f6; margin-top: 4px">knows mediator</div>
</div>
<div style="background: #fef3c7;border-radius: 10px; padding: 14px 20px; text-align: center; min-width: 120px">
<div style="font-weight: 600; color: #92400e">ColleagueB</div>
<div style="font-size: 0.75rem; color: #b45309; margin-top: 4px">knows mediator</div>
</div>
<div style="background: #fce7f3;border-radius: 10px; padding: 14px 20px; text-align: center; min-width: 120px">
<div style="font-weight: 600; color: #9d174d">ColleagueC</div>
<div style="font-size: 0.75rem; color: #be185d; margin-top: 4px">knows mediator</div>
</div>
</div>
</div>
</div>
<h3 id="without-vs-with-mediator">Without vs With Mediator</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 24px 0">
<div style="background: #fef2f2; border-radius: 12px; padding: 20px">
<div style="font-weight: 700; color: #991b1b; margin-bottom: 12px; text-align: center">Without Mediator</div>
<div style="color: #334155; font-size: 0.9rem; text-align: center">
<div style="font-family: monospace; background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 8px">
  A &harr; B<br/>
  A &harr; C<br/>
  B &harr; C<br/>
  <br/>
  n(n-1)/2 connections
</div>
</div>
</div>
<div style="background: #dcfce7; border-radius: 12px; padding: 20px">
<div style="font-weight: 700; color: #166534; margin-bottom: 12px; text-align: center">With Mediator</div>
<div style="color: #334155; font-size: 0.9rem; text-align: center">
<div style="font-family: monospace; background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 8px">
  A &rarr; M<br/>
  B &rarr; M<br/>
  C &rarr; M<br/>
  <br/>
  n connections
</div>
</div>
</div>
</div>
<hr />
<h2 id="when-to-use-mediator-pattern">When to Use Mediator Pattern</h2>
<div style="background: #dcfce7; border-radius: 12px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #166534; margin-bottom: 12px">Perfect Use Cases</div>
<ul style="color: #334155; margin: 0; padding-left: 20px; line-height: 1.8">
<li><strong>Complex UI interactions:</strong> Form fields that depend on each other's values</li>
<li><strong>Chat rooms/messaging:</strong> Users communicate through a central server</li>
<li><strong>Workflow orchestration:</strong> Coordinating multiple steps/services</li>
<li><strong>Event handling systems:</strong> Central dispatcher for events</li>
<li><strong>Resource scheduling:</strong> Managing shared resources (runways, meeting rooms)</li>
<li><strong>Game development:</strong> Game manager coordinating players, enemies, and environment</li>
<li><strong>IoT systems:</strong> Hub coordinating multiple devices</li>
</ul>
</div>
<hr />
<h2 id="anti-patterns-when-not-to-use">Anti-Patterns: When NOT to Use</h2>
<div style="background: #fef2f2; border-radius: 12px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #991b1b; margin-bottom: 12px">Common Mistakes</div>
<ul style="color: #334155; margin: 0; padding-left: 20px; line-height: 1.8">
<li><strong>God mediator:</strong> Mediator becomes too complex - split into multiple mediators by domain</li>
<li><strong>Simple cases:</strong> Two objects communicating don't need a mediator - direct reference is fine</li>
<li><strong>Performance critical paths:</strong> Extra indirection adds latency</li>
<li><strong>Hiding necessary coupling:</strong> Sometimes objects SHOULD know about each other</li>
<li><strong>Single point of failure:</strong> Mediator going down kills entire system</li>
</ul>
</div>
<hr />
<h2 id="python-implementation-chat-room-and-auction-system">Python Implementation: Chat Room and Auction System</h2>
<pre><code class="language-python">from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto


# ============================================================
# MEDIATOR INTERFACE
# ============================================================

class ChatMediator(ABC):
    &quot;&quot;&quot;
    Abstract mediator interface.
    Defines the contract for communication coordination.
    &quot;&quot;&quot;

    @abstractmethod
    def send_message(self, message: str, sender: 'User', recipient: 'User' = None) -&gt; None:
        &quot;&quot;&quot;Send a message from sender to recipient (or broadcast if None).&quot;&quot;&quot;
        pass

    @abstractmethod
    def add_user(self, user: 'User') -&gt; None:
        &quot;&quot;&quot;Add a user to the chat.&quot;&quot;&quot;
        pass

    @abstractmethod
    def remove_user(self, user: 'User') -&gt; None:
        &quot;&quot;&quot;Remove a user from the chat.&quot;&quot;&quot;
        pass


# ============================================================
# COLLEAGUE BASE CLASS
# ============================================================

class User(ABC):
    &quot;&quot;&quot;
    Abstract colleague class.
    Users communicate only through the mediator.
    &quot;&quot;&quot;

    def __init__(self, username: str, mediator: ChatMediator = None):
        self.username = username
        self.mediator = mediator
        self.is_online = True

    def set_mediator(self, mediator: ChatMediator) -&gt; None:
        &quot;&quot;&quot;Connect to a mediator.&quot;&quot;&quot;
        self.mediator = mediator

    def send(self, message: str, recipient: 'User' = None) -&gt; None:
        &quot;&quot;&quot;Send a message through the mediator.&quot;&quot;&quot;
        if self.mediator:
            self.mediator.send_message(message, self, recipient)
        else:
            print(f&quot;[{self.username}] Not connected to any chat!&quot;)

    @abstractmethod
    def receive(self, message: str, sender: 'User') -&gt; None:
        &quot;&quot;&quot;Handle a received message.&quot;&quot;&quot;
        pass


# ============================================================
# CONCRETE COLLEAGUES
# ============================================================

class RegularUser(User):
    &quot;&quot;&quot;Regular chat user.&quot;&quot;&quot;

    def receive(self, message: str, sender: 'User') -&gt; None:
        print(f&quot;[{self.username}] Message from {sender.username}: {message}&quot;)


class AdminUser(User):
    &quot;&quot;&quot;Admin user with special privileges.&quot;&quot;&quot;

    def receive(self, message: str, sender: 'User') -&gt; None:
        print(f&quot;[ADMIN:{self.username}] Message from {sender.username}: {message}&quot;)

    def broadcast_announcement(self, message: str) -&gt; None:
        &quot;&quot;&quot;Send announcement to all users.&quot;&quot;&quot;
        print(f&quot;[ADMIN:{self.username}] Broadcasting: {message}&quot;)
        self.send(f&quot;[ANNOUNCEMENT] {message}&quot;)

    def kick_user(self, user: User) -&gt; None:
        &quot;&quot;&quot;Kick a user from the chat.&quot;&quot;&quot;
        if self.mediator:
            self.mediator.remove_user(user)
            print(f&quot;[ADMIN:{self.username}] Kicked {user.username}&quot;)


class BotUser(User):
    &quot;&quot;&quot;Automated bot user.&quot;&quot;&quot;

    def __init__(self, username: str, auto_responses: Dict[str, str] = None):
        super().__init__(username)
        self.auto_responses = auto_responses or {}

    def receive(self, message: str, sender: 'User') -&gt; None:
        print(f&quot;[BOT:{self.username}] Received from {sender.username}: {message}&quot;)

        # Auto-respond based on keywords
        message_lower = message.lower()
        for keyword, response in self.auto_responses.items():
            if keyword in message_lower:
                self.send(response, sender)
                break


# ============================================================
# CONCRETE MEDIATOR - Chat Room
# ============================================================

@dataclass
class MessageLog:
    &quot;&quot;&quot;Log entry for a message.&quot;&quot;&quot;
    timestamp: datetime
    sender: str
    recipient: Optional[str]
    message: str


class ChatRoom(ChatMediator):
    &quot;&quot;&quot;
    Concrete mediator implementing a chat room.
    Manages user connections and message routing.
    &quot;&quot;&quot;

    def __init__(self, name: str):
        self.name = name
        self.users: Dict[str, User] = {}
        self.message_history: List[MessageLog] = []
        self.blocked_users: Set[str] = set()

    def add_user(self, user: User) -&gt; None:
        &quot;&quot;&quot;Add user and notify others.&quot;&quot;&quot;
        if user.username in self.blocked_users:
            print(f&quot;[SYSTEM] {user.username} is blocked from {self.name}&quot;)
            return

        self.users[user.username] = user
        user.set_mediator(self)

        # Notify all other users
        self._broadcast_system(f&quot;{user.username} joined the chat&quot;)
        print(f&quot;[SYSTEM] {user.username} connected to {self.name}&quot;)

    def remove_user(self, user: User) -&gt; None:
        &quot;&quot;&quot;Remove user and notify others.&quot;&quot;&quot;
        if user.username in self.users:
            del self.users[user.username]
            self._broadcast_system(f&quot;{user.username} left the chat&quot;)
            print(f&quot;[SYSTEM] {user.username} disconnected from {self.name}&quot;)

    def send_message(self, message: str, sender: User, recipient: User = None) -&gt; None:
        &quot;&quot;&quot;Route message to recipient or broadcast.&quot;&quot;&quot;
        # Log the message
        log = MessageLog(
            timestamp=datetime.now(),
            sender=sender.username,
            recipient=recipient.username if recipient else None,
            message=message
        )
        self.message_history.append(log)

        if recipient:
            # Direct message
            if recipient.username in self.users:
                recipient.receive(message, sender)
            else:
                print(f&quot;[SYSTEM] User {recipient.username} not found&quot;)
        else:
            # Broadcast to all except sender
            for username, user in self.users.items():
                if user != sender and user.is_online:
                    user.receive(message, sender)

    def _broadcast_system(self, message: str) -&gt; None:
        &quot;&quot;&quot;Broadcast a system message.&quot;&quot;&quot;
        for user in self.users.values():
            if user.is_online:
                print(f&quot;[SYSTEM -&gt; {user.username}] {message}&quot;)

    def block_user(self, username: str) -&gt; None:
        &quot;&quot;&quot;Block a user from joining.&quot;&quot;&quot;
        self.blocked_users.add(username)
        if username in self.users:
            self.remove_user(self.users[username])

    def get_online_users(self) -&gt; List[str]:
        &quot;&quot;&quot;Get list of online usernames.&quot;&quot;&quot;
        return [u.username for u in self.users.values() if u.is_online]

    def get_history(self, limit: int = 10) -&gt; List[MessageLog]:
        &quot;&quot;&quot;Get recent message history.&quot;&quot;&quot;
        return self.message_history[-limit:]


# ============================================================
# COMPLEX EXAMPLE: Auction System
# ============================================================

class BidStatus(Enum):
    PENDING = auto()
    ACCEPTED = auto()
    REJECTED = auto()
    OUTBID = auto()


@dataclass
class Bid:
    bidder: str
    amount: float
    timestamp: datetime = field(default_factory=datetime.now)
    status: BidStatus = BidStatus.PENDING


class AuctionMediator(ABC):
    &quot;&quot;&quot;Abstract mediator for auction system.&quot;&quot;&quot;

    @abstractmethod
    def place_bid(self, bidder: 'Bidder', amount: float) -&gt; BidStatus:
        pass

    @abstractmethod
    def register_bidder(self, bidder: 'Bidder') -&gt; None:
        pass


class Bidder:
    &quot;&quot;&quot;Participant in an auction.&quot;&quot;&quot;

    def __init__(self, name: str, budget: float):
        self.name = name
        self.budget = budget
        self.mediator: Optional[AuctionMediator] = None
        self.won_items: List[str] = []

    def set_mediator(self, mediator: AuctionMediator) -&gt; None:
        self.mediator = mediator

    def bid(self, amount: float) -&gt; BidStatus:
        &quot;&quot;&quot;Place a bid through the mediator.&quot;&quot;&quot;
        if not self.mediator:
            print(f&quot;[{self.name}] Not registered with any auction!&quot;)
            return BidStatus.REJECTED

        if amount &gt; self.budget:
            print(f&quot;[{self.name}] Cannot bid ${amount} - exceeds budget ${self.budget}&quot;)
            return BidStatus.REJECTED

        return self.mediator.place_bid(self, amount)

    def notify_outbid(self, new_amount: float) -&gt; None:
        &quot;&quot;&quot;Called when someone outbids.&quot;&quot;&quot;
        print(f&quot;[{self.name}] You've been outbid! New highest: ${new_amount}&quot;)

    def notify_won(self, item: str, amount: float) -&gt; None:
        &quot;&quot;&quot;Called when auction is won.&quot;&quot;&quot;
        self.won_items.append(item)
        self.budget -= amount
        print(f&quot;[{self.name}] Congratulations! You won '{item}' for ${amount}&quot;)


class Auction(AuctionMediator):
    &quot;&quot;&quot;
    Concrete mediator for auction.
    Coordinates bidding between multiple bidders.
    &quot;&quot;&quot;

    def __init__(self, item: str, starting_price: float, reserve_price: float = None):
        self.item = item
        self.starting_price = starting_price
        self.reserve_price = reserve_price or starting_price
        self.current_price = starting_price
        self.bidders: Dict[str, Bidder] = {}
        self.bids: List[Bid] = []
        self.highest_bidder: Optional[Bidder] = None
        self.is_active = True

    def register_bidder(self, bidder: Bidder) -&gt; None:
        &quot;&quot;&quot;Register a bidder for this auction.&quot;&quot;&quot;
        self.bidders[bidder.name] = bidder
        bidder.set_mediator(self)
        print(f&quot;[AUCTION:{self.item}] {bidder.name} registered (budget: ${bidder.budget})&quot;)

    def place_bid(self, bidder: Bidder, amount: float) -&gt; BidStatus:
        &quot;&quot;&quot;Process a bid and notify relevant parties.&quot;&quot;&quot;
        if not self.is_active:
            print(f&quot;[AUCTION:{self.item}] Auction has ended&quot;)
            return BidStatus.REJECTED

        bid = Bid(bidder=bidder.name, amount=amount)

        # Validate bid
        if amount &lt;= self.current_price:
            bid.status = BidStatus.REJECTED
            print(f&quot;[AUCTION:{self.item}] Bid ${amount} rejected - must exceed ${self.current_price}&quot;)
            return BidStatus.REJECTED

        # Accept bid
        bid.status = BidStatus.ACCEPTED
        self.bids.append(bid)

        # Notify previous highest bidder
        if self.highest_bidder and self.highest_bidder != bidder:
            self.highest_bidder.notify_outbid(amount)

        # Update state
        self.current_price = amount
        self.highest_bidder = bidder

        print(f&quot;[AUCTION:{self.item}] New highest bid: ${amount} by {bidder.name}&quot;)
        return BidStatus.ACCEPTED

    def end_auction(self) -&gt; Optional[Bidder]:
        &quot;&quot;&quot;End the auction and determine winner.&quot;&quot;&quot;
        self.is_active = False

        if not self.highest_bidder:
            print(f&quot;[AUCTION:{self.item}] No bids received - auction failed&quot;)
            return None

        if self.current_price &lt; self.reserve_price:
            print(f&quot;[AUCTION:{self.item}] Reserve price ${self.reserve_price} not met&quot;)
            return None

        # Notify winner
        self.highest_bidder.notify_won(self.item, self.current_price)

        # Notify losers
        for name, bidder in self.bidders.items():
            if bidder != self.highest_bidder:
                print(f&quot;[{name}] Auction ended. Winner: {self.highest_bidder.name}&quot;)

        return self.highest_bidder


# ============================================================
# USAGE EXAMPLES
# ============================================================

if __name__ == &quot;__main__&quot;:
    print(&quot;=&quot; * 60)
    print(&quot;CHAT ROOM EXAMPLE&quot;)
    print(&quot;=&quot; * 60)

    # Create chat room (mediator)
    chat = ChatRoom(&quot;General&quot;)

    # Create users (colleagues)
    alice = RegularUser(&quot;Alice&quot;)
    bob = RegularUser(&quot;Bob&quot;)
    charlie = RegularUser(&quot;Charlie&quot;)
    admin = AdminUser(&quot;Admin&quot;)
    bot = BotUser(&quot;HelpBot&quot;, {&quot;help&quot;: &quot;How can I assist you?&quot;, &quot;hello&quot;: &quot;Hi there!&quot;})

    # Add users to chat
    chat.add_user(alice)
    chat.add_user(bob)
    chat.add_user(charlie)
    chat.add_user(admin)
    chat.add_user(bot)

    print(&quot;\n--- Messages ---&quot;)
    alice.send(&quot;Hello everyone!&quot;)
    bob.send(&quot;Hi Alice!&quot;, alice)  # Direct message
    charlie.send(&quot;help&quot;)  # Bot will respond
    admin.broadcast_announcement(&quot;Server maintenance at 10 PM&quot;)

    print(&quot;\n--- Online Users ---&quot;)
    print(f&quot;Online: {chat.get_online_users()}&quot;)

    print(&quot;\n&quot; + &quot;=&quot; * 60)
    print(&quot;AUCTION EXAMPLE&quot;)
    print(&quot;=&quot; * 60)

    # Create auction (mediator)
    auction = Auction(&quot;Vintage Watch&quot;, starting_price=100, reserve_price=150)

    # Create bidders (colleagues)
    john = Bidder(&quot;John&quot;, budget=500)
    jane = Bidder(&quot;Jane&quot;, budget=300)
    jack = Bidder(&quot;Jack&quot;, budget=200)

    # Register bidders
    auction.register_bidder(john)
    auction.register_bidder(jane)
    auction.register_bidder(jack)

    print(&quot;\n--- Bidding ---&quot;)
    john.bid(110)
    jane.bid(130)
    jack.bid(150)
    john.bid(200)
    jane.bid(250)
    jack.bid(300)  # Exceeds budget

    print(&quot;\n--- End Auction ---&quot;)
    winner = auction.end_auction()
    if winner:
        print(f&quot;\nFinal winner: {winner.name} with ${auction.current_price}&quot;)
</code></pre>
<hr />
<h2 id="mediator-vs-facade-vs-observer">Mediator vs Facade vs Observer</h2>
<div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 16px">Common Interview Question: Pattern Comparison</div>
<table style="width: 100%; border-collapse: collapse; color: #334155">
    <thead>
<tr style="background: #e2e8f0">
<th style="padding: 12px; text-align: left">Aspect</th>
<th style="padding: 12px; text-align: left">Mediator</th>
<th style="padding: 12px; text-align: left">Facade</th>
<th style="padding: 12px; text-align: left">Observer</th>
</tr>
    </thead>
    <tbody>
<tr>
<td style="padding: 12px"><strong>Purpose</strong></td>
<td style="padding: 12px">Coordinate peer communication</td>
<td style="padding: 12px">Simplify complex subsystem</td>
<td style="padding: 12px">Notify of state changes</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>Direction</strong></td>
<td style="padding: 12px">Bidirectional</td>
<td style="padding: 12px">Unidirectional (client to subsystem)</td>
<td style="padding: 12px">Unidirectional (subject to observers)</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Awareness</strong></td>
<td style="padding: 12px">Colleagues know mediator</td>
<td style="padding: 12px">Subsystems don't know facade</td>
<td style="padding: 12px">Subject doesn't know observers</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>Example</strong></td>
<td style="padding: 12px">Chat room</td>
<td style="padding: 12px">Home theater remote</td>
<td style="padding: 12px">Newsletter subscription</td>
</tr>
    </tbody>
</table>
</div>
<hr />
<h2 id="interview-questions">Interview Questions</h2>
<details style="margin: 12px 0; padding: 16px; background: #f8fafc; border-radius: 8px">
<summary style="font-weight: 600; color: #1e293b; cursor: pointer">Q1: How do you prevent the mediator from becoming a God object?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> Several strategies:
    1. **Domain-specific mediators:** Split by business domain (UserMediator, OrderMediator)
    2. **Chain of mediators:** Hierarchical mediators that delegate
    3. **Use events:** Mediator dispatches events instead of direct calls
    4. **Single responsibility:** Mediator only routes, doesn't contain business logic
    5. **Composition:** Break into smaller coordinator classes
<pre><code class="language-python"># Bad: God mediator
class AppMediator:
def handle(self, event):
if event.type == &quot;user_login&quot;: ...
elif event.type == &quot;order_placed&quot;: ...
elif event.type == &quot;payment_received&quot;: ...
# 50 more event types...

# Good: Domain-specific mediators
class UserMediator: ...
class OrderMediator: ...
class PaymentMediator: ...</code></pre>
</div>
</details>
<details style="margin: 12px 0; padding: 16px; background: #f8fafc; border-radius: 8px">
<summary style="font-weight: 600; color: #1e293b; cursor: pointer">Q2: When would you use Mediator instead of Observer?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong>
    - **Mediator:** When objects need bidirectional communication and coordination logic is complex
    - **Observer:** When objects only need one-way notification (subject to observers)
<pre><code>Use Mediator when:
- Multiple objects need to communicate with each other (not just observe)
- Communication logic is complex with conditions and sequencing
- You need centralized control over interactions

Use Observer when:
- One object changes, many need to be notified
- Observers don't interact with each other
- Simple publish-subscribe semantics suffice
</code></pre>
</div>
</details>
<details style="margin: 12px 0; padding: 16px; background: #f8fafc; border-radius: 8px">
<summary style="font-weight: 600; color: #1e293b; cursor: pointer">Q3: How would you make a mediator fault-tolerant?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong>
    1. **Replicate mediator:** Primary-secondary setup with failover
    2. **Message persistence:** Store messages in durable queue
    3. **Idempotent handlers:** Allow safe message replay
    4. **Circuit breakers:** Protect against cascading failures
    5. **Health checks:** Monitor mediator health
    6. **Stateless design:** Keep mediator stateless, store state externally
<pre><code class="language-python">class FaultTolerantMediator:
def __init__(self):
self.message_store = PersistentQueue()
self.circuit_breaker = CircuitBreaker()

def send_message(self, msg, sender, recipient):
# Persist first for durability
msg_id = self.message_store.persist(msg, sender, recipient)

try:
if self.circuit_breaker.is_open:
raise ServiceUnavailable()
self._deliver(msg, sender, recipient)
self.message_store.mark_delivered(msg_id)
except Exception as e:
self.circuit_breaker.record_failure()
# Message will be retried from store</code></pre>
</div>
</details>
<details style="margin: 12px 0; padding: 16px; background: #f8fafc; border-radius: 8px">
<summary style="font-weight: 600; color: #1e293b; cursor: pointer">Q4: How does Redux implement the Mediator pattern?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> Redux Store acts as mediator:
    - **Colleagues:** React components
    - **Mediator:** Redux Store
    - **Communication:** Actions dispatched to store
    - **Coordination:** Reducers process actions, update state
    - **Notification:** Store notifies connected components via connect/useSelector
<pre><code>Key insight: Components never communicate directly. They dispatch actions to the store, and the store coordinates state updates and notifications.

```javascript
// Component A (colleague)
dispatch({ type: 'ADD_TO_CART', item: product });

// Store (mediator) - reducer handles coordination
function reducer(state, action) {
switch (action.type) {
case 'ADD_TO_CART':
// Update cart, inventory, recommendations, etc.
return { ...state, cart: [...state.cart, action.item] };
}
}

// Component B (colleague) - automatically notified via selector
const cart = useSelector(state =&gt; state.cart);
```
</code></pre>
</div>
</details>
<details style="margin: 12px 0; padding: 16px; background: #f8fafc; border-radius: 8px">
<summary style="font-weight: 600; color: #1e293b; cursor: pointer">Q5: Design a mediator for a smart home system.</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Key considerations:</strong>
    1. **Devices:** Lights, thermostat, security, music, blinds
    2. **Scenes:** "Movie mode" coordinates multiple devices
    3. **Automation rules:** "If motion detected after 10pm, turn on lights"
    4. **Conflict resolution:** What if user and automation conflict?
    5. **Priority levels:** Safety > User > Automation
    6. **Offline resilience:** What if hub loses connectivity?
<pre><code>Design: Central Hub as mediator with event-driven rules engine. Devices register capabilities, hub orchestrates based on rules and priorities.
</code></pre>
</div>
</details>
<hr />
<h2 id="best-practices">Best Practices</h2>
<div style="background: #dbeafe; border-radius: 12px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 12px">Production Guidelines</div>
<ol style="color: #334155; margin: 0; padding-left: 20px; line-height: 2">
<li><strong>Keep mediator focused:</strong> Single responsibility - only coordination, not business logic</li>
<li><strong>Use events/messages:</strong> Loose coupling between mediator and colleagues</li>
<li><strong>Implement logging:</strong> Track all communications for debugging</li>
<li><strong>Consider async:</strong> Don't block colleagues waiting for mediator</li>
<li><strong>Handle failures:</strong> What happens if mediator or colleague fails?</li>
<li><strong>Test in isolation:</strong> Mock mediator when testing colleagues</li>
<li><strong>Document protocols:</strong> Clear contract for how colleagues interact</li>
</ol>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<ul>
<li><a href="/topic/design-patterns/observer">Observer</a> - One-way notification vs bidirectional coordination</li>
<li><a href="/topic/design-patterns/facade">Facade</a> - Simplify subsystem access vs coordinate peers</li>
<li><a href="/topic/design-patterns/command">Command</a> - Mediator can route command objects</li>
<li><a href="/topic/design-patterns/chain-of-responsibility">Chain of Responsibility</a> - Alternative for request handling</li>
</ul>
