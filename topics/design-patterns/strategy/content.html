<h1 id="strategy-pattern">Strategy Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Strategy pattern defines a family of algorithms, encapsulates each one in a separate class, and makes them interchangeable at runtime. This behavioral pattern allows the algorithm to vary independently from clients that use it, enabling dynamic selection of behavior without modifying consuming code. At its core, Strategy implements the Open/Closed Principle by allowing new algorithms to be added without changing existing code.</p>
<p><strong>Difficulty:</strong> Intermediate to Advanced<br />
<strong>Category:</strong> Behavioral Pattern<br />
<strong>Also Known As:</strong> Policy Pattern<br />
<strong>Gang of Four Classification:</strong> Object Behavioral</p>
<div>
<div>Core Insight</div>
<div>
    Strategy pattern transforms "what algorithm to use" from a compile-time decision into a runtime decision. The key mental model: instead of the context containing conditional logic to select behavior, you inject the behavior itself as a dependency.
</div>
</div>
<hr />
<h2 id="internal-mechanisms-and-architecture">Internal Mechanisms and Architecture</h2>
<h3 id="the-fundamental-abstraction">The Fundamental Abstraction</h3>
<p>Strategy pattern operates on three foundational components with specific responsibilities:</p>
<div>
<div>
<div>
<div>1</div>
<div>
<div>Context (The Host)</div>
<div>Maintains a reference to a Strategy object. Delegates algorithm execution to the current strategy. Does NOT know which concrete strategy it holds - only that it conforms to the interface.</div>
</div>
</div>
<div>
<div>2</div>
<div>
<div>Strategy Interface (The Contract)</div>
<div>Declares the method(s) that all concrete strategies must implement. This is the polymorphic boundary that enables substitutability. Can be an interface, abstract class, or in dynamic languages, a duck-typed protocol.</div>
</div>
</div>
<div>
<div>3</div>
<div>
<div>Concrete Strategies (The Implementations)</div>
<div>Each implements the strategy interface with a specific algorithm. They are completely independent of each other and unaware of the context's internal state unless explicitly passed.</div>
</div>
</div>
</div>
</div>
<h3 id="memory-and-object-lifecycle-considerations">Memory and Object Lifecycle Considerations</h3>
<div>
<div>Critical Design Decision: Stateless vs Stateful Strategies</div>
<div>
<strong>Stateless strategies</strong> can be shared across multiple contexts (flyweight pattern), reducing memory footprint. A single PercentageDiscountStrategy(10%) instance can serve thousands of shopping carts.
    <br/><br/>
<strong>Stateful strategies</strong> maintain per-execution state and require careful lifecycle management. Each context needs its own instance, and you must consider thread safety implications.
</div>
</div>
<p><strong>Assumption:</strong> Most Strategy implementations assume strategies are stateless. If your strategy accumulates state between executions, you're likely conflating Strategy with <a href="/topics/design-patterns/state">[State Pattern]</a> or should extract that state into explicit context parameters.</p>
<h3 id="data-flow-architecture">Data Flow Architecture</h3>
<p>The context must provide strategies with the data they need. There are two fundamental approaches:</p>
<div>
<div>
<div>Push Model (Explicit Parameters)</div>
<div>
<div><code>strategy.execute(data, config)</code></div>
<strong>Pros:</strong> Clear dependencies, easily testable, strategies remain decoupled<br/>
<strong>Cons:</strong> May pass unused data, parameter lists can grow<br/>
<strong>Use when:</strong> Different strategies need different subsets of data
</div>
</div>
<div>
<div>Pull Model (Context Reference)</div>
<div>
<div><code>strategy.execute(context)</code></div>
<strong>Pros:</strong> Strategies access exactly what they need, simpler signatures<br/>
<strong>Cons:</strong> Tight coupling to context interface, harder to test in isolation<br/>
<strong>Use when:</strong> All strategies need access to most context data
</div>
</div>
</div>
<p><strong>Trade-off:</strong> The push model promotes better encapsulation and testability at the cost of potentially verbose method signatures. The pull model simplifies signatures but creates bidirectional coupling between strategy and context.</p>
<hr />
<h2 id="interview-deep-dive-internal-mechanisms">Interview Deep-Dive: Internal Mechanisms</h2>
<div>
<div>Level 1: Explain how the Strategy pattern achieves runtime algorithm selection.</div>
<div>
<strong>Answer:</strong> The context holds a reference typed to the strategy interface, not a concrete implementation. When the context needs to execute the algorithm, it calls the interface method on whatever concrete strategy is currently assigned. Because the reference is polymorphic, the actual code executed is determined by the runtime type of the assigned strategy object, not by compile-time binding. This allows swapping algorithms by simply reassigning the strategy reference - no conditionals, no recompilation.
</div>
</div>
<div>
<div>Level 2: What happens at the virtual dispatch level when strategy.execute() is called?</div>
<div>
<strong>Answer:</strong> In languages with vtables (C++, Java, C#), calling an interface method triggers a vtable lookup. The runtime examines the object's vtable pointer, finds the function pointer for the called method, and jumps to that address. This adds one pointer indirection compared to direct function calls - typically 1-3 nanoseconds overhead.
    <br/><br/>
    In dynamic languages (Python, JavaScript), method resolution involves dictionary lookups on the object and its prototype chain, which is slower but still negligible for most applications. JIT compilers can often inline monomorphic call sites where only one strategy type is ever used.
</div>
</div>
<div>
<div>Level 3: How would you optimize Strategy pattern for a hot path called millions of times per second?</div>
<div>
<strong>Answer:</strong> Several techniques:
    <br/><br/>
<strong>1. Monomorphization:</strong> If you know strategies at compile time, use generics/templates to generate specialized code paths, eliminating virtual dispatch entirely.
    <br/><br/>
<strong>2. Strategy caching:</strong> If strategy selection is based on repeating conditions, cache the selected strategy to avoid repeated selection logic.
    <br/><br/>
<strong>3. Batch processing:</strong> Instead of calling strategy.execute() per item, pass batches: strategy.executeBatch(items). This amortizes the virtual call cost.
    <br/><br/>
<strong>4. Branch prediction hints:</strong> If one strategy is used 95% of the time, structure code so the CPU's branch predictor can optimize for the common case.
    <br/><br/>
<strong>5. Consider inlining:</strong> For truly critical paths, the Strategy pattern may be inappropriate - inline the algorithm and accept reduced flexibility.
</div>
</div>
<hr />
<h2 id="strategy-vs-state-pattern-the-critical-distinction">Strategy vs State Pattern: The Critical Distinction</h2>
<p>This comparison appears in virtually every design patterns interview. While structurally identical, the patterns differ fundamentally in intent and usage.</p>
<div>
<div>Structural Identity, Semantic Difference</div>
<div>
<div>
<div>STRATEGY</div>
<div>
<div><strong>Who decides:</strong> External client chooses strategy</div>
<div><strong>Awareness:</strong> Strategies are unaware of each other</div>
<div><strong>Transitions:</strong> None - strategies don't trigger switches</div>
<div><strong>Question answered:</strong> "How should I do X?"</div>
<div><strong>Lifetime:</strong> Often set once, occasionally changed</div>
<div><strong>Mental model:</strong> Interchangeable algorithms</div>
</div>
</div>
<div>
<div>STATE</div>
<div>
<div><strong>Who decides:</strong> Object itself or states trigger transitions</div>
<div><strong>Awareness:</strong> States often know about valid transitions</div>
<div><strong>Transitions:</strong> States can trigger state changes</div>
<div><strong>Question answered:</strong> "What can I do now?"</div>
<div><strong>Lifetime:</strong> Changes frequently as object evolves</div>
<div><strong>Mental model:</strong> Finite state machine</div>
</div>
</div>
</div>
</div>
<h3 id="concrete-example-comparison">Concrete Example Comparison</h3>
<pre><code class="language-python"># STRATEGY: Payment processing - client chooses method
class PaymentProcessor:
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy  # Set externally, rarely changes

    def process(self, amount):
        return self._strategy.charge(amount)

# User explicitly selects: &quot;I want to pay with PayPal&quot;
processor = PaymentProcessor(PayPalStrategy())


# STATE: Order lifecycle - transitions happen internally
class Order:
    def __init__(self):
        self._state = PendingState(self)  # Internal management

    def pay(self):
        self._state.pay()  # State may transition to PaidState

    def ship(self):
        self._state.ship()  # PaidState transitions to ShippedState

# The order manages its own state transitions
order = Order()
order.pay()   # Pending -&gt; Paid (automatic transition)
order.ship()  # Paid -&gt; Shipped (automatic transition)
</code></pre>
<div>
<div>Interview Insight</div>
<div>
    The key tell: if you're modeling "modes" or "algorithms" that a user/client selects, use Strategy. If you're modeling "lifecycle phases" or "conditions" that the object transitions through based on events, use [[State Pattern]](/topics/design-patterns/state).
</div>
</div>
<h3 id="interview-deep-dive-strategy-vs-state">Interview Deep-Dive: Strategy vs State</h3>
<div>
<div>Level 1: When would refactoring from Strategy to State (or vice versa) be appropriate?</div>
<div>
<strong>Answer:</strong> Refactor Strategy to State when you discover that "strategies" naturally transition to each other based on operations. For example, if a CompressionStrategy starts needing to switch from LZ4 to GZIP when data exceeds a threshold, you've discovered implicit state.
    <br/><br/>
    Refactor State to Strategy when you realize states don't actually transition - they're just different modes that the client selects. If your "states" never call setState() internally, they're probably strategies.
</div>
</div>
<div>
<div>Level 2: Can Strategy and State patterns coexist in the same class? Give an example.</div>
<div>
<strong>Answer:</strong> Absolutely. Consider a video player:
    <br/><br/>
<strong>State:</strong> PlayingState, PausedState, BufferingState (lifecycle transitions)
    <br/>
<strong>Strategy:</strong> AudioCodecStrategy (AAC, MP3, FLAC), VideoScalingStrategy (fit, fill, crop)
    <br/><br/>
    The player transitions through states based on user actions and network conditions. Independently, the user can select codec and scaling strategies. These are orthogonal concerns - state manages "what operations are valid now" while strategy manages "how to perform those operations."
</div>
</div>
<div>
<div>Level 3: How would you design a hybrid pattern where strategies can influence state transitions?</div>
<div>
<strong>Answer:</strong> Use a result-based approach where strategy execution returns transition hints:
    <br/><br/>
    ```python
    class StrategyResult:
    def __init__(self, value, suggested_state=None):
    self.value = value
    self.suggested_state = suggested_state
<pre><code>class Context:
def execute(self):
result = self._strategy.execute(self._data)
if result.suggested_state:
self._state = result.suggested_state
return result.value
```
&lt;br/&gt;
This maintains separation of concerns: strategies compute results and can suggest transitions, but the context (or its current state) decides whether to honor those suggestions. This avoids strategies directly manipulating context state while enabling strategy-influenced transitions.
</code></pre>
</div>
</div>
<hr />
<h2 id="runtime-strategy-switching-patterns-and-pitfalls">Runtime Strategy Switching: Patterns and Pitfalls</h2>
<h3 id="dynamic-selection-mechanisms">Dynamic Selection Mechanisms</h3>
<div>
<div>Strategy Selection Approaches</div>
<div>
<div>
<div>1. Direct Injection</div>
<div>Client explicitly passes strategy. Most flexible, requires client knowledge.</div>
</div>
<div>
<div>2. Factory-Based Selection</div>
<div>Factory examines context and returns appropriate strategy. Centralizes selection logic.</div>
</div>
<div>
<div>3. Registry/Plugin System</div>
<div>Strategies self-register with metadata. System matches request to registered strategies.</div>
</div>
<div>
<div>4. Configuration-Driven</div>
<div>Strategy selected from config file, database, or feature flags. Enables runtime changes without deployment.</div>
</div>
</div>
</div>
<h3 id="strategy-registry-pattern">Strategy Registry Pattern</h3>
<pre><code class="language-python">from typing import Dict, Type, Callable, Any, Optional
from abc import ABC, abstractmethod

class SortingStrategy(ABC):
    &quot;&quot;&quot;Base strategy for sorting algorithms.&quot;&quot;&quot;

    @property
    @abstractmethod
    def name(self) -&gt; str:
        &quot;&quot;&quot;Identifier for registry lookup.&quot;&quot;&quot;
        pass

    @property
    @abstractmethod
    def time_complexity(self) -&gt; str:
        &quot;&quot;&quot;For documentation and selection.&quot;&quot;&quot;
        pass

    @property
    @abstractmethod
    def stable(self) -&gt; bool:
        &quot;&quot;&quot;Whether sort preserves equal element order.&quot;&quot;&quot;
        pass

    @abstractmethod
    def sort(self, data: list, key: Callable = None, reverse: bool = False) -&gt; list:
        pass


class StrategyRegistry:
    &quot;&quot;&quot;
    Central registry for strategy discovery and selection.
    Supports multiple selection criteria.
    &quot;&quot;&quot;

    _instance: Optional['StrategyRegistry'] = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._strategies: Dict[str, SortingStrategy] = {}
        return cls._instance

    def register(self, strategy: SortingStrategy) -&gt; 'StrategyRegistry':
        &quot;&quot;&quot;Register a strategy by its name.&quot;&quot;&quot;
        self._strategies[strategy.name] = strategy
        return self

    def get(self, name: str) -&gt; SortingStrategy:
        &quot;&quot;&quot;Direct lookup by name.&quot;&quot;&quot;
        if name not in self._strategies:
            raise KeyError(f&quot;Unknown strategy: {name}. Available: {list(self._strategies.keys())}&quot;)
        return self._strategies[name]

    def select_for_size(self, data_size: int, need_stable: bool = False) -&gt; SortingStrategy:
        &quot;&quot;&quot;
        Select optimal strategy based on data characteristics.
        This encapsulates the selection heuristics.
        &quot;&quot;&quot;
        candidates = list(self._strategies.values())

        if need_stable:
            candidates = [s for s in candidates if s.stable]

        # Heuristic: small data -&gt; simple algorithm, large data -&gt; efficient algorithm
        if data_size &lt; 50:
            # Prefer insertion sort for small arrays
            for s in candidates:
                if 'insertion' in s.name.lower():
                    return s
        elif data_size &lt; 10000:
            # Prefer quicksort for medium arrays
            for s in candidates:
                if 'quick' in s.name.lower():
                    return s
        else:
            # Prefer merge sort for large arrays (stable) or heap sort
            for s in candidates:
                if 'merge' in s.name.lower():
                    return s

        # Fallback to first available
        return candidates[0] if candidates else None

    def list_all(self) -&gt; Dict[str, Dict[str, Any]]:
        &quot;&quot;&quot;Return all strategies with metadata for UI/documentation.&quot;&quot;&quot;
        return {
            name: {
                'time_complexity': s.time_complexity,
                'stable': s.stable,
            }
            for name, s in self._strategies.items()
        }


# Concrete implementations
class QuickSortStrategy(SortingStrategy):
    @property
    def name(self) -&gt; str:
        return &quot;quicksort&quot;

    @property
    def time_complexity(self) -&gt; str:
        return &quot;O(n log n) average, O(n^2) worst&quot;

    @property
    def stable(self) -&gt; bool:
        return False  # Standard quicksort is not stable

    def sort(self, data: list, key: Callable = None, reverse: bool = False) -&gt; list:
        if len(data) &lt;= 1:
            return data.copy()

        # Three-way partitioning for better handling of duplicates
        result = data.copy()
        self._quicksort(result, 0, len(result) - 1, key or (lambda x: x))
        return result[::-1] if reverse else result

    def _quicksort(self, arr, low, high, key):
        if low &lt; high:
            pivot_idx = self._partition(arr, low, high, key)
            self._quicksort(arr, low, pivot_idx - 1, key)
            self._quicksort(arr, pivot_idx + 1, high, key)

    def _partition(self, arr, low, high, key):
        pivot = key(arr[high])
        i = low - 1
        for j in range(low, high):
            if key(arr[j]) &lt;= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1


class MergeSortStrategy(SortingStrategy):
    @property
    def name(self) -&gt; str:
        return &quot;mergesort&quot;

    @property
    def time_complexity(self) -&gt; str:
        return &quot;O(n log n) guaranteed&quot;

    @property
    def stable(self) -&gt; bool:
        return True  # Merge sort preserves order of equal elements

    def sort(self, data: list, key: Callable = None, reverse: bool = False) -&gt; list:
        if len(data) &lt;= 1:
            return data.copy()

        key = key or (lambda x: x)
        result = self._mergesort(data, key)
        return result[::-1] if reverse else result

    def _mergesort(self, arr, key):
        if len(arr) &lt;= 1:
            return arr

        mid = len(arr) // 2
        left = self._mergesort(arr[:mid], key)
        right = self._mergesort(arr[mid:], key)
        return self._merge(left, right, key)

    def _merge(self, left, right, key):
        result = []
        i = j = 0

        while i &lt; len(left) and j &lt; len(right):
            # &lt;= ensures stability (left element comes first on tie)
            if key(left[i]) &lt;= key(right[j]):
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1

        result.extend(left[i:])
        result.extend(right[j:])
        return result


class InsertionSortStrategy(SortingStrategy):
    @property
    def name(self) -&gt; str:
        return &quot;insertionsort&quot;

    @property
    def time_complexity(self) -&gt; str:
        return &quot;O(n^2) worst, O(n) nearly sorted&quot;

    @property
    def stable(self) -&gt; bool:
        return True

    def sort(self, data: list, key: Callable = None, reverse: bool = False) -&gt; list:
        result = data.copy()
        key = key or (lambda x: x)

        for i in range(1, len(result)):
            current = result[i]
            j = i - 1
            while j &gt;= 0 and key(result[j]) &gt; key(current):
                result[j + 1] = result[j]
                j -= 1
            result[j + 1] = current

        return result[::-1] if reverse else result


# Context that uses the registry
class DataSorter:
    &quot;&quot;&quot;Context class demonstrating registry-based strategy selection.&quot;&quot;&quot;

    def __init__(self, registry: StrategyRegistry):
        self._registry = registry
        self._strategy: Optional[SortingStrategy] = None
        self._auto_select = True

    def set_strategy(self, name: str) -&gt; 'DataSorter':
        &quot;&quot;&quot;Manually set strategy by name.&quot;&quot;&quot;
        self._strategy = self._registry.get(name)
        self._auto_select = False
        return self

    def enable_auto_selection(self) -&gt; 'DataSorter':
        &quot;&quot;&quot;Let the system choose optimal strategy.&quot;&quot;&quot;
        self._auto_select = True
        return self

    def sort(self, data: list, *, key: Callable = None,
             reverse: bool = False, need_stable: bool = False) -&gt; list:
        &quot;&quot;&quot;Sort data using current or auto-selected strategy.&quot;&quot;&quot;

        if self._auto_select:
            strategy = self._registry.select_for_size(len(data), need_stable)
        else:
            strategy = self._strategy

        if not strategy:
            raise RuntimeError(&quot;No sorting strategy available&quot;)

        return strategy.sort(data, key, reverse)


# Usage
registry = StrategyRegistry()
registry.register(QuickSortStrategy())
registry.register(MergeSortStrategy())
registry.register(InsertionSortStrategy())

sorter = DataSorter(registry)

# Auto-selection based on data size
small_data = [3, 1, 4, 1, 5]
large_data = list(range(100000, 0, -1))

sorted_small = sorter.sort(small_data)  # Uses insertion sort
sorted_large = sorter.sort(large_data)  # Uses merge sort

# Manual override
sorter.set_strategy(&quot;quicksort&quot;)
sorted_quick = sorter.sort(small_data)  # Forces quicksort
</code></pre>
<h3 id="thread-safety-in-strategy-switching">Thread Safety in Strategy Switching</h3>
<div>
<div>Critical Concurrency Consideration</div>
<div>
    If the context is shared across threads and strategies can be swapped at runtime, you face a race condition: Thread A may read the strategy reference while Thread B is updating it, leading to torn reads or use of partially-constructed strategy objects.
</div>
</div>
<pre><code class="language-python">import threading
from typing import Optional

class ThreadSafeContext:
    &quot;&quot;&quot;
    Demonstrates thread-safe strategy switching.
    Uses read-write lock for optimal concurrent read access.
    &quot;&quot;&quot;

    def __init__(self, initial_strategy: SortingStrategy):
        self._strategy = initial_strategy
        self._lock = threading.RLock()  # Reentrant for nested calls

    def set_strategy(self, strategy: SortingStrategy) -&gt; None:
        &quot;&quot;&quot;Thread-safe strategy replacement.&quot;&quot;&quot;
        with self._lock:
            self._strategy = strategy

    def execute(self, data: list) -&gt; list:
        &quot;&quot;&quot;
        Thread-safe execution.
        Captures strategy reference under lock, then executes outside lock.
        &quot;&quot;&quot;
        with self._lock:
            strategy = self._strategy  # Capture reference

        # Execute outside lock - allows concurrent executions with same strategy
        return strategy.sort(data)


class CopyOnWriteContext:
    &quot;&quot;&quot;
    Alternative: Copy-on-write for lock-free reads.
    Ideal when reads vastly outnumber writes.
    &quot;&quot;&quot;

    def __init__(self, initial_strategy: SortingStrategy):
        self._strategy = initial_strategy  # Atomic reference

    def set_strategy(self, strategy: SortingStrategy) -&gt; None:
        &quot;&quot;&quot;
        Atomic replacement - Python's GIL makes reference assignment atomic.
        For languages without GIL, use atomic references.
        &quot;&quot;&quot;
        self._strategy = strategy

    def execute(self, data: list) -&gt; list:
        &quot;&quot;&quot;Lock-free read - safe due to atomic reference.&quot;&quot;&quot;
        return self._strategy.sort(data)
</code></pre>
<h3 id="interview-deep-dive-runtime-strategy-switching">Interview Deep-Dive: Runtime Strategy Switching</h3>
<div>
<div>Level 1: What are the risks of changing strategies during execution?</div>
<div>
<strong>Answer:</strong> Three main risks:
    <br/><br/>
<strong>1. Inconsistent state:</strong> If an operation spans multiple strategy calls, switching mid-operation produces inconsistent results.
    <br/><br/>
<strong>2. Resource leaks:</strong> If strategies hold resources (connections, file handles), switching without proper cleanup causes leaks.
    <br/><br/>
<strong>3. Thread safety:</strong> Concurrent reads during a write can see torn references or partially-constructed objects.
</div>
</div>
<div>
<div>Level 2: How would you implement strategy hot-reloading from a configuration file?</div>
<div>
<strong>Answer:</strong> Use a file watcher combined with a strategy factory:
    <br/><br/>
    1. Watch config file for changes (inotify on Linux, FSEvents on macOS)
    <br/>2. On change, parse new configuration
    <br/>3. Use factory to instantiate new strategy from config
    <br/>4. Atomically swap the strategy reference
    <br/>5. If old strategy needs cleanup, do it after swap (not before)
    <br/><br/>
    Key consideration: validate new configuration before swapping. If validation fails, keep the old strategy and log the error. Never leave the system without a valid strategy.
</div>
</div>
<div>
<div>Level 3: Design a strategy versioning system that supports gradual rollouts and instant rollbacks.</div>
<div>
<strong>Answer:</strong> Implement a versioned strategy registry with traffic splitting:
    <br/><br/>
    ```python
    class VersionedStrategyManager:
    def __init__(self):
    self._versions = {}  # version -> strategy
    self._traffic_split = {}  # version -> percentage
    self._default_version = None
<pre><code>def register_version(self, version, strategy, traffic_pct=0):
self._versions[version] = strategy
self._traffic_split[version] = traffic_pct

def set_default(self, version):
self._default_version = version

def rollout(self, version, target_pct, step_pct=10, interval_sec=60):
# Gradually increase traffic to new version
current = self._traffic_split.get(version, 0)
while current &lt; target_pct:
current = min(current + step_pct, target_pct)
self._traffic_split[version] = current
self._rebalance_traffic()
time.sleep(interval_sec)
if self._health_check_failed(version):
self.instant_rollback(version)
return False
return True

def instant_rollback(self, version):
self._traffic_split[version] = 0
self._rebalance_traffic()

def select_for_request(self, request_id):
# Deterministic bucketing based on request ID
bucket = hash(request_id) % 100
cumulative = 0
for version, pct in self._traffic_split.items():
cumulative += pct
if bucket &lt; cumulative:
return self._versions[version]
return self._versions[self._default_version]
```
&lt;br/&gt;
This enables canary deployments, A/B testing, and instant rollback without deployment. The deterministic bucketing ensures consistent user experience across requests.
</code></pre>
</div>
</div>
<hr />
<h2 id="functional-alternatives-to-strategy-pattern">Functional Alternatives to Strategy Pattern</h2>
<p>In functional programming languages (and modern multi-paradigm languages), strategy pattern can be implemented without classes using first-class functions.</p>
<h3 id="function-based-strategies">Function-Based Strategies</h3>
<pre><code class="language-python">from typing import Callable, Dict, Any, TypeVar, Protocol
from decimal import Decimal
from functools import partial

# Type definitions
T = TypeVar('T')
DiscountFunction = Callable[[Decimal, Dict[str, Any]], Decimal]

# Strategies as pure functions
def no_discount(subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
    &quot;&quot;&quot;Null strategy - no discount applied.&quot;&quot;&quot;
    return Decimal(&quot;0&quot;)

def percentage_discount(percent: Decimal, subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
    &quot;&quot;&quot;Parameterized percentage discount.&quot;&quot;&quot;
    return subtotal * (percent / Decimal(&quot;100&quot;))

def fixed_amount_discount(amount: Decimal, min_purchase: Decimal,
                          subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
    &quot;&quot;&quot;Fixed amount off with minimum purchase requirement.&quot;&quot;&quot;
    if subtotal &gt;= min_purchase:
        return min(amount, subtotal)
    return Decimal(&quot;0&quot;)

def loyalty_discount(subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
    &quot;&quot;&quot;Discount based on loyalty tier from context.&quot;&quot;&quot;
    tier_rates = {
        &quot;bronze&quot;: Decimal(&quot;5&quot;),
        &quot;silver&quot;: Decimal(&quot;10&quot;),
        &quot;gold&quot;: Decimal(&quot;15&quot;),
        &quot;platinum&quot;: Decimal(&quot;20&quot;),
    }
    tier = context.get(&quot;loyalty_tier&quot;, &quot;&quot;).lower()
    rate = tier_rates.get(tier, Decimal(&quot;0&quot;))
    return subtotal * (rate / Decimal(&quot;100&quot;))


# Strategy factory using partial application
def create_percentage_strategy(percent: Decimal) -&gt; DiscountFunction:
    &quot;&quot;&quot;Factory that creates percentage discount strategies.&quot;&quot;&quot;
    return partial(percentage_discount, percent)

def create_fixed_strategy(amount: Decimal, min_purchase: Decimal = Decimal(&quot;0&quot;)) -&gt; DiscountFunction:
    &quot;&quot;&quot;Factory that creates fixed amount strategies.&quot;&quot;&quot;
    return partial(fixed_amount_discount, amount, min_purchase)


# Context using functional strategies
class FunctionalCart:
    &quot;&quot;&quot;Shopping cart using function-based strategies.&quot;&quot;&quot;

    def __init__(self):
        self._items: list = []
        self._discount_fn: DiscountFunction = no_discount
        self._context: Dict[str, Any] = {}

    def add_item(self, name: str, price: Decimal, quantity: int = 1) -&gt; 'FunctionalCart':
        self._items.append({&quot;name&quot;: name, &quot;price&quot;: price, &quot;quantity&quot;: quantity})
        return self

    def set_context(self, **kwargs) -&gt; 'FunctionalCart':
        self._context.update(kwargs)
        return self

    def set_discount(self, discount_fn: DiscountFunction) -&gt; 'FunctionalCart':
        self._discount_fn = discount_fn
        return self

    @property
    def subtotal(self) -&gt; Decimal:
        return sum(item[&quot;price&quot;] * item[&quot;quantity&quot;] for item in self._items)

    @property
    def discount(self) -&gt; Decimal:
        return self._discount_fn(self.subtotal, self._context)

    @property
    def total(self) -&gt; Decimal:
        return self.subtotal - self.discount


# Usage
cart = FunctionalCart()
cart.add_item(&quot;Laptop&quot;, Decimal(&quot;999.99&quot;))
cart.add_item(&quot;Mouse&quot;, Decimal(&quot;49.99&quot;))

# Using different strategies
cart.set_discount(create_percentage_strategy(Decimal(&quot;10&quot;)))
print(f&quot;10% off: ${cart.total}&quot;)

cart.set_discount(create_fixed_strategy(Decimal(&quot;50&quot;), Decimal(&quot;100&quot;)))
print(f&quot;$50 off: ${cart.total}&quot;)

cart.set_context(loyalty_tier=&quot;gold&quot;)
cart.set_discount(loyalty_discount)
print(f&quot;Gold member: ${cart.total}&quot;)
</code></pre>
<h3 id="strategy-composition-with-higher-order-functions">Strategy Composition with Higher-Order Functions</h3>
<pre><code class="language-python">from typing import List
from functools import reduce

# Higher-order functions for strategy composition
def compose_strategies(*strategies: DiscountFunction) -&gt; DiscountFunction:
    &quot;&quot;&quot;
    Compose multiple strategies - each applies to remaining amount.
    Like stacking coupons: 10% off, then $5 off the discounted price.
    &quot;&quot;&quot;
    def composed(subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
        total_discount = Decimal(&quot;0&quot;)
        remaining = subtotal

        for strategy in strategies:
            discount = strategy(remaining, context)
            total_discount += discount
            remaining -= discount

        return total_discount

    return composed


def best_of_strategies(*strategies: DiscountFunction) -&gt; DiscountFunction:
    &quot;&quot;&quot;Select the strategy that gives the maximum discount.&quot;&quot;&quot;
    def selector(subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
        discounts = [s(subtotal, context) for s in strategies]
        return max(discounts)

    return selector


def conditional_strategy(
    condition: Callable[[Decimal, Dict[str, Any]], bool],
    if_true: DiscountFunction,
    if_false: DiscountFunction = no_discount
) -&gt; DiscountFunction:
    &quot;&quot;&quot;Strategy that applies conditionally.&quot;&quot;&quot;
    def conditional(subtotal: Decimal, context: Dict[str, Any]) -&gt; Decimal:
        if condition(subtotal, context):
            return if_true(subtotal, context)
        return if_false(subtotal, context)

    return conditional


# Example compositions
vip_discount = compose_strategies(
    loyalty_discount,  # First apply loyalty discount
    create_percentage_strategy(Decimal(&quot;5&quot;)),  # Then additional 5% on remainder
)

best_deal = best_of_strategies(
    create_percentage_strategy(Decimal(&quot;15&quot;)),
    create_fixed_strategy(Decimal(&quot;25&quot;), Decimal(&quot;100&quot;)),
    loyalty_discount,
)

weekday_discount = conditional_strategy(
    condition=lambda s, ctx: ctx.get(&quot;is_weekday&quot;, False),
    if_true=create_percentage_strategy(Decimal(&quot;10&quot;)),
    if_false=create_percentage_strategy(Decimal(&quot;5&quot;)),
)
</code></pre>
<h3 id="when-to-use-classes-vs-functions">When to Use Classes vs Functions</h3>
<div>
<div>
<div>Prefer Classes When:</div>
<ul>
<li>Strategies need multiple methods</li>
<li>Strategies require shared state or resources</li>
<li>You need metadata (name, description, version)</li>
<li>Strategies are loaded dynamically (plugins)</li>
<li>Complex initialization or lifecycle management</li>
<li>IDE support for interface implementation</li>
</ul>
</div>
<div>
<div>Prefer Functions When:</div>
<ul>
<li>Single-method strategies</li>
<li>Stateless algorithms</li>
<li>Heavy use of composition (map, filter, reduce)</li>
<li>Functional programming paradigm</li>
<li>Closures can capture all needed state</li>
<li>Simpler testing (no mocking needed)</li>
</ul>
</div>
</div>
<h3 id="interview-deep-dive-functional-alternatives">Interview Deep-Dive: Functional Alternatives</h3>
<div>
<div>Level 1: Are lambdas and anonymous functions a valid implementation of Strategy pattern?</div>
<div>
<strong>Answer:</strong> Yes. The Gang of Four Strategy pattern predates widespread first-class function support, but the essence is "encapsulate algorithm and make it interchangeable." A lambda <code>(x, ctx) => x * 0.9</code> for a 10% discount is a perfectly valid strategy. The pattern is about the concept of swappable behavior, not necessarily about classes and interfaces.
</div>
</div>
<div>
<div>Level 2: How do you handle strategy metadata (name, description) in a functional approach?</div>
<div>
<strong>Answer:</strong> Several approaches:
    <br/><br/>
<strong>1. Named tuples/dataclasses:</strong> Bundle function with metadata
    ```python
    @dataclass
    class Strategy:
    name: str
    description: str
    execute: Callable
    ```
    <br/>
<strong>2. Function attributes:</strong> Python allows setting attributes on functions
    ```python
    def my_strategy(x, ctx): ...
    my_strategy.name = "My Strategy"
    my_strategy.description = "Does something"
    ```
    <br/>
<strong>3. Decorator pattern:</strong> Wrap functions with metadata
    ```python
    @strategy(name="Ten Percent", description="10% off")
    def ten_percent(x, ctx): ...
    ```
</div>
</div>
<div>
<div>Level 3: How would you implement a type-safe strategy pattern in TypeScript that supports both class and function strategies?</div>
<div>
<strong>Answer:</strong> Use a union type that accepts both:
    <br/><br/>
    ```typescript
    // Strategy can be either a function or an object with execute method
    type StrategyFunction<T, R> = (input: T, context: Context) => R;
<pre><code>  interface StrategyObject&lt;T, R&gt; {
    name: string;
    execute: (input: T, context: Context) =&gt; R;
    }

    type Strategy&lt;T, R&gt; = StrategyFunction&lt;T, R&gt; | StrategyObject&lt;T, R&gt;;

          // Context normalizes both forms
          class StrategyContext&lt;T, R&gt; {
            constructor(private strategy: Strategy&lt;T, R&gt;) {}

              execute(input: T, context: Context): R {
              if (typeof this.strategy === 'function') {
              return this.strategy(input, context);
              }
              return this.strategy.execute(input, context);
              }

              getName(): string {
              if (typeof this.strategy === 'function') {
              return this.strategy.name || 'anonymous';
              }
              return this.strategy.name;
              }
              }
              ```
</code></pre>
  <br/>
  This provides flexibility while maintaining type safety. The context handles normalization, so clients can use whichever form is most convenient.
</div>
</div>
<hr />
<h2 id="real-world-implementation-payment-processing">Real-World Implementation: Payment Processing</h2>
<p>Payment systems are a canonical Strategy pattern use case. Different payment methods have fundamentally different processing flows, fee structures, and validation requirements.</p>
<pre><code>          ```python
          from abc import ABC, abstractmethod
          from dataclasses import dataclass, field
          from decimal import Decimal, ROUND_HALF_UP
          from typing import Dict, Any, Optional, List
          from datetime import datetime
          from enum import Enum
          import re
          import hashlib


          class PaymentStatus(Enum):
          PENDING = &quot;pending&quot;
          PROCESSING = &quot;processing&quot;
          COMPLETED = &quot;completed&quot;
          FAILED = &quot;failed&quot;
          REFUNDED = &quot;refunded&quot;


          @dataclass
          class PaymentResult:
          &quot;&quot;&quot;Immutable result of a payment operation.&quot;&quot;&quot;
          success: bool
          status: PaymentStatus
          transaction_id: Optional[str] = None
          error_code: Optional[str] = None
          error_message: Optional[str] = None
          processor_response: Dict[str, Any] = field(default_factory=dict)
          fees: Decimal = Decimal(&quot;0&quot;)
          net_amount: Decimal = Decimal(&quot;0&quot;)


          @dataclass
          class PaymentRequest:
          &quot;&quot;&quot;Payment request with all necessary details.&quot;&quot;&quot;
          amount: Decimal
          currency: str
          customer_id: str
          idempotency_key: str
          metadata: Dict[str, Any] = field(default_factory=dict)


          class PaymentStrategy(ABC):
          &quot;&quot;&quot;
          Abstract payment strategy defining the contract for all payment methods.
          Each concrete strategy encapsulates a complete payment flow.
          &quot;&quot;&quot;

          @property
          @abstractmethod
          def name(self) -&gt; str:
          &quot;&quot;&quot;Human-readable payment method name.&quot;&quot;&quot;
          pass

          @property
          @abstractmethod
          def supported_currencies(self) -&gt; List[str]:
          &quot;&quot;&quot;List of ISO 4217 currency codes this method supports.&quot;&quot;&quot;
          pass

          @property
          @abstractmethod
          def min_amount(self) -&gt; Decimal:
          &quot;&quot;&quot;Minimum transaction amount in base currency.&quot;&quot;&quot;
          pass

          @property
          @abstractmethod
          def max_amount(self) -&gt; Decimal:
          &quot;&quot;&quot;Maximum transaction amount in base currency.&quot;&quot;&quot;
          pass

          @abstractmethod
          def calculate_fees(self, amount: Decimal, currency: str) -&gt; Decimal:
          &quot;&quot;&quot;Calculate processing fees for this payment method.&quot;&quot;&quot;
          pass

          @abstractmethod
          def validate(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; List[str]:
          &quot;&quot;&quot;
          Validate payment details before processing.
          Returns list of validation errors (empty if valid).
          &quot;&quot;&quot;
          pass

          @abstractmethod
          def process(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; PaymentResult:
          &quot;&quot;&quot;
          Execute the payment.
          This is where strategy-specific logic lives.
          &quot;&quot;&quot;
          pass

          @abstractmethod
          def refund(self, transaction_id: str, amount: Optional[Decimal] = None) -&gt; PaymentResult:
          &quot;&quot;&quot;Process a full or partial refund.&quot;&quot;&quot;
          pass

          def can_process(self, request: PaymentRequest) -&gt; bool:
          &quot;&quot;&quot;Check if this strategy can handle the given request.&quot;&quot;&quot;
          if request.currency not in self.supported_currencies:
          return False
          if request.amount &lt; self.min_amount or request.amount &gt; self.max_amount:
          return False
          return True


          class CreditCardStrategy(PaymentStrategy):
          &quot;&quot;&quot;
          Credit card payment processing.
          Demonstrates complex validation and fee structures.
          &quot;&quot;&quot;

          # Fee structure: percentage + fixed fee per transaction
          PERCENTAGE_FEE = Decimal(&quot;2.9&quot;)
          FIXED_FEE = Decimal(&quot;0.30&quot;)

          # Card brand specific rates (simplified)
          BRAND_RATES = {
          &quot;visa&quot;: Decimal(&quot;2.4&quot;),
          &quot;mastercard&quot;: Decimal(&quot;2.4&quot;),
          &quot;amex&quot;: Decimal(&quot;3.5&quot;),
          &quot;discover&quot;: Decimal(&quot;2.5&quot;),
          }

          @property
          def name(self) -&gt; str:
          return &quot;Credit Card&quot;

          @property
          def supported_currencies(self) -&gt; List[str]:
          return [&quot;USD&quot;, &quot;EUR&quot;, &quot;GBP&quot;, &quot;CAD&quot;, &quot;AUD&quot;]

          @property
          def min_amount(self) -&gt; Decimal:
          return Decimal(&quot;0.50&quot;)

          @property
          def max_amount(self) -&gt; Decimal:
          return Decimal(&quot;999999.99&quot;)

          def calculate_fees(self, amount: Decimal, currency: str) -&gt; Decimal:
          &quot;&quot;&quot;
          Credit card fees: percentage of amount + fixed fee.
          Real-world: varies by card brand, transaction type, merchant category.
          &quot;&quot;&quot;
          percentage_fee = amount * (self.PERCENTAGE_FEE / Decimal(&quot;100&quot;))
          total_fee = percentage_fee + self.FIXED_FEE
          return total_fee.quantize(Decimal(&quot;0.01&quot;), rounding=ROUND_HALF_UP)

          def validate(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; List[str]:
          errors = []

          card_number = payment_details.get(&quot;card_number&quot;, &quot;&quot;)
          expiry = payment_details.get(&quot;expiry&quot;, &quot;&quot;)
          cvv = payment_details.get(&quot;cvv&quot;, &quot;&quot;)

          # Luhn algorithm for card number validation
          if not self._luhn_check(card_number):
          errors.append(&quot;Invalid card number&quot;)

          # Expiry validation
          if not self._validate_expiry(expiry):
          errors.append(&quot;Card has expired or invalid expiry format&quot;)

          # CVV validation
          if not re.match(r&quot;^\d{3,4}$&quot;, cvv):
          errors.append(&quot;Invalid CVV&quot;)

          # Amount validation
          if not self.can_process(request):
          errors.append(f&quot;Amount must be between {self.min_amount} and {self.max_amount}&quot;)

          return errors

          def _luhn_check(self, card_number: str) -&gt; bool:
          &quot;&quot;&quot;Validate card number using Luhn algorithm.&quot;&quot;&quot;
          digits = [int(d) for d in card_number if d.isdigit()]
          if len(digits) &lt; 13 or len(digits) &gt; 19:
          return False

          checksum = 0
          for i, digit in enumerate(reversed(digits)):
          if i % 2 == 1:
          digit *= 2
          if digit &gt; 9:
          digit -= 9
          checksum += digit

          return checksum % 10 == 0

          def _validate_expiry(self, expiry: str) -&gt; bool:
          &quot;&quot;&quot;Validate MM/YY or MM/YYYY expiry format.&quot;&quot;&quot;
          match = re.match(r&quot;^(\d{2})/(\d{2}|\d{4})$&quot;, expiry)
          if not match:
          return False

          month, year = int(match.group(1)), int(match.group(2))
          if year &lt; 100:
          year += 2000

          if month &lt; 1 or month &gt; 12:
          return False

          now = datetime.now()
          expiry_date = datetime(year, month, 1)
          return expiry_date &gt;= datetime(now.year, now.month, 1)

          def process(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; PaymentResult:
          &quot;&quot;&quot;
          Process credit card payment.
          In production: calls payment gateway API (Stripe, Braintree, etc.)
          &quot;&quot;&quot;
          # Validation first
          errors = self.validate(request, payment_details)
          if errors:
          return PaymentResult(
          success=False,
          status=PaymentStatus.FAILED,
          error_code=&quot;VALIDATION_ERROR&quot;,
          error_message=&quot;; &quot;.join(errors),
          )

          # Simulate gateway call
          transaction_id = self._generate_transaction_id(request)
          fees = self.calculate_fees(request.amount, request.currency)

          # In real implementation: API call to payment processor
          # response = self._gateway.charge(...)

          return PaymentResult(
          success=True,
          status=PaymentStatus.COMPLETED,
          transaction_id=transaction_id,
          fees=fees,
          net_amount=request.amount - fees,
          processor_response={
          &quot;authorization_code&quot;: &quot;AUTH123456&quot;,
          &quot;card_brand&quot;: self._detect_card_brand(payment_details[&quot;card_number&quot;]),
          &quot;last_four&quot;: payment_details[&quot;card_number&quot;][-4:],
          },
          )

          def refund(self, transaction_id: str, amount: Optional[Decimal] = None) -&gt; PaymentResult:
          &quot;&quot;&quot;Process refund through payment gateway.&quot;&quot;&quot;
          # In production: API call to reverse/refund the charge
          return PaymentResult(
          success=True,
          status=PaymentStatus.REFUNDED,
          transaction_id=f&quot;REF-{transaction_id}&quot;,
          processor_response={&quot;original_transaction&quot;: transaction_id},
          )

          def _generate_transaction_id(self, request: PaymentRequest) -&gt; str:
          &quot;&quot;&quot;Generate unique transaction ID using idempotency key.&quot;&quot;&quot;
          data = f&quot;{request.idempotency_key}:{request.customer_id}:{request.amount}&quot;
          return f&quot;CC-{hashlib.sha256(data.encode()).hexdigest()[:16].upper()}&quot;

          def _detect_card_brand(self, card_number: str) -&gt; str:
          &quot;&quot;&quot;Detect card brand from number prefix.&quot;&quot;&quot;
          number = card_number.replace(&quot; &quot;, &quot;&quot;)
          if number.startswith(&quot;4&quot;):
          return &quot;visa&quot;
          elif number[:2] in [&quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;55&quot;]:
          return &quot;mastercard&quot;
          elif number[:2] in [&quot;34&quot;, &quot;37&quot;]:
          return &quot;amex&quot;
          elif number.startswith(&quot;6011&quot;):
          return &quot;discover&quot;
          return &quot;unknown&quot;


          class ACHStrategy(PaymentStrategy):
          &quot;&quot;&quot;
          ACH (Automated Clearing House) bank transfer strategy.
          Lower fees but slower settlement.
          &quot;&quot;&quot;

          PERCENTAGE_FEE = Decimal(&quot;0.8&quot;)
          MAX_FEE = Decimal(&quot;5.00&quot;)

          @property
          def name(self) -&gt; str:
          return &quot;ACH Bank Transfer&quot;

          @property
          def supported_currencies(self) -&gt; List[str]:
          return [&quot;USD&quot;]  # ACH is US-only

          @property
          def min_amount(self) -&gt; Decimal:
          return Decimal(&quot;1.00&quot;)

          @property
          def max_amount(self) -&gt; Decimal:
          return Decimal(&quot;100000.00&quot;)

          def calculate_fees(self, amount: Decimal, currency: str) -&gt; Decimal:
          &quot;&quot;&quot;ACH fees: percentage with cap.&quot;&quot;&quot;
          fee = amount * (self.PERCENTAGE_FEE / Decimal(&quot;100&quot;))
          return min(fee, self.MAX_FEE).quantize(Decimal(&quot;0.01&quot;), rounding=ROUND_HALF_UP)

          def validate(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; List[str]:
          errors = []

          routing = payment_details.get(&quot;routing_number&quot;, &quot;&quot;)
          account = payment_details.get(&quot;account_number&quot;, &quot;&quot;)

          # ABA routing number validation
          if not self._validate_routing_number(routing):
          errors.append(&quot;Invalid routing number&quot;)

          # Account number basic validation
          if not re.match(r&quot;^\d{4,17}$&quot;, account):
          errors.append(&quot;Invalid account number&quot;)

          if request.currency != &quot;USD&quot;:
          errors.append(&quot;ACH only supports USD&quot;)

          return errors

          def _validate_routing_number(self, routing: str) -&gt; bool:
          &quot;&quot;&quot;Validate 9-digit ABA routing number with checksum.&quot;&quot;&quot;
          if not re.match(r&quot;^\d{9}$&quot;, routing):
          return False

          # ABA checksum algorithm
          digits = [int(d) for d in routing]
          checksum = (
          3 * (digits[0] + digits[3] + digits[6]) +
          7 * (digits[1] + digits[4] + digits[7]) +
          1 * (digits[2] + digits[5] + digits[8])
          )
          return checksum % 10 == 0

          def process(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; PaymentResult:
          errors = self.validate(request, payment_details)
          if errors:
          return PaymentResult(
          success=False,
          status=PaymentStatus.FAILED,
          error_code=&quot;VALIDATION_ERROR&quot;,
          error_message=&quot;; &quot;.join(errors),
          )

          # ACH is asynchronous - returns pending status
          transaction_id = f&quot;ACH-{hashlib.sha256(request.idempotency_key.encode()).hexdigest()[:16].upper()}&quot;
          fees = self.calculate_fees(request.amount, request.currency)

          return PaymentResult(
          success=True,
          status=PaymentStatus.PENDING,  # ACH settles in 3-5 business days
          transaction_id=transaction_id,
          fees=fees,
          net_amount=request.amount - fees,
          processor_response={
          &quot;settlement_date&quot;: &quot;3-5 business days&quot;,
          &quot;routing_last_four&quot;: payment_details[&quot;routing_number&quot;][-4:],
          },
          )

          def refund(self, transaction_id: str, amount: Optional[Decimal] = None) -&gt; PaymentResult:
          return PaymentResult(
          success=True,
          status=PaymentStatus.PENDING,  # ACH refunds also take time
          transaction_id=f&quot;REF-{transaction_id}&quot;,
          )


          class CryptoStrategy(PaymentStrategy):
          &quot;&quot;&quot;
          Cryptocurrency payment strategy.
          Demonstrates handling of volatile assets and network fees.
          &quot;&quot;&quot;

          NETWORK_FEES = {
          &quot;BTC&quot;: Decimal(&quot;0.0001&quot;),  # Approximate, varies with network congestion
          &quot;ETH&quot;: Decimal(&quot;0.005&quot;),
          &quot;USDC&quot;: Decimal(&quot;5.00&quot;),  # ERC-20 gas fees
          }

          @property
          def name(self) -&gt; str:
          return &quot;Cryptocurrency&quot;

          @property
          def supported_currencies(self) -&gt; List[str]:
          return [&quot;BTC&quot;, &quot;ETH&quot;, &quot;USDC&quot;]

          @property
          def min_amount(self) -&gt; Decimal:
          return Decimal(&quot;0.01&quot;)  # In crypto units

          @property
          def max_amount(self) -&gt; Decimal:
          return Decimal(&quot;1000000&quot;)

          def calculate_fees(self, amount: Decimal, currency: str) -&gt; Decimal:
          &quot;&quot;&quot;Crypto fees: primarily network fees, no percentage.&quot;&quot;&quot;
          return self.NETWORK_FEES.get(currency, Decimal(&quot;0.01&quot;))

          def validate(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; List[str]:
          errors = []

          wallet_address = payment_details.get(&quot;wallet_address&quot;, &quot;&quot;)
          currency = request.currency

          # Basic address format validation
          if currency == &quot;BTC&quot;:
          if not re.match(r&quot;^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$&quot;, wallet_address):
          errors.append(&quot;Invalid Bitcoin address&quot;)
          elif currency == &quot;ETH&quot; or currency == &quot;USDC&quot;:
          if not re.match(r&quot;^0x[a-fA-F0-9]{40}$&quot;, wallet_address):
          errors.append(&quot;Invalid Ethereum address&quot;)

          return errors

          def process(self, request: PaymentRequest, payment_details: Dict[str, Any]) -&gt; PaymentResult:
          errors = self.validate(request, payment_details)
          if errors:
          return PaymentResult(
          success=False,
          status=PaymentStatus.FAILED,
          error_code=&quot;VALIDATION_ERROR&quot;,
          error_message=&quot;; &quot;.join(errors),
          )

          # Crypto payments are typically pending until confirmations
          transaction_id = f&quot;CRYPTO-{hashlib.sha256(request.idempotency_key.encode()).hexdigest()[:16].upper()}&quot;

          return PaymentResult(
          success=True,
          status=PaymentStatus.PENDING,  # Awaiting blockchain confirmations
          transaction_id=transaction_id,
          fees=self.calculate_fees(request.amount, request.currency),
          processor_response={
          &quot;confirmations_required&quot;: 3 if request.currency == &quot;BTC&quot; else 12,
          &quot;expected_time&quot;: &quot;10-60 minutes&quot;,
          },
          )

          def refund(self, transaction_id: str, amount: Optional[Decimal] = None) -&gt; PaymentResult:
          # Crypto refunds are outbound transactions, not reversals
          return PaymentResult(
          success=True,
          status=PaymentStatus.PENDING,
          transaction_id=f&quot;REF-{transaction_id}&quot;,
          processor_response={&quot;note&quot;: &quot;Refund requires separate outbound transaction&quot;},
          )


          class PaymentProcessor:
          &quot;&quot;&quot;
          Context class that orchestrates payment processing.
          Demonstrates strategy selection and fallback logic.
          &quot;&quot;&quot;

          def __init__(self):
          self._strategies: Dict[str, PaymentStrategy] = {}
          self._default_strategy: Optional[PaymentStrategy] = None

          def register_strategy(self, key: str, strategy: PaymentStrategy) -&gt; 'PaymentProcessor':
          &quot;&quot;&quot;Register a payment strategy with a lookup key.&quot;&quot;&quot;
          self._strategies[key] = strategy
          if self._default_strategy is None:
          self._default_strategy = strategy
          return self

          def set_default(self, key: str) -&gt; 'PaymentProcessor':
          &quot;&quot;&quot;Set the default payment strategy.&quot;&quot;&quot;
          if key not in self._strategies:
          raise ValueError(f&quot;Unknown strategy: {key}&quot;)
          self._default_strategy = self._strategies[key]
          return self

          def get_available_methods(self, currency: str, amount: Decimal) -&gt; List[Dict[str, Any]]:
          &quot;&quot;&quot;Return payment methods available for given currency/amount.&quot;&quot;&quot;
          request = PaymentRequest(
          amount=amount,
          currency=currency,
          customer_id=&quot;&quot;,
          idempotency_key=&quot;&quot;,
          )

          available = []
          for key, strategy in self._strategies.items():
          if strategy.can_process(request):
          available.append({
          &quot;key&quot;: key,
          &quot;name&quot;: strategy.name,
          &quot;fees&quot;: strategy.calculate_fees(amount, currency),
          })

          return available

          def process_payment(
          self,
          method: str,
          request: PaymentRequest,
          payment_details: Dict[str, Any]
          ) -&gt; PaymentResult:
          &quot;&quot;&quot;Process payment using specified method.&quot;&quot;&quot;
          if method not in self._strategies:
          return PaymentResult(
          success=False,
          status=PaymentStatus.FAILED,
          error_code=&quot;UNKNOWN_METHOD&quot;,
          error_message=f&quot;Payment method '{method}' not available&quot;,
          )

          strategy = self._strategies[method]

          if not strategy.can_process(request):
          return PaymentResult(
          success=False,
          status=PaymentStatus.FAILED,
          error_code=&quot;METHOD_UNAVAILABLE&quot;,
          error_message=f&quot;'{strategy.name}' cannot process this request&quot;,
          )

          return strategy.process(request, payment_details)


          # Usage example
          processor = PaymentProcessor()
          processor.register_strategy(&quot;credit_card&quot;, CreditCardStrategy())
          processor.register_strategy(&quot;ach&quot;, ACHStrategy())
          processor.register_strategy(&quot;crypto&quot;, CryptoStrategy())

          # Show available methods for a purchase
          methods = processor.get_available_methods(&quot;USD&quot;, Decimal(&quot;150.00&quot;))
          print(&quot;Available payment methods:&quot;)
          for m in methods:
          print(f&quot;  {m['name']}: fees ${m['fees']}&quot;)

          # Process a credit card payment
          request = PaymentRequest(
          amount=Decimal(&quot;150.00&quot;),
          currency=&quot;USD&quot;,
          customer_id=&quot;cust_123&quot;,
          idempotency_key=&quot;order_456_attempt_1&quot;,
          )

          result = processor.process_payment(&quot;credit_card&quot;, request, {
          &quot;card_number&quot;: &quot;4111111111111111&quot;,
          &quot;expiry&quot;: &quot;12/25&quot;,
          &quot;cvv&quot;: &quot;123&quot;,
          })

          print(f&quot;\nPayment result: {result.status.value}&quot;)
          print(f&quot;Transaction ID: {result.transaction_id}&quot;)
          print(f&quot;Fees: ${result.fees}&quot;)
          print(f&quot;Net amount: ${result.net_amount}&quot;)
          ```
</code></pre>
<h3 id="interview-deep-dive-payment-processing">Interview Deep-Dive: Payment Processing</h3>
<div>
<div>Level 1: Why is idempotency important in payment strategies?</div>
<div>
<strong>Answer:</strong> Network failures can cause clients to retry payment requests. Without idempotency, a retry could charge the customer twice. The idempotency key ensures that even if the same request is sent multiple times, the payment is only processed once.
  <br/><br/>
  Implementation: store the idempotency key with the transaction result. On subsequent requests with the same key, return the stored result instead of processing again.
</div>
</div>
<div>
<div>Level 2: How would you handle payment method failover (e.g., if credit card fails, try ACH)?</div>
<div>
<strong>Answer:</strong> Implement a fallback chain strategy:
  <br/><br/>
                  ```python
                  class FallbackPaymentStrategy(PaymentStrategy):
                  def __init__(self, primary: PaymentStrategy,
                  fallbacks: List[PaymentStrategy]):
                  self._primary = primary
                  self._fallbacks = fallbacks
<pre><code>              def process(self, request, details):
              # Try primary first
              result = self._primary.process(request, details)
              if result.success:
              return result

              # Try fallbacks in order
              for fallback in self._fallbacks:
              if fallback.can_process(request):
              fallback_details = self._adapt_details(
              details, fallback)
              result = fallback.process(request,
              fallback_details)
              if result.success:
              return result

              return result  # Return last failure
              ```
</code></pre>
  <br/>
  Key consideration: you need details for each fallback method. Either collect them upfront or prompt the user when fallback triggers.
</div>
</div>
<div>
<div>Level 3: Design a payment system that handles currency conversion with strategies for different conversion providers.</div>
<div>
<strong>Answer:</strong> Layer two strategy patterns - one for currency conversion, one for payment processing:
  <br/><br/>
                  ```python
                  class CurrencyConversionStrategy(ABC):
                  @abstractmethod
                  def get_rate(self, from_curr: str, to_curr: str) -> Decimal:
                  pass
<pre><code>              @abstractmethod
              def convert(self, amount: Decimal, from_curr: str,
              to_curr: str) -&gt; Decimal:
              pass

              class MultiCurrencyPaymentProcessor:
              def __init__(self,
              conversion_strategy: CurrencyConversionStrategy,
              payment_strategies: Dict[str, PaymentStrategy]):
              self._converter = conversion_strategy
              self._payments = payment_strategies

              def process(self, request: PaymentRequest,
              target_currency: str,
              payment_method: str,
              details: Dict) -&gt; PaymentResult:
              # Convert if necessary
              if request.currency != target_currency:
              rate = self._converter.get_rate(
              request.currency, target_currency)
              converted_amount = self._converter.convert(
              request.amount,
              request.currency,
              target_currency)
              request = PaymentRequest(
              amount=converted_amount,
              currency=target_currency,
              ...
              )

              # Process payment
              return self._payments[payment_method].process(
              request, details)
              ```
</code></pre>
  <br/>
  The conversion strategy can swap between providers (XE, Wise, bank rates) based on amount, currency pair, or time of day. This separation lets you optimize conversion rates independently of payment processing.
</div>
</div>
<hr />
<h2 id="design-choices-and-trade-offs">Design Choices and Trade-offs</h2>
<div>
<div>Key Design Decisions</div>
<div>
<div>
<div>Interface Granularity</div>
<div>
<strong>Single method:</strong> Simple, focused strategies (SRP). Risk: proliferation of strategy interfaces.
  <br/>
<strong>Multiple methods:</strong> Related operations grouped together. Risk: strategies may not need all methods.
  <br/>
<strong>Recommendation:</strong> Start with single-method interfaces. Combine only when methods are always used together.
</div>
</div>
<div>
<div>Constructor vs Setter Injection</div>
<div>
<strong>Constructor:</strong> Strategy is required, immutable after construction. Guarantees valid state.
  <br/>
<strong>Setter:</strong> Strategy can be changed at runtime. Requires null checks or default strategy.
  <br/>
<strong>Recommendation:</strong> Use constructor for mandatory strategies, setter for optional/changeable ones.
</div>
</div>
<div>
<div>Strategy Lifecycle</div>
<div>
<strong>Singleton strategies:</strong> Shared across contexts, must be stateless, memory efficient.
  <br/>
<strong>Per-context strategies:</strong> Can maintain state, more memory overhead, simpler reasoning.
  <br/>
<strong>Recommendation:</strong> Default to singletons. Use per-context only when state is truly needed.
</div>
</div>
<div>
<div>Error Handling</div>
<div>
<strong>Exceptions:</strong> Natural error propagation, but requires try-catch everywhere.
  <br/>
<strong>Result objects:</strong> Explicit error handling, self-documenting, enables pattern matching.
  <br/>
<strong>Recommendation:</strong> Result objects for expected failures (validation), exceptions for unexpected errors.
</div>
</div>
</div>
</div>
<h3 id="assumptions-and-invariants">Assumptions and Invariants</h3>
<div>
<div>Common Assumptions (Document These!)</div>
<div>
<strong>1. Strategies are interchangeable:</strong> Any strategy should be substitutable for any other without breaking the context. Violated if strategies have different preconditions.
  <br/>
<strong>2. Strategies are side-effect free:</strong> Calling a strategy shouldn't change global state. Violated by strategies that log, cache, or modify shared resources.
  <br/>
<strong>3. Strategy selection is stable:</strong> Once selected, the strategy doesn't need to change mid-operation. Violated by long-running operations that should adapt.
  <br/>
<strong>4. Context provides complete information:</strong> Strategies receive everything they need. Violated when strategies need to fetch additional data.
</div>
</div>
<hr />
<h2 id="common-anti-patterns-and-solutions">Common Anti-Patterns and Solutions</h2>
<div>
<div>Anti-Patterns to Avoid</div>
<div>
<div>1. The God Strategy</div>
<div>
<strong>Problem:</strong> Strategy interface with 10+ methods because "they're all related."
  <br/>
<strong>Solution:</strong> Split into focused interfaces. Use [[Interface Segregation]](/topics/solid/interface-segregation). A strategy should do one thing well.
</div>
</div>
<div>
<div>2. Context-Dependent Strategies</div>
<div>
<strong>Problem:</strong> Strategies call methods on context or access context's private state.
  <br/>
<strong>Solution:</strong> Pass required data explicitly. Strategies should be testable in isolation without a real context.
</div>
</div>
<div>
<div>3. Strategy Selection Spaghetti</div>
<div>
<strong>Problem:</strong> Complex if-else chains in client code to select strategies.
  <br/>
<strong>Solution:</strong> Extract selection logic into a factory or registry. Selection criteria become explicit and testable.
</div>
</div>
<div>
<div>4. Leaky Abstractions</div>
<div>
<strong>Problem:</strong> Client code checks strategy type to handle special cases: <code>if isinstance(strategy, FastStrategy)</code>
  <br/>
<strong>Solution:</strong> Add methods to interface for capability queries, or use [[Visitor Pattern]](/topics/design-patterns/visitor) for type-specific behavior.
</div>
</div>
<div>
<div>5. Premature Strategy-fication</div>
<div>
<strong>Problem:</strong> Creating strategy infrastructure for a single algorithm "for future flexibility."
  <br/>
<strong>Solution:</strong> YAGNI. Start with direct implementation. Refactor to Strategy when you actually have the second algorithm.
</div>
</div>
</div>
<hr />
<h2 id="testing-strategies">Testing Strategies</h2>
<pre><code>          ```python
          import unittest
          from decimal import Decimal
          from unittest.mock import Mock, patch


          class TestDiscountStrategy(unittest.TestCase):
          &quot;&quot;&quot;Unit tests for individual strategies - test in isolation.&quot;&quot;&quot;

          def test_percentage_discount_calculates_correctly(self):
          strategy = PercentageDiscountStrategy(Decimal(&quot;10&quot;), &quot;Test&quot;)

          discount = strategy.calculate_discount(
          Decimal(&quot;100.00&quot;),
          {}  # Minimal context
          )

          self.assertEqual(discount, Decimal(&quot;10.00&quot;))

          def test_loyalty_discount_requires_tier(self):
          strategy = LoyaltyDiscountStrategy()

          # Without tier - not applicable
          self.assertFalse(strategy.is_applicable({}))

          # With tier - applicable
          self.assertTrue(strategy.is_applicable({&quot;loyalty_tier&quot;: &quot;gold&quot;}))

          def test_fixed_discount_caps_at_subtotal(self):
          strategy = FixedAmountDiscountStrategy(
          amount=Decimal(&quot;100&quot;),
          min_purchase=Decimal(&quot;0&quot;)
          )

          # Discount shouldn't exceed subtotal
          discount = strategy.calculate_discount(Decimal(&quot;50.00&quot;), {})
          self.assertEqual(discount, Decimal(&quot;50.00&quot;))


          class TestStrategyComposition(unittest.TestCase):
          &quot;&quot;&quot;Test composed strategies maintain expected behavior.&quot;&quot;&quot;

          def test_best_of_selects_maximum_discount(self):
          strategies = [
          PercentageDiscountStrategy(Decimal(&quot;10&quot;), &quot;10%&quot;),
          FixedAmountDiscountStrategy(Decimal(&quot;20&quot;), Decimal(&quot;0&quot;)),
          ]

          selector = BestDiscountSelector()
          for s in strategies:
          selector.register(s)

          # For $100: 10% = $10, fixed = $20, should pick fixed
          best = selector.select_best(Decimal(&quot;100&quot;), {})
          discount = best.calculate_discount(Decimal(&quot;100&quot;), {})

          self.assertEqual(discount, Decimal(&quot;20.00&quot;))


          class TestContextIntegration(unittest.TestCase):
          &quot;&quot;&quot;Integration tests for context + strategy interaction.&quot;&quot;&quot;

          def test_cart_applies_strategy_correctly(self):
          cart = ShoppingCart()
          cart.add_item(CartItem(&quot;Test&quot;, Decimal(&quot;100&quot;), 1, &quot;test&quot;))

          # Manual strategy
          cart.set_strategy(PercentageDiscountStrategy(Decimal(&quot;15&quot;), &quot;Test&quot;))

          self.assertEqual(cart.subtotal, Decimal(&quot;100&quot;))
          self.assertEqual(cart.discount, Decimal(&quot;15&quot;))
          self.assertEqual(cart.total, Decimal(&quot;85&quot;))

          def test_cart_handles_missing_strategy(self):
          cart = ShoppingCart()
          cart.add_item(CartItem(&quot;Test&quot;, Decimal(&quot;100&quot;), 1, &quot;test&quot;))

          # No strategy set - should use default (no discount)
          self.assertEqual(cart.discount, Decimal(&quot;0&quot;))


          class TestStrategyMocking(unittest.TestCase):
          &quot;&quot;&quot;Demonstrate mocking strategies for complex testing scenarios.&quot;&quot;&quot;

          def test_with_mocked_strategy(self):
          # Create mock strategy
          mock_strategy = Mock(spec=DiscountStrategy)
          mock_strategy.name = &quot;Mock&quot;
          mock_strategy.is_applicable.return_value = True
          mock_strategy.calculate_discount.return_value = Decimal(&quot;42.00&quot;)

          cart = ShoppingCart()
          cart.add_item(CartItem(&quot;Test&quot;, Decimal(&quot;100&quot;), 1, &quot;test&quot;))
          cart.set_strategy(mock_strategy)

          discount = cart.discount

          self.assertEqual(discount, Decimal(&quot;42.00&quot;))
          mock_strategy.calculate_discount.assert_called_once()
          ```
</code></pre>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<div>
<div>Pattern Relationships</div>
<div>
<div>
<div>[[State Pattern]](/topics/design-patterns/state)</div>
<div>Same structure, different intent. State manages object lifecycle; Strategy provides algorithm alternatives.</div>
</div>
<div>
<div>[[Template Method]](/topics/design-patterns/template-method)</div>
<div>Alternative using inheritance. Template Method defines skeleton in base class; Strategy uses composition.</div>
</div>
<div>
<div>[[Factory Method]](/topics/design-patterns/factory-method)</div>
<div>Often used together. Factory creates strategies; Strategy executes algorithms.</div>
</div>
<div>
<div>[[Decorator]](/topics/design-patterns/decorator)</div>
<div>Can wrap strategies to add cross-cutting concerns (logging, caching, validation).</div>
</div>
<div>
<div>[[Command]](/topics/design-patterns/command)</div>
<div>Both encapsulate behavior. Command encapsulates requests with undo/redo; Strategy encapsulates algorithms.</div>
</div>
<div>
<div>[[Flyweight]](/topics/design-patterns/flyweight)</div>
<div>Stateless strategies can be shared as flyweights to reduce memory usage.</div>
</div>
</div>
</div>
<hr />
<h2 id="summary-interview-checklist">Summary: Interview Checklist</h2>
<div>
<div>Key Points for Interviews</div>
<ul>
<li><strong>Definition:</strong> Encapsulate interchangeable algorithms in separate classes</li>
<li><strong>Intent:</strong> Let algorithms vary independently from clients that use them</li>
<li><strong>vs State:</strong> Strategy is externally selected; State transitions internally</li>
<li><strong>Functional equivalent:</strong> First-class functions with partial application</li>
<li><strong>Key benefit:</strong> Open/Closed Principle - add algorithms without changing context</li>
<li><strong>Key cost:</strong> Class explosion if overused; virtual dispatch overhead</li>
<li><strong>When to use:</strong> Multiple algorithms, runtime selection needed, testing flexibility</li>
<li><strong>When not to use:</strong> Single algorithm, trivial conditionals, performance-critical paths</li>
</ul>
</div>
