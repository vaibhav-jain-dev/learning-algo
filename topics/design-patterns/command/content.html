<h1 id="command-pattern">Command Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Command pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. At its core, Command transforms method invocations into first-class objects that can be passed, stored, serialized, and manipulated independently of their execution context.</p>
<p><strong>Difficulty:</strong> Intermediate to Advanced<br />
<strong>Category:</strong> Behavioral Pattern<br />
<strong>Also Known As:</strong> Action, Transaction, Operation</p>
<hr />
<h2 id="mental-model-the-restaurant-analogy">Mental Model: The Restaurant Analogy</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<div style="font-size: 1.3rem; font-weight: 700; color: #1e293b; text-align: center; margin-bottom: 16px">The Restaurant Order System</div>
<div style="color: #334155; font-size: 1rem; line-height: 1.7">
    When you dine at a restaurant, you do not walk into the kitchen and instruct the chef directly. Instead, a waiter captures your request on an order slip, carries it to the kitchen, and hands it to the appropriate cook. That order slip IS the command object - it encapsulates everything about your request: what dish, how cooked, modifications. The waiter does not need culinary skills; the chef does not need to know who ordered. The order slip decouples the request from execution.
</div>
<div style="margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px">
<div style="background: #dbeafe; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #1e40af; font-weight: 600">Customer</div>
<div style="color: #3b82f6; font-size: 0.85rem">Client (creates request)</div>
</div>
<div style="background: #dcfce7; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #166534; font-weight: 600">Order Slip</div>
<div style="color: #22c55e; font-size: 0.85rem">Command Object</div>
</div>
<div style="background: #fef3c7; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #92400e; font-weight: 600">Waiter</div>
<div style="color: #f59e0b; font-size: 0.85rem">Invoker (triggers execution)</div>
</div>
<div style="background: #fce7f3; padding: 12px 16px; border-radius: 8px; text-align: center">
<div style="color: #9d174d; font-weight: 600">Chef</div>
<div style="color: #ec4899; font-size: 0.85rem">Receiver (does work)</div>
</div>
</div>
</div>
<div style="background: #fef3c7;border-radius: 8px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #92400e; margin-bottom: 8px">Expert Insight</div>
<div style="color: #78350f">
<strong>Novice thinks:</strong> "Command is just wrapping a function call in an object."<br/><br/>
<strong>Expert knows:</strong> "Command transforms <em>imperative code into data</em>. Once an action becomes data, you can store it, transmit it, queue it, serialize it, replay it, and undo it. This is the foundation of event sourcing, transaction logs, CQRS, and distributed systems. The real power emerges when you realize commands become auditable, recoverable, and reproducible."
</div>
</div>
<hr />
<h2 id="core-components-deep-dive">Core Components Deep Dive</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<div style="font-weight: 700; color: #1e293b; text-align: center; margin-bottom: 24px; font-size: 1.2rem">Command Pattern Architecture</div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 16px">
<div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap">
<div style="background: #dbeafe;border-radius: 12px; padding: 16px 24px; text-align: center; min-width: 160px">
<div style="font-weight: 700; color: #1e40af; font-size: 1.1rem">Client</div>
<div style="font-size: 0.8rem; color: #3b82f6; margin-top: 4px">Creates and configures<br/>concrete commands</div>
</div>
<div style="background: #fef3c7;border-radius: 12px; padding: 16px 24px; text-align: center; min-width: 160px">
<div style="font-weight: 700; color: #92400e; font-size: 1.1rem">Invoker</div>
<div style="font-size: 0.8rem; color: #b45309; margin-top: 4px; font-family: monospace">+ setCommand()<br/>+ invoke()<br/>+ history: Command[]</div>
</div>
</div>
<div style="color: #64748b; font-size: 1.5rem">triggers</div>
<div style="background: #f1f5f9;border-radius: 12px; padding: 16px 32px; text-align: center">
<div style="font-weight: 600; color: #475569; font-style: italic">Command (interface)</div>
<div style="font-size: 0.85rem; color: #64748b; margin-top: 8px; font-family: monospace">+ execute(): void<br/>+ undo(): void<br/>+ canExecute(): bool</div>
</div>
<div style="color: #64748b; font-size: 1rem">implements</div>
<div style="background: #dcfce7;border-radius: 12px; padding: 16px 32px; text-align: center">
<div style="font-weight: 700; color: #166534; font-size: 1.1rem">ConcreteCommand</div>
<div style="font-size: 0.8rem; color: #15803d; margin-top: 8px; font-family: monospace">- receiver: Receiver<br/>- previousState: State<br/>+ execute() / undo()</div>
</div>
<div style="color: #64748b; font-size: 1rem">delegates to</div>
<div style="background: #fce7f3;border-radius: 12px; padding: 16px 32px; text-align: center">
<div style="font-weight: 700; color: #9d174d; font-size: 1.1rem">Receiver</div>
<div style="font-size: 0.8rem; color: #be185d; margin-top: 8px; font-family: monospace">+ action()<br/>+ businessLogic()</div>
</div>
</div>
</div>
<h3 id="component-responsibilities">Component Responsibilities</h3>
<div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin: 20px 0">
<table style="width: 100%; border-collapse: collapse; color: #334155">
    <thead>
<tr style="background: #e2e8f0">
<th style="padding: 12px; text-align: left">Component</th>
<th style="padding: 12px; text-align: left">Responsibility</th>
<th style="padding: 12px; text-align: left">Key Design Decisions</th>
</tr>
    </thead>
    <tbody>
<tr>
<td style="padding: 12px"><strong>Command</strong></td>
<td style="padding: 12px">Declares execution interface</td>
<td style="padding: 12px">Should undo() be required? Should canExecute() exist?</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>ConcreteCommand</strong></td>
<td style="padding: 12px">Binds receiver to action, stores state for undo</td>
<td style="padding: 12px">How much state to capture? Snapshot vs delta?</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Invoker</strong></td>
<td style="padding: 12px">Manages command lifecycle, maintains history</td>
<td style="padding: 12px">Queue vs stack? History limit? Persistence?</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>Receiver</strong></td>
<td style="padding: 12px">Contains actual business logic</td>
<td style="padding: 12px">Should it know about commands? Coupling trade-offs</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Client</strong></td>
<td style="padding: 12px">Creates and configures commands</td>
<td style="padding: 12px">Factory pattern for command creation?</td>
</tr>
    </tbody>
</table>
</div>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Component Responsibilities and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Component Responsibilities and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Component Responsibilities?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Component Responsibilities provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Component Responsibilities?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Component Responsibilities from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="critical-assumption-analysis">Critical Assumption Analysis</h2>
<div style="background: #fef2f2;border-radius: 8px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #991b1b; margin-bottom: 12px">Hidden Assumptions That Can Break Your System</div>
<div style="color: #7f1d1d; line-height: 1.8">
<strong>1. Reversibility Assumption:</strong> Not all operations are reversible. Sending an email, making an API call to a third party, or triggering a physical action cannot be undone. Your design must distinguish between reversible and irreversible commands.<br/><br/>
<strong>2. Idempotency Assumption:</strong> Commands may be retried (network failures, crashes). If execute() is called twice, will your system be in a valid state? Non-idempotent commands require careful deduplication logic.<br/><br/>
<strong>3. State Isolation Assumption:</strong> Commands assume they capture sufficient state for undo. But if external state changes between execute() and undo() (concurrent modifications), your undo may corrupt data.<br/><br/>
<strong>4. Atomicity Assumption:</strong> A single command is assumed to be atomic. But what if execute() partially completes before throwing? Without careful design, you leave the system in an inconsistent state.
</div>
</div>
<hr />
<h2 id="undoredo-implementation-deep-dive">Undo/Redo Implementation Deep Dive</h2>
<h3 id="the-two-approaches-to-undo">The Two Approaches to Undo</h3>
<div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border-radius: 12px; padding: 24px; margin: 20px 0">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 16px; font-size: 1.1rem">Approach 1: Reverse Operation (Delta-Based)</div>
<div style="color: #1e3a8a; line-height: 1.7">
    Each command stores the minimal delta required to reverse itself. For example, a DeleteCommand stores the deleted text and its position. Undo re-inserts that text at that position.<br/><br/>
<strong>Pros:</strong> Memory efficient, fast undo/redo<br/>
<strong>Cons:</strong> Complex for operations with side effects, requires careful implementation<br/>
<strong>Best for:</strong> Text editors, drawing applications, simple CRUD operations
</div>
</div>
<div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); border-radius: 12px; padding: 24px; margin: 20px 0">
<div style="font-weight: 700; color: #166534; margin-bottom: 16px; font-size: 1.1rem">Approach 2: State Snapshot (Memento-Based)</div>
<div style="color: #14532d; line-height: 1.7">
    Each command stores a complete snapshot of the affected state before execution. Undo restores the snapshot. Often implemented using the [[Memento Pattern]](/topics/design-patterns/memento).<br/><br/>
<strong>Pros:</strong> Simple to implement, handles complex state changes<br/>
<strong>Cons:</strong> Memory intensive, slow for large states<br/>
<strong>Best for:</strong> Game save states, complex document editing, database transactions
</div>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is The Two Approaches to Undo and what problem does it solve?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about The Two Approaches to Undo in terms of its core purpose. Consider what specific problem it was designed to address and how it differs from simpler approaches. Try to explain it as if teaching someone who has never encountered this concept before.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply The Two Approaches to Undo?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where The Two Approaches to Undo provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using The Two Approaches to Undo?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider The Two Approaches to Undo from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="undoredo-stack-mechanics">Undo/Redo Stack Mechanics</h3>
<pre><code class="language-python">class UndoRedoManager:
    &quot;&quot;&quot;
    Manages command history with proper undo/redo semantics.

    Key invariant: undo_stack contains executed commands,
    redo_stack contains undone commands waiting to be redone.

    CRITICAL EDGE CASE: When a new command is executed after undo,
    the redo stack must be cleared - you cannot redo operations
    that would conflict with the new state.
    &quot;&quot;&quot;

    def __init__(self, max_history: int = 100):
        self._undo_stack: List[Command] = []
        self._redo_stack: List[Command] = []
        self._max_history = max_history
        self._is_undoing = False  # Prevents recursive history modification

    def execute(self, command: Command) -&gt; bool:
        &quot;&quot;&quot;
        Execute command and add to history.
        Returns False if command cannot be executed.
        &quot;&quot;&quot;
        if not command.can_execute():
            return False

        try:
            command.execute()
        except CommandExecutionError as e:
            # Command failed - do not add to history
            self._handle_execution_failure(command, e)
            return False

        self._undo_stack.append(command)

        # CRITICAL: Clear redo stack on new action
        # This is the &quot;branching timeline&quot; problem - once you
        # take a new action after undo, the old future is lost
        self._redo_stack.clear()

        # Enforce history limit (prevent memory leak)
        while len(self._undo_stack) &gt; self._max_history:
            discarded = self._undo_stack.pop(0)
            self._on_command_discarded(discarded)

        return True

    def undo(self) -&gt; bool:
        &quot;&quot;&quot;
        Undo the most recent command.

        Returns False if nothing to undo or undo fails.
        &quot;&quot;&quot;
        if not self._undo_stack:
            return False

        command = self._undo_stack.pop()

        try:
            self._is_undoing = True
            command.undo()
        except UndoFailureError as e:
            # Undo failed - this is a serious problem
            # The system may be in an inconsistent state
            self._handle_undo_failure(command, e)
            # Re-add to undo stack since undo failed
            self._undo_stack.append(command)
            return False
        finally:
            self._is_undoing = False

        self._redo_stack.append(command)
        return True

    def redo(self) -&gt; bool:
        &quot;&quot;&quot;
        Redo the most recently undone command.

        IMPORTANT: redo() re-executes the command, which means
        any validation in execute() runs again. The command might
        fail if the system state has changed.
        &quot;&quot;&quot;
        if not self._redo_stack:
            return False

        command = self._redo_stack.pop()

        # Re-check if command can still execute in current state
        if not command.can_execute():
            # State has changed - cannot redo
            return False

        try:
            command.execute()
        except CommandExecutionError:
            return False

        self._undo_stack.append(command)
        return True

    def _on_command_discarded(self, command: Command) -&gt; None:
        &quot;&quot;&quot;
        Called when a command is removed from history due to limit.
        Override to release resources held by the command.
        &quot;&quot;&quot;
        if hasattr(command, 'release_resources'):
            command.release_resources()
</code></pre>
<div style="background: #fef3c7;border-radius: 8px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #92400e; margin-bottom: 8px">Interview Trap: The Redo Invalidation Problem</div>
<div style="color: #78350f">
    When you undo command A, then execute new command B, then try to redo A - what happens? The naive answer is "redo A". The correct answer is "A is no longer in the redo stack because B invalidated it." Executing B after undoing A creates a new timeline branch, and the old redo history must be discarded. This is why most applications clear the redo stack on any new action.
</div>
</div>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Undo/Redo Stack Mechanics and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Undo/Redo Stack Mechanics and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Undo/Redo Stack Mechanics?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Undo/Redo Stack Mechanics provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Undo/Redo Stack Mechanics?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Undo/Redo Stack Mechanics from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions-undoredo">Interview Questions: Undo/Redo</h3>
<details style="margin: 12px 0; padding: 16px; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 8px">
<summary style="font-weight: 700; color: #1e293b; cursor: pointer; font-size: 1.05rem">Level 1: How do you implement undo/redo using the Command pattern?</summary>
<div style="margin-top: 16px; color: #334155; line-height: 1.8">
<strong>Answer:</strong> Maintain two stacks - an undo stack for executed commands and a redo stack for undone commands. Each command implements execute() and undo() methods. On execute(), push to undo stack and clear redo stack. On undo(), pop from undo stack, call undo(), push to redo stack. On redo(), pop from redo stack, call execute(), push to undo stack.
<details style="margin: 12px 0; padding: 12px; background: #f1f5f9; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 2: What happens when undo() fails partway through? How do you maintain consistency?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> This is the "partial undo" problem. Solutions include:
<ol>
<li><strong>Transactional undo</strong>: Wrap undo in a try-catch, and if it fails, attempt to re-execute to restore state</li>
<li><strong>Snapshot before undo</strong>: Take a memento before undo, restore on failure</li>
<li><strong>Two-phase undo</strong>: First validate undo is possible (dry run), then execute</li>
<li><strong>Compensation commands</strong>: Generate a compensating command that will fix any partial state</li>
</ol>
<p>The safest approach is making undo operations atomic - design them so they either fully complete or fully fail without side effects.</p>
<details style="margin: 12px 0; padding: 12px; background: #e2e8f0; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 3: How would you implement collaborative undo in a multi-user real-time editor where User A and User B can both undo their own actions?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> This requires Operational Transformation (OT) or Conflict-free Replicated Data Types (CRDTs). Key challenges:
<ol>
<li><strong>Per-user undo stacks</strong>: Each user has their own undo history, but all modify shared state</li>
<li><strong>Transform on undo</strong>: When User A undoes their action, the undo must be transformed against all operations User B made after A's original action</li>
<li><strong>Causality tracking</strong>: Use vector clocks or Lamport timestamps to establish happened-before relationships</li>
<li><strong>Conflict resolution</strong>: Define merge policies when undoing creates conflicts with concurrent edits</li>
</ol>
<p>Example: User A types &quot;Hello&quot; at position 0, User B types &quot;World&quot; at position 5. If A undoes, you must adjust B's operation to account for the removed text. Google Docs uses OT, while Figma uses CRDTs for this problem.</p>
<p>Implementation requires:<br />
- Each command includes author ID and logical timestamp<br />
- Undo transforms the inverse operation against all subsequent operations from other users<br />
- The transformed undo is broadcast to all clients</p>
</div>
</details>
</div>
</details>
</div>
</details>
<details style="margin: 12px 0; padding: 16px; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 8px">
<summary style="font-weight: 700; color: #1e293b; cursor: pointer; font-size: 1.05rem">Level 1: How do you handle commands that cannot be undone?</summary>
<div style="margin-top: 16px; color: #334155; line-height: 1.8">
<strong>Answer:</strong> Mark commands as irreversible and handle them specially:
<pre><code class="language-python">class Command(ABC):
@property
def is_reversible(self) -&gt; bool:
return True  # Override to return False for irreversible commands
```

For irreversible commands: warn user before execution, do not add to undo stack, or implement &quot;soft&quot; alternatives (soft delete instead of hard delete).
</code></pre>
<details style="margin: 12px 0; padding: 12px; background: #f1f5f9; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 2: What if an irreversible command is in the middle of a macro? How do you undo the macro?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> Several strategies:
<ol>
<li><strong>Block macro creation</strong>: Prevent irreversible commands from being added to macros</li>
<li><strong>Partial undo</strong>: Undo everything before the irreversible command, mark the rest as &quot;cannot undo&quot;</li>
<li><strong>Checkpoint macros</strong>: Split macro at irreversible boundaries, warn user that undo will only go back to the checkpoint</li>
<li><strong>Compensating actions</strong>: For some &quot;irreversible&quot; operations, provide a compensating action (e.g., &quot;unsend&quot; email within time window)</li>
</ol>
<details style="margin: 12px 0; padding: 12px; background: #e2e8f0; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 3: Design an undo system for a payment processing application where some commands trigger external API calls</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> This requires the [[Saga Pattern]](/topics/design-patterns/saga) combined with Command:
<ol>
<li><strong>Two-phase commands</strong>: Separate &quot;prepare&quot; (reversible, local) from &quot;commit&quot; (irreversible, external)</li>
<li><strong>Compensation over reversal</strong>: Instead of undoing a payment, issue a refund command</li>
<li><strong>Eventual consistency</strong>: Accept that undo may not be immediate - use async compensation</li>
<li><strong>Audit trail</strong>: Log all commands and their compensation status for reconciliation</li>
</ol>
<p>Architecture:<br />
```<br />
PaymentCommand:<br />
- execute(): create local pending record, call payment API<br />
- undo(): if pending, cancel; if completed, queue RefundCommand<br />
- compensation: RefundCommand with correlation ID</p>
<pre><code>        RefundCommand:
        - execute(): call refund API, mark original as refunded
        - undo(): cannot undo a refund (business rule)
        ```
</code></pre>
<p>Critical considerations:<br />
- Idempotency keys for API calls<br />
- Timeout handling (what if API call hangs?)<br />
- State machine for payment lifecycle (pending -&gt; completed -&gt; refunding -&gt; refunded)<br />
- Dead letter queue for failed compensations</p>
</div>
</details>
</div>
</details>
</div>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions: Undo/Redo?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions: Undo/Redo in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions: Undo/Redo?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions: Undo/Redo provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions: Undo/Redo?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions: Undo/Redo from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="macro-commands-composite-commands">Macro Commands (Composite Commands)</h2>
<p>Macro commands combine multiple commands into a single unit that can be executed, undone, and redone atomically. This implements the <a href="/topics/design-patterns/composite">[Composite Pattern]</a> within the Command pattern.</p>
<h3 id="macro-command-architecture">Macro Command Architecture</h3>
<pre><code class="language-python">from typing import List, Optional, Callable
from enum import Enum, auto


class ExecutionPolicy(Enum):
    &quot;&quot;&quot;Defines how macro handles failures&quot;&quot;&quot;
    STOP_ON_FAILURE = auto()      # Stop and rollback on first failure
    CONTINUE_ON_FAILURE = auto()  # Skip failed commands, continue others
    ALL_OR_NOTHING = auto()       # Validate all first, then execute


class MacroCommand(Command):
    &quot;&quot;&quot;
    Composite command that executes multiple commands as one unit.

    Design decisions:
    - Commands execute in order (use PriorityMacro for priority-based)
    - Undo happens in reverse order
    - Failure policy determines rollback behavior
    &quot;&quot;&quot;

    def __init__(
        self,
        name: str,
        commands: Optional[List[Command]] = None,
        execution_policy: ExecutionPolicy = ExecutionPolicy.STOP_ON_FAILURE
    ):
        self.name = name
        self._commands: List[Command] = commands or []
        self._executed: List[Command] = []
        self._policy = execution_policy

    def add(self, command: Command) -&gt; 'MacroCommand':
        &quot;&quot;&quot;Fluent interface for building macros&quot;&quot;&quot;
        self._commands.append(command)
        return self

    def can_execute(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if macro can execute.
        For ALL_OR_NOTHING policy, all commands must be executable.
        &quot;&quot;&quot;
        if self._policy == ExecutionPolicy.ALL_OR_NOTHING:
            return all(cmd.can_execute() for cmd in self._commands)
        return len(self._commands) &gt; 0

    def execute(self) -&gt; None:
        &quot;&quot;&quot;
        Execute all commands according to policy.

        CRITICAL: Track which commands were executed for proper undo.
        &quot;&quot;&quot;
        self._executed.clear()

        for command in self._commands:
            try:
                if not command.can_execute():
                    if self._policy == ExecutionPolicy.STOP_ON_FAILURE:
                        raise MacroExecutionError(f&quot;Command cannot execute: {command}&quot;)
                    continue

                command.execute()
                self._executed.append(command)

            except Exception as e:
                if self._policy == ExecutionPolicy.STOP_ON_FAILURE:
                    # Rollback all executed commands
                    self._rollback()
                    raise MacroExecutionError(f&quot;Macro failed: {e}&quot;) from e
                elif self._policy == ExecutionPolicy.ALL_OR_NOTHING:
                    self._rollback()
                    raise
                # CONTINUE_ON_FAILURE: log and continue

    def undo(self) -&gt; None:
        &quot;&quot;&quot;
        Undo executed commands in reverse order.

        IMPORTANT: Only undo commands that were actually executed,
        not all commands in the macro definition.
        &quot;&quot;&quot;
        for command in reversed(self._executed):
            try:
                command.undo()
            except UndoFailureError:
                # Log but continue - best effort undo
                pass
        self._executed.clear()

    def _rollback(self) -&gt; None:
        &quot;&quot;&quot;Internal rollback for failure recovery&quot;&quot;&quot;
        for command in reversed(self._executed):
            try:
                command.undo()
            except:
                pass  # Best effort during rollback
        self._executed.clear()


class RecordingMacro(MacroCommand):
    &quot;&quot;&quot;
    Macro that records commands as they are executed elsewhere.
    Used for &quot;record macro&quot; functionality in editors.
    &quot;&quot;&quot;

    def __init__(self, name: str):
        super().__init__(name)
        self._is_recording = False

    def start_recording(self) -&gt; None:
        self._is_recording = True
        self._commands.clear()

    def stop_recording(self) -&gt; None:
        self._is_recording = False

    def record(self, command: Command) -&gt; None:
        &quot;&quot;&quot;Called by invoker after each command execution during recording&quot;&quot;&quot;
        if self._is_recording:
            # Store a copy/clone if command is mutable
            self._commands.append(command.clone() if hasattr(command, 'clone') else command)
</code></pre>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a Macro Command Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Macro Command Architecture in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Macro Command Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Macro Command Architecture provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Macro Command Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Macro Command Architecture from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions-macro-commands">Interview Questions: Macro Commands</h3>
<details style="margin: 12px 0; padding: 16px; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 8px">
<summary style="font-weight: 700; color: #1e293b; cursor: pointer; font-size: 1.05rem">Level 1: How does a MacroCommand differ from simply calling multiple commands in sequence?</summary>
<div style="margin-top: 16px; color: #334155; line-height: 1.8">
<strong>Answer:</strong> A MacroCommand provides:
<pre><code>1. **Atomic undo**: All commands undo as one unit
2. **Single history entry**: One undo step instead of many
3. **Encapsulation**: Client sees one command, not implementation details
4. **Reusability**: Save and replay the macro
5. **Failure handling**: Coordinated rollback on failure

Without MacroCommand, undoing 10 sequential commands requires 10 undo operations, and partial failure handling is ad-hoc.
</code></pre>
<details style="margin: 12px 0; padding: 12px; background: #f1f5f9; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 2: How do you handle commands in a macro that depend on the results of previous commands?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> Several approaches:
<ol>
<li>
<p><strong>Lazy parameter resolution</strong>: Commands take suppliers/callbacks instead of values</p>
<pre><code class="language-python">class DependentCommand(Command):
def __init__(self, value_supplier: Callable[[], Any]):
self._get_value = value_supplier

def execute(self):
value = self._get_value()  # Resolved at execution time
</code></pre>
</li>
<li>
<p><strong>Shared context object</strong>: Commands read/write to a shared context</p>
<pre><code class="language-python">class MacroContext:
def __init__(self):
self.results = {}

# Commands access context.results[&quot;previous_command_key&quot;]
</code></pre>
</li>
<li>
<p><strong>Command chaining</strong>: Commands explicitly link to predecessors</p>
</li>
</ol>
<details style="margin: 12px 0; padding: 12px; background: #e2e8f0; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 3: Design a macro system that supports conditional execution, loops, and branching based on command results</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> This essentially becomes a domain-specific workflow engine:
<pre><code class="language-python">        class ConditionalCommand(Command):
        def __init__(self, condition: Callable[[], bool],
        if_true: Command, if_false: Optional[Command] = None):
        self._condition = condition
        self._if_true = if_true
        self._if_false = if_false
        self._executed_branch: Optional[Command] = None

        def execute(self):
        if self._condition():
        self._if_true.execute()
        self._executed_branch = self._if_true
        elif self._if_false:
        self._if_false.execute()
        self._executed_branch = self._if_false

        def undo(self):
        if self._executed_branch:
        self._executed_branch.undo()


        class LoopCommand(Command):
        def __init__(self, condition: Callable[[], bool],
        body: Command, max_iterations: int = 1000):
        self._condition = condition
        self._body = body
        self._max_iterations = max_iterations
        self._iterations_executed: List[Command] = []

        def execute(self):
        iterations = 0
        while self._condition() and iterations &lt; self._max_iterations:
        # Clone body for each iteration to preserve undo state
        iteration_cmd = self._body.clone()
        iteration_cmd.execute()
        self._iterations_executed.append(iteration_cmd)
        iterations += 1

        def undo(self):
        for cmd in reversed(self._iterations_executed):
        cmd.undo()
        self._iterations_executed.clear()</code></pre>
<p>Key design considerations:<br />
- <strong>Undo complexity</strong>: Each loop iteration needs independent undo state<br />
- <strong>Infinite loop protection</strong>: Max iteration limit<br />
- <strong>Early exit</strong>: Support break/continue semantics<br />
- <strong>State isolation</strong>: Each iteration may need its own context<br />
- <strong>Memory</strong>: Long loops create many command objects</p>
<p>This pattern is used in workflow engines like Temporal, Cadence, and business process automation tools.</p>
</div>
</details>
</div>
</details>
</div>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Interview Questions: Macro Commands and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Interview Questions: Macro Commands and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions: Macro Commands?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions: Macro Commands provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions: Macro Commands?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions: Macro Commands from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="command-queuing-and-scheduling">Command Queuing and Scheduling</h2>
<p>Command queuing decouples command creation from execution, enabling deferred processing, rate limiting, prioritization, and retry logic.</p>
<h3 id="queue-architecture">Queue Architecture</h3>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<div style="font-weight: 700; color: #1e293b; text-align: center; margin-bottom: 20px; font-size: 1.1rem">Command Queue Flow</div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 12px">
<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; align-items: center">
<div style="background: #dbeafe;border-radius: 8px; padding: 12px 20px; text-align: center">
<div style="font-weight: 600; color: #1e40af">Producer</div>
<div style="font-size: 0.75rem; color: #3b82f6">Creates commands</div>
</div>
<div style="color: #64748b; font-size: 1.5rem">enqueue</div>
<div style="background: #fef3c7;border-radius: 8px; padding: 12px 20px; text-align: center; min-width: 120px">
<div style="font-weight: 600; color: #92400e">Queue</div>
<div style="font-size: 0.75rem; color: #b45309">Priority + Scheduling</div>
</div>
<div style="color: #64748b; font-size: 1.5rem">dequeue</div>
<div style="background: #dcfce7;border-radius: 8px; padding: 12px 20px; text-align: center">
<div style="font-weight: 600; color: #166534">Worker</div>
<div style="font-size: 0.75rem; color: #15803d">Executes commands</div>
</div>
</div>
<div style="display: flex; gap: 60px; margin-top: 12px; flex-wrap: wrap; justify-content: center">
<div style="background: #fee2e2;border-radius: 6px; padding: 8px 12px; font-size: 0.8rem; color: #991b1b">Dead Letter Queue</div>
<div style="background: #e0e7ff;border-radius: 6px; padding: 8px 12px; font-size: 0.8rem; color: #3730a3">Retry Queue</div>
<div style="background: #f3e8ff;border-radius: 6px; padding: 8px 12px; font-size: 0.8rem; color: #6b21a8">Scheduled Queue</div>
</div>
</div>
</div>
<pre><code class="language-python">import heapq
import threading
import time
from dataclasses import dataclass, field
from typing import Optional, Callable
from datetime import datetime, timedelta
from enum import IntEnum


class Priority(IntEnum):
    LOW = 30
    NORMAL = 20
    HIGH = 10
    CRITICAL = 0


@dataclass(order=True)
class QueuedCommand:
    &quot;&quot;&quot;Wrapper for queued commands with metadata&quot;&quot;&quot;
    priority: int
    scheduled_time: float
    command: Command = field(compare=False)
    retry_count: int = field(default=0, compare=False)
    max_retries: int = field(default=3, compare=False)
    created_at: datetime = field(default_factory=datetime.now, compare=False)
    correlation_id: str = field(default=&quot;&quot;, compare=False)


class CommandQueue:
    &quot;&quot;&quot;
    Priority queue with scheduling, retry, and dead letter support.

    Thread-safe implementation for concurrent producers/consumers.

    Design decisions:
    - Priority queue (heapq) for O(log n) insert/remove
    - Scheduled commands wait until their time
    - Failed commands go to retry queue with exponential backoff
    - Commands exceeding max retries go to dead letter queue
    &quot;&quot;&quot;

    def __init__(
        self,
        max_size: int = 10000,
        on_dead_letter: Optional[Callable[[QueuedCommand, Exception], None]] = None
    ):
        self._queue: List[QueuedCommand] = []
        self._dead_letter: List[tuple[QueuedCommand, Exception]] = []
        self._lock = threading.RLock()
        self._not_empty = threading.Condition(self._lock)
        self._max_size = max_size
        self._on_dead_letter = on_dead_letter
        self._running = True

    def enqueue(
        self,
        command: Command,
        priority: Priority = Priority.NORMAL,
        delay: Optional[timedelta] = None,
        correlation_id: str = &quot;&quot;
    ) -&gt; bool:
        &quot;&quot;&quot;
        Add command to queue.

        Returns False if queue is full.
        &quot;&quot;&quot;
        with self._lock:
            if len(self._queue) &gt;= self._max_size:
                return False

            scheduled_time = time.time()
            if delay:
                scheduled_time += delay.total_seconds()

            queued = QueuedCommand(
                priority=priority,
                scheduled_time=scheduled_time,
                command=command,
                correlation_id=correlation_id
            )

            heapq.heappush(self._queue, queued)
            self._not_empty.notify()
            return True

    def dequeue(self, timeout: Optional[float] = None) -&gt; Optional[QueuedCommand]:
        &quot;&quot;&quot;
        Get next command to execute.

        Blocks until a command is available and its scheduled time has passed.
        Returns None on timeout or shutdown.
        &quot;&quot;&quot;
        deadline = time.time() + timeout if timeout else None

        with self._not_empty:
            while self._running:
                if not self._queue:
                    # Wait for commands
                    remaining = deadline - time.time() if deadline else None
                    if remaining is not None and remaining &lt;= 0:
                        return None
                    self._not_empty.wait(remaining)
                    continue

                # Peek at highest priority command
                queued = self._queue[0]
                now = time.time()

                if queued.scheduled_time &lt;= now:
                    # Ready to execute
                    return heapq.heappop(self._queue)

                # Wait until scheduled time or timeout
                wait_time = queued.scheduled_time - now
                if deadline:
                    wait_time = min(wait_time, deadline - now)

                if wait_time &gt; 0:
                    self._not_empty.wait(wait_time)

            return None

    def retry(self, queued: QueuedCommand, error: Exception) -&gt; bool:
        &quot;&quot;&quot;
        Retry a failed command with exponential backoff.

        Returns False if max retries exceeded (sent to dead letter).
        &quot;&quot;&quot;
        queued.retry_count += 1

        if queued.retry_count &gt; queued.max_retries:
            self._send_to_dead_letter(queued, error)
            return False

        # Exponential backoff: 1s, 2s, 4s, 8s...
        backoff = 2 ** (queued.retry_count - 1)
        queued.scheduled_time = time.time() + backoff

        with self._lock:
            heapq.heappush(self._queue, queued)
            self._not_empty.notify()

        return True

    def _send_to_dead_letter(self, queued: QueuedCommand, error: Exception) -&gt; None:
        &quot;&quot;&quot;Handle commands that have exhausted retries&quot;&quot;&quot;
        with self._lock:
            self._dead_letter.append((queued, error))

        if self._on_dead_letter:
            self._on_dead_letter(queued, error)


class CommandWorker:
    &quot;&quot;&quot;
    Worker that processes commands from queue.

    Can run multiple workers for parallel processing.
    &quot;&quot;&quot;

    def __init__(self, queue: CommandQueue, worker_id: str = &quot;worker-1&quot;):
        self._queue = queue
        self._worker_id = worker_id
        self._running = False
        self._thread: Optional[threading.Thread] = None

    def start(self) -&gt; None:
        self._running = True
        self._thread = threading.Thread(target=self._process_loop, daemon=True)
        self._thread.start()

    def stop(self) -&gt; None:
        self._running = False

    def _process_loop(self) -&gt; None:
        while self._running:
            queued = self._queue.dequeue(timeout=1.0)
            if queued is None:
                continue

            try:
                queued.command.execute()
            except Exception as e:
                self._queue.retry(queued, e)
</code></pre>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a Queue Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Queue Architecture in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Queue Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Queue Architecture provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Queue Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Queue Architecture from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions-command-queuing">Interview Questions: Command Queuing</h3>
<details style="margin: 12px 0; padding: 16px; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 8px">
<summary style="font-weight: 700; color: #1e293b; cursor: pointer; font-size: 1.05rem">Level 1: Why use a command queue instead of executing commands immediately?</summary>
<div style="margin-top: 16px; color: #334155; line-height: 1.8">
<strong>Answer:</strong> Command queuing provides:
<pre><code>1. **Decoupling**: Producers and consumers work independently
2. **Load leveling**: Smooth out traffic spikes
3. **Retry logic**: Automatic retry with backoff on failure
4. **Scheduling**: Execute commands at specific times
5. **Prioritization**: Critical commands execute first
6. **Scalability**: Add more workers without changing producers
7. **Resilience**: Commands survive process restarts (if persisted)
</code></pre>
<details style="margin: 12px 0; padding: 12px; background: #f1f5f9; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 2: How do you ensure exactly-once execution of queued commands in a distributed system?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> Exactly-once is impossible in distributed systems, but you can achieve effectively-once through:
<ol>
<li>
<p><strong>Idempotency keys</strong>: Each command has a unique ID; receivers track processed IDs</p>
</li>
<li>
<p><strong>Deduplication window</strong>: Store recent command IDs in cache (Redis) for deduplication</p>
</li>
<li>
<p><strong>Transactional outbox</strong>: Write command to database in same transaction as business logic, separate process publishes</p>
</li>
<li>
<p><strong>At-least-once + idempotent handlers</strong>: Accept duplicates but make handlers idempotent</p>
<pre><code class="language-python">class IdempotentCommandHandler:
def __init__(self, dedup_cache: Redis):
self._cache = dedup_cache

def handle(self, command: Command) -&gt; bool:
# Check if already processed
if self._cache.exists(command.idempotency_key):
return False  # Already processed

# Process command
command.execute()

# Mark as processed (with TTL for cache cleanup)
self._cache.setex(command.idempotency_key, 86400, &quot;processed&quot;)
return True
</code></pre>
</li>
</ol>
<details style="margin: 12px 0; padding: 12px; background: #e2e8f0; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 3: Design a command queue system that maintains ordering guarantees while allowing parallel processing for unrelated commands</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> This requires partitioned ordering - order within a partition, parallelism across partitions:
<pre><code class="language-python">        class PartitionedCommandQueue:
        &quot;&quot;&quot;
        Commands with same partition key execute in order.
        Commands with different keys can execute in parallel.

        Example: Order commands for same customer_id must be ordered,
        but orders for different customers can be parallel.
        &quot;&quot;&quot;

        def __init__(self, num_partitions: int = 16):
        self._partitions: Dict[int, Queue] = {
        i: Queue() for i in range(num_partitions)
        }
        self._workers: List[PartitionWorker] = []

        def enqueue(self, command: Command, partition_key: str) -&gt; None:
        # Consistent hash to partition
        partition_id = hash(partition_key) % len(self._partitions)
        self._partitions[partition_id].put(command)

        def start_workers(self, workers_per_partition: int = 1) -&gt; None:
        # Each partition has dedicated workers
        # Workers within same partition process sequentially
        for partition_id, queue in self._partitions.items():
        worker = PartitionWorker(queue, partition_id)
        worker.start()
        self._workers.append(worker)</code></pre>
<p>Advanced considerations:<br />
- <strong>Sticky sessions</strong>: Route related commands to same partition<br />
- <strong>Partition rebalancing</strong>: Handle worker failures without losing ordering<br />
- <strong>Head-of-line blocking</strong>: One slow command blocks entire partition<br />
- <strong>Dynamic partitioning</strong>: Adjust partitions based on load</p>
<p>This pattern is used by Kafka (partition ordering), SQS FIFO (message group ID), and Azure Service Bus (sessions).</p>
</div>
</details>
</div>
</details>
</div>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is an Interview Questions: Command Queuing?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Interview Questions: Command Queuing in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions: Command Queuing?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions: Command Queuing provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions: Command Queuing?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions: Command Queuing from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="transaction-scripts-with-command-pattern">Transaction Scripts with Command Pattern</h2>
<p>Transaction scripts combine the Command pattern with <a href="/topics/databases/acid">[ACID properties]</a> to provide database-like transaction semantics for business operations.</p>
<h3 id="transaction-command-architecture">Transaction Command Architecture</h3>
<pre><code class="language-python">from contextlib import contextmanager
from typing import TypeVar, Generic
from enum import Enum, auto


class TransactionState(Enum):
    PENDING = auto()
    EXECUTING = auto()
    COMMITTED = auto()
    ROLLED_BACK = auto()
    FAILED = auto()


T = TypeVar('T')


class TransactionCommand(Command, Generic[T]):
    &quot;&quot;&quot;
    Command with explicit transaction lifecycle.

    Implements two-phase commit pattern:
    1. prepare(): Validate and acquire resources
    2. execute(): Perform the operation
    3. commit(): Make changes permanent
    4. rollback(): Revert on failure

    This separates validation from execution, allowing
    pre-flight checks before any state changes.
    &quot;&quot;&quot;

    def __init__(self):
        self._state = TransactionState.PENDING
        self._result: Optional[T] = None
        self._savepoint: Optional[Any] = None

    @property
    def state(self) -&gt; TransactionState:
        return self._state

    def prepare(self) -&gt; bool:
        &quot;&quot;&quot;
        Validate command can execute and acquire necessary locks.

        Returns False if command cannot proceed.
        No state changes should occur here.
        &quot;&quot;&quot;
        raise NotImplementedError

    def execute(self) -&gt; T:
        &quot;&quot;&quot;
        Perform the operation. May be called only after prepare().

        State changes happen here but are not yet permanent.
        &quot;&quot;&quot;
        raise NotImplementedError

    def commit(self) -&gt; None:
        &quot;&quot;&quot;
        Make changes permanent. Called after successful execute().

        After commit, rollback is no longer possible.
        &quot;&quot;&quot;
        raise NotImplementedError

    def rollback(self) -&gt; None:
        &quot;&quot;&quot;
        Revert any changes made during execute().

        Must restore system to pre-execute state.
        &quot;&quot;&quot;
        raise NotImplementedError

    def undo(self) -&gt; None:
        &quot;&quot;&quot;Alias for rollback in Command interface&quot;&quot;&quot;
        self.rollback()


class TransactionManager:
    &quot;&quot;&quot;
    Coordinates transaction lifecycle for multiple commands.

    Implements the Saga pattern for distributed transactions
    where commands may affect different services/databases.
    &quot;&quot;&quot;

    def __init__(self):
        self._commands: List[TransactionCommand] = []
        self._executed: List[TransactionCommand] = []

    @contextmanager
    def transaction(self):
        &quot;&quot;&quot;
        Context manager for transaction scope.

        Usage:
            with manager.transaction():
                manager.add(command1)
                manager.add(command2)
            # Auto-commits on success, rollbacks on exception
        &quot;&quot;&quot;
        try:
            yield self
            self.commit_all()
        except Exception as e:
            self.rollback_all()
            raise TransactionError(f&quot;Transaction failed: {e}&quot;) from e
        finally:
            self._commands.clear()
            self._executed.clear()

    def add(self, command: TransactionCommand) -&gt; None:
        &quot;&quot;&quot;Add command to current transaction&quot;&quot;&quot;
        self._commands.append(command)

    def commit_all(self) -&gt; None:
        &quot;&quot;&quot;
        Two-phase commit across all commands.

        Phase 1: Prepare all (vote)
        Phase 2: Execute and commit all

        If any prepare fails, no commands execute.
        If any execute fails, all executed commands rollback.
        &quot;&quot;&quot;
        # Phase 1: Prepare
        for command in self._commands:
            if not command.prepare():
                raise TransactionError(f&quot;Prepare failed for {command}&quot;)

        # Phase 2: Execute
        try:
            for command in self._commands:
                command.execute()
                self._executed.append(command)

            # Phase 3: Commit
            for command in self._executed:
                command.commit()

        except Exception as e:
            self.rollback_all()
            raise

    def rollback_all(self) -&gt; None:
        &quot;&quot;&quot;Rollback all executed commands in reverse order&quot;&quot;&quot;
        for command in reversed(self._executed):
            try:
                command.rollback()
            except Exception as rollback_error:
                # Log but continue - best effort rollback
                pass
        self._executed.clear()


# Practical example: Bank transfer transaction
class TransferFundsCommand(TransactionCommand[str]):
    &quot;&quot;&quot;
    Transfer funds between accounts with full transaction support.

    Demonstrates:
    - Prepare phase validates balances and acquires locks
    - Execute phase performs the transfer
    - Commit phase releases locks and confirms
    - Rollback phase reverses the transfer
    &quot;&quot;&quot;

    def __init__(
        self,
        from_account: BankAccount,
        to_account: BankAccount,
        amount: Decimal,
        lock_manager: LockManager
    ):
        super().__init__()
        self._from = from_account
        self._to = to_account
        self._amount = amount
        self._lock_manager = lock_manager
        self._locks_held: List[Lock] = []
        self._transfer_id: Optional[str] = None

    def prepare(self) -&gt; bool:
        &quot;&quot;&quot;
        Validate and acquire locks.

        IMPORTANT: Acquire locks in consistent order (by account ID)
        to prevent deadlocks when multiple transfers run concurrently.
        &quot;&quot;&quot;
        # Order accounts to prevent deadlock
        accounts = sorted([self._from, self._to], key=lambda a: a.id)

        # Acquire locks
        for account in accounts:
            lock = self._lock_manager.acquire(account.id, timeout=5.0)
            if not lock:
                self._release_locks()
                return False
            self._locks_held.append(lock)

        # Validate balance
        if self._from.balance &lt; self._amount:
            self._release_locks()
            return False

        self._state = TransactionState.EXECUTING
        return True

    def execute(self) -&gt; str:
        &quot;&quot;&quot;Perform the transfer&quot;&quot;&quot;
        self._from.balance -= self._amount
        self._to.balance += self._amount
        self._transfer_id = generate_transfer_id()
        self._result = self._transfer_id
        return self._transfer_id

    def commit(self) -&gt; None:
        &quot;&quot;&quot;Finalize and release locks&quot;&quot;&quot;
        self._from.save()
        self._to.save()
        self._release_locks()
        self._state = TransactionState.COMMITTED

    def rollback(self) -&gt; None:
        &quot;&quot;&quot;Reverse the transfer&quot;&quot;&quot;
        if self._state == TransactionState.EXECUTING:
            self._from.balance += self._amount
            self._to.balance -= self._amount
        self._release_locks()
        self._state = TransactionState.ROLLED_BACK

    def _release_locks(self) -&gt; None:
        for lock in self._locks_held:
            lock.release()
        self._locks_held.clear()
</code></pre>

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What is a Transaction Command Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about Transaction Command Architecture in terms of its fundamental definition and purpose. Consider what makes it unique compared to related concepts. Try to identify the key characteristics that define it and the problems it was designed to solve.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Transaction Command Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Transaction Command Architecture provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Transaction Command Architecture?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Transaction Command Architecture from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h3 id="interview-questions-transaction-scripts">Interview Questions: Transaction Scripts</h3>
<details style="margin: 12px 0; padding: 16px; background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 8px">
<summary style="font-weight: 700; color: #1e293b; cursor: pointer; font-size: 1.05rem">Level 1: How does the Command pattern enable transaction-like behavior without a database?</summary>
<div style="margin-top: 16px; color: #334155; line-height: 1.8">
<strong>Answer:</strong> Command pattern provides transaction semantics through:
<pre><code>1. **Atomicity**: MacroCommand groups operations; all succeed or all fail via rollback
2. **Consistency**: canExecute() validates invariants before execution
3. **Isolation**: Lock acquisition in prepare() prevents concurrent modifications
4. **Durability**: Command serialization allows persistence and recovery

The key is that each command captures enough state to reverse itself, and the transaction manager coordinates multiple commands.
</code></pre>
<details style="margin: 12px 0; padding: 12px; background: #f1f5f9; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 2: How do you handle long-running transactions that span multiple services?</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> Use the [[Saga Pattern]](/topics/design-patterns/saga) instead of traditional transactions:
<ol>
<li><strong>Choreography</strong>: Each service publishes events, others react</li>
<li><strong>Orchestration</strong>: Central coordinator tells each service what to do</li>
</ol>
<p>Each step has a compensating action. If step N fails, execute compensations for steps N-1 to 1 in reverse.</p>
<pre><code class="language-python">    class SagaStep:
    def __init__(self, action: Command, compensation: Command):
    self.action = action
    self.compensation = compensation


    class Saga:
    def __init__(self, steps: List[SagaStep]):
    self._steps = steps
    self._completed_steps: List[SagaStep] = []

    async def execute(self) -&gt; None:
    for step in self._steps:
    try:
    await step.action.execute()
    self._completed_steps.append(step)
    except Exception:
    await self._compensate()
    raise

    async def _compensate(self) -&gt; None:
    for step in reversed(self._completed_steps):
    await step.compensation.execute()</code></pre>
<details style="margin: 12px 0; padding: 12px; background: #e2e8f0; border-radius: 6px">
<summary style="font-weight: 600; color: #475569; cursor: pointer">Level 3: Design a transaction system that handles the case where compensation itself fails</summary>
<div style="margin-top: 12px; color: #334155">
<strong>Answer:</strong> This is the "compensation failure" problem, one of the hardest distributed systems challenges:
<p><strong>Strategy 1: Retry with exponential backoff</strong><br />
```python<br />
async def compensate_with_retry(step: SagaStep, max_retries: int = 5):<br />
for attempt in range(max_retries):<br />
try:<br />
await step.compensation.execute()<br />
return<br />
except Exception:<br />
await asyncio.sleep(2 ** attempt)</p>
<pre><code>        # Exhausted retries - escalate
        await send_to_manual_resolution_queue(step)
        ```
</code></pre>
<p><strong>Strategy 2: Idempotent compensations with state machine</strong><br />
```python<br />
class CompensationState(Enum):<br />
PENDING = auto()<br />
COMPENSATING = auto()<br />
COMPENSATED = auto()<br />
FAILED = auto()</p>
<pre><code>        # Store compensation state in durable storage
        # Background worker retries PENDING/COMPENSATING indefinitely
        ```
</code></pre>
<p><strong>Strategy 3: Human-in-the-loop escalation</strong><br />
- After N retries, create a ticket for manual resolution<br />
- Provide operator with context and suggested actions<br />
- Log everything for forensics</p>
<p><strong>Strategy 4: Semantic locking</strong><br />
- Mark the affected resource as &quot;in-compensation&quot;<br />
- Block other operations until compensation succeeds<br />
- Eventually consistent - system heals itself</p>
<p>Critical requirements:<br />
- All compensations must be idempotent<br />
- Persistent state tracking for compensations<br />
- Alerting and monitoring for stuck compensations<br />
- Clear SLA for manual resolution</p>
<p>This is why companies like Uber built custom saga frameworks (Cadence, now Temporal) with built-in compensation handling.</p>
</div>
</details>
</div>
</details>
</div>
</details>
<hr />

<div class="qa-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
<h4 style="color: #0369a1; margin-top: 0;">Check Your Understanding</h4>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q1: What are Interview Questions: Transaction Scripts and why are they important?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider the different types or categories of Interview Questions: Transaction Scripts and what distinguishes them. Think about real-world examples where each type would be most appropriate. Understanding the variety helps you select the right tool for each situation.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q2: In what scenarios would you apply Interview Questions: Transaction Scripts?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Think about the characteristics of problems where Interview Questions: Transaction Scripts provides the most value. Consider both the technical requirements (data structures, algorithms needed) and the business context (scalability, performance constraints). Real-world applications often require adapting the theoretical approach to practical constraints.</p>
</div>
</details>
<details style="margin-bottom: 12px;">
<summary style="cursor: pointer; font-weight: 600; color: #1e293b;">Q3: What are the trade-offs involved in using Interview Questions: Transaction Scripts?</summary>
<div style="padding: 12px; background: white; border-radius: 8px; margin-top: 8px;">
<p>Consider Interview Questions: Transaction Scripts from multiple perspectives: What do you gain? What do you sacrifice? Think about time vs. space trade-offs, simplicity vs. flexibility, and short-term convenience vs. long-term maintainability. The best engineers understand these trade-offs deeply and make informed decisions based on their specific context.</p>
</div>
</details>
</div>
<h2 id="command-pattern-vs-related-patterns">Command Pattern vs Related Patterns</h2>
<div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin: 20px 0">
<table style="width: 100%; border-collapse: collapse; color: #334155; font-size: 0.95rem">
    <thead>
<tr style="background: #e2e8f0">
<th style="padding: 12px; text-align: left">Aspect</th>
<th style="padding: 12px; text-align: left">Command</th>
<th style="padding: 12px; text-align: left">[[Strategy]](/topics/design-patterns/strategy)</th>
<th style="padding: 12px; text-align: left">[[Memento]](/topics/design-patterns/memento)</th>
</tr>
    </thead>
    <tbody>
<tr>
<td style="padding: 12px"><strong>Purpose</strong></td>
<td style="padding: 12px">Encapsulate request as object</td>
<td style="padding: 12px">Encapsulate algorithm</td>
<td style="padding: 12px">Capture and restore state</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>State</strong></td>
<td style="padding: 12px">Contains parameters + receiver</td>
<td style="padding: 12px">Usually stateless</td>
<td style="padding: 12px">Contains full state snapshot</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Undo</strong></td>
<td style="padding: 12px">Via reverse operation</td>
<td style="padding: 12px">No undo concept</td>
<td style="padding: 12px">Via state restoration</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>Lifetime</strong></td>
<td style="padding: 12px">Created, executed, potentially stored</td>
<td style="padding: 12px">Swapped at runtime</td>
<td style="padding: 12px">Created, stored, restored</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Use with</strong></td>
<td style="padding: 12px">Undo, queuing, logging</td>
<td style="padding: 12px">Algorithm selection</td>
<td style="padding: 12px">Checkpoints, save/load</td>
</tr>
    </tbody>
</table>
</div>
<div style="background: #dbeafe;border-radius: 8px; padding: 20px; margin: 20px 0">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 8px">Command + Memento Hybrid</div>
<div style="color: #1e3a8a; line-height: 1.7">
    For complex undo scenarios, combine both patterns: Command defines <em>what</em> to do and <em>how</em> to reverse it, while Memento captures the <em>before state</em> for when reverse operations are too complex or risky. This is common in game engines where "undo" restores a checkpoint rather than reversing each action.
</div>
</div>
<hr />
<h2 id="real-world-implementation-full-text-editor">Real-World Implementation: Full Text Editor</h2>
<pre><code class="language-python">&quot;&quot;&quot;
Production-ready text editor implementation demonstrating:
- Undo/redo with history limit
- Macro recording and playback
- Command serialization for persistence
- Selection-aware commands
- Clipboard integration
&quot;&quot;&quot;

from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from typing import List, Optional, Tuple, Dict, Any
from datetime import datetime
import json
from copy import deepcopy


# ============================================================
# DOCUMENT MODEL
# ============================================================

@dataclass
class Selection:
    &quot;&quot;&quot;Represents a text selection (cursor position if start == end)&quot;&quot;&quot;
    start: int
    end: int

    @property
    def is_cursor(self) -&gt; bool:
        return self.start == self.end

    @property
    def length(self) -&gt; int:
        return self.end - self.start

    def normalize(self) -&gt; 'Selection':
        &quot;&quot;&quot;Ensure start &lt;= end&quot;&quot;&quot;
        return Selection(min(self.start, self.end), max(self.start, self.end))


@dataclass
class Document:
    &quot;&quot;&quot;
    Text document with selection tracking.
    This is the Receiver in Command pattern terminology.
    &quot;&quot;&quot;
    content: str = &quot;&quot;
    selection: Selection = field(default_factory=lambda: Selection(0, 0))

    def insert_at(self, position: int, text: str) -&gt; None:
        self.content = self.content[:position] + text + self.content[position:]

    def delete_range(self, start: int, end: int) -&gt; str:
        deleted = self.content[start:end]
        self.content = self.content[:start] + self.content[end:]
        return deleted

    def get_range(self, start: int, end: int) -&gt; str:
        return self.content[start:end]


# ============================================================
# COMMAND INTERFACE
# ============================================================

class EditorCommand(ABC):
    &quot;&quot;&quot;
    Base command for editor operations.

    Design decisions:
    - Commands are immutable after creation (parameters fixed)
    - Undo state is captured during execute(), not at creation
    - Serializable for persistence and replay
    &quot;&quot;&quot;

    @abstractmethod
    def execute(self, doc: Document) -&gt; None:
        &quot;&quot;&quot;Execute the command on the document&quot;&quot;&quot;
        pass

    @abstractmethod
    def undo(self, doc: Document) -&gt; None:
        &quot;&quot;&quot;Reverse the command effect&quot;&quot;&quot;
        pass

    @property
    @abstractmethod
    def description(self) -&gt; str:
        &quot;&quot;&quot;Human-readable description for UI&quot;&quot;&quot;
        pass

    @property
    def is_mergeable(self) -&gt; bool:
        &quot;&quot;&quot;Can this command be merged with the previous one?&quot;&quot;&quot;
        return False

    def merge_with(self, previous: 'EditorCommand') -&gt; Optional['EditorCommand']:
        &quot;&quot;&quot;Attempt to merge with previous command. Return merged or None.&quot;&quot;&quot;
        return None

    def to_dict(self) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;Serialize for persistence&quot;&quot;&quot;
        return {
            'type': self.__class__.__name__,
            'data': self._serialize_data()
        }

    @abstractmethod
    def _serialize_data(self) -&gt; Dict[str, Any]:
        pass


# ============================================================
# CONCRETE COMMANDS
# ============================================================

class InsertTextCommand(EditorCommand):
    &quot;&quot;&quot;
    Insert text at current selection.

    If there's a selection, it's replaced (delete + insert).
    Supports merging consecutive character insertions into one undo step.
    &quot;&quot;&quot;

    def __init__(self, text: str, position: Optional[int] = None):
        self._text = text
        self._position = position  # None means use current selection
        self._deleted_text: str = &quot;&quot;
        self._original_selection: Optional[Selection] = None
        self._executed_position: int = 0

    def execute(self, doc: Document) -&gt; None:
        self._original_selection = deepcopy(doc.selection)
        sel = doc.selection.normalize()

        # Determine insertion position
        self._executed_position = self._position if self._position is not None else sel.start

        # Delete selected text first (if any)
        if sel.length &gt; 0:
            self._deleted_text = doc.delete_range(sel.start, sel.end)
            self._executed_position = sel.start

        # Insert new text
        doc.insert_at(self._executed_position, self._text)

        # Move cursor to end of inserted text
        new_pos = self._executed_position + len(self._text)
        doc.selection = Selection(new_pos, new_pos)

    def undo(self, doc: Document) -&gt; None:
        # Remove inserted text
        doc.delete_range(self._executed_position,
                        self._executed_position + len(self._text))

        # Restore deleted text (if any)
        if self._deleted_text:
            doc.insert_at(self._executed_position, self._deleted_text)

        # Restore original selection
        if self._original_selection:
            doc.selection = self._original_selection

    @property
    def description(self) -&gt; str:
        preview = self._text[:20] + &quot;...&quot; if len(self._text) &gt; 20 else self._text
        return f'Type &quot;{preview}&quot;'

    @property
    def is_mergeable(self) -&gt; bool:
        # Single characters can be merged for better undo experience
        return len(self._text) == 1 and self._text not in ' \n\t'

    def merge_with(self, previous: EditorCommand) -&gt; Optional[EditorCommand]:
        if not isinstance(previous, InsertTextCommand):
            return None
        if not previous.is_mergeable:
            return None

        # Check if positions are consecutive
        expected_pos = previous._executed_position + len(previous._text)
        if self._executed_position != expected_pos:
            return None

        # Create merged command
        merged = InsertTextCommand(previous._text + self._text)
        merged._executed_position = previous._executed_position
        merged._original_selection = previous._original_selection
        merged._deleted_text = previous._deleted_text
        return merged

    def _serialize_data(self) -&gt; Dict[str, Any]:
        return {'text': self._text, 'position': self._position}


class DeleteCommand(EditorCommand):
    &quot;&quot;&quot;
    Delete text at current selection or single character.

    direction: -1 for backspace (delete before cursor)
               +1 for delete key (delete after cursor)
    &quot;&quot;&quot;

    def __init__(self, direction: int = -1, count: int = 1):
        self._direction = direction
        self._count = count
        self._deleted_text: str = &quot;&quot;
        self._delete_position: int = 0
        self._original_selection: Optional[Selection] = None

    def execute(self, doc: Document) -&gt; None:
        self._original_selection = deepcopy(doc.selection)
        sel = doc.selection.normalize()

        if sel.length &gt; 0:
            # Delete selection
            self._delete_position = sel.start
            self._deleted_text = doc.delete_range(sel.start, sel.end)
        else:
            # Delete based on direction
            if self._direction &lt; 0:  # Backspace
                start = max(0, sel.start - self._count)
                self._delete_position = start
                self._deleted_text = doc.delete_range(start, sel.start)
            else:  # Delete key
                self._delete_position = sel.start
                end = min(len(doc.content), sel.start + self._count)
                self._deleted_text = doc.delete_range(sel.start, end)

        doc.selection = Selection(self._delete_position, self._delete_position)

    def undo(self, doc: Document) -&gt; None:
        doc.insert_at(self._delete_position, self._deleted_text)
        if self._original_selection:
            doc.selection = self._original_selection

    @property
    def description(self) -&gt; str:
        action = &quot;Backspace&quot; if self._direction &lt; 0 else &quot;Delete&quot;
        preview = self._deleted_text[:20] if self._deleted_text else &quot;&quot;
        return f'{action} &quot;{preview}&quot;'

    def _serialize_data(self) -&gt; Dict[str, Any]:
        return {'direction': self._direction, 'count': self._count}


class ClipboardCommand(EditorCommand):
    &quot;&quot;&quot;Cut or copy selected text to clipboard&quot;&quot;&quot;

    def __init__(self, clipboard: 'Clipboard', cut: bool = False):
        self._clipboard = clipboard
        self._cut = cut
        self._copied_text: str = &quot;&quot;
        self._original_selection: Optional[Selection] = None
        self._cut_position: int = 0

    def execute(self, doc: Document) -&gt; None:
        self._original_selection = deepcopy(doc.selection)
        sel = doc.selection.normalize()

        self._copied_text = doc.get_range(sel.start, sel.end)
        self._clipboard.content = self._copied_text

        if self._cut and sel.length &gt; 0:
            self._cut_position = sel.start
            doc.delete_range(sel.start, sel.end)
            doc.selection = Selection(sel.start, sel.start)

    def undo(self, doc: Document) -&gt; None:
        if self._cut and self._copied_text:
            doc.insert_at(self._cut_position, self._copied_text)
            if self._original_selection:
                doc.selection = self._original_selection

    @property
    def description(self) -&gt; str:
        action = &quot;Cut&quot; if self._cut else &quot;Copy&quot;
        return f'{action} &quot;{self._copied_text[:20]}&quot;'

    def _serialize_data(self) -&gt; Dict[str, Any]:
        return {'cut': self._cut}


class PasteCommand(EditorCommand):
    &quot;&quot;&quot;Paste from clipboard at current selection&quot;&quot;&quot;

    def __init__(self, clipboard: 'Clipboard'):
        self._clipboard = clipboard
        self._insert_command: Optional[InsertTextCommand] = None

    def execute(self, doc: Document) -&gt; None:
        if self._clipboard.content:
            self._insert_command = InsertTextCommand(self._clipboard.content)
            self._insert_command.execute(doc)

    def undo(self, doc: Document) -&gt; None:
        if self._insert_command:
            self._insert_command.undo(doc)

    @property
    def description(self) -&gt; str:
        return f'Paste &quot;{self._clipboard.content[:20]}&quot;'

    def _serialize_data(self) -&gt; Dict[str, Any]:
        return {}


# ============================================================
# MACRO COMMAND
# ============================================================

class MacroCommand(EditorCommand):
    &quot;&quot;&quot;
    Composite command that groups multiple commands.

    Supports:
    - Atomic execution (all or nothing)
    - Single undo step for entire macro
    - Nested macros
    &quot;&quot;&quot;

    def __init__(self, name: str, commands: Optional[List[EditorCommand]] = None):
        self._name = name
        self._commands: List[EditorCommand] = commands or []
        self._executed_commands: List[EditorCommand] = []

    def add(self, command: EditorCommand) -&gt; 'MacroCommand':
        self._commands.append(command)
        return self

    def execute(self, doc: Document) -&gt; None:
        self._executed_commands.clear()

        for command in self._commands:
            try:
                command.execute(doc)
                self._executed_commands.append(command)
            except Exception as e:
                # Rollback on failure
                self._rollback(doc)
                raise MacroExecutionError(f&quot;Macro '{self._name}' failed: {e}&quot;) from e

    def undo(self, doc: Document) -&gt; None:
        self._rollback(doc)

    def _rollback(self, doc: Document) -&gt; None:
        for command in reversed(self._executed_commands):
            try:
                command.undo(doc)
            except Exception:
                pass  # Best effort
        self._executed_commands.clear()

    @property
    def description(self) -&gt; str:
        return f'Macro: {self._name} ({len(self._commands)} steps)'

    def _serialize_data(self) -&gt; Dict[str, Any]:
        return {
            'name': self._name,
            'commands': [cmd.to_dict() for cmd in self._commands]
        }


# ============================================================
# HISTORY MANAGER (INVOKER)
# ============================================================

@dataclass
class Clipboard:
    content: str = &quot;&quot;


class HistoryManager:
    &quot;&quot;&quot;
    Manages command execution and history.

    Features:
    - Undo/redo stacks
    - Command merging for better UX
    - History persistence
    - Memory limit management
    &quot;&quot;&quot;

    def __init__(self, document: Document, max_history: int = 100):
        self._document = document
        self._undo_stack: List[EditorCommand] = []
        self._redo_stack: List[EditorCommand] = []
        self._max_history = max_history
        self._is_recording = False
        self._recorded_commands: List[EditorCommand] = []

    def execute(self, command: EditorCommand) -&gt; None:
        &quot;&quot;&quot;Execute command and manage history&quot;&quot;&quot;
        command.execute(self._document)

        # Try to merge with previous command
        if self._undo_stack and command.is_mergeable:
            merged = command.merge_with(self._undo_stack[-1])
            if merged:
                self._undo_stack[-1] = merged
            else:
                self._undo_stack.append(command)
        else:
            self._undo_stack.append(command)

        # Clear redo stack (new action invalidates redo history)
        self._redo_stack.clear()

        # Enforce history limit
        while len(self._undo_stack) &gt; self._max_history:
            self._undo_stack.pop(0)

        # Record for macro
        if self._is_recording:
            self._recorded_commands.append(command)

    def undo(self) -&gt; bool:
        &quot;&quot;&quot;Undo last command&quot;&quot;&quot;
        if not self._undo_stack:
            return False

        command = self._undo_stack.pop()
        command.undo(self._document)
        self._redo_stack.append(command)
        return True

    def redo(self) -&gt; bool:
        &quot;&quot;&quot;Redo last undone command&quot;&quot;&quot;
        if not self._redo_stack:
            return False

        command = self._redo_stack.pop()
        command.execute(self._document)
        self._undo_stack.append(command)
        return True

    def start_recording(self) -&gt; None:
        &quot;&quot;&quot;Start recording commands for a macro&quot;&quot;&quot;
        self._is_recording = True
        self._recorded_commands.clear()

    def stop_recording(self, name: str) -&gt; MacroCommand:
        &quot;&quot;&quot;Stop recording and return the macro&quot;&quot;&quot;
        self._is_recording = False
        macro = MacroCommand(name, self._recorded_commands.copy())
        self._recorded_commands.clear()
        return macro

    def can_undo(self) -&gt; bool:
        return len(self._undo_stack) &gt; 0

    def can_redo(self) -&gt; bool:
        return len(self._redo_stack) &gt; 0

    def get_undo_description(self) -&gt; Optional[str]:
        if self._undo_stack:
            return self._undo_stack[-1].description
        return None

    def get_redo_description(self) -&gt; Optional[str]:
        if self._redo_stack:
            return self._redo_stack[-1].description
        return None


# ============================================================
# TEXT EDITOR (CLIENT)
# ============================================================

class TextEditor:
    &quot;&quot;&quot;
    High-level editor API.

    Provides intuitive methods that internally use commands.
    &quot;&quot;&quot;

    def __init__(self):
        self.document = Document()
        self.clipboard = Clipboard()
        self.history = HistoryManager(self.document)
        self._macros: Dict[str, MacroCommand] = {}

    def type(self, text: str) -&gt; None:
        self.history.execute(InsertTextCommand(text))

    def backspace(self, count: int = 1) -&gt; None:
        self.history.execute(DeleteCommand(-1, count))

    def delete(self, count: int = 1) -&gt; None:
        self.history.execute(DeleteCommand(+1, count))

    def select(self, start: int, end: int) -&gt; None:
        self.document.selection = Selection(start, end)

    def select_all(self) -&gt; None:
        self.select(0, len(self.document.content))

    def copy(self) -&gt; None:
        self.history.execute(ClipboardCommand(self.clipboard, cut=False))

    def cut(self) -&gt; None:
        self.history.execute(ClipboardCommand(self.clipboard, cut=True))

    def paste(self) -&gt; None:
        self.history.execute(PasteCommand(self.clipboard))

    def undo(self) -&gt; bool:
        return self.history.undo()

    def redo(self) -&gt; bool:
        return self.history.redo()

    def start_macro_recording(self) -&gt; None:
        self.history.start_recording()

    def stop_macro_recording(self, name: str) -&gt; None:
        macro = self.history.stop_recording(name)
        self._macros[name] = macro

    def play_macro(self, name: str) -&gt; None:
        if name in self._macros:
            self.history.execute(self._macros[name])

    @property
    def text(self) -&gt; str:
        return self.document.content


# ============================================================
# USAGE EXAMPLE
# ============================================================

if __name__ == &quot;__main__&quot;:
    editor = TextEditor()

    # Type some text
    editor.type(&quot;Hello, World!&quot;)
    print(f&quot;After typing: '{editor.text}'&quot;)

    # Select and cut
    editor.select(0, 7)
    editor.cut()
    print(f&quot;After cut: '{editor.text}'&quot;)

    # Paste twice
    editor.select(0, 0)
    editor.paste()
    editor.paste()
    print(f&quot;After paste x2: '{editor.text}'&quot;)

    # Undo multiple times
    editor.undo()
    editor.undo()
    print(f&quot;After 2 undos: '{editor.text}'&quot;)

    # Redo
    editor.redo()
    print(f&quot;After redo: '{editor.text}'&quot;)

    # Macro example
    editor2 = TextEditor()
    editor2.start_macro_recording()
    editor2.type(&quot;BEGIN\n&quot;)
    editor2.type(&quot;// Your code here\n&quot;)
    editor2.type(&quot;END\n&quot;)
    editor2.stop_macro_recording(&quot;code-block&quot;)

    editor2.document.content = &quot;&quot;  # Clear
    editor2.play_macro(&quot;code-block&quot;)
    print(f&quot;After macro: '{editor2.text}'&quot;)

    editor2.undo()  # Undoes entire macro
    print(f&quot;After undo macro: '{editor2.text}'&quot;)
</code></pre>
<hr />
<h2 id="advanced-design-trade-offs">Advanced Design Trade-offs</h2>
<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; padding: 24px; margin: 20px 0">
<div style="font-weight: 700; color: #92400e; margin-bottom: 16px; font-size: 1.1rem">Key Design Decisions and Their Trade-offs</div>
<div style="color: #78350f; line-height: 1.8">
<strong>1. Command granularity:</strong> Should each keystroke be a command, or group related actions?<br/>
<span style="margin-left: 20px; display: block; margin-top: 4px">Fine-grained = more undo flexibility, more memory. Coarse-grained = less memory, less flexibility.</span><br/>
<p><strong>2. State storage location:</strong> Should commands store state internally or reference external storage?<br/><br />
<span style="margin-left: 20px; display: block; margin-top: 4px">Internal = self-contained, larger commands. External = smaller commands, coordination complexity.</span><br/></p>
<p><strong>3. Receiver coupling:</strong> Should commands know about receivers or use indirection?<br/><br />
<span style="margin-left: 20px; display: block; margin-top: 4px">Direct reference = simpler, tighter coupling. Indirection (locator) = flexible, more complexity.</span><br/></p>
<p><strong>4. Validation timing:</strong> Validate at creation time, execution time, or both?<br/><br />
<span style="margin-left: 20px; display: block; margin-top: 4px">Creation = fail fast, stale validation. Execution = current state, delayed feedback.</span></p>
</div>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<ul>
<li><a href="/topics/design-patterns/memento">[Memento]</a> - Capture state snapshots for complex undo scenarios</li>
<li><a href="/topics/design-patterns/strategy">[Strategy]</a> - Encapsulate algorithms (stateless) vs actions (stateful)</li>
<li><a href="/topics/design-patterns/composite">[Composite]</a> - Structure for MacroCommand implementation</li>
<li><a href="/topics/design-patterns/chain-of-responsibility">[Chain of Responsibility]</a> - Commands can form processing pipelines</li>
<li><a href="/topics/design-patterns/observer">[Observer]</a> - Notify on command execution for logging/audit</li>
<li><a href="/topics/design-patterns/factory-method">[Factory Method]</a> - Create commands based on input type</li>
<li><a href="/topics/design-patterns/saga">[Saga]</a> - Distributed transactions using compensating commands</li>
<li><a href="/topics/system-design/event-sourcing">[Event Sourcing]</a> - Commands become the source of truth</li>
</ul>
