<h1 id="facade-pattern">Facade Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Facade pattern provides a unified, simplified interface to a complex subsystem of classes, libraries, or frameworks. It acts as a high-level entry point that shields clients from the intricate dependencies, initialization sequences, and interaction protocols within the subsystem.</p>
<blockquote>
<p><strong>Core Insight</strong>: A Facade does not add new functionality—it orchestrates existing capabilities into cohesive, use-case-driven operations that align with client mental models rather than implementation details.</p>
</blockquote>
<div>
<div>
<span>Client</span>
</div>
<div>&#8595;</div>
<div>
<div>
<div>Facade</div>
<div>Simplified API surface</div>
</div>
</div>
<div>orchestrates &#8595;</div>
<div>
<div>Complex Subsystem</div>
<div>
<div>ServiceA</div>
<div>ServiceB</div>
<div>ServiceC</div>
<div>ServiceD</div>
</div>
<div>
<span>internal dependencies</span>
<span>&#8596;</span>
<span>initialization order</span>
<span>&#8596;</span>
<span>state management</span>
</div>
</div>
</div>
<hr />
<h2 id="internal-mechanisms-and-architecture">Internal Mechanisms and Architecture</h2>
<h3 id="how-facades-work-internally">How Facades Work Internally</h3>
<p>A Facade maintains references to subsystem components and coordinates their interactions. Understanding the internal mechanics reveals critical design decisions:</p>
<p><strong>Component Lifecycle Management</strong></p>
<pre><code class="language-python">class PaymentFacade:
    def __init__(self, config: PaymentConfig):
        # Eager vs lazy initialization trade-off
        self._fraud_detector = None  # Lazy - expensive ML model
        self._validator = CardValidator()  # Eager - lightweight
        self._gateway = self._create_gateway(config)  # Eager - required
        self._audit_log = AuditLogger(config.audit_path)

    @property
    def fraud_detector(self) -&gt; FraudDetector:
        &quot;&quot;&quot;Lazy initialization for expensive subsystem components&quot;&quot;&quot;
        if self._fraud_detector is None:
            self._fraud_detector = FraudDetector.load_model(
                model_path=&quot;/models/fraud_v3.pkl&quot;,
                threshold=0.85
            )
        return self._fraud_detector
</code></pre>
<div>
<div>Critical Assumption</div>
<div>Facades assume ownership of subsystem component lifecycles. If external code holds references to subsystem objects, the Facade cannot guarantee consistent state or proper cleanup. This becomes critical when implementing dispose/cleanup patterns.</div>
</div>
<p><strong>Request Orchestration Patterns</strong></p>
<p>Facades internally implement one of several orchestration strategies:</p>
<pre><code class="language-python">class OrderFacade:
    def place_order(self, order: Order) -&gt; OrderResult:
        # Sequential orchestration with compensation
        saga = OrderSaga()

        try:
            # Phase 1: Validation (can fail fast)
            self._inventory.validate_availability(order.items)
            self._payment.validate_method(order.payment_info)

            # Phase 2: Reservations (compensatable)
            saga.add_step(
                action=lambda: self._inventory.reserve(order.items),
                compensate=lambda: self._inventory.release(order.items)
            )
            saga.add_step(
                action=lambda: self._payment.authorize(order.total),
                compensate=lambda txn: self._payment.void(txn)
            )

            # Phase 3: Commit
            saga.execute()
            return OrderResult(success=True, order_id=saga.order_id)

        except SubsystemError as e:
            saga.compensate()  # Rollback in reverse order
            raise OrderFailedError(str(e), partial_state=saga.state)
</code></pre>
<h3 id="subsystem-encapsulation-boundaries">Subsystem Encapsulation Boundaries</h3>
<p>Encapsulation in Facades operates at multiple levels:</p>
<div>
<div>
<div>
<div>Interface Level</div>
<div>Hides method signatures, parameter complexity, return types of subsystem</div>
</div>
<div>
<div>Protocol Level</div>
<div>Hides calling order, initialization sequences, state dependencies</div>
</div>
<div>
<div>Error Level</div>
<div>Translates subsystem exceptions into domain-specific errors</div>
</div>
<div>
<div>Resource Level</div>
<div>Manages connections, pooling, caching transparently</div>
</div>
</div>
</div>
<pre><code class="language-python">class DatabaseFacade:
    &quot;&quot;&quot;Encapsulates connection management, query building, result mapping&quot;&quot;&quot;

    def __init__(self, connection_string: str):
        # Resource-level encapsulation
        self._pool = ConnectionPool(
            connection_string,
            min_size=5,
            max_size=20,
            timeout=30
        )
        self._query_builder = QueryBuilder()
        self._mapper = ResultMapper()

    def find_users_by_criteria(
        self,
        criteria: UserSearchCriteria
    ) -&gt; List[User]:
        &quot;&quot;&quot;
        Interface-level: Hides SQL, connection handling, mapping
        Protocol-level: Manages acquire -&gt; execute -&gt; release -&gt; map
        Error-level: Translates DB errors to domain exceptions
        &quot;&quot;&quot;
        connection = None
        try:
            # Protocol encapsulation
            connection = self._pool.acquire()

            # Interface encapsulation - hide query complexity
            query = self._query_builder.select(&quot;users&quot;) \
                .where(criteria.to_conditions()) \
                .order_by(criteria.sort_field) \
                .limit(criteria.page_size) \
                .offset(criteria.page * criteria.page_size) \
                .build()

            result = connection.execute(query)

            # Mapping encapsulation
            return self._mapper.map_all(result, User)

        except ConnectionTimeoutError:
            # Error-level encapsulation
            raise ServiceUnavailableError(
                &quot;Database temporarily unavailable&quot;,
                retry_after=30
            )
        except QueryExecutionError as e:
            if &quot;unique constraint&quot; in str(e):
                raise DuplicateEntityError(&quot;User already exists&quot;)
            raise DataAccessError(f&quot;Query failed: {e}&quot;)
        finally:
            if connection:
                self._pool.release(connection)
</code></pre>
<hr />
<h2 id="facade-vs-adapter-critical-distinctions">Facade vs Adapter: Critical Distinctions</h2>
<p>Understanding when to use Facade versus <a href="/topic/design-patterns/adapter">[Adapter]</a> is a common interview topic. The distinction is subtle but important:</p>
<div>
<div>
<div>Facade Pattern</div>
<div>
<div><strong>Intent:</strong> Simplify a complex interface</div>
<div><strong>Direction:</strong> Many-to-One (multiple subsystems to single interface)</div>
<div><strong>Interface:</strong> Creates NEW simplified interface</div>
<div><strong>Coupling:</strong> Client knows only Facade</div>
<div><strong>Functionality:</strong> Subset of subsystem capabilities</div>
</div>
</div>
<div>
<div>Adapter Pattern</div>
<div>
<div><strong>Intent:</strong> Make incompatible interface compatible</div>
<div><strong>Direction:</strong> One-to-One (single adaptee to single target)</div>
<div><strong>Interface:</strong> Conforms to EXISTING target interface</div>
<div><strong>Coupling:</strong> Client knows target interface</div>
<div><strong>Functionality:</strong> Complete translation of adaptee</div>
</div>
</div>
</div>
<h3 id="combined-usage-pattern">Combined Usage Pattern</h3>
<p>Real systems often use both patterns together:</p>
<pre><code class="language-python"># Legacy payment system with incompatible interface
class LegacyPaymentGateway:
    def process_cc_txn(self, cc_num: str, exp: str, cvv: str,
                       amt_cents: int, merchant_id: str) -&gt; dict:
        # Returns: {&quot;code&quot;: 0, &quot;auth&quot;: &quot;ABC123&quot;, &quot;msg&quot;: &quot;OK&quot;}
        pass

# Modern payment interface (target)
class PaymentProcessor(Protocol):
    def charge(self, card: CardInfo, amount: Money) -&gt; PaymentResult:
        ...

# ADAPTER: Makes legacy gateway conform to modern interface
class LegacyPaymentAdapter(PaymentProcessor):
    def __init__(self, gateway: LegacyPaymentGateway, merchant_id: str):
        self._gateway = gateway
        self._merchant_id = merchant_id

    def charge(self, card: CardInfo, amount: Money) -&gt; PaymentResult:
        # Translate modern interface to legacy
        response = self._gateway.process_cc_txn(
            cc_num=card.number,
            exp=f&quot;{card.exp_month:02d}{card.exp_year % 100:02d}&quot;,
            cvv=card.cvv,
            amt_cents=int(amount.cents),
            merchant_id=self._merchant_id
        )

        # Translate legacy response to modern result
        if response[&quot;code&quot;] == 0:
            return PaymentResult(
                success=True,
                authorization_code=response[&quot;auth&quot;]
            )
        return PaymentResult(success=False, error=response[&quot;msg&quot;])

# FACADE: Simplifies entire checkout process
class CheckoutFacade:
    def __init__(
        self,
        payment: PaymentProcessor,  # Could be adapter or native
        inventory: InventoryService,
        shipping: ShippingCalculator,
        tax: TaxService,
        notifications: NotificationService
    ):
        self._payment = payment
        self._inventory = inventory
        self._shipping = shipping
        self._tax = tax
        self._notifications = notifications

    def complete_purchase(self, cart: Cart, customer: Customer) -&gt; Order:
        &quot;&quot;&quot;Single method hides 5 subsystems and their interactions&quot;&quot;&quot;
        # Facade orchestrates, potentially using adapted components
        pass
</code></pre>
<div>
<div>Trade-off Analysis</div>
<div>Using Adapters within a Facade adds a layer of indirection but enables swapping implementations (e.g., switching payment gateways) without changing the Facade. The cost is additional object allocation and method call overhead—typically negligible except in high-frequency paths.</div>
</div>
<hr />
<h2 id="api-simplification-strategies">API Simplification Strategies</h2>
<h3 id="reducing-cognitive-load">Reducing Cognitive Load</h3>
<p>Effective API simplification involves multiple techniques:</p>
<p><strong>1. Parameter Object Consolidation</strong></p>
<pre><code class="language-python"># Before: 12 parameters
def create_server(
    name: str, region: str, zone: str, machine_type: str,
    disk_size: int, disk_type: str, image: str, network: str,
    subnet: str, tags: List[str], labels: Dict[str, str],
    service_account: str
) -&gt; Server:
    pass

# After: Single configuration object
@dataclass
class ServerConfig:
    name: str
    region: str = &quot;us-east-1&quot;
    zone: str = &quot;a&quot;
    machine_type: str = &quot;n1-standard-1&quot;
    disk_size_gb: int = 100
    disk_type: str = &quot;ssd&quot;
    image: str = &quot;ubuntu-22.04&quot;
    network: str = &quot;default&quot;
    subnet: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    labels: Dict[str, str] = field(default_factory=dict)
    service_account: Optional[str] = None

    @classmethod
    def for_web_server(cls, name: str) -&gt; &quot;ServerConfig&quot;:
        &quot;&quot;&quot;Factory method for common use case&quot;&quot;&quot;
        return cls(
            name=name,
            machine_type=&quot;n1-standard-2&quot;,
            tags=[&quot;http-server&quot;, &quot;https-server&quot;],
            labels={&quot;role&quot;: &quot;web&quot;}
        )

class ComputeFacade:
    def create_server(self, config: ServerConfig) -&gt; Server:
        # Single entry point with sensible defaults
        pass
</code></pre>
<p><strong>2. Operation Composition</strong></p>
<pre><code class="language-python">class MediaProcessingFacade:
    &quot;&quot;&quot;Composes multiple operations into single logical units&quot;&quot;&quot;

    def prepare_for_streaming(
        self,
        source: Path,
        output_dir: Path,
        quality_levels: List[str] = [&quot;1080p&quot;, &quot;720p&quot;, &quot;480p&quot;]
    ) -&gt; StreamingPackage:
        &quot;&quot;&quot;
        Internally executes:
        1. Probe source for metadata
        2. Extract audio tracks
        3. Transcode to each quality level
        4. Generate adaptive bitrate manifest
        5. Create thumbnails at intervals
        6. Generate preview clip
        7. Package for CDN upload
        &quot;&quot;&quot;
        metadata = self._prober.analyze(source)

        variants = []
        for quality in quality_levels:
            transcoded = self._transcoder.transcode(
                source,
                self._get_encoding_params(quality, metadata)
            )
            variants.append(transcoded)

        manifest = self._packager.create_hls_manifest(variants)
        thumbnails = self._thumbnail_gen.extract(source, interval_seconds=10)
        preview = self._clip_extractor.create_preview(source, duration=30)

        return StreamingPackage(
            manifest=manifest,
            variants=variants,
            thumbnails=thumbnails,
            preview=preview,
            metadata=metadata
        )
</code></pre>
<p><strong>3. Error Consolidation and Translation</strong></p>
<pre><code class="language-python">class PaymentFacadeError(Exception):
    &quot;&quot;&quot;Base exception for all payment operations&quot;&quot;&quot;
    def __init__(self, message: str, code: str, retriable: bool = False):
        super().__init__(message)
        self.code = code
        self.retriable = retriable

class PaymentFacade:
    def charge(self, payment: PaymentRequest) -&gt; PaymentResult:
        try:
            # Multiple subsystems, each with own exception types
            validated = self._validator.validate(payment.card)
            fraud_score = self._fraud_detector.score(payment)

            if fraud_score &gt; 0.8:
                raise FraudDetectedError(score=fraud_score)

            result = self._gateway.process(payment)
            self._ledger.record(result)

            return result

        except CardValidationError as e:
            # Translate subsystem errors to facade errors
            raise PaymentFacadeError(
                &quot;Invalid card details&quot;,
                code=&quot;CARD_INVALID&quot;,
                retriable=False
            ) from e
        except GatewayTimeoutError as e:
            raise PaymentFacadeError(
                &quot;Payment processor temporarily unavailable&quot;,
                code=&quot;GATEWAY_TIMEOUT&quot;,
                retriable=True
            ) from e
        except FraudDetectedError as e:
            raise PaymentFacadeError(
                &quot;Transaction declined for security reasons&quot;,
                code=&quot;FRAUD_SUSPECTED&quot;,
                retriable=False
            ) from e
        except LedgerWriteError as e:
            # Critical: payment succeeded but ledger failed
            self._alert_service.critical(
                &quot;Ledger write failed after successful payment&quot;,
                payment_id=result.id
            )
            # Still return success - reconciliation handles this
            return result
</code></pre>
<hr />
<h2 id="layered-facades-architecture">Layered Facades Architecture</h2>
<p>Complex systems often employ multiple Facade layers, each serving different abstraction levels:</p>
<div>
<div>
<span>External Clients</span>
</div>
<div>
<div>
<div>Public API Facade</div>
<div>REST/GraphQL endpoints, rate limiting, auth</div>
</div>
</div>
<div>&#8595;</div>
<div>
<div>
<div>Application Service Facade</div>
<div>Use-case orchestration, transactions, business rules</div>
</div>
</div>
<div>&#8595;</div>
<div>
<div>
<div>Domain Facade A</div>
<div>Orders</div>
</div>
<div>
<div>Domain Facade B</div>
<div>Payments</div>
</div>
<div>
<div>Domain Facade C</div>
<div>Inventory</div>
</div>
</div>
<div>&#8595;</div>
<div>
<div>Infrastructure Layer</div>
<div>
<span>Database</span>
<span>Cache</span>
<span>Message Queue</span>
<span>External APIs</span>
</div>
</div>
</div>
<h3 id="implementation-of-layered-facades">Implementation of Layered Facades</h3>
<pre><code class="language-python"># Layer 1: Infrastructure Facades
class CacheFacade:
    &quot;&quot;&quot;Hides Redis complexity: connection pooling, serialization, key management&quot;&quot;&quot;
    def __init__(self, redis_url: str):
        self._pool = redis.ConnectionPool.from_url(redis_url)
        self._serializer = PickleSerializer()

    def get_or_compute(
        self,
        key: str,
        compute_fn: Callable[[], T],
        ttl: timedelta = timedelta(hours=1)
    ) -&gt; T:
        cached = self._get(key)
        if cached is not None:
            return cached

        value = compute_fn()
        self._set(key, value, ttl)
        return value


class DatabaseFacade:
    &quot;&quot;&quot;Hides SQLAlchemy session management, query optimization&quot;&quot;&quot;
    pass


# Layer 2: Domain Facades
class InventoryFacade:
    &quot;&quot;&quot;Domain operations for inventory management&quot;&quot;&quot;

    def __init__(self, db: DatabaseFacade, cache: CacheFacade):
        self._db = db
        self._cache = cache

    def check_availability(self, sku: str, quantity: int) -&gt; AvailabilityResult:
        # Uses infrastructure facades internally
        inventory = self._cache.get_or_compute(
            f&quot;inventory:{sku}&quot;,
            lambda: self._db.get_inventory(sku),
            ttl=timedelta(minutes=5)
        )
        return AvailabilityResult(
            available=inventory.quantity &gt;= quantity,
            current_stock=inventory.quantity
        )


class PaymentFacade:
    &quot;&quot;&quot;Domain operations for payment processing&quot;&quot;&quot;

    def __init__(self, gateway: PaymentGateway, fraud: FraudService):
        self._gateway = gateway
        self._fraud = fraud


# Layer 3: Application Service Facade
class OrderServiceFacade:
    &quot;&quot;&quot;Orchestrates order workflows across domains&quot;&quot;&quot;

    def __init__(
        self,
        inventory: InventoryFacade,
        payment: PaymentFacade,
        shipping: ShippingFacade,
        notifications: NotificationFacade
    ):
        self._inventory = inventory
        self._payment = payment
        self._shipping = shipping
        self._notifications = notifications

    @transactional
    def place_order(self, order_request: OrderRequest) -&gt; OrderResult:
        &quot;&quot;&quot;Single transaction spanning multiple domain facades&quot;&quot;&quot;

        # Validate across domains
        for item in order_request.items:
            availability = self._inventory.check_availability(
                item.sku, item.quantity
            )
            if not availability.available:
                raise InsufficientStockError(item.sku)

        # Reserve and charge
        reservation = self._inventory.reserve(order_request.items)
        payment = self._payment.charge(order_request.payment)

        # Create shipment
        shipment = self._shipping.create_shipment(order_request)

        # Async notification
        self._notifications.send_order_confirmation_async(
            order_request.customer_email,
            order_id=reservation.order_id
        )

        return OrderResult(
            order_id=reservation.order_id,
            payment_id=payment.transaction_id,
            tracking_number=shipment.tracking_number
        )


# Layer 4: Public API Facade
class PublicAPIFacade:
    &quot;&quot;&quot;External-facing API with security, rate limiting, versioning&quot;&quot;&quot;

    def __init__(
        self,
        order_service: OrderServiceFacade,
        auth: AuthService,
        rate_limiter: RateLimiter
    ):
        self._order_service = order_service
        self._auth = auth
        self._rate_limiter = rate_limiter

    def handle_create_order(self, request: HTTPRequest) -&gt; HTTPResponse:
        # Authentication
        user = self._auth.validate_token(request.headers[&quot;Authorization&quot;])

        # Rate limiting
        if not self._rate_limiter.allow(user.id, &quot;create_order&quot;):
            return HTTPResponse(429, {&quot;error&quot;: &quot;Rate limit exceeded&quot;})

        # Validate and transform request
        try:
            order_request = OrderRequest.from_api_v1(request.body, user)
        except ValidationError as e:
            return HTTPResponse(400, {&quot;error&quot;: str(e)})

        # Delegate to application service
        try:
            result = self._order_service.place_order(order_request)
            return HTTPResponse(201, result.to_api_v1())
        except InsufficientStockError as e:
            return HTTPResponse(409, {&quot;error&quot;: &quot;Item unavailable&quot;})
        except PaymentDeclinedError as e:
            return HTTPResponse(402, {&quot;error&quot;: &quot;Payment declined&quot;})
</code></pre>
<div>
<div>Design Choice: Layer Communication</div>
<div>Each layer should only communicate with the layer immediately below it. Skipping layers (e.g., API facade directly accessing database facade) violates the layered architecture and makes the system harder to reason about, test, and modify.</div>
</div>
<hr />
<h2 id="implementation-complete-examples">Implementation: Complete Examples</h2>
<h3 id="go---e-commerce-order-facade-with-saga-pattern">Go - E-Commerce Order Facade with Saga Pattern</h3>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// Subsystem interfaces

type InventoryService interface {
	CheckStock(ctx context.Context, sku string, qty int) (bool, error)
	Reserve(ctx context.Context, sku string, qty int) (string, error)
	Release(ctx context.Context, reservationID string) error
}

type PaymentService interface {
	Authorize(ctx context.Context, amount Money, card CardInfo) (string, error)
	Capture(ctx context.Context, authID string) error
	Void(ctx context.Context, authID string) error
}

type ShippingService interface {
	CalculateRate(ctx context.Context, items []Item, addr Address) (Money, error)
	CreateShipment(ctx context.Context, orderID string, items []Item, addr Address) (string, error)
	CancelShipment(ctx context.Context, shipmentID string) error
}

type NotificationService interface {
	SendOrderConfirmation(ctx context.Context, email string, order OrderDetails) error
}

// Domain types

type Money struct {
	Amount   int64
	Currency string
}

func (m Money) Add(other Money) Money {
	return Money{Amount: m.Amount + other.Amount, Currency: m.Currency}
}

type CardInfo struct {
	Number    string
	ExpMonth  int
	ExpYear   int
	CVV       string
	HolderName string
}

type Address struct {
	Street  string
	City    string
	State   string
	ZipCode string
	Country string
}

type Item struct {
	SKU      string
	Name     string
	Quantity int
	Price    Money
	Weight   float64
}

type OrderRequest struct {
	CustomerID    string
	CustomerEmail string
	Items         []Item
	ShippingAddr  Address
	BillingAddr   Address
	Card          CardInfo
}

type OrderDetails struct {
	OrderID        string
	Items          []Item
	Subtotal       Money
	ShippingCost   Money
	Tax            Money
	Total          Money
	TrackingNumber string
	EstimatedDelivery time.Time
}

// Saga implementation for distributed transaction management

type SagaStep struct {
	Name       string
	Execute    func(ctx context.Context) error
	Compensate func(ctx context.Context) error
}

type Saga struct {
	steps     []SagaStep
	executed  []int
	mu        sync.Mutex
}

func NewSaga() *Saga {
	return &amp;Saga{
		steps:    make([]SagaStep, 0),
		executed: make([]int, 0),
	}
}

func (s *Saga) AddStep(step SagaStep) {
	s.steps = append(s.steps, step)
}

func (s *Saga) Execute(ctx context.Context) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	for i, step := range s.steps {
		if err := step.Execute(ctx); err != nil {
			// Compensate in reverse order
			s.compensate(ctx)
			return fmt.Errorf(&quot;saga failed at step '%s': %w&quot;, step.Name, err)
		}
		s.executed = append(s.executed, i)
	}
	return nil
}

func (s *Saga) compensate(ctx context.Context) {
	// Reverse order compensation
	for i := len(s.executed) - 1; i &gt;= 0; i-- {
		stepIdx := s.executed[i]
		step := s.steps[stepIdx]
		if step.Compensate != nil {
			if err := step.Compensate(ctx); err != nil {
				// Log but continue - compensation must complete
				fmt.Printf(&quot;WARNING: compensation failed for step '%s': %v\n&quot;,
					step.Name, err)
			}
		}
	}
}

// The Facade

type OrderFacade struct {
	inventory     InventoryService
	payment       PaymentService
	shipping      ShippingService
	notifications NotificationService

	// Configuration
	taxRate       float64
	orderTimeout  time.Duration
}

type OrderFacadeConfig struct {
	TaxRate      float64
	OrderTimeout time.Duration
}

func NewOrderFacade(
	inventory InventoryService,
	payment PaymentService,
	shipping ShippingService,
	notifications NotificationService,
	config OrderFacadeConfig,
) *OrderFacade {
	return &amp;OrderFacade{
		inventory:     inventory,
		payment:       payment,
		shipping:      shipping,
		notifications: notifications,
		taxRate:       config.TaxRate,
		orderTimeout:  config.OrderTimeout,
	}
}

func (f *OrderFacade) PlaceOrder(
	ctx context.Context,
	req OrderRequest,
) (*OrderDetails, error) {
	// Apply timeout to entire operation
	ctx, cancel := context.WithTimeout(ctx, f.orderTimeout)
	defer cancel()

	// Phase 1: Validation (fail fast, no compensation needed)
	if err := f.validateRequest(req); err != nil {
		return nil, fmt.Errorf(&quot;validation failed: %w&quot;, err)
	}

	// Check stock availability for all items
	for _, item := range req.Items {
		available, err := f.inventory.CheckStock(ctx, item.SKU, item.Quantity)
		if err != nil {
			return nil, fmt.Errorf(&quot;stock check failed: %w&quot;, err)
		}
		if !available {
			return nil, fmt.Errorf(&quot;insufficient stock for SKU %s&quot;, item.SKU)
		}
	}

	// Calculate totals
	subtotal := f.calculateSubtotal(req.Items)
	shippingCost, err := f.shipping.CalculateRate(ctx, req.Items, req.ShippingAddr)
	if err != nil {
		return nil, fmt.Errorf(&quot;shipping calculation failed: %w&quot;, err)
	}
	tax := Money{
		Amount:   int64(float64(subtotal.Amount) * f.taxRate),
		Currency: subtotal.Currency,
	}
	total := subtotal.Add(shippingCost).Add(tax)

	// Phase 2: Execute saga with compensation
	orderID := generateOrderID()
	var reservationIDs []string
	var authorizationID string
	var trackingNumber string

	saga := NewSaga()

	// Step 1: Reserve inventory
	saga.AddStep(SagaStep{
		Name: &quot;reserve_inventory&quot;,
		Execute: func(ctx context.Context) error {
			for _, item := range req.Items {
				resID, err := f.inventory.Reserve(ctx, item.SKU, item.Quantity)
				if err != nil {
					return err
				}
				reservationIDs = append(reservationIDs, resID)
			}
			return nil
		},
		Compensate: func(ctx context.Context) error {
			for _, resID := range reservationIDs {
				f.inventory.Release(ctx, resID)
			}
			return nil
		},
	})

	// Step 2: Authorize payment
	saga.AddStep(SagaStep{
		Name: &quot;authorize_payment&quot;,
		Execute: func(ctx context.Context) error {
			var err error
			authorizationID, err = f.payment.Authorize(ctx, total, req.Card)
			return err
		},
		Compensate: func(ctx context.Context) error {
			return f.payment.Void(ctx, authorizationID)
		},
	})

	// Step 3: Create shipment
	saga.AddStep(SagaStep{
		Name: &quot;create_shipment&quot;,
		Execute: func(ctx context.Context) error {
			var err error
			trackingNumber, err = f.shipping.CreateShipment(
				ctx, orderID, req.Items, req.ShippingAddr)
			return err
		},
		Compensate: func(ctx context.Context) error {
			return f.shipping.CancelShipment(ctx, trackingNumber)
		},
	})

	// Step 4: Capture payment (no compensation - funds released automatically)
	saga.AddStep(SagaStep{
		Name: &quot;capture_payment&quot;,
		Execute: func(ctx context.Context) error {
			return f.payment.Capture(ctx, authorizationID)
		},
		Compensate: nil, // Capture is final - handle via refund process
	})

	// Execute the saga
	if err := saga.Execute(ctx); err != nil {
		return nil, err
	}

	// Build order details
	orderDetails := &amp;OrderDetails{
		OrderID:          orderID,
		Items:            req.Items,
		Subtotal:         subtotal,
		ShippingCost:     shippingCost,
		Tax:              tax,
		Total:            total,
		TrackingNumber:   trackingNumber,
		EstimatedDelivery: time.Now().AddDate(0, 0, 5),
	}

	// Async notification (fire and forget with logging)
	go func() {
		bgCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()
		if err := f.notifications.SendOrderConfirmation(
			bgCtx, req.CustomerEmail, *orderDetails); err != nil {
			fmt.Printf(&quot;WARNING: failed to send confirmation: %v\n&quot;, err)
		}
	}()

	return orderDetails, nil
}

func (f *OrderFacade) validateRequest(req OrderRequest) error {
	if len(req.Items) == 0 {
		return errors.New(&quot;order must contain at least one item&quot;)
	}
	if req.CustomerEmail == &quot;&quot; {
		return errors.New(&quot;customer email is required&quot;)
	}
	// Additional validation...
	return nil
}

func (f *OrderFacade) calculateSubtotal(items []Item) Money {
	var total int64
	currency := &quot;USD&quot;
	for _, item := range items {
		total += item.Price.Amount * int64(item.Quantity)
		currency = item.Price.Currency
	}
	return Money{Amount: total, Currency: currency}
}

func generateOrderID() string {
	return fmt.Sprintf(&quot;ORD-%d&quot;, time.Now().UnixNano())
}
</code></pre>
<h3 id="python---media-processing-facade-with-progress-tracking">Python - Media Processing Facade with Progress Tracking</h3>
<pre><code class="language-python">from __future__ import annotations
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import Callable, Dict, List, Optional, Protocol
from concurrent.futures import ThreadPoolExecutor, Future
import threading
import time


class ProcessingStage(Enum):
    ANALYZING = auto()
    TRANSCODING = auto()
    PACKAGING = auto()
    UPLOADING = auto()
    COMPLETE = auto()
    FAILED = auto()


@dataclass
class ProgressUpdate:
    stage: ProcessingStage
    percent: float
    message: str
    elapsed_seconds: float
    estimated_remaining: Optional[float] = None


ProgressCallback = Callable[[ProgressUpdate], None]


# Subsystem protocols

class MediaAnalyzer(Protocol):
    def analyze(self, source: Path) -&gt; MediaMetadata: ...


class Transcoder(Protocol):
    def transcode(
        self,
        source: Path,
        output: Path,
        params: TranscodeParams,
        on_progress: Optional[Callable[[float], None]] = None
    ) -&gt; TranscodeResult: ...


class Packager(Protocol):
    def create_manifest(
        self,
        variants: List[Path],
        output_dir: Path
    ) -&gt; Path: ...

    def create_thumbnails(
        self,
        source: Path,
        output_dir: Path,
        interval_seconds: int
    ) -&gt; List[Path]: ...


class CDNUploader(Protocol):
    def upload(
        self,
        files: List[Path],
        destination: str,
        on_progress: Optional[Callable[[float], None]] = None
    ) -&gt; CDNUploadResult: ...


# Domain types

@dataclass
class MediaMetadata:
    duration_seconds: float
    width: int
    height: int
    codec: str
    bitrate: int
    audio_tracks: List[AudioTrack]


@dataclass
class AudioTrack:
    language: str
    codec: str
    channels: int


@dataclass
class TranscodeParams:
    resolution: str
    video_codec: str = &quot;h264&quot;
    audio_codec: str = &quot;aac&quot;
    video_bitrate: int = 5000000
    audio_bitrate: int = 128000
    keyframe_interval: int = 2


@dataclass
class TranscodeResult:
    output_path: Path
    duration_seconds: float
    file_size_bytes: int


@dataclass
class CDNUploadResult:
    urls: Dict[str, str]
    manifest_url: str


@dataclass
class QualityPreset:
    name: str
    resolution: str
    video_bitrate: int

    @classmethod
    def hd_1080p(cls) -&gt; QualityPreset:
        return cls(&quot;1080p&quot;, &quot;1920x1080&quot;, 5000000)

    @classmethod
    def hd_720p(cls) -&gt; QualityPreset:
        return cls(&quot;720p&quot;, &quot;1280x720&quot;, 2500000)

    @classmethod
    def sd_480p(cls) -&gt; QualityPreset:
        return cls(&quot;480p&quot;, &quot;854x480&quot;, 1000000)

    @classmethod
    def default_ladder(cls) -&gt; List[QualityPreset]:
        return [cls.hd_1080p(), cls.hd_720p(), cls.sd_480p()]


@dataclass
class ProcessingResult:
    &quot;&quot;&quot;Complete result of media processing pipeline&quot;&quot;&quot;
    manifest_url: str
    variant_urls: Dict[str, str]
    thumbnail_urls: List[str]
    metadata: MediaMetadata
    processing_time_seconds: float


@dataclass
class ProcessingJob:
    &quot;&quot;&quot;Internal job tracking&quot;&quot;&quot;
    id: str
    source: Path
    stage: ProcessingStage = ProcessingStage.ANALYZING
    progress: float = 0.0
    start_time: float = field(default_factory=time.time)
    error: Optional[str] = None
    result: Optional[ProcessingResult] = None
    _lock: threading.Lock = field(default_factory=threading.Lock)

    def update(
        self,
        stage: ProcessingStage,
        progress: float,
        callback: Optional[ProgressCallback] = None
    ):
        with self._lock:
            self.stage = stage
            self.progress = progress

            if callback:
                elapsed = time.time() - self.start_time
                callback(ProgressUpdate(
                    stage=stage,
                    percent=progress,
                    message=f&quot;{stage.name}: {progress:.1f}%&quot;,
                    elapsed_seconds=elapsed
                ))


class MediaProcessingFacade:
    &quot;&quot;&quot;
    Unified interface for complex media processing pipeline.

    Encapsulates:
    - Media analysis and validation
    - Multi-quality transcoding (parallel)
    - Adaptive bitrate packaging (HLS/DASH)
    - CDN upload with resumability
    - Progress tracking and callbacks

    Trade-offs:
    - Memory: Keeps job state in memory (use Redis for distributed)
    - Parallelism: Thread pool size affects resource usage
    - Error handling: Partial failures require manual cleanup
    &quot;&quot;&quot;

    def __init__(
        self,
        analyzer: MediaAnalyzer,
        transcoder: Transcoder,
        packager: Packager,
        uploader: CDNUploader,
        work_dir: Path,
        max_parallel_transcodes: int = 3
    ):
        self._analyzer = analyzer
        self._transcoder = transcoder
        self._packager = packager
        self._uploader = uploader
        self._work_dir = work_dir
        self._executor = ThreadPoolExecutor(max_workers=max_parallel_transcodes)
        self._jobs: Dict[str, ProcessingJob] = {}
        self._lock = threading.Lock()

    def process_for_streaming(
        self,
        source: Path,
        cdn_destination: str,
        presets: Optional[List[QualityPreset]] = None,
        on_progress: Optional[ProgressCallback] = None
    ) -&gt; ProcessingResult:
        &quot;&quot;&quot;
        Process media file for adaptive streaming delivery.

        Args:
            source: Path to source media file
            cdn_destination: CDN path prefix for uploads
            presets: Quality ladder (defaults to 1080p, 720p, 480p)
            on_progress: Optional callback for progress updates

        Returns:
            ProcessingResult with URLs and metadata

        Raises:
            MediaProcessingError: If any stage fails
        &quot;&quot;&quot;
        presets = presets or QualityPreset.default_ladder()
        job_id = self._create_job_id(source)
        job = ProcessingJob(id=job_id, source=source)

        with self._lock:
            self._jobs[job_id] = job

        try:
            # Stage 1: Analyze source
            job.update(ProcessingStage.ANALYZING, 0, on_progress)
            metadata = self._analyzer.analyze(source)
            job.update(ProcessingStage.ANALYZING, 100, on_progress)

            # Stage 2: Transcode to all quality levels (parallel)
            job.update(ProcessingStage.TRANSCODING, 0, on_progress)
            variants = self._transcode_parallel(
                source, presets, job, on_progress
            )
            job.update(ProcessingStage.TRANSCODING, 100, on_progress)

            # Stage 3: Package for streaming
            job.update(ProcessingStage.PACKAGING, 0, on_progress)
            output_dir = self._work_dir / job_id
            manifest = self._packager.create_manifest(variants, output_dir)
            thumbnails = self._packager.create_thumbnails(
                source, output_dir, interval_seconds=10
            )
            job.update(ProcessingStage.PACKAGING, 100, on_progress)

            # Stage 4: Upload to CDN
            job.update(ProcessingStage.UPLOADING, 0, on_progress)
            all_files = variants + [manifest] + thumbnails
            upload_result = self._uploader.upload(
                all_files,
                cdn_destination,
                on_progress=lambda p: job.update(
                    ProcessingStage.UPLOADING, p, on_progress
                )
            )

            # Build result
            job.update(ProcessingStage.COMPLETE, 100, on_progress)
            result = ProcessingResult(
                manifest_url=upload_result.manifest_url,
                variant_urls=upload_result.urls,
                thumbnail_urls=[
                    upload_result.urls[t.name] for t in thumbnails
                ],
                metadata=metadata,
                processing_time_seconds=time.time() - job.start_time
            )
            job.result = result
            return result

        except Exception as e:
            job.stage = ProcessingStage.FAILED
            job.error = str(e)
            raise MediaProcessingError(
                f&quot;Processing failed at {job.stage.name}: {e}&quot;
            ) from e

    def _transcode_parallel(
        self,
        source: Path,
        presets: List[QualityPreset],
        job: ProcessingJob,
        on_progress: Optional[ProgressCallback]
    ) -&gt; List[Path]:
        &quot;&quot;&quot;Transcode to multiple qualities in parallel&quot;&quot;&quot;
        futures: List[tuple[QualityPreset, Future]] = []
        progress_per_preset: Dict[str, float] = {p.name: 0 for p in presets}
        progress_lock = threading.Lock()

        def update_aggregate_progress():
            with progress_lock:
                total = sum(progress_per_preset.values()) / len(presets)
                job.update(ProcessingStage.TRANSCODING, total, on_progress)

        for preset in presets:
            output = self._work_dir / job.id / f&quot;{preset.name}.mp4&quot;
            output.parent.mkdir(parents=True, exist_ok=True)

            def transcode_one(p: QualityPreset, out: Path):
                def on_transcode_progress(percent: float):
                    progress_per_preset[p.name] = percent
                    update_aggregate_progress()

                params = TranscodeParams(
                    resolution=p.resolution,
                    video_bitrate=p.video_bitrate
                )
                result = self._transcoder.transcode(
                    source, out, params, on_transcode_progress
                )
                return result.output_path

            future = self._executor.submit(transcode_one, preset, output)
            futures.append((preset, future))

        # Wait for all and collect results
        variants = []
        errors = []
        for preset, future in futures:
            try:
                variants.append(future.result())
            except Exception as e:
                errors.append(f&quot;{preset.name}: {e}&quot;)

        if errors:
            raise MediaProcessingError(
                f&quot;Transcoding failed: {'; '.join(errors)}&quot;
            )

        return variants

    def get_job_status(self, job_id: str) -&gt; Optional[ProcessingJob]:
        &quot;&quot;&quot;Get current status of a processing job&quot;&quot;&quot;
        with self._lock:
            return self._jobs.get(job_id)

    def _create_job_id(self, source: Path) -&gt; str:
        return f&quot;job_{source.stem}_{int(time.time() * 1000)}&quot;


class MediaProcessingError(Exception):
    &quot;&quot;&quot;Raised when media processing fails&quot;&quot;&quot;
    pass
</code></pre>
<hr />
<h2 id="edge-cases-and-failure-handling">Edge Cases and Failure Handling</h2>
<h3 id="partial-failure-scenarios">Partial Failure Scenarios</h3>
<div>
<div>Critical Edge Cases</div>
<div>
<div>
<div>Subsystem Timeout Mid-Operation</div>
<div>Payment authorized but shipping service times out. Authorization will auto-expire in 7 days. Must track authorization IDs for manual void if shipment creation fails permanently.</div>
</div>
<div>
<div>Compensation Failure</div>
<div>Saga compensation step fails (e.g., inventory release fails). System enters inconsistent state. Requires: dead letter queue for failed compensations, manual intervention workflows, idempotent compensation operations.</div>
</div>
<div>
<div>Subsystem State Divergence</div>
<div>Network partition causes Facade to believe operation failed, but subsystem succeeded. Implement idempotency keys, exactly-once semantics, or compensating transactions with reconciliation.</div>
</div>
<div>
<div>Circular Dependency</div>
<div>Subsystem A requires initialization data from Subsystem B, which requires A. Solution: lazy initialization, dependency injection containers, or two-phase initialization in Facade constructor.</div>
</div>
</div>
</div>
<h3 id="idempotency-in-facades">Idempotency in Facades</h3>
<pre><code class="language-python">class IdempotentOrderFacade:
    &quot;&quot;&quot;Facade with built-in idempotency for distributed systems&quot;&quot;&quot;

    def __init__(
        self,
        order_service: OrderService,
        idempotency_store: IdempotencyStore,  # Redis/DynamoDB
        ttl: timedelta = timedelta(hours=24)
    ):
        self._orders = order_service
        self._store = idempotency_store
        self._ttl = ttl

    def place_order(
        self,
        idempotency_key: str,  # Client-provided unique key
        request: OrderRequest
    ) -&gt; OrderResult:
        &quot;&quot;&quot;
        Idempotent order placement.

        If called multiple times with same idempotency_key:
        - In-progress: Raises ConcurrentOperationError
        - Completed: Returns cached result
        - Failed: Allows retry
        &quot;&quot;&quot;
        # Check for existing operation
        existing = self._store.get(idempotency_key)

        if existing:
            if existing.status == &quot;completed&quot;:
                return existing.result  # Return cached result
            elif existing.status == &quot;in_progress&quot;:
                if existing.started_at &gt; datetime.now() - timedelta(minutes=5):
                    raise ConcurrentOperationError(
                        &quot;Operation already in progress&quot;
                    )
                # Stale in-progress, allow retry

        # Mark as in-progress
        self._store.set(
            idempotency_key,
            IdempotencyRecord(
                status=&quot;in_progress&quot;,
                started_at=datetime.now(),
                request_hash=hash_request(request)
            ),
            ttl=self._ttl
        )

        try:
            result = self._orders.place_order(request)

            # Mark as completed with result
            self._store.set(
                idempotency_key,
                IdempotencyRecord(
                    status=&quot;completed&quot;,
                    result=result,
                    completed_at=datetime.now()
                ),
                ttl=self._ttl
            )

            return result

        except Exception as e:
            # Mark as failed (allows retry)
            self._store.set(
                idempotency_key,
                IdempotencyRecord(
                    status=&quot;failed&quot;,
                    error=str(e),
                    failed_at=datetime.now()
                ),
                ttl=self._ttl
            )
            raise
</code></pre>
<hr />
<h2 id="interview-questions-3-level-recursive-deep-dive">Interview Questions: 3-Level Recursive Deep Dive</h2>
<h3 id="section-1-core-facade-concepts">Section 1: Core Facade Concepts</h3>
<p><strong>Level 1: What is the Facade pattern and when would you use it?</strong></p>
<p>The Facade pattern provides a simplified interface to a complex subsystem. Use it when:</p>
<ul>
<li>A subsystem has many interdependent classes with complex initialization</li>
<li>You want to decouple clients from subsystem implementation details</li>
<li>You need to layer a subsystem with different abstraction levels</li>
<li>Third-party libraries have complex APIs that most clients only use partially</li>
</ul>
<blockquote>
<p><strong>Level 2: How do you decide what belongs in the Facade interface versus exposing subsystem components directly?</strong></p>
</blockquote>
<p>The decision involves analyzing usage patterns and coupling trade-offs:</p>
<ol>
<li><strong>80/20 Analysis</strong>: If 80% of clients need the same 20% of subsystem functionality, that 20% belongs in the Facade</li>
<li><strong>Cohesion Test</strong>: Operations that are always called together should be combined into single Facade methods</li>
<li><strong>Stability Principle</strong>: Stable, well-understood operations go in Facade; experimental features can remain direct</li>
<li><strong>Error Boundary</strong>: Operations requiring complex error handling/recovery should be in Facade</li>
</ol>
<pre><code class="language-python">class GoodFacade:
    def common_workflow(self):  # 80% of clients need this
        pass

    def get_subsystem(self) -&gt; Subsystem:  # Escape hatch for power users
        return self._subsystem
</code></pre>
<blockquote>
<blockquote>
<p><strong>Level 3: What happens when Facade method granularity doesn't match client transaction boundaries?</strong></p>
</blockquote>
</blockquote>
<p>This creates the <strong>Transaction Boundary Mismatch Problem</strong>:</p>
<pre><code class="language-python"># Facade designed for individual operations
class PaymentFacade:
    def authorize(self, payment): ...
    def capture(self, auth_id): ...

# But client needs atomic &quot;charge&quot; operation
# If authorize succeeds but capture fails, who handles cleanup?
</code></pre>
<p>Solutions:</p>
<ol>
<li><strong>Saga in Facade</strong>: Facade implements compensating transactions internally</li>
<li><strong>Unit of Work</strong>: Facade accepts transaction context, client manages boundaries</li>
<li><strong>Operation Composition</strong>: Add coarse-grained methods alongside fine-grained</li>
<li><strong>Event Sourcing</strong>: Facade emits events, separate handler ensures consistency</li>
</ol>
<p>The trade-off: Coarse-grained methods reduce flexibility; fine-grained methods leak transaction complexity to clients.</p>
<hr />
<h3 id="section-2-facade-vs-related-patterns">Section 2: Facade vs Related Patterns</h3>
<p><strong>Level 1: How does Facade differ from <a href="/topic/design-patterns/adapter">[Adapter]</a>?</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Facade</th>
<th>Adapter</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Intent</strong></td>
<td>Simplify</td>
<td>Make compatible</td>
</tr>
<tr>
<td><strong>Interface</strong></td>
<td>Creates new</td>
<td>Conforms to existing</td>
</tr>
<tr>
<td><strong>Scope</strong></td>
<td>Multiple classes</td>
<td>Single class</td>
</tr>
<tr>
<td><strong>Direction</strong></td>
<td>Many-to-one</td>
<td>One-to-one</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Level 2: Can a system use both Facade and Adapter, and how do they interact?</strong></p>
</blockquote>
<p>Yes, commonly in these configurations:</p>
<ol>
<li><strong>Adapter inside Facade</strong>: Facade uses Adapters for individual subsystem components</li>
<li><strong>Facade wrapped by Adapter</strong>: Legacy Facade adapted to new interface requirements</li>
<li><strong>Parallel existence</strong>: Different entry points for different client types</li>
</ol>
<pre><code class="language-python">class PaymentFacade:
    def __init__(self):
        # Adapters hide third-party payment gateway differences
        self._stripe = StripeAdapter(stripe.Client())
        self._paypal = PayPalAdapter(paypal.SDK())

    def charge(self, method: PaymentMethod, amount: Money):
        # Facade selects and orchestrates adapted components
        adapter = self._stripe if method.type == &quot;card&quot; else self._paypal
        return adapter.charge(amount)
</code></pre>
<blockquote>
<blockquote>
<p><strong>Level 3: When does combining Facade and Adapter create problematic coupling, and how do you avoid it?</strong></p>
</blockquote>
</blockquote>
<p>Problems arise when:</p>
<ol>
<li><strong>Adaptation Logic Leaks</strong>: Facade makes decisions based on adaptee internals</li>
<li><strong>Circular Dependencies</strong>: Adapter needs Facade context, Facade needs Adapter</li>
<li><strong>Inconsistent Abstractions</strong>: Adapted interfaces don't align semantically</li>
</ol>
<pre><code class="language-python"># PROBLEMATIC: Facade knows too much about Stripe internals
class BadPaymentFacade:
    def charge(self, amount):
        if self._stripe._client.api_version &lt; &quot;2020-01-01&quot;:  # Leaking!
            return self._stripe.legacy_charge(amount)
        return self._stripe.charge(amount)

# BETTER: Adapter handles all version differences internally
class StripeAdapter:
    def charge(self, amount):
        # Version handling encapsulated in adapter
        if self._api_version &lt; &quot;2020-01-01&quot;:
            return self._legacy_charge(amount)
        return self._modern_charge(amount)
</code></pre>
<p><strong>Avoidance strategies</strong>:</p>
<ul>
<li><a href="/topic/design-patterns/dependency-inversion">[Dependency Inversion]</a>: Define interfaces in Facade layer, Adapters implement</li>
<li><a href="/topic/design-patterns/strategy">[Strategy Pattern]</a>: Inject payment strategies rather than concrete adapters</li>
<li>Anti-Corruption Layer: Separate translation layer between domains</li>
</ul>
<hr />
<h3 id="section-3-subsystem-encapsulation">Section 3: Subsystem Encapsulation</h3>
<p><strong>Level 1: What does &quot;encapsulation&quot; mean in the context of Facades?</strong></p>
<p>Facade encapsulation means hiding:</p>
<ul>
<li>Internal class relationships and dependencies</li>
<li>Initialization order and configuration complexity</li>
<li>Communication protocols between components</li>
<li>Error types and recovery mechanisms</li>
<li>Resource management (connections, threads, memory)</li>
</ul>
<blockquote>
<p><strong>Level 2: How do you handle subsystem state that needs to be exposed without breaking encapsulation?</strong></p>
</blockquote>
<p>Options with trade-offs:</p>
<ol>
<li>
<p><strong>Snapshot DTOs</strong>: Return immutable copies of state</p>
<ul>
<li>Pro: Full encapsulation, thread-safe</li>
<li>Con: Memory overhead, potential staleness</li>
</ul>
</li>
<li>
<p><strong>Observable/Callback</strong>: Subsystem pushes state changes</p>
<ul>
<li>Pro: Real-time, inverted control</li>
<li>Con: Callback complexity, ordering issues</li>
</ul>
</li>
<li>
<p><strong>Read-Only Views</strong>: Return interfaces with only getters</p>
<ul>
<li>Pro: Type safety, no copies</li>
<li>Con: Still exposes structure</li>
</ul>
</li>
</ol>
<pre><code class="language-python">class InventoryFacade:
    def get_stock_snapshot(self, sku: str) -&gt; StockSnapshot:
        &quot;&quot;&quot;Returns immutable point-in-time view&quot;&quot;&quot;
        stock = self._warehouse.get_stock(sku)
        return StockSnapshot(
            sku=sku,
            available=stock.available,
            reserved=stock.reserved,
            as_of=datetime.now()
        )

    def subscribe_stock_changes(
        self,
        sku: str,
        callback: Callable[[StockChange], None]
    ) -&gt; Subscription:
        &quot;&quot;&quot;Push-based state observation&quot;&quot;&quot;
        return self._event_bus.subscribe(
            f&quot;stock.{sku}.changed&quot;,
            lambda event: callback(StockChange.from_event(event))
        )
</code></pre>
<blockquote>
<blockquote>
<p><strong>Level 3: What are the implications of Facade encapsulation for testing and debugging in production?</strong></p>
</blockquote>
</blockquote>
<p><strong>Testing Challenges</strong>:</p>
<ul>
<li>Cannot inject mocks for internal components without breaking encapsulation</li>
<li>Integration tests become necessary, increasing test time and flakiness</li>
<li>Behavior verification requires observing side effects, not internal state</li>
</ul>
<p><strong>Solutions</strong>:</p>
<pre><code class="language-python">class TestableOrderFacade:
    def __init__(
        self,
        # Inject through constructor for testability
        inventory: InventoryService = None,
        payment: PaymentService = None
    ):
        # Production code can pass None for defaults
        self._inventory = inventory or ProductionInventoryService()
        self._payment = payment or ProductionPaymentService()
</code></pre>
<p><strong>Production Debugging Challenges</strong>:</p>
<ul>
<li>Logs must be emitted at Facade boundary, not just subsystems</li>
<li>Correlation IDs must propagate through all subsystems</li>
<li>Metrics aggregation: distinguish Facade latency from subsystem latency</li>
</ul>
<pre><code class="language-python">class InstrumentedFacade:
    def place_order(self, request):
        correlation_id = generate_correlation_id()
        context = Context(correlation_id=correlation_id)

        with self._tracer.span(&quot;facade.place_order&quot;) as span:
            span.set_attribute(&quot;correlation_id&quot;, correlation_id)

            try:
                # Pass context to all subsystem calls
                result = self._do_place_order(request, context)
                span.set_status(Status.OK)
                return result
            except Exception as e:
                span.set_status(Status.ERROR, str(e))
                span.record_exception(e)
                raise
</code></pre>
<hr />
<h3 id="section-4-layered-facades">Section 4: Layered Facades</h3>
<p><strong>Level 1: When should you use multiple layers of Facades?</strong></p>
<p>Use layered Facades when:</p>
<ul>
<li>Different clients need different abstraction levels (API vs internal services)</li>
<li>System has distinct architectural boundaries (infrastructure, domain, application)</li>
<li>Teams own different layers with separate release cycles</li>
<li>Security/audit requirements differ by layer</li>
</ul>
<blockquote>
<p><strong>Level 2: How do you prevent layered Facades from becoming a performance bottleneck?</strong></p>
</blockquote>
<p>Each layer adds overhead:</p>
<ul>
<li>Method call overhead (minimal)</li>
<li>Object allocation for DTOs between layers (can be significant)</li>
<li>Validation repeated at each layer (redundant)</li>
<li>Logging/tracing at each layer (multiplicative)</li>
</ul>
<p><strong>Optimization strategies</strong>:</p>
<pre><code class="language-python"># 1. Bypass layers for read-heavy paths
class OptimizedLayeredFacade:
    def get_user_profile(self, user_id: str):
        # Skip domain layer, go directly to cache
        return self._cache.get(f&quot;profile:{user_id}&quot;)

    def update_user_profile(self, user_id: str, updates: dict):
        # Full layer traversal for writes
        return self._domain_facade.update_user(user_id, updates)

# 2. Bulk operations to amortize layer overhead
class BatchAwareFacade:
    def get_users(self, user_ids: List[str]):
        # Single traversal for many items
        return self._domain_facade.get_users_batch(user_ids)

# 3. Lazy loading to defer layer traversal
class LazyLayeredFacade:
    def get_order(self, order_id: str) -&gt; LazyOrder:
        # Returns proxy, only traverses layers on access
        return LazyOrder(order_id, self._domain_facade)
</code></pre>
<blockquote>
<blockquote>
<p><strong>Level 3: How do you handle cross-layer transactions in a layered Facade architecture?</strong></p>
</blockquote>
</blockquote>
<p>Cross-layer transactions are inherently challenging because each layer may have its own transaction semantics:</p>
<p><strong>Problem scenarios</strong>:</p>
<ol>
<li>API layer commits but domain layer rolls back</li>
<li>Domain layer commits but infrastructure layer fails</li>
<li>Partial commits across layers leave inconsistent state</li>
</ol>
<p><strong>Solutions by architecture style</strong>:</p>
<p><strong>Monolithic (shared database)</strong>:</p>
<pre><code class="language-python">class TransactionalFacade:
    @transactional(propagation=REQUIRED)  # Share transaction
    def place_order(self, request):
        # All layers share same DB transaction
        order = self._domain_facade.create_order(request)
        self._notification_facade.queue_confirmation(order)
        return order
</code></pre>
<p><strong>Microservices (distributed)</strong>:</p>
<pre><code class="language-python">class SagaOrchestrator:
    &quot;&quot;&quot;Cross-service saga managed at API layer&quot;&quot;&quot;

    def place_order(self, request):
        saga = Saga()

        # Each step is independent transaction
        saga.add_step(
            execute=lambda: self._order_service.create(request),
            compensate=lambda r: self._order_service.cancel(r.order_id)
        )
        saga.add_step(
            execute=lambda: self._payment_service.charge(request.payment),
            compensate=lambda r: self._payment_service.refund(r.payment_id)
        )

        return saga.execute()
</code></pre>
<p><strong>Event Sourcing</strong>:</p>
<pre><code class="language-python">class EventSourcedFacade:
    &quot;&quot;&quot;Events are source of truth, projections are eventually consistent&quot;&quot;&quot;

    def place_order(self, request):
        # Emit event - single atomic write
        event = OrderPlaced(request)
        self._event_store.append(event)

        # Projections update asynchronously
        # UI shows &quot;processing&quot; until projections catch up
        return OrderPending(event.id)
</code></pre>
<hr />
<h3 id="section-5-real-world-implications">Section 5: Real-World Implications</h3>
<p><strong>Level 1: What are common mistakes when implementing the Facade pattern?</strong></p>
<ol>
<li><strong>God Facade</strong>: Single Facade becomes dumping ground for all subsystem access</li>
<li><strong>Leaky Abstraction</strong>: Facade methods expose subsystem-specific types/exceptions</li>
<li><strong>Tight Coupling</strong>: Facade directly instantiates all dependencies (no DI)</li>
<li><strong>Missing Escape Hatch</strong>: No way to access subsystem for advanced use cases</li>
<li><strong>Inconsistent Granularity</strong>: Mix of high-level and low-level operations</li>
</ol>
<blockquote>
<p><strong>Level 2: How do you evolve a Facade's API without breaking existing clients?</strong></p>
</blockquote>
<p><strong>Versioning strategies</strong>:</p>
<pre><code class="language-python"># 1. Method-level versioning
class PaymentFacade:
    def charge(self, amount: Money) -&gt; ChargeResult:
        &quot;&quot;&quot;Original method, maintained for compatibility&quot;&quot;&quot;
        return self.charge_v2(amount, ChargeOptions())

    def charge_v2(
        self,
        amount: Money,
        options: ChargeOptions
    ) -&gt; ChargeResultV2:
        &quot;&quot;&quot;Enhanced version with more options&quot;&quot;&quot;
        pass

# 2. Interface versioning
class PaymentFacadeV1(Protocol):
    def charge(self, amount: Money) -&gt; ChargeResult: ...

class PaymentFacadeV2(PaymentFacadeV1):
    def charge_with_options(
        self, amount: Money, options: ChargeOptions
    ) -&gt; ChargeResultV2: ...

# 3. Feature flags
class PaymentFacade:
    def charge(self, amount: Money, **kwargs) -&gt; ChargeResult:
        if self._features.is_enabled(&quot;enhanced_fraud_check&quot;):
            return self._charge_with_enhanced_fraud(amount, **kwargs)
        return self._legacy_charge(amount)
</code></pre>
<blockquote>
<blockquote>
<p><strong>Level 3: How does Facade design change in distributed systems with eventual consistency?</strong></p>
</blockquote>
</blockquote>
<p>Distributed Facades must handle:</p>
<ol>
<li><strong>Partial Visibility</strong>: Client may see stale state due to replication lag</li>
<li><strong>Conflicting Updates</strong>: Concurrent operations may create conflicts</li>
<li><strong>Network Partitions</strong>: Subsystems may be temporarily unreachable</li>
<li><strong>Ordering Guarantees</strong>: Operations may complete out of order</li>
</ol>
<pre><code class="language-python">class DistributedOrderFacade:
    def place_order(self, request: OrderRequest) -&gt; OrderHandle:
        &quot;&quot;&quot;
        Returns handle immediately, order processes asynchronously.
        Client must poll or subscribe for completion.
        &quot;&quot;&quot;
        # Write to durable queue - fast, reliable
        message_id = self._queue.publish(
            topic=&quot;orders.pending&quot;,
            message=request.to_message(),
            deduplication_id=request.idempotency_key
        )

        # Return handle for tracking
        return OrderHandle(
            tracking_id=message_id,
            status_url=f&quot;/orders/{message_id}/status&quot;,
            estimated_completion=timedelta(seconds=30)
        )

    def get_order_status(self, tracking_id: str) -&gt; OrderStatus:
        &quot;&quot;&quot;
        May return PENDING, PROCESSING, COMPLETED, or FAILED.
        COMPLETED may still show stale details due to replication.
        &quot;&quot;&quot;
        # Check fast cache first
        cached = self._cache.get(f&quot;order:{tracking_id}&quot;)
        if cached and cached.status in (&quot;COMPLETED&quot;, &quot;FAILED&quot;):
            return cached

        # Fall back to source of truth (slower)
        return self._order_store.get_status(tracking_id)

    async def subscribe_order_updates(
        self,
        tracking_id: str
    ) -&gt; AsyncIterator[OrderUpdate]:
        &quot;&quot;&quot;
        Real-time updates via SSE or WebSocket.
        Handles reconnection and replay.
        &quot;&quot;&quot;
        last_seen = None
        while True:
            updates = await self._event_stream.read(
                topic=f&quot;orders.{tracking_id}&quot;,
                after=last_seen
            )
            for update in updates:
                last_seen = update.sequence
                yield update
                if update.is_terminal:
                    return
</code></pre>
<div>
<div>Eventual Consistency Trade-off</div>
<div>Distributed Facades trade immediate consistency for availability and partition tolerance ([[CAP Theorem]](/topic/system-design/cap-theorem)). The Facade API must communicate this: return handles instead of results, provide status polling, and document staleness windows.</div>
</div>
<hr />
<h2 id="best-practices-and-anti-patterns">Best Practices and Anti-Patterns</h2>
<h3 id="best-practices">Best Practices</h3>
<div>
<div>
<div>Provide Escape Hatches</div>
<div>Expose underlying subsystems for power users who need fine-grained control. Don't force all access through Facade.</div>
</div>
<div>
<div>Design for Composition</div>
<div>Accept dependencies through constructor (DI) rather than creating them internally. Enables testing and flexibility.</div>
</div>
<div>
<div>Translate Errors Consistently</div>
<div>Convert subsystem exceptions to Facade-specific errors. Include retriability hints and correlation IDs.</div>
</div>
<div>
<div>Document Assumptions</div>
<div>Clearly state thread-safety guarantees, transaction boundaries, and consistency models.</div>
</div>
</div>
<h3 id="anti-patterns">Anti-Patterns</h3>
<div>
<div>
<div>God Facade</div>
<div>Single Facade with 50+ methods covering unrelated functionality. Split into focused, cohesive Facades.</div>
</div>
<div>
<div>Transparent Facade</div>
<div>Facade methods that simply delegate to single subsystem method without adding value. Remove unnecessary indirection.</div>
</div>
<div>
<div>Shared State Facade</div>
<div>Facade holds mutable state between method calls. Keep Facades stateless; state belongs in subsystems.</div>
</div>
<div>
<div>Facade Without Abstraction</div>
<div>Facade interface exposes implementation details (concrete types, config objects). Define clean, abstract contracts.</div>
</div>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<ul>
<li><a href="/topic/design-patterns/adapter">[Adapter]</a> - Interface translation vs simplification</li>
<li><a href="/topic/design-patterns/mediator">[Mediator]</a> - Centralizes communication between components</li>
<li><a href="/topic/design-patterns/proxy">[Proxy]</a> - Controls access to another object</li>
<li><a href="/topic/design-patterns/abstract-factory">[Abstract Factory]</a> - Often used with Facade for subsystem creation</li>
<li><a href="/topic/design-patterns/singleton">[Singleton]</a> - Facades often implemented as singletons (with caution)</li>
<li><a href="/topic/design-patterns/composite">[Composite]</a> - Subsystems may be composites accessed through Facade</li>
</ul>
<hr />
<h2 id="summary">Summary</h2>
<p>The Facade pattern is deceptively simple in concept but requires careful design in practice. Key takeaways:</p>
<ol>
<li><strong>Simplification, not hiding</strong>: Provide simplified access while allowing direct subsystem access when needed</li>
<li><strong>Transaction management</strong>: Facades often become natural transaction boundaries requiring saga/compensation patterns</li>
<li><strong>Layering strategy</strong>: Multiple Facade layers serve different abstraction needs but add overhead</li>
<li><strong>Distributed challenges</strong>: Eventual consistency, idempotency, and correlation become critical concerns</li>
<li><strong>Evolution planning</strong>: Version Facade APIs from the start; breaking changes are expensive</li>
</ol>
<p>The most successful Facades balance simplicity with flexibility, hiding complexity without restricting power users.</p>
