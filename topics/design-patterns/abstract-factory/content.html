<style>
/* Mobile-specific styles for iPhone 15 and similar devices */
@media screen and (max-width: 480px) {
    /* Force all grid layouts to single column */
    [style*="grid-template-columns"] {
        display: block !important;
    }
    [style*="grid-template-columns"] > div {
        margin-bottom: 16px !important;
    }
    /* Adjust padding for mobile */
    [style*="padding: 32px"],
    [style*="padding: 24px"] {
        padding: 16px !important;
    }
    /* Smaller headings */
    h4[style*="font-size: 18px"],
    h4[style*="font-size: 16px"] {
        font-size: 15px !important;
    }
    /* Readable font sizes */
    [style*="font-size: 13px"],
    [style*="font-size: 12px"],
    [style*="font-size: 11px"],
    [style*="font-size: 10px"] {
        font-size: 13px !important;
        line-height: 1.6 !important;
    }
    /* Flex containers stack vertically */
    [style*="display: flex"][style*="gap"] {
        flex-direction: column !important;
    }
    /* Better spacing for nested content */
    [style*="padding-left: 64px"],
    [style*="padding-left: 48px"],
    [style*="padding-left: 40px"] {
        padding-left: 16px !important;
    }
    /* Code blocks */
    pre {
        font-size: 12px !important;
        padding: 12px !important;
        overflow-x: auto !important;
    }
    pre code {
        font-size: 12px !important;
    }
    /* Tables */
    table {
        font-size: 12px !important;
        display: block !important;
        overflow-x: auto !important;
    }
    th, td {
        padding: 8px !important;
        font-size: 12px !important;
    }
}
</style>
<h1 id="abstract-factory-pattern">Abstract Factory Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Abstract Factory pattern provides an interface for creating <strong>families of related or dependent objects</strong> without specifying their concrete classes. Unlike <a href="/topics/design-patterns/factory-method">[Factory Method]</a> which creates a single product, Abstract Factory orchestrates the creation of multiple products that must work together coherently.</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 12px; padding: 20px; margin: 20px 0">
<h4 style="margin: 0 0 12px 0; color: #1e40af">Core Insight</h4>
<p style="margin: 0; font-size: 15px; line-height: 1.6; color: #475569">
Abstract Factory enforces a <strong>product family constraint</strong>: all products created by a single factory instance are guaranteed to be compatible. This is the pattern's defining characteristic and primary value proposition.
</p>
</div>
<p><strong>The fundamental problem it solves</strong>: When your system needs to create objects that belong together (a &quot;family&quot;), and mixing objects from different families would cause subtle bugs or visual inconsistencies, you need a mechanism to guarantee family coherence at the architectural level.</p>
<hr />
<h2 id="section-1-factory-families---the-core-abstraction">Section 1: Factory Families - The Core Abstraction</h2>
<h3 id="11-what-constitutes-a-factory-family">1.1 What Constitutes a Factory Family</h3>
<p>A <strong>factory family</strong> consists of:</p>
<ol>
<li>A <strong>product family</strong> - A set of related objects designed to work together</li>
<li>A <strong>concrete factory</strong> - The class responsible for creating all products in that family</li>
<li>An <strong>invariant</strong> - The guarantee that all products from one factory are mutually compatible</li>
</ol>
<div style="background: #fefce8;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #a16207">Key Assumption</h4>
<p style="margin: 0; color: #713f12; font-size: 14px">
The pattern assumes that <strong>all products within a family share enough common interface</strong> that they can be substituted for products from another family. If MacButton and WindowsButton have fundamentally different behaviors (not just appearance), the abstraction breaks down.
</p>
</div>
<h3 id="12-the-family-invariant-deep-dive">1.2 The Family Invariant Deep Dive</h3>
<p>The family invariant is enforced through <strong>construction-time binding</strong>, not runtime checks:</p>
<pre><code class="language-python">class UIFactory(ABC):
    @abstractmethod
    def create_button(self) -&gt; Button: ...

    @abstractmethod
    def create_scrollbar(self) -&gt; Scrollbar: ...

    # The invariant: if you call both methods on the same instance,
    # the returned objects are GUARANTEED compatible
</code></pre>
<p><strong>Internal mechanism</strong>: The concrete factory holds the &quot;family identity&quot; as implicit state. When <code>MacFactory.create_button()</code> is called, the method's implementation (not runtime configuration) determines the product type.</p>
<h3 id="13-family-consistency-vs-product-consistency">1.3 Family Consistency vs. Product Consistency</h3>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0">
<div style="background: #f0fdf4;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #166534">Family Consistency (Abstract Factory)</h5>
<p style="margin: 0; font-size: 13px; color: #15803d">
  All products created by MacFactory work together. All products created by WindowsFactory work together. You cannot mix.
</p>
</div>
<div style="background: #fef2f2;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #991b1b">Product Consistency (Factory Method)</h5>
<p style="margin: 0; font-size: 13px; color: #b91c1c">
  Each factory method creates one product type. No guarantee about relationships between different products.
</p>
</div>
</div>
<h3 id="interview-questions-factory-families-3-levels-deep">Interview Questions: Factory Families (3 Levels Deep)</h3>
<div style="background: #f8fafc;border-radius: 8px; padding: 20px; margin: 20px 0">
<p><strong>Level 1: &quot;What is a factory family and why does it matter?&quot;</strong></p>
<blockquote>
<p>A factory family is a set of related products designed to work together, created by a single concrete factory. It matters because it prevents incompatibility bugs - like trying to use a Windows scrollbar rendering callback with a Mac button event system. The factory guarantees coherence by construction.</p>
</blockquote>
<p><strong>Level 2: &quot;How does Abstract Factory enforce family consistency, and what happens if a developer circumvents it?&quot;</strong></p>
<blockquote>
<p>Enforcement is structural, not runtime: the concrete factory class itself embodies the family identity. A developer could circumvent it by:</p>
<ol>
<li>Storing products in variables typed to concrete classes and mixing them</li>
<li>Using multiple factory instances from different families in the same context</li>
<li>Casting abstract products to concrete types and directly instantiating others</li>
</ol>
<p>Circumvention leads to subtle bugs: mismatched event systems, incompatible rendering pipelines, or memory layout mismatches in low-level systems. Prevention requires discipline (code reviews) or language-level help (Rust's type system can encode family membership).</p>
</blockquote>
<p><strong>Level 3: &quot;Design a type system that makes family mixing a compile-time error. What are the trade-offs of different approaches?&quot;</strong></p>
<blockquote>
<p><strong>Approach 1: Phantom Types</strong></p>
<pre><code class="language-typescript">type Button&lt;Family&gt; = { render(): void; __family: Family };
</code></pre>
</blockquote>
<pre><code>&gt; type MacFamily = { readonly brand: 'mac' };
&gt; type WinFamily = { readonly brand: 'win' };
&gt;
&gt; function createDialog&lt;F&gt;(btn: Button&lt;F&gt;, scroll: Scrollbar&lt;F&gt;) { ... }
</code></pre>
<blockquote>
<p>// Mixing families is now a type error</p>
<pre><code>Trade-off: Requires generic propagation throughout the codebase; verbose.

**Approach 2: Module-level Isolation**
Each family is a separate module with internal concrete types, exporting only through a unified interface.
Trade-off: Duplicated interface definitions; harder to add new families.

**Approach 3: Dependent Types (Idris, Agda)**
Family membership encoded as a type-level proof term.
Trade-off: Extreme complexity; not practical for most production systems.

The pragmatic solution for most systems is Approach 1 combined with [[Dependency Injection]](/topics/design-patterns/dependency-injection) to ensure factory consistency at the composition root.
</code></pre>
</blockquote>
</div>
<hr />
<h2 id="section-2-ui-toolkit-example---the-canonical-use-case">Section 2: UI Toolkit Example - The Canonical Use Case</h2>
<h3 id="21-why-ui-toolkits-are-the-perfect-example">2.1 Why UI Toolkits Are the Perfect Example</h3>
<p>UI toolkits demonstrate Abstract Factory's value because:</p>
<ol>
<li><strong>Visual coherence is immediately observable</strong> - A Windows button in a Mac app looks wrong</li>
<li><strong>Event systems are tightly coupled</strong> - Mac uses responder chains; Windows uses message loops</li>
<li><strong>Rendering pipelines differ</strong> - DirectX vs. Metal vs. OpenGL backends</li>
<li><strong>Accessibility APIs vary</strong> - Screen readers expect platform-specific semantics</li>
</ol>
<h3 id="22-anatomy-of-a-cross-platform-ui-factory">2.2 Anatomy of a Cross-Platform UI Factory</h3>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #334155; margin: 0 0 20px 0; text-align: center">Cross-Platform UI Factory Architecture</h4>
<div style="display: flex; flex-direction: column; gap: 20px">
<div style="display: flex; justify-content: center; gap: 12px; flex-wrap: wrap">
<div style="background: #dbeafe;border-radius: 8px; padding: 12px 20px; text-align: center">
<div style="font-weight: 700; color: #1e40af; font-size: 14px">WidgetFactory</div>
<div style="font-size: 11px; color: #3b82f6; margin-top: 4px">interface</div>
<div style="font-family: monospace; font-size: 11px; color: #1e3a5f; margin-top: 8px; text-align: left">
  +createButton()<br/>
  +createScrollbar()<br/>
  +createTextInput()<br/>
  +createMenu()<br/>
  +getEventLoop()
</div>
</div>
</div>
<div style="display: flex; justify-content: center">
<div style="color: #64748b; font-size: 12px">implements</div>
</div>
<div style="display: flex; justify-content: center; gap: 16px; flex-wrap: wrap">
<div style="background: #dcfce7;border-radius: 8px; padding: 12px 16px; text-align: center; min-width: 140px">
<div style="font-weight: 600; color: #166534; font-size: 13px">MacWidgetFactory</div>
<div style="font-size: 10px; color: #15803d; margin-top: 4px">Cocoa/AppKit backend</div>
</div>
<div style="background: #e0e7ff;border-radius: 8px; padding: 12px 16px; text-align: center; min-width: 140px">
<div style="font-weight: 600; color: #3730a3; font-size: 13px">WinWidgetFactory</div>
<div style="font-size: 10px; color: #4338ca; margin-top: 4px">Win32/WinRT backend</div>
</div>
<div style="background: #fef3c7;border-radius: 8px; padding: 12px 16px; text-align: center; min-width: 140px">
<div style="font-weight: 600; color: #92400e; font-size: 13px">LinuxWidgetFactory</div>
<div style="font-size: 10px; color: #b45309; margin-top: 4px">GTK/Qt backend</div>
</div>
</div>
<div style="padding-top: 16px; margin-top: 8px">
<div style="text-align: center; color: #64748b; font-size: 12px; margin-bottom: 12px">Each factory creates a complete, coherent product family</div>
<div style="display: flex; justify-content: center; gap: 8px; flex-wrap: wrap">
<div style="background: #f0fdf4;border-radius: 4px; padding: 6px 10px; font-size: 11px; color: #166534">MacButton</div>
<div style="background: #f0fdf4;border-radius: 4px; padding: 6px 10px; font-size: 11px; color: #166534">MacScrollbar</div>
<div style="background: #f0fdf4;border-radius: 4px; padding: 6px 10px; font-size: 11px; color: #166534">MacEventLoop</div>
<div style="background: #eef2ff;border-radius: 4px; padding: 6px 10px; font-size: 11px; color: #3730a3">WinButton</div>
<div style="background: #eef2ff;border-radius: 4px; padding: 6px 10px; font-size: 11px; color: #3730a3">WinScrollbar</div>
<div style="background: #eef2ff;border-radius: 4px; padding: 6px 10px; font-size: 11px; color: #3730a3">WinEventLoop</div>
</div>
</div>
</div>
</div>
<h3 id="23-hidden-complexity-event-system-coupling">2.3 Hidden Complexity: Event System Coupling</h3>
<p>The most underappreciated aspect of UI Abstract Factories is <strong>event system coupling</strong>:</p>
<pre><code class="language-python">    class Button(ABC):
    @abstractmethod
    def on_click(self, handler: Callable[['ClickEvent'], None]) -&gt; None:
    &quot;&quot;&quot;Register click handler.

    CRITICAL: The ClickEvent type varies by platform!
    - Mac: contains responder chain info, gesture recognizer state
    - Windows: contains HWND, message ID, WPARAM, LPARAM
    - Linux/GTK: contains GdkEvent pointer, widget hierarchy

    The abstract Button hides this, but the factory must ensure
    the event loop that dispatches events understands the event format.
    &quot;&quot;&quot;
    pass</code></pre>
<div style="background: #fef2f2;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #991b1b">Edge Case: Mixed Event Systems</h4>
<p style="margin: 0; color: #7f1d1d; font-size: 14px">
If you create a MacButton but run it with a Windows event loop, the button will never receive click events. The event loop doesn't know how to translate Windows messages into Mac responder chain calls. <strong>This is why the factory must also provide the event loop</strong> - it's part of the family.
</p>
</div>
<h3 id="interview-questions-ui-toolkit-3-levels-deep">Interview Questions: UI Toolkit (3 Levels Deep)</h3>
<div style="background: #f8fafc;border-radius: 8px; padding: 20px; margin: 20px 0">
<p><strong>Level 1: &quot;Why is UI toolkit development a canonical example of Abstract Factory?&quot;</strong></p>
<blockquote>
<p>UI toolkits need to create multiple related components (buttons, scrollbars, text inputs) that must be visually and behaviorally consistent. A Mac button must work with Mac menus and Mac event handling. Abstract Factory guarantees this by making the platform choice a single decision point that affects all component creation.</p>
</blockquote>
<p><strong>Level 2: &quot;Beyond visual consistency, what other 'hidden' products must a UI factory family include?&quot;</strong></p>
<blockquote>
<p>A complete UI factory family includes:</p>
<ol>
<li><strong>Event loop/message pump</strong> - Platform-specific event dispatching</li>
<li><strong>Accessibility provider</strong> - Screen reader integration (AT-SPI on Linux, MSAA/UIA on Windows, NSAccessibility on Mac)</li>
<li><strong>Clipboard handler</strong> - Platform clipboard formats differ</li>
<li><strong>Drag-and-drop coordinator</strong> - Drop target/source protocols vary</li>
<li><strong>Font rasterizer</strong> - ClearType vs. FreeType vs. Core Text</li>
<li><strong>Input method editor</strong> - IME integration for CJK languages</li>
<li><strong>Theme provider</strong> - System theme colors, dark mode detection</li>
</ol>
<p>Missing any of these creates subtle bugs: text looks wrong, accessibility doesn't work, copy-paste fails for certain data types.</p>
</blockquote>
<p><strong>Level 3: &quot;Design a UI factory that supports runtime theme switching without recreating all widgets. What patterns would you combine with Abstract Factory?&quot;</strong></p>
<blockquote>
<p>Runtime theme switching requires separating <strong>widget identity</strong> from <strong>widget appearance</strong>:</p>
<p><strong>Solution: Abstract Factory + <a href="/topics/design-patterns/strategy">[Strategy]</a> + <a href="/topics/design-patterns/observer">[Observer]</a></strong></p>
<pre><code class="language-python">class Button:
    def __init__(self, renderer: ButtonRenderer, theme_manager: ThemeManager):
        self.renderer = renderer
        theme_manager.subscribe(self._on_theme_change)

    def _on_theme_change(self, new_theme: Theme):
        # Get new renderer from current factory
        self.renderer = new_theme.factory.create_button_renderer()
        self.invalidate()  # Trigger repaint

class ThemeManager:
    def switch_theme(self, new_factory: WidgetFactory):
        self.current_factory = new_factory
        self.notify_subscribers(Theme(new_factory))
</code></pre>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>Memory: Each widget holds a reference to its renderer (slight overhead)</li>
<li>Complexity: Two-layer abstraction (widget + renderer) is harder to understand</li>
<li>Performance: Theme switch triggers O(n) updates for n widgets</li>
<li>Consistency: Brief visual inconsistency during transition if not batched</li>
</ul>
<p><strong>Alternative</strong>: Use <a href="/topics/design-patterns/flyweight">[Flyweight]</a> for shared rendering state, reducing memory overhead.</p>
</blockquote>
</div>
<hr />
<h2 id="section-3-cross-platform-development---beyond-ui">Section 3: Cross-Platform Development - Beyond UI</h2>
<h3 id="31-platform-abstraction-layers">3.1 Platform Abstraction Layers</h3>
<p>Abstract Factory excels at creating <strong>Platform Abstraction Layers (PALs)</strong>:</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #334155; margin: 0 0 20px 0; text-align: center">Platform Abstraction Layer Architecture</h4>
<div style="display: flex; flex-direction: column; gap: 16px">
<div style="background: #fef3c7;border-radius: 8px; padding: 16px; text-align: center">
<div style="font-weight: 700; color: #92400e">Application Layer</div>
<div style="font-size: 12px; color: #b45309">Business logic - uses only abstract interfaces</div>
</div>
<div style="display: flex; justify-content: center">
<div style="width: 2px; height: 20px; background: #94a3b8"></div>
</div>
<div style="background: #dbeafe;border-radius: 8px; padding: 16px; text-align: center">
<div style="font-weight: 700; color: #1e40af">PlatformFactory Interface</div>
<div style="font-size: 12px; color: #3b82f6; margin-top: 8px">
  createFileSystem() | createNetwork() | createThreading() | createGraphics()
</div>
</div>
<div style="display: flex; justify-content: center">
<div style="width: 2px; height: 20px; background: #94a3b8"></div>
</div>
<div style="display: flex; justify-content: center; gap: 12px; flex-wrap: wrap">
<div style="background: #dcfce7;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 120px; max-width: 160px">
<div style="font-weight: 600; color: #166534; font-size: 13px">POSIXFactory</div>
<div style="font-size: 10px; color: #15803d">Linux, macOS, BSD</div>
</div>
<div style="background: #e0e7ff;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 120px; max-width: 160px">
<div style="font-weight: 600; color: #3730a3; font-size: 13px">Win32Factory</div>
<div style="font-size: 10px; color: #4338ca">Windows desktop</div>
</div>
<div style="background: #fce7f3;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 120px; max-width: 160px">
<div style="font-weight: 600; color: #9d174d; font-size: 13px">WebFactory</div>
<div style="font-size: 10px; color: #be185d">Browser/WASM</div>
</div>
<div style="background: #fef9c3;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 120px; max-width: 160px">
<div style="font-weight: 600; color: #854d0e; font-size: 13px">EmbeddedFactory</div>
<div style="font-size: 10px; color: #a16207">RTOS, bare metal</div>
</div>
</div>
</div>
</div>
<h3 id="32-the-cross-cutting-concerns-problem">3.2 The Cross-Cutting Concerns Problem</h3>
<p>A subtle issue arises when products have <strong>cross-cutting dependencies</strong>:</p>
<pre><code class="language-python">    class PlatformFactory(ABC):
    @abstractmethod
    def create_file_system(self) -&gt; FileSystem: ...

    @abstractmethod
    def create_network(self) -&gt; Network: ...

    @abstractmethod
    def create_logger(self) -&gt; Logger: ...

    # Problem: Logger might need FileSystem for file logging
    # AND Network for remote logging. But these are created separately!

    class WindowsFactory(PlatformFactory):
    def create_logger(self) -&gt; Logger:
    # Option 1: Logger creates its own dependencies (breaks DI)
    # Option 2: Logger takes FileSystem and Network (circular!)
    # Option 3: Use a service locator (anti-pattern?)
    pass</code></pre>
<div style="background: #eff6ff;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #1e40af">Design Choice: Factory as Service Locator</h4>
<p style="margin: 0; color: #1e3a5f; font-size: 14px">
  One solution is to make the factory itself a parameter to product constructors. The logger receives the factory and lazily retrieves dependencies. This is controversial - it resembles Service Locator, which hides dependencies. The trade-off is explicit: cross-cutting concerns require either dependency hiding or complex initialization ordering.
</p>
</div>
<h3 id="33-conditional-compilation-vs-abstract-factory">3.3 Conditional Compilation vs. Abstract Factory</h3>
<p>Many cross-platform codebases use <strong>conditional compilation</strong> instead of Abstract Factory:</p>
<pre><code class="language-cpp">    // Conditional compilation approach
    #ifdef _WIN32
    #include &quot;windows_impl.h&quot;
    using FileSystem = WindowsFileSystem;
    #elif __APPLE__
    #include &quot;mac_impl.h&quot;
    using FileSystem = MacFileSystem;
    #else
    #include &quot;linux_impl.h&quot;
    using FileSystem = LinuxFileSystem;
    #endif</code></pre>
<p><strong>Trade-off analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Abstract Factory</th>
<th>Conditional Compilation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Runtime switching</td>
<td>Yes</td>
<td>No (compile-time only)</td>
</tr>
<tr>
<td>Binary size</td>
<td>Larger (all platforms)</td>
<td>Smaller (one platform)</td>
</tr>
<tr>
<td>Testing</td>
<td>Mock factory injection</td>
<td>Requires target platform</td>
</tr>
<tr>
<td>Complexity</td>
<td>Higher abstraction overhead</td>
<td>Lower, but scattered</td>
</tr>
<tr>
<td>Link-time dependencies</td>
<td>All platforms linked</td>
<td>Only active platform</td>
</tr>
</tbody>
</table>
<h3 id="34-cloud-provider-abstraction-real-world-case-study">3.4 Cloud Provider Abstraction (Real-World Case Study)</h3>
<pre><code class="language-python">    class CloudInfrastructureFactory(ABC):
    &quot;&quot;&quot;Abstract factory for multi-cloud deployments.&quot;&quot;&quot;

    @abstractmethod
    def create_compute(self) -&gt; ComputeService:
    &quot;&quot;&quot;Create VM/container service.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_storage(self) -&gt; StorageService:
    &quot;&quot;&quot;Create object storage service.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_database(self) -&gt; DatabaseService:
    &quot;&quot;&quot;Create managed database service.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_queue(self) -&gt; QueueService:
    &quot;&quot;&quot;Create message queue service.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_identity(self) -&gt; IdentityService:
    &quot;&quot;&quot;Create IAM/identity service.&quot;&quot;&quot;
    pass

    class AWSFactory(CloudInfrastructureFactory):
    def __init__(self, region: str, credentials: AWSCredentials):
    self.region = region
    self.credentials = credentials
    self._session = None  # Lazy initialization

    def create_compute(self) -&gt; ComputeService:
    return EC2Service(self._get_session())

    def create_storage(self) -&gt; StorageService:
    return S3Service(self._get_session())

    def create_database(self) -&gt; DatabaseService:
    return RDSService(self._get_session())

    def create_queue(self) -&gt; QueueService:
    return SQSService(self._get_session())

    def create_identity(self) -&gt; IdentityService:
    return IAMService(self._get_session())

    def _get_session(self):
    if self._session is None:
    self._session = boto3.Session(
    region_name=self.region,
    **self.credentials.to_dict()
    )
    return self._session

    class GCPFactory(CloudInfrastructureFactory):
    # Similar implementation for Google Cloud
    pass

    class AzureFactory(CloudInfrastructureFactory):
    # Similar implementation for Azure
    pass</code></pre>
<div style="background: #fef2f2;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #991b1b">Real-World Edge Case: Service Parity</h4>
<p style="margin: 0; color: #7f1d1d; font-size: 14px">
Cloud providers don't have perfect feature parity. AWS Lambda has different cold start characteristics than Azure Functions. S3 has eventual consistency properties that GCS doesn't. <strong>The abstraction leaks</strong>. Solutions: 1) Lowest common denominator API, 2) Provider-specific extension interfaces, 3) Feature flags in the abstract interface.
</p>
</div>
<h3 id="interview-questions-cross-platform-development-3-levels-deep">Interview Questions: Cross-Platform Development (3 Levels Deep)</h3>
<div style="background: #f8fafc;border-radius: 8px; padding: 20px; margin: 20px 0">
<p><strong>Level 1: &quot;How does Abstract Factory help with cross-platform development?&quot;</strong></p>
<blockquote>
<p>Abstract Factory creates a single abstraction point for platform differences. Application code depends only on abstract interfaces (FileSystem, Network, etc.), and a platform-specific factory provides concrete implementations. Switching platforms means changing only the factory instantiation, not the application logic.</p>
</blockquote>
<p><strong>Level 2: &quot;What happens when platforms have fundamentally different capabilities? How do you handle the 'leaky abstraction' problem?&quot;</strong></p>
<blockquote>
<p>Platform capability gaps create leaky abstractions. Solutions:</p>
<ol>
<li>
<p><strong>Lowest Common Denominator</strong>: Define the interface as the intersection of all platforms. Simple but limits functionality.</p>
</li>
<li>
<p><strong>Capability Query</strong>: Add <code>supports_feature(feature: str) -&gt; bool</code> to products. Application code checks before using advanced features.</p>
</li>
<li>
<p><strong>Optional Interfaces</strong>: Use interface segregation - <code>StorageService</code> vs <code>VersionedStorageService</code>. Only implement advanced interfaces on capable platforms.</p>
</li>
<li>
<p><strong>Adapter + Emulation</strong>: Emulate missing features. Example: Emulate S3's eventual consistency model on GCS by adding artificial delays in the adapter.</p>
</li>
<li>
<p><strong>Fail-Fast with Clear Error</strong>: Throw <code>NotSupportedOnPlatform</code> with guidance on alternatives.</p>
</li>
</ol>
<p>The choice depends on whether the feature is essential or optional. Essential features need emulation; optional ones need capability queries.</p>
</blockquote>
<p><strong>Level 3: &quot;Design a multi-cloud factory system that handles: (a) partial failures during multi-service operations, (b) service version incompatibilities, and (c) live cloud provider migration without downtime.&quot;</strong></p>
<blockquote>
<p>This requires combining Abstract Factory with several other patterns:</p>
<p><strong>(a) Partial Failures - <a href="/topics/system-design/saga">[Saga Pattern]</a></strong>:</p>
<pre><code class="language-python">class CloudTransactionFactory(CloudFactory):
    def create_provisioning_saga(self) -&gt; ProvisioningSaga:
        return ProvisioningSaga(
            steps=[
                self.create_compute,  # Step 1
                self.create_storage,  # Step 2
                self.create_database, # Step 3
            ],
            compensations=[
                self._destroy_compute,
                self._destroy_storage,
                self._destroy_database,
            ]
        )
</code></pre>
<p><strong>(b) Version Incompatibilities - Factory Versioning</strong>:</p>
<pre><code class="language-python">class CloudFactoryRegistry:
    def get_factory(self, provider: str, api_version: str) -&gt; CloudFactory:
        # Returns factory compatible with specific API version
        # Internally maps to versioned implementations
        key = f&quot;{provider}:{api_version}&quot;
        return self._factories[key]
</code></pre>
<p><strong>(c) Live Migration - <a href="/topics/system-design/blue-green">[Blue-Green Deployment]</a> + Dual-Write</strong>:</p>
<pre><code class="language-python">class MigratingFactory(CloudFactory):
    def __init__(self, source: CloudFactory, target: CloudFactory,
                 migration_state: MigrationState):
        self.source = source
        self.target = target
        self.state = migration_state

    def create_storage(self) -&gt; StorageService:
        if self.state.phase == 'dual_write':
            return DualWriteStorage(
                self.source.create_storage(),
                self.target.create_storage()
            )
        elif self.state.phase == 'target_primary':
            return self.target.create_storage()
        else:
            return self.source.create_storage()
</code></pre>
<p><strong>Trade-offs</strong>: Migration adds latency (dual writes), complexity (state machines), and cost (running two systems). The benefit is zero-downtime migration and ability to rollback.</p>
</blockquote>
</div>
<hr />
<h2 id="section-4-factory-method-vs-abstract-factory---critical-distinctions">Section 4: Factory Method vs Abstract Factory - Critical Distinctions</h2>
<h3 id="41-structural-comparison">4.1 Structural Comparison</h3>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #334155; margin: 0 0 20px 0; text-align: center">Factory Method vs Abstract Factory</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px">
<div style="background: #dbeafe;border-radius: 10px; padding: 16px">
<h5 style="color: #1e40af; margin: 0 0 12px 0; text-align: center">Factory Method</h5>
<div style="font-size: 13px; color: #1e3a5f">
<div style="margin-bottom: 8px"><strong>Structure:</strong> Single method in a class</div>
<div style="margin-bottom: 8px"><strong>Creates:</strong> One product type</div>
<div style="margin-bottom: 8px"><strong>Extension:</strong> Subclass overrides method</div>
<div style="margin-bottom: 8px"><strong>Relationship:</strong> IS-A (inheritance)</div>
<div style="background: #bfdbfe; padding: 8px; border-radius: 4px; margin-top: 12px">
<code style="font-size: 11px">
  class Dialog:<br/>
  &nbsp;&nbsp;def create_button(self) -> Button:<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;return DefaultButton()
</code>
</div>
</div>
</div>
<div style="background: #dcfce7;border-radius: 10px; padding: 16px">
<h5 style="color: #166534; margin: 0 0 12px 0; text-align: center">Abstract Factory</h5>
<div style="font-size: 13px; color: #14532d">
<div style="margin-bottom: 8px"><strong>Structure:</strong> Interface with multiple methods</div>
<div style="margin-bottom: 8px"><strong>Creates:</strong> Family of related products</div>
<div style="margin-bottom: 8px"><strong>Extension:</strong> New factory class</div>
<div style="margin-bottom: 8px"><strong>Relationship:</strong> HAS-A (composition)</div>
<div style="background: #bbf7d0; padding: 8px; border-radius: 4px; margin-top: 12px">
<code style="font-size: 11px">
  class WidgetFactory:<br/>
  &nbsp;&nbsp;def create_button(self) -> Button<br/>
  &nbsp;&nbsp;def create_scroll(self) -> Scrollbar<br/>
  &nbsp;&nbsp;def create_menu(self) -> Menu
</code>
</div>
</div>
</div>
</div>
</div>
<h3 id="42-when-to-use-which">4.2 When to Use Which</h3>
<div style="background: #fefce8;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #a16207">Decision Framework</h4>
<div style="color: #713f12; font-size: 14px">
<p><strong>Use Factory Method when:</strong></p>
<ul style="margin: 8px 0">
<li>You need to create ONE type of object with variations</li>
<li>Subclasses should decide which class to instantiate</li>
<li>You want to defer instantiation to derived classes</li>
</ul>
<p><strong>Use Abstract Factory when:</strong></p>
<ul style="margin: 8px 0">
<li>You need to create MULTIPLE related objects that must work together</li>
<li>System should be independent of how products are created</li>
<li>You need to enforce family constraints (no mixing)</li>
</ul>
</div>
</div>
<h3 id="43-the-composition-relationship">4.3 The Composition Relationship</h3>
<p>Abstract Factory often <strong>contains</strong> Factory Methods:</p>
<pre><code class="language-python">    class WidgetFactory(ABC):
    &quot;&quot;&quot;Abstract Factory for UI widgets.&quot;&quot;&quot;

    @abstractmethod
    def create_button(self) -&gt; Button:
    &quot;&quot;&quot;Factory Method for buttons.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_scrollbar(self) -&gt; Scrollbar:
    &quot;&quot;&quot;Factory Method for scrollbars.&quot;&quot;&quot;
    pass

    # Each abstract method IS a Factory Method
    # The collection of related Factory Methods IS an Abstract Factory</code></pre>
<h3 id="44-evolution-path">4.4 Evolution Path</h3>
<p>Systems often evolve from Factory Method to Abstract Factory:</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #334155; margin: 0 0 16px 0; text-align: center">Pattern Evolution</h4>
<div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px">
<div style="background: #f1f5f9;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 100px">
<div style="font-weight: 600; color: #475569; font-size: 12px">Stage 1</div>
<div style="font-size: 11px; color: #64748b">Constructor</div>
<div style="font-family: monospace; font-size: 10px; margin-top: 4px">new Button()</div>
</div>
<div style="color: #94a3b8; font-size: 20px">-></div>
<div style="background: #dbeafe;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 100px">
<div style="font-weight: 600; color: #1e40af; font-size: 12px">Stage 2</div>
<div style="font-size: 11px; color: #3b82f6">Factory Method</div>
<div style="font-family: monospace; font-size: 10px; margin-top: 4px">createButton()</div>
</div>
<div style="color: #94a3b8; font-size: 20px">-></div>
<div style="background: #dcfce7;border-radius: 8px; padding: 12px 16px; text-align: center; flex: 1; min-width: 100px">
<div style="font-weight: 600; color: #166534; font-size: 12px">Stage 3</div>
<div style="font-size: 11px; color: #15803d">Abstract Factory</div>
<div style="font-family: monospace; font-size: 10px; margin-top: 4px">factory.createX()</div>
</div>
</div>
<div style="margin-top: 16px; padding-top: 12px;font-size: 12px; color: #64748b; text-align: center">
  Evolve when: single product becomes family, OR platform variations emerge
</div>
</div>
<h3 id="45-anti-pattern-premature-abstract-factory">4.5 Anti-Pattern: Premature Abstract Factory</h3>
<div style="background: #fef2f2;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #991b1b">Common Mistake: Over-Engineering</h4>
<p style="margin: 0; color: #7f1d1d; font-size: 14px">
Creating an Abstract Factory when you only have one product family and no plans for more is over-engineering. The indirection adds complexity without benefit. <strong>YAGNI</strong> (You Aren't Gonna Need It) applies. Start with direct construction or Factory Method; refactor to Abstract Factory when the second family appears.
</p>
</div>
<h3 id="interview-questions-factory-method-vs-abstract-factory-3-levels-deep">Interview Questions: Factory Method vs Abstract Factory (3 Levels Deep)</h3>
<div style="background: #f8fafc;border-radius: 8px; padding: 20px; margin: 20px 0">
<p><strong>Level 1: &quot;What is the key difference between Factory Method and Abstract Factory?&quot;</strong></p>
<blockquote>
<p>Factory Method creates ONE product through inheritance (subclass overrides a creation method). Abstract Factory creates a FAMILY of related products through composition (client holds a factory object). Factory Method is about deferring instantiation to subclasses; Abstract Factory is about enforcing family consistency.</p>
</blockquote>
<p><strong>Level 2: &quot;Can you have an Abstract Factory that uses only one product? Would that be a valid use of the pattern?&quot;</strong></p>
<blockquote>
<p>Technically yes, but it's likely a design smell. If there's only one product, you lose the main benefit: family consistency guarantees. However, there are valid cases:</p>
<ol>
<li><strong>Future-proofing</strong>: You know more products are coming</li>
<li><strong>Testing</strong>: The factory interface enables mock injection even for one product</li>
<li><strong>Configuration</strong>: Factory encapsulates complex construction parameters</li>
</ol>
<p>But generally, single-product &quot;Abstract Factories&quot; should be Factory Methods. The pattern's essence is <em>families</em> - without multiple related products, the abstraction isn't pulling its weight.</p>
</blockquote>
<p><strong>Level 3: &quot;Design a system that needs to switch between Factory Method and Abstract Factory at runtime based on configuration. What are the implications for your type system and client code?&quot;</strong></p>
<blockquote>
<p>This is a fascinating edge case requiring careful design:</p>
<pre><code class="language-python">class ProductionStrategy(ABC):
    @abstractmethod
    def get_button(self, context: Context) -&gt; Button:
        &quot;&quot;&quot;May create new or return cached, family-aware or not.&quot;&quot;&quot;
        pass

class SimpleFactoryStrategy(ProductionStrategy):
    &quot;&quot;&quot;Uses Factory Method - no family constraints.&quot;&quot;&quot;
    def get_button(self, context: Context) -&gt; Button:
        return context.create_button()  # Factory Method call

class FamilyFactoryStrategy(ProductionStrategy):
    &quot;&quot;&quot;Uses Abstract Factory - enforces family.&quot;&quot;&quot;
    def __init__(self, factory: WidgetFactory):
        self.factory = factory

    def get_button(self, context: Context) -&gt; Button:
        return self.factory.create_button()  # Abstract Factory call

class Application:
    def __init__(self, strategy: ProductionStrategy):
        self.strategy = strategy  # Injected based on config
</code></pre>
<p><strong>Implications</strong>:</p>
<ol>
<li>
<p><strong>Type System</strong>: Both strategies must return the same abstract type (<code>Button</code>). The difference is in guarantees, not types.</p>
</li>
<li>
<p><strong>Family Safety</strong>: When using <code>SimpleFactoryStrategy</code>, family mixing is possible. Client code can't assume safety.</p>
</li>
<li>
<p><strong>Capability Query</strong>: Consider adding <code>strategy.guarantees_family_consistency() -&gt; bool</code> so clients can adapt.</p>
</li>
<li>
<p><strong>Documentation</strong>: The contract is behavioral, not structural. Must be clearly documented.</p>
</li>
<li>
<p><strong>Testing</strong>: Each strategy needs separate test suites - one verifying family constraints, one verifying single-product flexibility.</p>
</li>
</ol>
<p>This pattern is useful in frameworks that serve both simple use cases (factory method sufficient) and complex multi-platform cases (abstract factory needed).</p>
</blockquote>
</div>
<hr />
<h2 id="section-5-implementation-deep-dive">Section 5: Implementation Deep Dive</h2>
<h3 id="51-python-implementation-database-driver-factory">5.1 Python Implementation: Database Driver Factory</h3>
<pre><code class="language-python">    from abc import ABC, abstractmethod
    from typing import TypeVar, Generic, Any, Dict, List, Optional
    from dataclasses import dataclass
    from contextlib import contextmanager
    import threading

    # Type variable for family identification (phantom type technique)
    F = TypeVar('F', bound='FamilyMarker')

    class FamilyMarker:
    &quot;&quot;&quot;Base class for phantom type markers.&quot;&quot;&quot;
    pass

    class PostgresFamily(FamilyMarker):
    &quot;&quot;&quot;Marker for PostgreSQL product family.&quot;&quot;&quot;
    pass

    class MySQLFamily(FamilyMarker):
    &quot;&quot;&quot;Marker for MySQL product family.&quot;&quot;&quot;
    pass

    class SQLiteFamily(FamilyMarker):
    &quot;&quot;&quot;Marker for SQLite product family.&quot;&quot;&quot;
    pass

    # ============================================
    # ABSTRACT PRODUCTS
    # ============================================

    @dataclass
    class QueryResult:
    &quot;&quot;&quot;Unified query result structure.&quot;&quot;&quot;
    columns: List[str]
    rows: List[tuple]
    affected_rows: int
    last_insert_id: Optional[int]

    class Connection(ABC, Generic[F]):
    &quot;&quot;&quot;Abstract connection product.&quot;&quot;&quot;

    @abstractmethod
    def execute(self, sql: str, params: tuple = ()) -&gt; QueryResult:
    &quot;&quot;&quot;Execute SQL and return results.&quot;&quot;&quot;
    pass

    @abstractmethod
    def begin_transaction(self) -&gt; 'Transaction[F]':
    &quot;&quot;&quot;Start a new transaction.&quot;&quot;&quot;
    pass

    @abstractmethod
    def close(self) -&gt; None:
    &quot;&quot;&quot;Close the connection.&quot;&quot;&quot;
    pass

    @abstractmethod
    def is_alive(self) -&gt; bool:
    &quot;&quot;&quot;Check if connection is still valid.&quot;&quot;&quot;
    pass

    class Transaction(ABC, Generic[F]):
    &quot;&quot;&quot;Abstract transaction product.&quot;&quot;&quot;

    @abstractmethod
    def commit(self) -&gt; None:
    &quot;&quot;&quot;Commit the transaction.&quot;&quot;&quot;
    pass

    @abstractmethod
    def rollback(self) -&gt; None:
    &quot;&quot;&quot;Rollback the transaction.&quot;&quot;&quot;
    pass

    @abstractmethod
    def execute(self, sql: str, params: tuple = ()) -&gt; QueryResult:
    &quot;&quot;&quot;Execute within transaction.&quot;&quot;&quot;
    pass

    @abstractmethod
    def savepoint(self, name: str) -&gt; 'Savepoint[F]':
    &quot;&quot;&quot;Create a savepoint within transaction.&quot;&quot;&quot;
    pass

    class Savepoint(ABC, Generic[F]):
    &quot;&quot;&quot;Abstract savepoint product - demonstrates nested family products.&quot;&quot;&quot;

    @abstractmethod
    def release(self) -&gt; None:
    &quot;&quot;&quot;Release the savepoint.&quot;&quot;&quot;
    pass

    @abstractmethod
    def rollback_to(self) -&gt; None:
    &quot;&quot;&quot;Rollback to this savepoint.&quot;&quot;&quot;
    pass

    class ConnectionPool(ABC, Generic[F]):
    &quot;&quot;&quot;Abstract connection pool product.&quot;&quot;&quot;

    @abstractmethod
    def acquire(self) -&gt; Connection[F]:
    &quot;&quot;&quot;Acquire a connection from the pool.&quot;&quot;&quot;
    pass

    @abstractmethod
    def release(self, conn: Connection[F]) -&gt; None:
    &quot;&quot;&quot;Release a connection back to the pool.&quot;&quot;&quot;
    pass

    @abstractmethod
    def close_all(self) -&gt; None:
    &quot;&quot;&quot;Close all connections in the pool.&quot;&quot;&quot;
    pass

    @contextmanager
    def connection(self):
    &quot;&quot;&quot;Context manager for automatic release.&quot;&quot;&quot;
    conn = self.acquire()
    try:
    yield conn
    finally:
    self.release(conn)

    class QueryBuilder(ABC, Generic[F]):
    &quot;&quot;&quot;Abstract query builder - handles dialect differences.&quot;&quot;&quot;

    @abstractmethod
    def select(self, *columns: str) -&gt; 'QueryBuilder[F]':
    pass

    @abstractmethod
    def from_table(self, table: str) -&gt; 'QueryBuilder[F]':
    pass

    @abstractmethod
    def where(self, condition: str, *params) -&gt; 'QueryBuilder[F]':
    pass

    @abstractmethod
    def limit(self, n: int) -&gt; 'QueryBuilder[F]':
    pass

    @abstractmethod
    def build(self) -&gt; tuple[str, tuple]:
    &quot;&quot;&quot;Return (sql, params) tuple.&quot;&quot;&quot;
    pass

    # ============================================
    # POSTGRESQL FAMILY
    # ============================================

    class PostgresConnection(Connection[PostgresFamily]):
    &quot;&quot;&quot;PostgreSQL connection implementation.&quot;&quot;&quot;

    def __init__(self, host: str, port: int, database: str,
    user: str, password: str):
    self.host = host
    self.port = port
    self.database = database
    self._conn = None  # Would be psycopg2 connection
    self._closed = False
    # Simulate connection
    print(f&quot;PostgreSQL: Connected to {host}:{port}/{database}&quot;)

    def execute(self, sql: str, params: tuple = ()) -&gt; QueryResult:
    if self._closed:
    raise RuntimeError(&quot;Connection is closed&quot;)
    # PostgreSQL uses $1, $2 for placeholders
    print(f&quot;PostgreSQL executing: {sql} with {params}&quot;)
    return QueryResult(columns=[], rows=[], affected_rows=0,
    last_insert_id=None)

    def begin_transaction(self) -&gt; 'PostgresTransaction':
    return PostgresTransaction(self)

    def close(self) -&gt; None:
    self._closed = True
    print(&quot;PostgreSQL: Connection closed&quot;)

    def is_alive(self) -&gt; bool:
    return not self._closed

    class PostgresTransaction(Transaction[PostgresFamily]):
    &quot;&quot;&quot;PostgreSQL transaction with MVCC semantics.&quot;&quot;&quot;

    def __init__(self, conn: PostgresConnection):
    self.conn = conn
    self._active = True
    # PostgreSQL transaction isolation
    conn.execute(&quot;BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED&quot;)

    def commit(self) -&gt; None:
    if not self._active:
    raise RuntimeError(&quot;Transaction already completed&quot;)
    self.conn.execute(&quot;COMMIT&quot;)
    self._active = False

    def rollback(self) -&gt; None:
    if not self._active:
    raise RuntimeError(&quot;Transaction already completed&quot;)
    self.conn.execute(&quot;ROLLBACK&quot;)
    self._active = False

    def execute(self, sql: str, params: tuple = ()) -&gt; QueryResult:
    if not self._active:
    raise RuntimeError(&quot;Transaction not active&quot;)
    return self.conn.execute(sql, params)

    def savepoint(self, name: str) -&gt; 'PostgresSavepoint':
    self.conn.execute(f&quot;SAVEPOINT {name}&quot;)
    return PostgresSavepoint(self, name)

    class PostgresSavepoint(Savepoint[PostgresFamily]):
    &quot;&quot;&quot;PostgreSQL savepoint implementation.&quot;&quot;&quot;

    def __init__(self, tx: PostgresTransaction, name: str):
    self.tx = tx
    self.name = name

    def release(self) -&gt; None:
    self.tx.execute(f&quot;RELEASE SAVEPOINT {self.name}&quot;)

    def rollback_to(self) -&gt; None:
    self.tx.execute(f&quot;ROLLBACK TO SAVEPOINT {self.name}&quot;)

    class PostgresConnectionPool(ConnectionPool[PostgresFamily]):
    &quot;&quot;&quot;PostgreSQL connection pool with PgBouncer-like semantics.&quot;&quot;&quot;

    def __init__(self, factory: 'PostgresFactory',
    min_size: int = 5, max_size: int = 20):
    self.factory = factory
    self.min_size = min_size
    self.max_size = max_size
    self._available: List[PostgresConnection] = []
    self._in_use: List[PostgresConnection] = []
    self._lock = threading.Lock()

    # Pre-populate minimum connections
    for _ in range(min_size):
    self._available.append(self.factory.create_connection())

    def acquire(self) -&gt; PostgresConnection:
    with self._lock:
    # Try to reuse existing connection
    while self._available:
    conn = self._available.pop()
    if conn.is_alive():
    self._in_use.append(conn)
    return conn

    # Create new if under max
    if len(self._in_use) &lt; self.max_size:
    conn = self.factory.create_connection()
    self._in_use.append(conn)
    return conn

    raise RuntimeError(&quot;Connection pool exhausted&quot;)

    def release(self, conn: PostgresConnection) -&gt; None:
    with self._lock:
    if conn in self._in_use:
    self._in_use.remove(conn)
    if conn.is_alive():
    self._available.append(conn)
    else:
    conn.close()

    def close_all(self) -&gt; None:
    with self._lock:
    for conn in self._available + self._in_use:
    conn.close()
    self._available.clear()
    self._in_use.clear()

    class PostgresQueryBuilder(QueryBuilder[PostgresFamily]):
    &quot;&quot;&quot;PostgreSQL query builder with dialect-specific features.&quot;&quot;&quot;

    def __init__(self):
    self._columns: List[str] = []
    self._table: str = &quot;&quot;
    self._conditions: List[tuple[str, tuple]] = []
    self._limit: Optional[int] = None
    self._param_count = 0

    def select(self, *columns: str) -&gt; 'PostgresQueryBuilder':
    self._columns.extend(columns)
    return self

    def from_table(self, table: str) -&gt; 'PostgresQueryBuilder':
    self._table = table
    return self

    def where(self, condition: str, *params) -&gt; 'PostgresQueryBuilder':
    # Convert ? placeholders to PostgreSQL $N style
    converted = condition
    for i, _ in enumerate(params):
    self._param_count += 1
    converted = converted.replace(&quot;?&quot;, f&quot;${self._param_count}&quot;, 1)
    self._conditions.append((converted, params))
    return self

    def limit(self, n: int) -&gt; 'PostgresQueryBuilder':
    self._limit = n
    return self

    def build(self) -&gt; tuple[str, tuple]:
    cols = &quot;, &quot;.join(self._columns) if self._columns else &quot;*&quot;
    sql = f&quot;SELECT {cols} FROM {self._table}&quot;

    params: List[Any] = []
    if self._conditions:
    where_clauses = []
    for cond, cond_params in self._conditions:
    where_clauses.append(cond)
    params.extend(cond_params)
    sql += &quot; WHERE &quot; + &quot; AND &quot;.join(where_clauses)

    if self._limit is not None:
    sql += f&quot; LIMIT {self._limit}&quot;

    return sql, tuple(params)

    # ============================================
    # MYSQL FAMILY (Abbreviated - similar structure)
    # ============================================

    class MySQLConnection(Connection[MySQLFamily]):
    &quot;&quot;&quot;MySQL connection with MySQL-specific features.&quot;&quot;&quot;

    def __init__(self, host: str, port: int, database: str,
    user: str, password: str):
    self.host = host
    print(f&quot;MySQL: Connected to {host}:{port}/{database}&quot;)
    self._closed = False

    def execute(self, sql: str, params: tuple = ()) -&gt; QueryResult:
    # MySQL uses %s for placeholders
    print(f&quot;MySQL executing: {sql} with {params}&quot;)
    return QueryResult(columns=[], rows=[], affected_rows=0,
    last_insert_id=None)

    def begin_transaction(self) -&gt; 'MySQLTransaction':
    return MySQLTransaction(self)

    def close(self) -&gt; None:
    self._closed = True

    def is_alive(self) -&gt; bool:
    return not self._closed

    class MySQLTransaction(Transaction[MySQLFamily]):
    def __init__(self, conn: MySQLConnection):
    self.conn = conn
    conn.execute(&quot;START TRANSACTION&quot;)
    self._active = True

    def commit(self) -&gt; None:
    self.conn.execute(&quot;COMMIT&quot;)
    self._active = False

    def rollback(self) -&gt; None:
    self.conn.execute(&quot;ROLLBACK&quot;)
    self._active = False

    def execute(self, sql: str, params: tuple = ()) -&gt; QueryResult:
    return self.conn.execute(sql, params)

    def savepoint(self, name: str) -&gt; 'MySQLSavepoint':
    self.conn.execute(f&quot;SAVEPOINT {name}&quot;)
    return MySQLSavepoint(self, name)

    class MySQLSavepoint(Savepoint[MySQLFamily]):
    def __init__(self, tx: MySQLTransaction, name: str):
    self.tx = tx
    self.name = name

    def release(self) -&gt; None:
    self.tx.execute(f&quot;RELEASE SAVEPOINT {self.name}&quot;)

    def rollback_to(self) -&gt; None:
    self.tx.execute(f&quot;ROLLBACK TO SAVEPOINT {self.name}&quot;)

    class MySQLQueryBuilder(QueryBuilder[MySQLFamily]):
    &quot;&quot;&quot;MySQL query builder with backtick quoting.&quot;&quot;&quot;

    def __init__(self):
    self._columns: List[str] = []
    self._table: str = &quot;&quot;
    self._conditions: List[tuple[str, tuple]] = []
    self._limit: Optional[int] = None

    def select(self, *columns: str) -&gt; 'MySQLQueryBuilder':
    # MySQL uses backticks for identifiers
    self._columns.extend(f&quot;`{c}`&quot; for c in columns)
    return self

    def from_table(self, table: str) -&gt; 'MySQLQueryBuilder':
    self._table = f&quot;`{table}`&quot;
    return self

    def where(self, condition: str, *params) -&gt; 'MySQLQueryBuilder':
    self._conditions.append((condition, params))
    return self

    def limit(self, n: int) -&gt; 'MySQLQueryBuilder':
    self._limit = n
    return self

    def build(self) -&gt; tuple[str, tuple]:
    cols = &quot;, &quot;.join(self._columns) if self._columns else &quot;*&quot;
    sql = f&quot;SELECT {cols} FROM {self._table}&quot;

    params: List[Any] = []
    if self._conditions:
    where_clauses = []
    for cond, cond_params in self._conditions:
    where_clauses.append(cond)
    params.extend(cond_params)
    sql += &quot; WHERE &quot; + &quot; AND &quot;.join(where_clauses)

    if self._limit is not None:
    sql += f&quot; LIMIT {self._limit}&quot;

    return sql, tuple(params)

    # ============================================
    # ABSTRACT FACTORY
    # ============================================

    class DatabaseFactory(ABC, Generic[F]):
    &quot;&quot;&quot;Abstract factory for database product families.&quot;&quot;&quot;

    @abstractmethod
    def create_connection(self) -&gt; Connection[F]:
    &quot;&quot;&quot;Create a new database connection.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_pool(self, min_size: int = 5,
    max_size: int = 20) -&gt; ConnectionPool[F]:
    &quot;&quot;&quot;Create a connection pool.&quot;&quot;&quot;
    pass

    @abstractmethod
    def create_query_builder(self) -&gt; QueryBuilder[F]:
    &quot;&quot;&quot;Create a query builder for this database's dialect.&quot;&quot;&quot;
    pass

    @abstractmethod
    def get_dialect_name(self) -&gt; str:
    &quot;&quot;&quot;Return the SQL dialect name.&quot;&quot;&quot;
    pass

    # ============================================
    # CONCRETE FACTORIES
    # ============================================

    class PostgresFactory(DatabaseFactory[PostgresFamily]):
    &quot;&quot;&quot;Factory for PostgreSQL database products.&quot;&quot;&quot;

    def __init__(self, host: str, port: int, database: str,
    user: str, password: str):
    self.host = host
    self.port = port
    self.database = database
    self.user = user
    self.password = password

    def create_connection(self) -&gt; PostgresConnection:
    return PostgresConnection(
    self.host, self.port, self.database,
    self.user, self.password
    )

    def create_pool(self, min_size: int = 5,
    max_size: int = 20) -&gt; PostgresConnectionPool:
    return PostgresConnectionPool(self, min_size, max_size)

    def create_query_builder(self) -&gt; PostgresQueryBuilder:
    return PostgresQueryBuilder()

    def get_dialect_name(self) -&gt; str:
    return &quot;PostgreSQL&quot;

    class MySQLFactory(DatabaseFactory[MySQLFamily]):
    &quot;&quot;&quot;Factory for MySQL database products.&quot;&quot;&quot;

    def __init__(self, host: str, port: int, database: str,
    user: str, password: str):
    self.host = host
    self.port = port
    self.database = database
    self.user = user
    self.password = password

    def create_connection(self) -&gt; MySQLConnection:
    return MySQLConnection(
    self.host, self.port, self.database,
    self.user, self.password
    )

    def create_pool(self, min_size: int = 5,
    max_size: int = 20) -&gt; ConnectionPool[MySQLFamily]:
    # Simplified - would create MySQLConnectionPool
    raise NotImplementedError(&quot;MySQL pool not shown for brevity&quot;)

    def create_query_builder(self) -&gt; MySQLQueryBuilder:
    return MySQLQueryBuilder()

    def get_dialect_name(self) -&gt; str:
    return &quot;MySQL&quot;

    # ============================================
    # CLIENT CODE
    # ============================================

    class UserRepository(Generic[F]):
    &quot;&quot;&quot;
    Repository that works with any database family.
    Note the Generic[F] - this propagates family type safety.
    &quot;&quot;&quot;

    def __init__(self, factory: DatabaseFactory[F]):
    self.factory = factory
    self.pool = factory.create_pool(min_size=2, max_size=10)

    def find_by_id(self, user_id: int) -&gt; Optional[Dict[str, Any]]:
    &quot;&quot;&quot;Find user by ID using the appropriate dialect.&quot;&quot;&quot;
    qb = self.factory.create_query_builder()
    sql, params = (qb
    .select(&quot;id&quot;, &quot;name&quot;, &quot;email&quot;)
    .from_table(&quot;users&quot;)
    .where(&quot;id = ?&quot;, user_id)
    .limit(1)
    .build())

    with self.pool.connection() as conn:
    result = conn.execute(sql, params)
    if result.rows:
    return dict(zip(result.columns, result.rows[0]))
    return None

    def create_user(self, name: str, email: str) -&gt; int:
    &quot;&quot;&quot;Create user within a transaction.&quot;&quot;&quot;
    with self.pool.connection() as conn:
    tx = conn.begin_transaction()
    try:
    # Transaction operations are guaranteed to be
    # from the same family as the connection
    result = tx.execute(
    &quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;,
    (name, email)
    )
    tx.commit()
    return result.last_insert_id or 0
    except Exception:
    tx.rollback()
    raise

    # ============================================
    # USAGE EXAMPLE
    # ============================================

    def main():
    # Configuration would come from environment
    db_type = &quot;postgresql&quot;

    # Factory selection - the ONLY place where concrete types appear
    if db_type == &quot;postgresql&quot;:
    factory: DatabaseFactory = PostgresFactory(
    host=&quot;localhost&quot;,
    port=5432,
    database=&quot;myapp&quot;,
    user=&quot;admin&quot;,
    password=&quot;secret&quot;
    )
    elif db_type == &quot;mysql&quot;:
    factory = MySQLFactory(
    host=&quot;localhost&quot;,
    port=3306,
    database=&quot;myapp&quot;,
    user=&quot;admin&quot;,
    password=&quot;secret&quot;
    )
    else:
    raise ValueError(f&quot;Unknown database type: {db_type}&quot;)

    # Client code is database-agnostic
    repo = UserRepository(factory)

    # These operations work identically regardless of database
    user = repo.find_by_id(1)
    new_id = repo.create_user(&quot;Alice&quot;, &quot;alice@example.com&quot;)

    print(f&quot;Using dialect: {factory.get_dialect_name()}&quot;)
    print(f&quot;Found user: {user}&quot;)
    print(f&quot;Created user with ID: {new_id}&quot;)

    if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<h3 id="52-go-implementation-cross-platform-file-system">5.2 Go Implementation: Cross-Platform File System</h3>
<pre><code class="language-go">    package main

    import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;os&quot;
    &quot;path/filepath&quot;
    &quot;sync&quot;
    &quot;time&quot;
    )

    // ============================================
    // ABSTRACT PRODUCTS
    // ============================================

    // FileInfo represents file metadata across platforms
    type FileInfo interface {
    Name() string
    Size() int64
    Mode() uint32
    ModTime() time.Time
    IsDir() bool
    // Platform-specific metadata access
    PlatformAttrs() map[string]interface{}
    }

    // File represents an open file handle
    type File interface {
    io.Reader
    io.Writer
    io.Closer
    io.Seeker
    Sync() error
    Stat() (FileInfo, error)
    // Platform-specific operations
    Lock() error
    Unlock() error
    }

    // Directory represents a directory handle
    type Directory interface {
    List() ([]FileInfo, error)
    Create(name string) error
    Remove(name string) error
    Close() error
    }

    // FileWatcher watches for file system changes
    type FileWatcher interface {
    Watch(path string, callback func(event WatchEvent)) error
    Unwatch(path string) error
    Close() error
    }

    // WatchEvent represents a file system event
    type WatchEvent struct {
    Path      string
    Type      WatchEventType
    Timestamp time.Time
    }

    type WatchEventType int

    const (
    Created WatchEventType = iota
    Modified
    Deleted
    Renamed
    )

    // ============================================
    // POSIX FAMILY (Linux, macOS, BSD)
    // ============================================

    type POSIXFileInfo struct {
    name    string
    size    int64
    mode    uint32
    modTime time.Time
    isDir   bool
    uid     uint32
    gid     uint32
    inode   uint64
    }

    func (f *POSIXFileInfo) Name() string                       { return f.name }
    func (f *POSIXFileInfo) Size() int64                        { return f.size }
    func (f *POSIXFileInfo) Mode() uint32                       { return f.mode }
    func (f *POSIXFileInfo) ModTime() time.Time                 { return f.modTime }
    func (f *POSIXFileInfo) IsDir() bool                        { return f.isDir }
    func (f *POSIXFileInfo) PlatformAttrs() map[string]interface{} {
    return map[string]interface{}{
    &quot;uid&quot;:   f.uid,
    &quot;gid&quot;:   f.gid,
    &quot;inode&quot;: f.inode,
    }
    }

    type POSIXFile struct {
    file   *os.File
    path   string
    locked bool
    mu     sync.Mutex
    }

    func (f *POSIXFile) Read(p []byte) (int, error)  { return f.file.Read(p) }
    func (f *POSIXFile) Write(p []byte) (int, error) { return f.file.Write(p) }
    func (f *POSIXFile) Close() error                { return f.file.Close() }
    func (f *POSIXFile) Sync() error                 { return f.file.Sync() }

    func (f *POSIXFile) Seek(offset int64, whence int) (int64, error) {
    return f.file.Seek(offset, whence)
    }

    func (f *POSIXFile) Stat() (FileInfo, error) {
    info, err := f.file.Stat()
    if err != nil {
    return nil, err
    }
    return &amp;POSIXFileInfo{
    name:    info.Name(),
    size:    info.Size(),
    mode:    uint32(info.Mode()),
    modTime: info.ModTime(),
    isDir:   info.IsDir(),
    // In real impl, would extract uid/gid/inode from syscall.Stat_t
    }, nil
    }

    func (f *POSIXFile) Lock() error {
    f.mu.Lock()
    defer f.mu.Unlock()
    // In real implementation: syscall.Flock(f.file.Fd(), syscall.LOCK_EX)
    fmt.Printf(&quot;POSIX: Acquired exclusive lock on %s via flock()\n&quot;, f.path)
    f.locked = true
    return nil
    }

    func (f *POSIXFile) Unlock() error {
    f.mu.Lock()
    defer f.mu.Unlock()
    // In real implementation: syscall.Flock(f.file.Fd(), syscall.LOCK_UN)
    fmt.Printf(&quot;POSIX: Released lock on %s\n&quot;, f.path)
    f.locked = false
    return nil
    }

    type POSIXDirectory struct {
    path string
    }

    func (d *POSIXDirectory) List() ([]FileInfo, error) {
    entries, err := os.ReadDir(d.path)
    if err != nil {
    return nil, err
    }

    infos := make([]FileInfo, 0, len(entries))
    for _, entry := range entries {
    info, _ := entry.Info()
    infos = append(infos, &amp;POSIXFileInfo{
    name:    info.Name(),
    size:    info.Size(),
    mode:    uint32(info.Mode()),
    modTime: info.ModTime(),
    isDir:   info.IsDir(),
    })
    }
    return infos, nil
    }

    func (d *POSIXDirectory) Create(name string) error {
    return os.Mkdir(filepath.Join(d.path, name), 0755)
    }

    func (d *POSIXDirectory) Remove(name string) error {
    return os.Remove(filepath.Join(d.path, name))
    }

    func (d *POSIXDirectory) Close() error { return nil }

    type POSIXFileWatcher struct {
    // In real implementation: uses inotify (Linux) or kqueue (BSD/macOS)
    watches map[string]func(WatchEvent)
    mu      sync.RWMutex
    }

    func NewPOSIXFileWatcher() *POSIXFileWatcher {
    return &amp;POSIXFileWatcher{
    watches: make(map[string]func(WatchEvent)),
    }
    }

    func (w *POSIXFileWatcher) Watch(path string, callback func(WatchEvent)) error {
    w.mu.Lock()
    defer w.mu.Unlock()
    // Real impl: syscall to inotify_add_watch or kevent
    fmt.Printf(&quot;POSIX: Watching %s via inotify/kqueue\n&quot;, path)
    w.watches[path] = callback
    return nil
    }

    func (w *POSIXFileWatcher) Unwatch(path string) error {
    w.mu.Lock()
    defer w.mu.Unlock()
    delete(w.watches, path)
    return nil
    }

    func (w *POSIXFileWatcher) Close() error {
    w.mu.Lock()
    defer w.mu.Unlock()
    w.watches = nil
    return nil
    }

    // ============================================
    // WINDOWS FAMILY
    // ============================================

    type WindowsFileInfo struct {
    name       string
    size       int64
    attrs      uint32 // FILE_ATTRIBUTE_* flags
    modTime    time.Time
    isDir      bool
    fileIndex  uint64 // Unique file ID on NTFS
    volumeSerial uint32
    }

    func (f *WindowsFileInfo) Name() string       { return f.name }
    func (f *WindowsFileInfo) Size() int64        { return f.size }
    func (f *WindowsFileInfo) Mode() uint32       { return f.attrs }
    func (f *WindowsFileInfo) ModTime() time.Time { return f.modTime }
    func (f *WindowsFileInfo) IsDir() bool        { return f.isDir }
    func (f *WindowsFileInfo) PlatformAttrs() map[string]interface{} {
    return map[string]interface{}{
    &quot;attributes&quot;:   f.attrs,
    &quot;fileIndex&quot;:    f.fileIndex,
    &quot;volumeSerial&quot;: f.volumeSerial,
    &quot;isHidden&quot;:     f.attrs&amp;0x2 != 0, // FILE_ATTRIBUTE_HIDDEN
    &quot;isSystem&quot;:     f.attrs&amp;0x4 != 0, // FILE_ATTRIBUTE_SYSTEM
    &quot;isReadOnly&quot;:   f.attrs&amp;0x1 != 0, // FILE_ATTRIBUTE_READONLY
    }
    }

    type WindowsFile struct {
    file   *os.File
    path   string
    handle uintptr // HANDLE from CreateFile
    }

    func (f *WindowsFile) Read(p []byte) (int, error)  { return f.file.Read(p) }
    func (f *WindowsFile) Write(p []byte) (int, error) { return f.file.Write(p) }
    func (f *WindowsFile) Close() error                { return f.file.Close() }
    func (f *WindowsFile) Sync() error                 { return f.file.Sync() }

    func (f *WindowsFile) Seek(offset int64, whence int) (int64, error) {
    return f.file.Seek(offset, whence)
    }

    func (f *WindowsFile) Stat() (FileInfo, error) {
    info, err := f.file.Stat()
    if err != nil {
    return nil, err
    }
    return &amp;WindowsFileInfo{
    name:    info.Name(),
    size:    info.Size(),
    modTime: info.ModTime(),
    isDir:   info.IsDir(),
    }, nil
    }

    func (f *WindowsFile) Lock() error {
    // Windows uses LockFileEx, not flock
    // Supports byte-range locking unlike POSIX flock
    fmt.Printf(&quot;Windows: Acquired lock on %s via LockFileEx()\n&quot;, f.path)
    return nil
    }

    func (f *WindowsFile) Unlock() error {
    fmt.Printf(&quot;Windows: Released lock on %s via UnlockFileEx()\n&quot;, f.path)
    return nil
    }

    type WindowsDirectory struct {
    path   string
    handle uintptr // HANDLE from FindFirstFile
    }

    func (d *WindowsDirectory) List() ([]FileInfo, error) {
    // Windows uses FindFirstFile/FindNextFile pattern
    fmt.Printf(&quot;Windows: Listing %s via FindFirstFile/FindNextFile\n&quot;, d.path)
    entries, err := os.ReadDir(d.path)
    if err != nil {
    return nil, err
    }

    infos := make([]FileInfo, 0, len(entries))
    for _, entry := range entries {
    info, _ := entry.Info()
    infos = append(infos, &amp;WindowsFileInfo{
    name:    info.Name(),
    size:    info.Size(),
    modTime: info.ModTime(),
    isDir:   info.IsDir(),
    })
    }
    return infos, nil
    }

    func (d *WindowsDirectory) Create(name string) error {
    // Windows: CreateDirectory API
    return os.Mkdir(filepath.Join(d.path, name), 0755)
    }

    func (d *WindowsDirectory) Remove(name string) error {
    return os.Remove(filepath.Join(d.path, name))
    }

    func (d *WindowsDirectory) Close() error {
    // Windows: FindClose
    return nil
    }

    type WindowsFileWatcher struct {
    // Uses ReadDirectoryChangesW on Windows
    watches map[string]func(WatchEvent)
    mu      sync.RWMutex
    }

    func NewWindowsFileWatcher() *WindowsFileWatcher {
    return &amp;WindowsFileWatcher{
    watches: make(map[string]func(WatchEvent)),
    }
    }

    func (w *WindowsFileWatcher) Watch(path string, callback func(WatchEvent)) error {
    w.mu.Lock()
    defer w.mu.Unlock()
    fmt.Printf(&quot;Windows: Watching %s via ReadDirectoryChangesW\n&quot;, path)
    w.watches[path] = callback
    return nil
    }

    func (w *WindowsFileWatcher) Unwatch(path string) error {
    w.mu.Lock()
    defer w.mu.Unlock()
    delete(w.watches, path)
    return nil
    }

    func (w *WindowsFileWatcher) Close() error {
    return nil
    }

    // ============================================
    // ABSTRACT FACTORY
    // ============================================

    // FileSystemFactory creates platform-specific file system products
    type FileSystemFactory interface {
    OpenFile(path string, flags int) (File, error)
    OpenDirectory(path string) (Directory, error)
    CreateWatcher() FileWatcher
    Stat(path string) (FileInfo, error)
    GetPlatformName() string

    // Platform-specific capability queries
    SupportsSymlinks() bool
    SupportsHardLinks() bool
    SupportsByteRangeLocking() bool
    MaxPathLength() int
    }

    // ============================================
    // CONCRETE FACTORIES
    // ============================================

    type POSIXFactory struct {
    rootPath string
    }

    func NewPOSIXFactory(rootPath string) *POSIXFactory {
    return &amp;POSIXFactory{rootPath: rootPath}
    }

    func (f *POSIXFactory) OpenFile(path string, flags int) (File, error) {
    file, err := os.OpenFile(path, flags, 0644)
    if err != nil {
    return nil, err
    }
    return &amp;POSIXFile{file: file, path: path}, nil
    }

    func (f *POSIXFactory) OpenDirectory(path string) (Directory, error) {
    info, err := os.Stat(path)
    if err != nil {
    return nil, err
    }
    if !info.IsDir() {
    return nil, fmt.Errorf(&quot;not a directory: %s&quot;, path)
    }
    return &amp;POSIXDirectory{path: path}, nil
    }

    func (f *POSIXFactory) CreateWatcher() FileWatcher {
    return NewPOSIXFileWatcher()
    }

    func (f *POSIXFactory) Stat(path string) (FileInfo, error) {
    info, err := os.Stat(path)
    if err != nil {
    return nil, err
    }
    return &amp;POSIXFileInfo{
    name:    info.Name(),
    size:    info.Size(),
    mode:    uint32(info.Mode()),
    modTime: info.ModTime(),
    isDir:   info.IsDir(),
    }, nil
    }

    func (f *POSIXFactory) GetPlatformName() string      { return &quot;POSIX&quot; }
    func (f *POSIXFactory) SupportsSymlinks() bool       { return true }
    func (f *POSIXFactory) SupportsHardLinks() bool      { return true }
    func (f *POSIXFactory) SupportsByteRangeLocking() bool { return false } // flock is whole-file
    func (f *POSIXFactory) MaxPathLength() int           { return 4096 } // PATH_MAX

    type WindowsFactory struct {
    rootPath string
    }

    func NewWindowsFactory(rootPath string) *WindowsFactory {
    return &amp;WindowsFactory{rootPath: rootPath}
    }

    func (f *WindowsFactory) OpenFile(path string, flags int) (File, error) {
    file, err := os.OpenFile(path, flags, 0644)
    if err != nil {
    return nil, err
    }
    return &amp;WindowsFile{file: file, path: path}, nil
    }

    func (f *WindowsFactory) OpenDirectory(path string) (Directory, error) {
    info, err := os.Stat(path)
    if err != nil {
    return nil, err
    }
    if !info.IsDir() {
    return nil, fmt.Errorf(&quot;not a directory: %s&quot;, path)
    }
    return &amp;WindowsDirectory{path: path}, nil
    }

    func (f *WindowsFactory) CreateWatcher() FileWatcher {
    return NewWindowsFileWatcher()
    }

    func (f *WindowsFactory) Stat(path string) (FileInfo, error) {
    info, err := os.Stat(path)
    if err != nil {
    return nil, err
    }
    return &amp;WindowsFileInfo{
    name:    info.Name(),
    size:    info.Size(),
    modTime: info.ModTime(),
    isDir:   info.IsDir(),
    }, nil
    }

    func (f *WindowsFactory) GetPlatformName() string      { return &quot;Windows&quot; }
    func (f *WindowsFactory) SupportsSymlinks() bool       { return true } // Since Vista with elevation
    func (f *WindowsFactory) SupportsHardLinks() bool      { return true } // NTFS only
    func (f *WindowsFactory) SupportsByteRangeLocking() bool { return true }
    func (f *WindowsFactory) MaxPathLength() int           { return 260 } // MAX_PATH, 32K with \\?\ prefix

    // ============================================
    // CLIENT CODE
    // ============================================

    // FileManager is a cross-platform file manager client
    type FileManager struct {
    factory FileSystemFactory
    watcher FileWatcher
    }

    func NewFileManager(factory FileSystemFactory) *FileManager {
    return &amp;FileManager{
    factory: factory,
    watcher: factory.CreateWatcher(),
    }
    }

    func (m *FileManager) CopyFile(src, dst string) error {
    // All operations use abstract interfaces
    srcFile, err := m.factory.OpenFile(src, os.O_RDONLY)
    if err != nil {
    return fmt.Errorf(&quot;open source: %w&quot;, err)
    }
    defer srcFile.Close()

    dstFile, err := m.factory.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC)
    if err != nil {
    return fmt.Errorf(&quot;open dest: %w&quot;, err)
    }
    defer dstFile.Close()

    // Lock source for reading, dest for writing
    if err := srcFile.Lock(); err != nil {
    return fmt.Errorf(&quot;lock source: %w&quot;, err)
    }
    defer srcFile.Unlock()

    if err := dstFile.Lock(); err != nil {
    return fmt.Errorf(&quot;lock dest: %w&quot;, err)
    }
    defer dstFile.Unlock()

    // Copy data
    buf := make([]byte, 32*1024)
    for {
    n, err := srcFile.Read(buf)
    if n &gt; 0 {
    if _, werr := dstFile.Write(buf[:n]); werr != nil {
    return fmt.Errorf(&quot;write: %w&quot;, werr)
    }
    }
    if err == io.EOF {
    break
    }
    if err != nil {
    return fmt.Errorf(&quot;read: %w&quot;, err)
    }
    }

    return dstFile.Sync()
    }

    func (m *FileManager) WatchDirectory(path string, onChange func(string)) error {
    return m.watcher.Watch(path, func(event WatchEvent) {
    onChange(fmt.Sprintf(&quot;%s: %s&quot;, event.Type, event.Path))
    })
    }

    func (m *FileManager) Close() error {
    return m.watcher.Close()
    }

    // ============================================
    // FACTORY SELECTOR
    // ============================================

    func GetFileSystemFactory(platform string) FileSystemFactory {
    switch platform {
    case &quot;windows&quot;:
    return NewWindowsFactory(&quot;&quot;)
    case &quot;posix&quot;, &quot;linux&quot;, &quot;darwin&quot;:
    return NewPOSIXFactory(&quot;&quot;)
    default:
    // Default to POSIX
    return NewPOSIXFactory(&quot;&quot;)
    }
    }

    // ============================================
    // MAIN
    // ============================================

    func main() {
    // In real code, would detect platform automatically
    platform := &quot;posix&quot;

    factory := GetFileSystemFactory(platform)
    manager := NewFileManager(factory)
    defer manager.Close()

    fmt.Printf(&quot;File Manager initialized for: %s\n&quot;, factory.GetPlatformName())
    fmt.Printf(&quot;  Symlinks supported: %v\n&quot;, factory.SupportsSymlinks())
    fmt.Printf(&quot;  Byte-range locking: %v\n&quot;, factory.SupportsByteRangeLocking())
    fmt.Printf(&quot;  Max path length: %d\n&quot;, factory.MaxPathLength())

    // Example operations - work identically on all platforms
    err := manager.CopyFile(&quot;/tmp/source.txt&quot;, &quot;/tmp/dest.txt&quot;)
    if err != nil {
    fmt.Printf(&quot;Copy failed: %v\n&quot;, err)
    }

    err = manager.WatchDirectory(&quot;/tmp&quot;, func(change string) {
    fmt.Printf(&quot;Change detected: %s\n&quot;, change)
    })
    if err != nil {
    fmt.Printf(&quot;Watch failed: %v\n&quot;, err)
    }
    }</code></pre>
<hr />
<h2 id="section-6-advanced-topics-and-edge-cases">Section 6: Advanced Topics and Edge Cases</h2>
<h3 id="61-factory-composition-combining-multiple-factories">6.1 Factory Composition: Combining Multiple Factories</h3>
<p>Sometimes systems need products from multiple factories:</p>
<pre><code class="language-python">    class CompositeCloudFactory:
    &quot;&quot;&quot;Combines products from multiple cloud providers.&quot;&quot;&quot;

    def __init__(self,
    compute_factory: CloudFactory,
    storage_factory: CloudFactory,
    database_factory: CloudFactory):
    # WARNING: This breaks family consistency!
    # Only valid when products are truly independent
    self.compute = compute_factory
    self.storage = storage_factory
    self.database = database_factory

    def create_compute(self) -&gt; ComputeService:
    return self.compute.create_compute()

    def create_storage(self) -&gt; StorageService:
    return self.storage.create_storage()

    def create_database(self) -&gt; DatabaseService:
    return self.database.create_database()</code></pre>
<div style="background: #fef2f2;border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0">
<h4 style="margin: 0 0 8px 0; color: #991b1b">Design Trade-off: Composite Factories</h4>
<p style="margin: 0; color: #7f1d1d; font-size: 14px">
  Composite factories sacrifice family consistency for flexibility. Use only when: (1) Products are truly independent, (2) Cross-provider communication is handled explicitly, (3) The performance/cost benefits outweigh the complexity. Document the "allowed combinations" clearly.
</p>
</div>
<h3 id="62-factory-caching-and-singleton-integration">6.2 Factory Caching and Singleton Integration</h3>
<p>Factories often integrate with <a href="/topics/design-patterns/singleton">[Singleton]</a>:</p>
<pre><code class="language-python">    class FactoryRegistry:
    &quot;&quot;&quot;Global registry of factories - Singleton pattern.&quot;&quot;&quot;

    _instance: Optional['FactoryRegistry'] = None
    _lock = threading.Lock()

    def __new__(cls):
    if cls._instance is None:
    with cls._lock:
    if cls._instance is None:
    cls._instance = super().__new__(cls)
    cls._instance._factories: Dict[str, CloudFactory] = {}
    return cls._instance

    def register(self, name: str, factory: CloudFactory) -&gt; None:
    self._factories[name] = factory

    def get(self, name: str) -&gt; CloudFactory:
    if name not in self._factories:
    raise KeyError(f&quot;No factory registered for: {name}&quot;)
    return self._factories[name]</code></pre>
<h3 id="63-lazy-product-creation">6.3 Lazy Product Creation</h3>
<p>For expensive products, defer creation:</p>
<pre><code class="language-python">    class LazyDatabaseFactory(DatabaseFactory):
    &quot;&quot;&quot;Factory that creates products lazily on first use.&quot;&quot;&quot;

    def __init__(self, underlying: DatabaseFactory):
    self._underlying = underlying
    self._pool: Optional[ConnectionPool] = None
    self._lock = threading.Lock()

    def create_pool(self, **kwargs) -&gt; ConnectionPool:
    if self._pool is None:
    with self._lock:
    if self._pool is None:
    self._pool = self._underlying.create_pool(**kwargs)
    return self._pool</code></pre>
<h3 id="64-testing-with-mock-factories">6.4 Testing with Mock Factories</h3>
<pre><code class="language-python">    class MockDatabaseFactory(DatabaseFactory[MockFamily]):
    &quot;&quot;&quot;Factory for unit testing - creates in-memory mocks.&quot;&quot;&quot;

    def __init__(self):
    self.created_connections: List[MockConnection] = []
    self.executed_queries: List[str] = []

    def create_connection(self) -&gt; MockConnection:
    conn = MockConnection(self)
    self.created_connections.append(conn)
    return conn

    def create_pool(self, **kwargs) -&gt; MockConnectionPool:
    return MockConnectionPool(self)

    def create_query_builder(self) -&gt; MockQueryBuilder:
    return MockQueryBuilder()

    # Test assertion helpers
    def assert_query_executed(self, pattern: str):
    matching = [q for q in self.executed_queries if pattern in q]
    assert matching, f&quot;No query matching '{pattern}' was executed&quot;

    def assert_connection_count(self, expected: int):
    assert len(self.created_connections) == expected</code></pre>
<hr />
<h2 id="section-7-common-pitfalls-and-anti-patterns">Section 7: Common Pitfalls and Anti-Patterns</h2>
<h3 id="71-the-god-factory-anti-pattern">7.1 The &quot;God Factory&quot; Anti-Pattern</h3>
<div style="background: #fef2f2;border-radius: 10px; padding: 20px; margin: 20px 0">
<h4 style="margin: 0 0 12px 0; color: #991b1b">Anti-Pattern: God Factory</h4>
<div style="color: #7f1d1d; font-size: 14px">
<p><strong>Problem:</strong> Factory that creates too many unrelated products:</p>
<pre style="background: #fee2e2; padding: 12px; border-radius: 4px; overflow-x: auto">
  class ApplicationFactory:
  def create_database(self): ...
  def create_cache(self): ...
  def create_email_sender(self): ...  # Unrelated!
  def create_pdf_generator(self): ... # Unrelated!
  def create_logger(self): ...
  def create_metrics(self): ...
</pre>
<p style="margin-top: 12px"><strong>Solution:</strong> Split into multiple focused factories. Use [[Interface Segregation]](/topics/design-patterns/solid) principle.</p>
</div>
</div>
<h3 id="72-violating-liskov-substitution">7.2 Violating Liskov Substitution</h3>
<pre><code class="language-python">    # BAD: Products behave differently across families
    class MacButton(Button):
    def click(self):
    # Mac-specific: shows confirmation dialog first
    if not self._show_confirmation():
    return
    super().click()

    class WindowsButton(Button):
    def click(self):
    # Windows: clicks immediately
    super().click()

    # Client code expecting immediate click will break on Mac!</code></pre>
<h3 id="73-factory-configuration-explosion">7.3 Factory Configuration Explosion</h3>
<p>When factories have many configuration options, use <a href="/topics/design-patterns/builder">[Builder]</a>:</p>
<pre><code class="language-python">    # BAD: Constructor with too many parameters
    factory = PostgresFactory(
    host=&quot;localhost&quot;,
    port=5432,
    database=&quot;myapp&quot;,
    user=&quot;admin&quot;,
    password=&quot;secret&quot;,
    ssl_mode=&quot;require&quot;,
    ssl_cert=&quot;/path/to/cert&quot;,
    pool_min=5,
    pool_max=20,
    connect_timeout=30,
    statement_timeout=60,
    ...  # 15 more parameters
    )

    # GOOD: Use builder
    factory = (PostgresFactoryBuilder()
    .host(&quot;localhost&quot;)
    .port(5432)
    .database(&quot;myapp&quot;)
    .credentials(&quot;admin&quot;, &quot;secret&quot;)
    .ssl(mode=&quot;require&quot;, cert=&quot;/path/to/cert&quot;)
    .pool(min=5, max=20)
    .timeouts(connect=30, statement=60)
    .build())</code></pre>
<hr />
<h2 id="section-8-related-patterns">Section 8: Related Patterns</h2>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin: 20px 0">
<div style="background: #f8fafc;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #334155">[[Factory Method]](/topics/design-patterns/factory-method)</h5>
<p style="margin: 0; font-size: 13px; color: #64748b">
  Single product creation via inheritance. Abstract Factory often composed of multiple Factory Methods.
</p>
</div>
<div style="background: #f8fafc;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #334155">[[Builder]](/topics/design-patterns/builder)</h5>
<p style="margin: 0; font-size: 13px; color: #64748b">
  Step-by-step construction. Use when products require complex configuration before creation.
</p>
</div>
<div style="background: #f8fafc;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #334155">[[Prototype]](/topics/design-patterns/prototype)</h5>
<p style="margin: 0; font-size: 13px; color: #64748b">
  Clone-based creation. Alternative when products are expensive to create from scratch.
</p>
</div>
<div style="background: #f8fafc;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #334155">[[Singleton]](/topics/design-patterns/singleton)</h5>
<p style="margin: 0; font-size: 13px; color: #64748b">
  Factories are often singletons. Ensures consistent factory instance across application.
</p>
</div>
<div style="background: #f8fafc;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #334155">[[Dependency Injection]](/topics/design-patterns/dependency-injection)</h5>
<p style="margin: 0; font-size: 13px; color: #64748b">
  Factories are injected into clients. Enables testing and configuration flexibility.
</p>
</div>
<div style="background: #f8fafc;border-radius: 10px; padding: 16px">
<h5 style="margin: 0 0 8px 0; color: #334155">[[Strategy]](/topics/design-patterns/strategy)</h5>
<p style="margin: 0; font-size: 13px; color: #64748b">
  Factory selection itself can be a strategy. Runtime factory switching based on context.
</p>
</div>
</div>
<hr />
<h2 id="quick-reference-card">Quick Reference Card</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 12px; padding: 24px; margin: 20px 0">
<h3 id="pattern-essence">Pattern Essence</h3>
<div style="color: #475569">
<pre><code>        - **Intent**: Create families of related objects without specifying concrete classes
        - **Key Benefit**: Guarantees product family consistency by construction
        - **Category**: Creational Pattern (GoF)
</code></pre>
</div>
<h3 id="decision-checklist">Decision Checklist</h3>
<table>
<thead>
<tr>
<th>Question</th>
<th>If Yes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Multiple related objects that must work together?</td>
<td>Use Abstract Factory</td>
</tr>
<tr>
<td>Only one product type with variations?</td>
<td>Use Factory Method</td>
</tr>
<tr>
<td>Products need complex multi-step construction?</td>
<td>Combine with Builder</td>
</tr>
<tr>
<td>Only one product family, no plans for more?</td>
<td>Avoid - use direct construction</td>
</tr>
<tr>
<td>Products from different families can mix safely?</td>
<td>Consider Factory Method per product</td>
</tr>
</tbody>
</table>
<h3 id="key-trade-offs">Key Trade-offs</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Pro</th>
<th>Con</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adding families</td>
<td>Easy - new factory class</td>
<td>N/A</td>
</tr>
<tr>
<td>Adding products</td>
<td>N/A</td>
<td>Hard - modify all factories</td>
</tr>
<tr>
<td>Testing</td>
<td>Mock factory injection</td>
<td>More interfaces to mock</td>
</tr>
<tr>
<td>Flexibility</td>
<td>Switch families at runtime</td>
<td>Locked into family constraints</td>
</tr>
<tr>
<td>Complexity</td>
<td>Clear separation</td>
<td>Additional abstraction layer</td>
</tr>
</tbody>
</table>
<h3 id="code-smell-indicators">Code Smell Indicators</h3>
<pre><code>      - Scattered `if/switch` on type for object creation
      - Products accidentally mixed from different sources
      - Difficulty testing due to concrete dependencies
      - Factory with 10+ unrelated creation methods (God Factory)
</code></pre>
<h3 id="implementation-checklist">Implementation Checklist</h3>
<ol>
<li>Identify product families and product types</li>
<li>Define abstract product interfaces (one per product type)</li>
<li>Implement concrete products for each family</li>
<li>Define abstract factory interface</li>
<li>Implement concrete factory for each family</li>
<li>Client code depends only on abstract interfaces</li>
<li>Inject factory at composition root</li>
<li>Document family constraints and product relationships</li>
</ol>
</div>
