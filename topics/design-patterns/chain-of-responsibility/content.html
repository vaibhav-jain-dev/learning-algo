<h1 id="chain-of-responsibility-pattern">Chain of Responsibility Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Chain of Responsibility pattern passes requests along a chain of handlers. Each handler decides to process the request or pass it to the next handler in the chain. It decouples senders from receivers by giving multiple objects a chance to handle the request.</p>
<p><strong>Difficulty:</strong> Intermediate<br />
<strong>Category:</strong> Behavioral Pattern<br />
<strong>First Documented:</strong> GoF (1994)</p>
<div>
<h4>Core Insight</h4>
<p>Chain of Responsibility transforms <span>hard-coded request routing</span> into a <span>dynamic chain of potential handlers</span>. The sender doesn't know (or care) which handler will ultimately process the request - only that the request enters the chain. This is the foundation of <span>middleware architectures</span> used in every major web framework.</p>
</div>
<hr />
<h2 id="simple-explanation-the-customer-support-escalation">Simple Explanation: The Customer Support Escalation</h2>
<div>
<h3>Think of Customer Support Escalation</h3>
<p>
    When you contact customer support with a problem, your request goes through a chain:
</p>
<div>
<div>
<div>Chatbot</div>
<div>FAQs, simple issues</div>
</div>
<div>&#8594;</div>
<div>
<div>L1 Support</div>
<div>Common problems</div>
</div>
<div>&#8594;</div>
<div>
<div>L2 Support</div>
<div>Technical issues</div>
</div>
<div>&#8594;</div>
<div>
<div>Engineering</div>
<div>Complex bugs</div>
</div>
<div>&#8594;</div>
<div>
<div>Management</div>
<div>Escalations</div>
</div>
</div>
<p>
    Each level tries to handle your issue. If they can't, they escalate to the next level. You don't need to know who will ultimately solve your problem - the chain figures it out.
</p>
<div>
<strong>The Key Insight:</strong>
<span> The sender doesn't know (or care) which handler will process the request. Each handler decides: <span>handle it</span>, <span>pass it on</span>, or <span>both</span>.</span>
</div>
</div>
<hr />
<h2 id="real-company-usage">Real Company Usage</h2>
<div>
<table>
<thead>
<tr>
<th>Company/Framework</th>
<th>How They Use Chain of Responsibility</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Express.js</strong></td>
<td>Middleware chain (auth, logging, parsing, routing)</td>
</tr>
<tr>
<td><strong>Django</strong></td>
<td>Middleware pipeline for request/response processing</td>
</tr>
<tr>
<td><strong>Spring</strong></td>
<td>Filter chains for security, logging, compression</td>
</tr>
<tr>
<td><strong>AWS Lambda</strong></td>
<td>Event handlers in serverless pipelines</td>
</tr>
<tr>
<td><strong>Stripe</strong></td>
<td>Webhook handlers for different event types</td>
</tr>
<tr>
<td><strong>Logging (Python)</strong></td>
<td>Logger hierarchy with different handlers</td>
</tr>
<tr>
<td><strong>DOM Events</strong></td>
<td>Event bubbling from child to parent elements</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h2 id="pattern-architecture-deep-dive">Pattern Architecture Deep Dive</h2>
<h3 id="the-three-handler-behaviors">The Three Handler Behaviors</h3>
<div>
<p>Every handler in a chain must decide one of three behaviors:</p>
<div>
<div>
<div>
<div>1</div>
<h4>Handle and Stop</h4>
</div>
<p>Process the request completely and <span>terminate the chain</span>. No downstream handlers see the request.</p>
<div>
  return Response(200, body)
</div>
</div>
<div>
<div>
<div>2</div>
<h4>Handle and Pass</h4>
</div>
<p>Do some processing (enrich, validate, log) then <span>delegate to next handler</span>. May also process the response.</p>
<div>
  log(req); resp = next(req); log(resp)
</div>
</div>
<div>
<div>
<div>3</div>
<h4>Pass Without Processing</h4>
</div>
<p>Request doesn't match this handler's criteria. <span>Forward unchanged</span> to next handler.</p>
<div>
  return self._next.handle(request)
</div>
</div>
</div>
</div>
<h3 id="chain-flow-visualization">Chain Flow Visualization</h3>
<div>
<div>
<pre><code>&lt;!-- Request Flow --&gt;
</code></pre>
<div>
<div>REQUEST FLOW (Inbound)</div>
<div>
<div>Client</div>
<div>&#8594;</div>
<div>
<div>Logging</div>
<div>log request</div>
</div>
<div>&#8594;</div>
<div>
<div>Auth</div>
<div>verify token</div>
</div>
<div>&#8594;</div>
<div>
<div>Rate Limit</div>
<div>check quota</div>
</div>
<div>&#8594;</div>
<div>
<div>Validation</div>
<div>check body</div>
</div>
<div>&#8594;</div>
<div>Handler</div>
</div>
</div>
<pre><code>&lt;!-- Response Flow --&gt;
</code></pre>
<div>
<div>RESPONSE FLOW (Outbound)</div>
<div>
<div>Handler</div>
<div>&#8594;</div>
<div>
<div>Validation</div>
<div>pass-through</div>
</div>
<div>&#8594;</div>
<div>
<div>Rate Limit</div>
<div>add headers</div>
</div>
<div>&#8594;</div>
<div>
<div>Auth</div>
<div>pass-through</div>
</div>
<div>&#8594;</div>
<div>
<div>Logging</div>
<div>log response</div>
</div>
<div>&#8594;</div>
<div>Client</div>
</div>
</div>
</div>
<div>
<strong>Key Observation:</strong>
<span> The response flows back through the <em>same handlers in reverse order</em>. This enables handlers like Logging to measure total request duration by capturing timestamps on both inbound and outbound passes.</span>
</div>
</div>
<hr />
<h2 id="handler-chain-termination-strategies">Handler Chain Termination Strategies</h2>
<div>
<p>One of the most critical design decisions in Chain of Responsibility is <span>how and when the chain terminates</span>. There are several strategies:</p>
<div>
<div>
<h4>1. First Match Wins</h4>
<p>Chain stops at the <span>first handler that can process</span> the request. Common in routing.</p>
<pre><code>if self.can_handle(request):
  return self.process(request)
return self._next.handle(request)</code></pre>
</div>
<div>
<h4>2. Pipeline (All Process)</h4>
<p><span>Every handler processes</span> and passes along. Chain ends at final handler. Used in middleware.</p>
<pre><code>self.before_processing(request)
  response = self._next.handle(request)
return self.after_processing(response)</code></pre>
</div>
<div>
<h4>3. Short-Circuit on Failure</h4>
<p>Chain stops immediately when a handler <span>rejects the request</span>. Common in auth/validation.</p>
<pre><code>if not self.is_valid(request):
  return Response(400, "Invalid")
return self._next.handle(request)</code></pre>
</div>
<div>
<h4>4. Default/Fallback Handler</h4>
<p>Chain always ends with a <span>guaranteed handler</span> that catches unhandled requests.</p>
<pre><code>class DefaultHandler(Handler):
  def handle(self, request):
return Response(404, "Not Found")</code></pre>
</div>
</div>
</div>
<div>
<h4>Critical Design Decision: What Happens if No Handler Processes?</h4>
<p>If your chain can potentially have <em>no handler</em> process the request, you MUST handle this case:</p>
<ul>
<li><strong>Return null/None:</strong> Client must check and handle gracefully</li>
<li><strong>Throw exception:</strong> Explicit failure, caught at boundary</li>
<li><strong>Default handler:</strong> Catch-all at chain end (recommended)</li>
<li><strong>Return error response:</strong> HTTP 404, gRPC NOT_FOUND, etc.</li>
</ul>
</div>
<hr />
<h2 id="middleware-pattern-the-modern-chain-of-responsibility">Middleware Pattern: The Modern Chain of Responsibility</h2>
<div>
<h4>Understanding Middleware</h4>
<p><span>Middleware</span> is Chain of Responsibility applied to HTTP request/response processing. Each middleware wraps the next, creating an "onion" architecture where requests pass inward through layers and responses pass outward through the same layers in reverse. This is the dominant pattern in web frameworks: Express.js, Koa, Django, Spring, ASP.NET Core, and virtually every modern HTTP framework.</p>
</div>
<h3 id="middleware-architecture-diagram">Middleware Architecture Diagram</h3>
<div>
<div>
<span>The "Onion" Model of Middleware</span>
</div>
<div>
<div>
  <!-- Outer layer - Logging -->
<div>
<div>LOGGING</div>
</div>
  <!-- Auth layer -->
<div>
<div>AUTH</div>
</div>
  <!-- Rate Limit layer -->
<div>
<div>RATE LIMIT</div>
</div>
  <!-- Validation layer -->
<div>
<div>VALIDATION</div>
</div>
  <!-- Core Handler -->
<div>
<div>HANDLER<br><span>Business Logic</span></div>
</div>
</div>
</div>
<div>
<div>
<div></div>
<span>Request flows inward</span>
</div>
<div>
<div></div>
<span>Response flows outward</span>
</div>
</div>
</div>
<h3 id="expressjs-vs-python-middleware-comparison">Express.js vs Python Middleware Comparison</h3>
<div>
<div>
<div>
<div>JavaScript</div>
<span>Express.js Middleware</span>
</div>
<pre><code>// Middleware receives (req, res, next)
  function authMiddleware(req, res, next) {
  const token = req.headers.authorization;
<p>if (!validateToken(token)) {<br />
// Short-circuit: don't call next()<br />
return res.status(401).json({<br />
error: 'Unauthorized'<br />
});<br />
}</p>
<p>// Enrich request for downstream<br />
req.user = decodeToken(token);</p>
<p>// Pass to next middleware<br />
next();<br />
}</p>
<p>// Chain order = execution order<br />
app.use(loggingMiddleware);<br />
app.use(authMiddleware);<br />
app.use(rateLimitMiddleware);<br />
app.use('/api', router);</code></pre></p>
</div>
<div>
<div>
<div>Python</div>
<span>Class-Based Handler Chain</span>
</div>
<pre><code># Handler holds reference to next
  class AuthHandler(Handler):
  def handle(self, request):
  token = request.headers.get("Authorization")
<p>if not self.validate_token(token):</p>
<h1 id="short-circuit-return-without">Short-circuit: return without</h1>
<h1 id="calling-next">calling next</h1>
<p>return Response(<br />
status=401,<br />
body={&quot;error&quot;: &quot;Unauthorized&quot;}<br />
)</p>
<h1 id="enrich-request-for-downstream">Enrich request for downstream</h1>
<p>request.user = self.decode_token(token)</p>
<h1 id="pass-to-next-handler">Pass to next handler</h1>
<p>return self._next.handle(request)</p>
<h1 id="build-chain-via-set-next">Build chain via set_next()</h1>
<p>logging.set_next(auth).set_next(rate_limit)</code></pre></p>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-chain-fundamentals">Interview Deep-Dive: Chain Fundamentals</h2>
<div>
<div>Level 1: What is the core problem Chain of Responsibility solves?</div>
<div>
<strong>Answer:</strong> It solves the problem of <span>coupling the sender of a request to its receiver</span>. Without the pattern, the sender must know exactly which object can handle its request, leading to tight coupling and violations of the Open/Closed Principle.
  <br/><br/>
  With Chain of Responsibility, the sender only knows about a single entry point (the first handler). The chain itself determines which handler(s) process the request. This enables:
<ul>
<li>Adding new handlers without modifying sender code</li>
<li>Reordering handlers without modifying sender code</li>
<li>Different chains for different contexts (testing, production)</li>
</ul>
</div>
</div>
<div>
<div>Level 2: How does Chain of Responsibility differ from the [[Decorator]](/topic/design-patterns/decorator) pattern? They look structurally similar.</div>
<div>
<strong>Answer:</strong> While both patterns involve chaining objects with similar interfaces, they differ in <span>intent and behavior</span>:
  <br/><br/>
<strong>Chain of Responsibility:</strong>
<ul>
<li>Handlers <em>decide</em> whether to process</li>
<li>Request may be handled by zero, one, or many handlers</li>
<li>Chain can be <em>short-circuited</em> at any point</li>
<li>Primary goal: <em>route</em> requests to appropriate handler</li>
</ul>
  <br/>
<strong>[[Decorator]](/topic/design-patterns/decorator):</strong>
<ul>
<li>Decorators <em>always</em> add behavior</li>
<li>Every decorator in the chain executes</li>
<li>Chain cannot be short-circuited</li>
<li>Primary goal: <em>enhance</em> object capabilities</li>
</ul>
  <br/>
  The key tell: in Decorator, all wrappers execute. In Chain of Responsibility, handlers may pass without processing.
</div>
</div>
<div>
<div>Level 3: Design a handler chain where handlers can execute in parallel for independent checks, then merge results. What are the tradeoffs?</div>
<div>
<strong>Answer:</strong> This is a <span>Fan-Out/Fan-In</span> variant of Chain of Responsibility:
<pre><code>  ```python
  class ParallelHandler(Handler):
  def __init__(self, handlers: List[Handler]):
  self._handlers = handlers

  async def handle(self, request):
  # Fan-out: run handlers concurrently
  tasks = [h.handle(request) for h in self._handlers]
  results = await asyncio.gather(*tasks, return_exceptions=True)

  # Fan-in: merge results
  for result in results:
  if isinstance(result, Exception):
  return Response(500, f&quot;Handler failed: {result}&quot;)
  if result.status &gt;= 400:
  return result  # First failure wins

  # All passed, continue chain
  return self._next.handle(request)
  ```
</code></pre>
<p><strong>Tradeoffs:</strong></p>
<ul>
<li><strong>Pro:</strong> Reduced latency when handlers are I/O-bound (auth check + rate limit check in parallel)</li>
<li><strong>Pro:</strong> Better resource utilization under high concurrency</li>
<li><strong>Con:</strong> Wasted work if early handler would have rejected (can't short-circuit)</li>
<li><strong>Con:</strong> Complex error handling - what if 2 of 3 handlers fail?</li>
<li><strong>Con:</strong> Handlers can't enrich request for each other (no data flow between parallel handlers)</li>
<li><strong>Con:</strong> Debugging is harder - non-deterministic execution order</li>
</ul>
<p><strong>When to use:</strong> When handlers are independent, I/O-bound, and rejection is rare. Classic example: validating a request against multiple external services (fraud check, inventory check, payment pre-auth).</p>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-middleware-patterns">Interview Deep-Dive: Middleware Patterns</h2>
<div>
<div>Level 1: Why does middleware order matter? Give a concrete example.</div>
<div>
<strong>Answer:</strong> Middleware order determines <span>which cross-cutting concerns apply to which requests</span> and in what sequence.
  <br/><br/>
<strong>Example - Auth before Rate Limiting:</strong>
      ```
      CORRECT:  Logging -> Auth -> RateLimit -> Handler
      WRONG:    Logging -> RateLimit -> Auth -> Handler
      ```
<p>If rate limiting comes before auth:</p>
<ul>
<li>Unauthenticated requests consume rate limit quota</li>
<li>Attacker can exhaust rate limit for legitimate users</li>
<li>Rate limits can't be per-user (user unknown yet)</li>
</ul>
<p>Another example - Compression and Encryption:<br />
<code>CORRECT:  Compress -&gt; Encrypt (compress plaintext, then encrypt) WRONG:    Encrypt -&gt; Compress (encrypted data doesn't compress well)</code></p>
</div>
</div>
<div>
<div>Level 2: How do you handle errors that occur in the middle of a middleware chain? What about cleanup?</div>
<div>
<strong>Answer:</strong> There are three main strategies:
  <br/><br/>
<strong>1. Error Handler Middleware (Recommended):</strong>
  <br/>
  Place an error-catching middleware at the <em>outermost</em> layer:
<pre><code>  ```python
  class ErrorHandlerMiddleware(Handler):
  def handle(self, request):
  try:
  return self._next.handle(request)
  except ValidationError as e:
  return Response(400, {&quot;error&quot;: str(e)})
  except AuthError as e:
  return Response(401, {&quot;error&quot;: str(e)})
  except Exception as e:
  log.exception(&quot;Unhandled error&quot;)
  return Response(500, {&quot;error&quot;: &quot;Internal error&quot;})
  ```
</code></pre>
<p><strong>2. Result Objects Instead of Exceptions:</strong></p>
<pre><code>  ```python
  @dataclass
  class Result:
  success: bool
  value: Any = None
  error: str = None

  # Handlers return Result, never raise
  def handle(self, request) -&gt; Result:
  if not valid:
  return Result(success=False, error=&quot;Invalid&quot;)
  return self._next.handle(request)
  ```
</code></pre>
<p><strong>3. Cleanup via Context Managers:</strong></p>
<pre><code>  ```python
  class ResourceHandler(Handler):
  def handle(self, request):
  with self.acquire_resource() as resource:
  request.context[&quot;resource&quot;] = resource
  return self._next.handle(request)
  # Resource automatically cleaned up, even on exception
  ```
</code></pre>
<p><strong>Best Practice:</strong> Use error middleware at the boundary, Result objects for expected failures, exceptions for unexpected failures.</p>
</div>
</div>
<div>
<div>Level 3: Design a middleware system that supports both synchronous and asynchronous handlers in the same chain. What are the challenges?</div>
<div>
<strong>Answer:</strong> This is a real challenge in mixed codebases. Here's an approach:
<pre><code>  ```python
  import asyncio
  import inspect

  class UnifiedHandler(ABC):
  @abstractmethod
  def handle(self, request) -&gt; Union[Response, Awaitable[Response]]:
  pass

  class ChainRunner:
  def __init__(self, handlers: List[UnifiedHandler]):
  self._handlers = handlers

  async def run_async(self, request) -&gt; Response:
  async def run_handler(handler, req, next_fn):
  # Wrap sync handlers in async
  result = handler.handle(req)
  if inspect.isawaitable(result):
  return await result
  return result

  # Build the chain from end to start
  async def terminal(req):
  return Response(404, &quot;Not Found&quot;)

  chain = terminal
  for handler in reversed(self._handlers):
  prev_chain = chain
  chain = lambda req, h=handler, p=prev_chain: run_handler(h, req, p)

  return await chain(request)

  def run_sync(self, request) -&gt; Response:
  # For sync-only chains, avoid async overhead
  return asyncio.run(self.run_async(request))
  ```
</code></pre>
<p><strong>Challenges:</strong></p>
<ul>
<li><strong>Colored function problem:</strong> Once you have one async handler, the entire chain must be async-aware</li>
<li><strong>Performance:</strong> Wrapping sync handlers in async adds overhead (~1-5 microseconds per handler)</li>
<li><strong>Context propagation:</strong> Python's contextvars work differently in sync vs async</li>
<li><strong>Testing:</strong> Need both sync and async test utilities</li>
<li><strong>Error handling:</strong> Async exceptions behave differently (unhandled exceptions, cancellation)</li>
</ul>
<p><strong>Recommendation:</strong> In new code, go fully async. For legacy, wrap the sync/async boundary at the outermost layer, not per-handler.</p>
<p>See <a href="/topic/system-design/concurrency-patterns">[Concurrency Patterns]</a> for more on async design.</p>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-request-processing">Interview Deep-Dive: Request Processing</h2>
<div>
<div>Level 1: How do handlers communicate data to downstream handlers?</div>
<div>
<strong>Answer:</strong> The standard approach is <span>request enrichment</span> - handlers add data to the request object:
<pre><code>  ```python
  class AuthHandler(Handler):
  def handle(self, request):
  token = request.headers.get(&quot;Authorization&quot;)
  user = self.validate_and_decode(token)

  # Enrich request with user info
  request.user = user
  request.context[&quot;permissions&quot;] = user.permissions
  request.context[&quot;authenticated_at&quot;] = datetime.now()

  return self._next.handle(request)

  class AuthorizationHandler(Handler):
  def handle(self, request):
  # Use data from upstream handler
  if &quot;admin&quot; not in request.context[&quot;permissions&quot;]:
  return Response(403, &quot;Forbidden&quot;)
  return self._next.handle(request)
  ```
</code></pre>
<p><strong>Alternative approaches:</strong></p>
<ul>
<li><strong>Thread-local/Context variables:</strong> Implicit passing (Python's contextvars, Java's ThreadLocal)</li>
<li><strong>Return value chaining:</strong> Each handler returns modified request</li>
<li><strong>Separate context object:</strong> Pass (request, context) tuple through chain</li>
</ul>
</div>
</div>
<div>
<div>Level 2: How do you implement request/response transformation in middleware?</div>
<div>
<strong>Answer:</strong> The key is that middleware executes <span>twice per request</span> - once on the way in, once on the way out:
<pre><code>  ```python
  class CompressionHandler(Handler):
  def handle(self, request):
  # INBOUND: Check if client accepts compression
  accepts_gzip = &quot;gzip&quot; in request.headers.get(&quot;Accept-Encoding&quot;, &quot;&quot;)

  # Pass request to next handler
  response = self._next.handle(request)

  # OUTBOUND: Compress response if client accepts and body is large
  if accepts_gzip and len(response.body) &gt; 1000:
  response.body = gzip.compress(response.body.encode())
  response.headers[&quot;Content-Encoding&quot;] = &quot;gzip&quot;

  return response

  class TimingHandler(Handler):
  def handle(self, request):
  start = time.perf_counter()

  response = self._next.handle(request)

  # Add timing to response headers
  elapsed_ms = (time.perf_counter() - start) * 1000
  response.headers[&quot;X-Response-Time&quot;] = f&quot;{elapsed_ms:.2f}ms&quot;

  return response
  ```
</code></pre>
<p><strong>Critical insight:</strong> The order of inbound processing is opposite to outbound processing. If chain is A -&gt; B -&gt; C -&gt; Handler:</p>
<ul>
<li>Inbound: A's pre-processing, B's pre-processing, C's pre-processing, Handler</li>
<li>Outbound: C's post-processing, B's post-processing, A's post-processing</li>
</ul>
</div>
</div>
<div>
<div>Level 3: Design a handler that retries failed requests. What invariants must you maintain?</div>
<div>
<strong>Answer:</strong> Retry middleware is deceptively complex:
<pre><code>  ```python
  class RetryHandler(Handler):
  def __init__(self, max_retries=3, backoff_ms=100, retryable_statuses={500, 502, 503}):
  self._max_retries = max_retries
  self._backoff_ms = backoff_ms
  self._retryable = retryable_statuses

  def handle(self, request):
  # INVARIANT 1: Must buffer request body (streams can only be read once)
  if hasattr(request, 'body_stream'):
  request.body = request.body_stream.read()

  # INVARIANT 2: Idempotency - only retry safe/idempotent methods
  if request.method not in ('GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE'):
  # POST is not idempotent - don't retry
  return self._next.handle(request)

  last_response = None
  for attempt in range(self._max_retries + 1):
  # INVARIANT 3: Fresh request copy each attempt
  request_copy = self._clone_request(request)

  try:
  response = self._next.handle(request_copy)

  if response.status not in self._retryable:
  return response

  last_response = response

  except TransientError as e:
  # Network errors are retryable
  last_response = Response(503, str(e))

  # INVARIANT 4: Exponential backoff
  if attempt &lt; self._max_retries:
  sleep_ms = self._backoff_ms * (2 ** attempt)
  time.sleep(sleep_ms / 1000)

  # INVARIANT 5: Return last response, not raise
  return last_response
  ```
</code></pre>
<p><strong>Critical Invariants:</strong></p>
<ol>
<li><strong>Body buffering:</strong> Request body streams can only be read once - must buffer before retry</li>
<li><strong>Idempotency:</strong> Only retry idempotent operations (GET, PUT, DELETE). Never blindly retry POST</li>
<li><strong>Request isolation:</strong> Each retry must use a fresh request copy (prevents state leakage)</li>
<li><strong>Backoff:</strong> Exponential backoff prevents thundering herd on recovering service</li>
<li><strong>Timeout budget:</strong> Total retry time must fit within client's timeout</li>
<li><strong>Circuit breaker integration:</strong> Stop retrying if service is known-down (see [[Circuit Breaker]](/topic/system-design/removing-bottlenecks))</li>
</ol>
</div>
</div>
<hr />
<h2 id="real-world-example-authentication-middleware">Real-World Example: Authentication Middleware</h2>
<div>
<h3>Complete JWT Authentication Handler</h3>
<p>This example demonstrates a production-quality authentication handler with <span>multiple authentication strategies</span>, <span>proper error handling</span>, and <span>request enrichment</span>.</p>
<pre><code>```python
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
import jwt
import hashlib
import re


@dataclass
class User:
&quot;&quot;&quot;Authenticated user information.&quot;&quot;&quot;
id: str
email: str
roles: List[str] = field(default_factory=list)
metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AuthResult:
&quot;&quot;&quot;Result of authentication attempt.&quot;&quot;&quot;
success: bool
user: Optional[User] = None
error: Optional[str] = None
auth_method: Optional[str] = None


class AuthStrategy(ABC):
&quot;&quot;&quot;Abstract authentication strategy.&quot;&quot;&quot;

@property
@abstractmethod
def name(self) -&gt; str:
pass

@abstractmethod
def authenticate(self, request) -&gt; AuthResult:
pass


class JWTAuthStrategy(AuthStrategy):
&quot;&quot;&quot;JWT Bearer token authentication.&quot;&quot;&quot;

def __init__(self, secret_key: str, algorithms: List[str] = None):
self._secret = secret_key
self._algorithms = algorithms or [&quot;HS256&quot;]

@property
def name(self) -&gt; str:
return &quot;jwt&quot;

def authenticate(self, request) -&gt; AuthResult:
auth_header = request.headers.get(&quot;Authorization&quot;, &quot;&quot;)

if not auth_header.startswith(&quot;Bearer &quot;):
return AuthResult(success=False, error=&quot;Missing Bearer token&quot;)

token = auth_header[7:]  # Strip &quot;Bearer &quot;

try:
payload = jwt.decode(
token,
self._secret,
algorithms=self._algorithms
)

# Validate expiration
if &quot;exp&quot; in payload:
exp = datetime.fromtimestamp(payload[&quot;exp&quot;])
if exp &lt; datetime.now():
return AuthResult(success=False, error=&quot;Token expired&quot;)

user = User(
id=payload.get(&quot;sub&quot;),
email=payload.get(&quot;email&quot;, &quot;&quot;),
roles=payload.get(&quot;roles&quot;, []),
metadata={&quot;token_issued&quot;: payload.get(&quot;iat&quot;)}
)

return AuthResult(success=True, user=user, auth_method=&quot;jwt&quot;)

except jwt.InvalidTokenError as e:
return AuthResult(success=False, error=f&quot;Invalid token: {e}&quot;)


class APIKeyAuthStrategy(AuthStrategy):
&quot;&quot;&quot;API key authentication for service-to-service calls.&quot;&quot;&quot;

def __init__(self, valid_keys: Dict[str, User]):
# Map of API key hash -&gt; User
self._keys = {self._hash_key(k): v for k, v in valid_keys.items()}

@property
def name(self) -&gt; str:
return &quot;api_key&quot;

def _hash_key(self, key: str) -&gt; str:
return hashlib.sha256(key.encode()).hexdigest()

def authenticate(self, request) -&gt; AuthResult:
api_key = request.headers.get(&quot;X-API-Key&quot;)

if not api_key:
return AuthResult(success=False, error=&quot;Missing API key&quot;)

key_hash = self._hash_key(api_key)
user = self._keys.get(key_hash)

if not user:
return AuthResult(success=False, error=&quot;Invalid API key&quot;)

return AuthResult(success=True, user=user, auth_method=&quot;api_key&quot;)


class AuthenticationHandler(Handler):
&quot;&quot;&quot;
Multi-strategy authentication handler.

Tries each authentication strategy in order.
Short-circuits on first successful auth or explicit rejection.
&quot;&quot;&quot;

def __init__(self, strategies: List[AuthStrategy], required: bool = True):
super().__init__()
self._strategies = strategies
self._required = required

def handle(self, request) -&gt; Response:
# Skip auth for certain paths (health checks, public endpoints)
if self._is_public_path(request.path):
return self._pass_to_next(request)

# Try each strategy
for strategy in self._strategies:
result = strategy.authenticate(request)

if result.success:
# Enrich request with user info
request.user = result.user
request.context[&quot;auth_method&quot;] = result.auth_method
request.context[&quot;authenticated&quot;] = True

return self._pass_to_next(request)

# If strategy explicitly rejected (vs just &quot;not applicable&quot;), stop
if self._is_explicit_rejection(result):
return Response(
status=401,
body={&quot;error&quot;: result.error, &quot;auth_method&quot;: strategy.name},
headers={&quot;WWW-Authenticate&quot;: self._get_challenge(strategy)}
)

# No strategy succeeded
if self._required:
return Response(
status=401,
body={&quot;error&quot;: &quot;Authentication required&quot;},
headers={&quot;WWW-Authenticate&quot;: self._get_challenges()}
)

# Auth optional, continue without user
request.context[&quot;authenticated&quot;] = False
return self._pass_to_next(request)

def _is_public_path(self, path: str) -&gt; bool:
public_patterns = [
r&quot;^/health$&quot;,
r&quot;^/metrics$&quot;,
r&quot;^/api/v\d+/public/&quot;,
]
return any(re.match(p, path) for p in public_patterns)

def _is_explicit_rejection(self, result: AuthResult) -&gt; bool:
# Distinguish &quot;wrong credentials&quot; from &quot;no credentials provided&quot;
explicit_errors = [&quot;Invalid token&quot;, &quot;Token expired&quot;, &quot;Invalid API key&quot;]
return result.error and any(e in result.error for e in explicit_errors)

def _get_challenge(self, strategy: AuthStrategy) -&gt; str:
if strategy.name == &quot;jwt&quot;:
return 'Bearer realm=&quot;api&quot;'
return f'{strategy.name} realm=&quot;api&quot;'

def _get_challenges(self) -&gt; str:
return &quot;, &quot;.join(self._get_challenge(s) for s in self._strategies)
```
</code></pre>
</div>
<hr />
<h2 id="real-world-example-logging-middleware">Real-World Example: Logging Middleware</h2>
<div>
<h3>Production Logging Handler with Structured Output</h3>
<pre><code>```python
import json
import time
import uuid
from dataclasses import dataclass, asdict
from typing import Optional, Dict, Any
from datetime import datetime


@dataclass
class RequestLog:
&quot;&quot;&quot;Structured log entry for request.&quot;&quot;&quot;
timestamp: str
request_id: str
method: str
path: str
query_params: Dict[str, str]
user_id: Optional[str]
user_agent: str
client_ip: str

def to_json(self) -&gt; str:
return json.dumps(asdict(self))


@dataclass
class ResponseLog:
&quot;&quot;&quot;Structured log entry for response.&quot;&quot;&quot;
timestamp: str
request_id: str
status_code: int
duration_ms: float
response_size: int
error: Optional[str]

def to_json(self) -&gt; str:
return json.dumps(asdict(self))


class LoggingHandler(Handler):
&quot;&quot;&quot;
Structured logging middleware with request correlation.

Features:
- Request ID generation/propagation
- Timing measurement
- Structured JSON output
- PII redaction
- Configurable log levels
&quot;&quot;&quot;

SENSITIVE_HEADERS = {&quot;authorization&quot;, &quot;x-api-key&quot;, &quot;cookie&quot;, &quot;set-cookie&quot;}
SENSITIVE_FIELDS = {&quot;password&quot;, &quot;token&quot;, &quot;secret&quot;, &quot;credit_card&quot;}

def __init__(self, logger, log_bodies: bool = False, max_body_size: int = 1000):
super().__init__()
self._logger = logger
self._log_bodies = log_bodies
self._max_body_size = max_body_size

def handle(self, request) -&gt; Response:
# Generate or propagate request ID
request_id = request.headers.get(&quot;X-Request-ID&quot;) or str(uuid.uuid4())
request.context[&quot;request_id&quot;] = request_id

# Capture start time
start_time = time.perf_counter()

# Log inbound request
self._log_request(request, request_id)

try:
# Process rest of chain
response = self._pass_to_next(request)

# Log outbound response
duration_ms = (time.perf_counter() - start_time) * 1000
self._log_response(response, request_id, duration_ms)

# Add correlation headers to response
response.headers[&quot;X-Request-ID&quot;] = request_id
response.headers[&quot;X-Response-Time&quot;] = f&quot;{duration_ms:.2f}ms&quot;

return response

except Exception as e:
# Log error
duration_ms = (time.perf_counter() - start_time) * 1000
self._log_error(request_id, e, duration_ms)
raise

def _log_request(self, request, request_id: str):
log_entry = RequestLog(
timestamp=datetime.utcnow().isoformat() + &quot;Z&quot;,
request_id=request_id,
method=request.method,
path=request.path,
query_params=self._redact_sensitive(dict(getattr(request, 'query', {}))),
user_id=getattr(request, 'user', None) and request.user.id,
user_agent=request.headers.get(&quot;User-Agent&quot;, &quot;&quot;),
client_ip=request.headers.get(&quot;X-Forwarded-For&quot;, &quot;unknown&quot;).split(&quot;,&quot;)[0],
)

self._logger.info(f&quot;REQUEST {log_entry.to_json()}&quot;)

if self._log_bodies and request.body:
safe_body = self._redact_body(request.body)
self._logger.debug(f&quot;REQUEST_BODY request_id={request_id} body={safe_body}&quot;)

def _log_response(self, response, request_id: str, duration_ms: float):
body_size = len(str(response.body)) if response.body else 0

log_entry = ResponseLog(
timestamp=datetime.utcnow().isoformat() + &quot;Z&quot;,
request_id=request_id,
status_code=response.status,
duration_ms=round(duration_ms, 2),
response_size=body_size,
error=response.body.get(&quot;error&quot;) if isinstance(response.body, dict) else None,
)

# Use appropriate log level based on status
if response.status &gt;= 500:
self._logger.error(f&quot;RESPONSE {log_entry.to_json()}&quot;)
elif response.status &gt;= 400:
self._logger.warning(f&quot;RESPONSE {log_entry.to_json()}&quot;)
else:
self._logger.info(f&quot;RESPONSE {log_entry.to_json()}&quot;)

def _log_error(self, request_id: str, error: Exception, duration_ms: float):
self._logger.error(
f&quot;ERROR request_id={request_id} &quot;
f&quot;duration_ms={duration_ms:.2f} &quot;
f&quot;error_type={type(error).__name__} &quot;
f&quot;error_message={str(error)}&quot;
)

def _redact_sensitive(self, data: Dict[str, Any]) -&gt; Dict[str, Any]:
&quot;&quot;&quot;Redact sensitive fields from dictionaries.&quot;&quot;&quot;
return {
k: &quot;[REDACTED]&quot; if k.lower() in self.SENSITIVE_FIELDS else v
for k, v in data.items()
}

def _redact_body(self, body: Any) -&gt; str:
&quot;&quot;&quot;Redact and truncate request/response bodies.&quot;&quot;&quot;
if isinstance(body, dict):
safe_body = self._redact_sensitive(body)
body_str = json.dumps(safe_body)
else:
body_str = str(body)

if len(body_str) &gt; self._max_body_size:
return body_str[:self._max_body_size] + &quot;...[TRUNCATED]&quot;
return body_str
```
</code></pre>
</div>
<hr />
<h2 id="python-implementation-complete-middleware-chain">Python Implementation: Complete Middleware Chain</h2>
<h3 id="http-middleware-chain">HTTP Middleware Chain</h3>
<pre><code class="language-python">from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, Callable, List
from datetime import datetime
import json
import time


@dataclass
class Request:
&quot;&quot;&quot;HTTP-like request object.&quot;&quot;&quot;
path: str
method: str
headers: Dict[str, str] = field(default_factory=dict)
body: Optional[Any] = None
user: Optional[str] = None
context: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Response:
&quot;&quot;&quot;HTTP-like response object.&quot;&quot;&quot;
status: int
body: Any
headers: Dict[str, str] = field(default_factory=dict)


class Handler(ABC):
&quot;&quot;&quot;
Base handler in the chain.
Each handler can process the request and/or pass to next.
&quot;&quot;&quot;

def __init__(self):
self._next: Optional['Handler'] = None

def set_next(self, handler: 'Handler') -&gt; 'Handler':
&quot;&quot;&quot;Set the next handler and return it for chaining.&quot;&quot;&quot;
self._next = handler
return handler

def handle(self, request: Request) -&gt; Optional[Response]:
&quot;&quot;&quot;Process request. Override in subclasses.&quot;&quot;&quot;
return self._pass_to_next(request)

def _pass_to_next(self, request: Request) -&gt; Optional[Response]:
&quot;&quot;&quot;Pass request to next handler in chain.&quot;&quot;&quot;
if self._next:
return self._next.handle(request)
return None


class AuthenticationHandler(Handler):
&quot;&quot;&quot;Verify authentication token.&quot;&quot;&quot;

def __init__(self, valid_tokens: set = None):
super().__init__()
self.valid_tokens = valid_tokens or {&quot;token123&quot;, &quot;admin_token&quot;}

def handle(self, request: Request) -&gt; Optional[Response]:
auth_header = request.headers.get(&quot;Authorization&quot;, &quot;&quot;)

if not auth_header.startswith(&quot;Bearer &quot;):
return Response(
status=401,
body={&quot;error&quot;: &quot;Missing or invalid Authorization header&quot;}
)

token = auth_header.split(&quot; &quot;)[1]
if token not in self.valid_tokens:
return Response(
status=401,
body={&quot;error&quot;: &quot;Invalid token&quot;}
)

# Set user info for downstream handlers
request.user = f&quot;user_{token[:5]}&quot;
request.context[&quot;authenticated&quot;] = True

return self._pass_to_next(request)


class RateLimitHandler(Handler):
&quot;&quot;&quot;Limit requests per user/IP.&quot;&quot;&quot;

def __init__(self, max_requests: int = 100, window_seconds: int = 60):
super().__init__()
self.max_requests = max_requests
self.window_seconds = window_seconds
self._request_counts: Dict[str, List[float]] = {}

def handle(self, request: Request) -&gt; Optional[Response]:
identifier = request.user or request.headers.get(&quot;X-Forwarded-For&quot;, &quot;unknown&quot;)
current_time = time.time()

# Get or create request history
if identifier not in self._request_counts:
self._request_counts[identifier] = []

# Remove old requests outside window
cutoff = current_time - self.window_seconds
self._request_counts[identifier] = [
t for t in self._request_counts[identifier] if t &gt; cutoff
]

# Check rate limit
if len(self._request_counts[identifier]) &gt;= self.max_requests:
return Response(
status=429,
body={&quot;error&quot;: &quot;Rate limit exceeded&quot;},
headers={&quot;Retry-After&quot;: str(self.window_seconds)}
)

# Record this request
self._request_counts[identifier].append(current_time)
request.context[&quot;rate_limit_remaining&quot;] = (
self.max_requests - len(self._request_counts[identifier])
)

return self._pass_to_next(request)


class ValidationHandler(Handler):
&quot;&quot;&quot;Validate request data.&quot;&quot;&quot;

def handle(self, request: Request) -&gt; Optional[Response]:
# POST/PUT requests should have a body
if request.method in (&quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;):
if not request.body:
return Response(
status=400,
body={&quot;error&quot;: &quot;Request body required&quot;}
)

# Validate JSON if Content-Type indicates JSON
content_type = request.headers.get(&quot;Content-Type&quot;, &quot;&quot;)
if &quot;application/json&quot; in content_type:
if not isinstance(request.body, (dict, list)):
return Response(
status=400,
body={&quot;error&quot;: &quot;Invalid JSON body&quot;}
)

return self._pass_to_next(request)


class LoggingHandler(Handler):
&quot;&quot;&quot;Log request and response details.&quot;&quot;&quot;

def handle(self, request: Request) -&gt; Optional[Response]:
start_time = time.time()

# Log incoming request
print(f&quot;[{datetime.now().isoformat()}] --&gt; {request.method} {request.path}&quot;)
print(f&quot;    User: {request.user or 'anonymous'}&quot;)

# Process rest of chain
response = self._pass_to_next(request)

# Log response
duration_ms = (time.time() - start_time) * 1000
status = response.status if response else &quot;NO_RESPONSE&quot;
print(f&quot;[{datetime.now().isoformat()}] &lt;-- {status} ({duration_ms:.2f}ms)&quot;)

return response


class CORSHandler(Handler):
&quot;&quot;&quot;Handle Cross-Origin Resource Sharing.&quot;&quot;&quot;

def __init__(self, allowed_origins: List[str] = None):
super().__init__()
self.allowed_origins = allowed_origins or [&quot;*&quot;]

def handle(self, request: Request) -&gt; Optional[Response]:
origin = request.headers.get(&quot;Origin&quot;, &quot;&quot;)

# Handle preflight OPTIONS request
if request.method == &quot;OPTIONS&quot;:
return Response(
status=204,
body=None,
headers={
&quot;Access-Control-Allow-Origin&quot;: self._get_allowed_origin(origin),
&quot;Access-Control-Allow-Methods&quot;: &quot;GET, POST, PUT, DELETE, OPTIONS&quot;,
&quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type, Authorization&quot;,
&quot;Access-Control-Max-Age&quot;: &quot;86400&quot;
}
)

# Add CORS headers for regular requests
response = self._pass_to_next(request)
if response:
response.headers[&quot;Access-Control-Allow-Origin&quot;] = self._get_allowed_origin(origin)

return response

def _get_allowed_origin(self, origin: str) -&gt; str:
if &quot;*&quot; in self.allowed_origins:
return &quot;*&quot;
if origin in self.allowed_origins:
return origin
return self.allowed_origins[0] if self.allowed_origins else &quot;&quot;


class RoutingHandler(Handler):
&quot;&quot;&quot;Route requests to appropriate handlers.&quot;&quot;&quot;

def __init__(self):
super().__init__()
self._routes: Dict[str, Dict[str, Callable]] = {}

def route(self, path: str, method: str, handler: Callable):
&quot;&quot;&quot;Register a route handler.&quot;&quot;&quot;
if path not in self._routes:
self._routes[path] = {}
self._routes[path][method] = handler

def handle(self, request: Request) -&gt; Optional[Response]:
# Find matching route
path_handlers = self._routes.get(request.path)
if not path_handlers:
return Response(status=404, body={&quot;error&quot;: &quot;Not found&quot;})

method_handler = path_handlers.get(request.method)
if not method_handler:
return Response(
status=405,
body={&quot;error&quot;: &quot;Method not allowed&quot;},
headers={&quot;Allow&quot;: &quot;, &quot;.join(path_handlers.keys())}
)

# Execute route handler
try:
return method_handler(request)
except Exception as e:
return Response(
status=500,
body={&quot;error&quot;: str(e)}
)


# Build the middleware chain
def create_app():
&quot;&quot;&quot;Create application with middleware chain.&quot;&quot;&quot;

# Create handlers
logging = LoggingHandler()
cors = CORSHandler(allowed_origins=[&quot;https://example.com&quot;, &quot;http://localhost:3000&quot;])
auth = AuthenticationHandler()
rate_limit = RateLimitHandler(max_requests=10, window_seconds=60)
validation = ValidationHandler()
router = RoutingHandler()

# Build chain: logging -&gt; cors -&gt; auth -&gt; rate_limit -&gt; validation -&gt; router
logging.set_next(cors).set_next(auth).set_next(rate_limit).set_next(validation).set_next(router)

# Register routes
router.route(&quot;/api/users&quot;, &quot;GET&quot;, lambda req: Response(
status=200,
body={&quot;users&quot;: [{&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;}, {&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;}]}
))

router.route(&quot;/api/users&quot;, &quot;POST&quot;, lambda req: Response(
status=201,
body={&quot;created&quot;: req.body, &quot;id&quot;: 3}
))

return logging  # Return first handler in chain


# Usage
app = create_app()

print(&quot;=== Test 1: Valid GET request ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;GET&quot;,
headers={&quot;Authorization&quot;: &quot;Bearer token123&quot;}
))
print(f&quot;Response: {response}\n&quot;)

print(&quot;=== Test 2: Missing auth ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;GET&quot;,
headers={}
))
print(f&quot;Response: {response}\n&quot;)

print(&quot;=== Test 3: POST with body ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;POST&quot;,
headers={
&quot;Authorization&quot;: &quot;Bearer token123&quot;,
&quot;Content-Type&quot;: &quot;application/json&quot;
},
body={&quot;name&quot;: &quot;Charlie&quot;, &quot;email&quot;: &quot;charlie@example.com&quot;}
))
print(f&quot;Response: {response}\n&quot;)

print(&quot;=== Test 4: POST without body ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;POST&quot;,
headers={
&quot;Authorization&quot;: &quot;Bearer token123&quot;,
&quot;Content-Type&quot;: &quot;application/json&quot;
}
))
print(f&quot;Response: {response}\n&quot;)
</code></pre>
<hr />
<h2 id="chain-of-responsibility-vs-related-patterns">Chain of Responsibility vs Related Patterns</h2>
<div>
<div>
<div>
<h4>Chain of Responsibility</h4>
<p>Passes request through handlers until processed.</p>
<div>
<strong>Handler decides:</strong> <span>Process or pass</span><br>
<strong>Result:</strong> <span>0, 1, or many handlers process</span>
</div>
</div>
<div>
<h4>[[Decorator]](/topic/design-patterns/decorator)</h4>
<p>Wraps objects to add behavior.</p>
<div>
<strong>All decorators:</strong> <span>Always execute</span><br>
<strong>Result:</strong> <span>All enhance the object</span>
</div>
</div>
<div>
<h4>[[Command]](/topic/design-patterns/command)</h4>
<p>Encapsulates request as object.</p>
<div>
<strong>Request is:</strong> <span>Stored/queued</span><br>
<strong>Handler:</strong> <span>Known in advance</span>
</div>
</div>
<div>
<h4>[[Strategy]](/topic/design-patterns/strategy)</h4>
<p>Selects one algorithm at runtime.</p>
<div>
<strong>Selection:</strong> <span>Explicit, single</span><br>
<strong>Result:</strong> <span>Exactly one strategy runs</span>
</div>
</div>
</div>
<div>
<strong>Quick Decision Guide:</strong>
<ul>
<li><strong>Chain of Responsibility:</strong> "I don't know who should handle this - let the chain decide"</li>
<li><strong>[[Decorator]](/topic/design-patterns/decorator):</strong> "I want to add features to this object"</li>
<li><strong>[[Command]](/topic/design-patterns/command):</strong> "I want to parameterize, queue, or log operations"</li>
<li><strong>[[Strategy]](/topic/design-patterns/strategy):</strong> "I want to swap algorithms without changing context"</li>
</ul>
</div>
</div>
<hr />
<h2 id="common-mistakes-and-anti-patterns">Common Mistakes and Anti-Patterns</h2>
<div>
<h3 id="mistake-1-forgetting-default-handler">Mistake 1: Forgetting Default Handler</h3>
<pre><code>        ```python
        # BAD: Request might not be handled
        chain = auth.set_next(validation).set_next(router)
        response = chain.handle(request)  # Could be None!

        # GOOD: Always have a fallback
        class NotFoundHandler(Handler):
        def handle(self, request):
        return Response(status=404, body={&quot;error&quot;: &quot;Not found&quot;})

        chain = auth.set_next(validation).set_next(router).set_next(NotFoundHandler())
        ```
</code></pre>
<h3 id="mistake-2-circular-chain">Mistake 2: Circular Chain</h3>
<pre><code>        ```python
        # BAD: Infinite loop!
        handler_a.set_next(handler_b)
        handler_b.set_next(handler_a)  # Circular!

        # GOOD: Linear chain with termination
        handler_a.set_next(handler_b).set_next(handler_c)  # Ends at c
        ```
</code></pre>
<h3 id="mistake-3-order-dependent-hidden-bugs">Mistake 3: Order-Dependent Hidden Bugs</h3>
<pre><code>        ```python
        # BAD: Auth after rate limit - can rate limit unauthenticated requests
        chain = rate_limit.set_next(auth)

        # GOOD: Auth before rate limit - rate limit per authenticated user
        chain = auth.set_next(rate_limit)
        ```
</code></pre>
<h3 id="mistake-4-handlers-modifying-shared-state">Mistake 4: Handlers Modifying Shared State</h3>
<pre><code>        ```python
        # BAD: Handler modifies shared request object, affects other chains
        class BadHandler(Handler):
        def handle(self, request):
        request.headers[&quot;X-Modified&quot;] = &quot;true&quot;  # Mutates original!
        return self._pass_to_next(request)

        # GOOD: Create a copy if you need to modify
        class GoodHandler(Handler):
        def handle(self, request):
        enriched = Request(
        path=request.path,
        method=request.method,
        headers={**request.headers, &quot;X-Modified&quot;: &quot;true&quot;},
        body=request.body
        )
        return self._pass_to_next(enriched)
        ```
</code></pre>
<h3 id="mistake-5-not-handling-exceptions">Mistake 5: Not Handling Exceptions</h3>
<pre><code>        ```python
        # BAD: Exception in handler breaks entire chain
        class FragileHandler(Handler):
        def handle(self, request):
        data = json.loads(request.body)  # Could raise!
        return self._pass_to_next(request)

        # GOOD: Wrap in error handling or use error middleware
        class RobustHandler(Handler):
        def handle(self, request):
        try:
        data = json.loads(request.body)
        except json.JSONDecodeError as e:
        return Response(400, {&quot;error&quot;: f&quot;Invalid JSON: {e}&quot;})
        return self._pass_to_next(request)
        ```
</code></pre>
</div>
<hr />
<h2 id="interview-deep-dive-advanced-scenarios">Interview Deep-Dive: Advanced Scenarios</h2>
<div>
<div>Level 1: How would you implement chain configuration that can be changed at runtime?</div>
<div>
<strong>Answer:</strong> Use a <span>ChainBuilder</span> pattern that reconstructs the chain when configuration changes:
<pre><code>          ```python
          class ChainBuilder:
          def __init__(self):
          self._handlers = []

          def add(self, handler: Handler) -&gt; 'ChainBuilder':
          self._handlers.append(handler)
          return self

          def add_if(self, condition: bool, handler: Handler) -&gt; 'ChainBuilder':
          if condition:
          self._handlers.append(handler)
          return self

          def build(self) -&gt; Handler:
          if not self._handlers:
          raise ValueError(&quot;Chain must have at least one handler&quot;)

          for i in range(len(self._handlers) - 1):
          self._handlers[i].set_next(self._handlers[i + 1])

          return self._handlers[0]

          # Usage with runtime configuration
          def build_chain(config: dict) -&gt; Handler:
          builder = ChainBuilder()

          if config.get(&quot;enable_logging&quot;):
          builder.add(LoggingHandler())

          if config.get(&quot;require_auth&quot;):
          builder.add(AuthHandler())

          if config.get(&quot;rate_limit&quot;):
          builder.add(RateLimitHandler(
          max_requests=config[&quot;rate_limit&quot;][&quot;max&quot;],
          window_seconds=config[&quot;rate_limit&quot;][&quot;window&quot;]
          ))

          builder.add(ValidationHandler())
          builder.add(RouterHandler())

          return builder.build()
          ```
</code></pre>
</div>
</div>
<div>
<div>Level 2: How would you implement branching chains where a handler can route to different sub-chains?</div>
<div>
<strong>Answer:</strong> Implement a <span>CompositeHandler</span> that routes to sub-chains based on conditions:
<pre><code>          ```python
          class BranchingHandler(Handler):
          &quot;&quot;&quot;Routes to different chains based on request properties.&quot;&quot;&quot;

          def __init__(self):
          super().__init__()
          self._branches: Dict[str, Handler] = {}
          self._default: Optional[Handler] = None

          def add_branch(self, condition: str, chain: Handler) -&gt; 'BranchingHandler':
          self._branches[condition] = chain
          return self

          def set_default(self, chain: Handler) -&gt; 'BranchingHandler':
          self._default = chain
          return self

          def handle(self, request: Request) -&gt; Response:
          # Route based on path prefix
          for prefix, chain in self._branches.items():
          if request.path.startswith(prefix):
          return chain.handle(request)

          if self._default:
          return self._default.handle(request)

          return Response(404, {&quot;error&quot;: &quot;No matching route&quot;})

          # Usage: Different chains for different API versions
          branching = BranchingHandler()
          branching.add_branch(&quot;/api/v1/&quot;, v1_chain)
          branching.add_branch(&quot;/api/v2/&quot;, v2_chain)
          branching.add_branch(&quot;/internal/&quot;, internal_chain)
          branching.set_default(public_chain)
          ```
</code></pre>
<p>This enables <span>tree-like routing</span> where different paths get different middleware stacks.</p>
</div>
</div>
<div>
<div>Level 3: Design a handler chain that supports transactional semantics - if any handler fails, all previous handlers' effects are rolled back.</div>
<div>
<strong>Answer:</strong> This requires a <span>Saga-like pattern</span> with compensating actions:
<pre><code>          ```python
          from typing import Callable, List, Tuple
          from contextlib import contextmanager

          class TransactionalHandler(Handler):
          &quot;&quot;&quot;Handler that supports rollback on downstream failures.&quot;&quot;&quot;

          @abstractmethod
          def execute(self, request: Request) -&gt; Request:
          &quot;&quot;&quot;Forward action - modify request/state.&quot;&quot;&quot;
          pass

          @abstractmethod
          def compensate(self, request: Request, error: Exception):
          &quot;&quot;&quot;Rollback action - undo changes on failure.&quot;&quot;&quot;
          pass

          def handle(self, request: Request) -&gt; Response:
          try:
          # Execute forward action
          modified_request = self.execute(request)

          # Pass to next handler
          response = self._pass_to_next(modified_request)

          # If downstream failed, compensate
          if response and response.status &gt;= 500:
          self.compensate(request, Exception(f&quot;Downstream error: {response.status}&quot;))

          return response

          except Exception as e:
          # Compensate on exception
          self.compensate(request, e)
          raise


          class SagaCoordinator(Handler):
          &quot;&quot;&quot;Coordinates transactional chain with compensation.&quot;&quot;&quot;

          def __init__(self, handlers: List[TransactionalHandler]):
          super().__init__()
          self._handlers = handlers

          def handle(self, request: Request) -&gt; Response:
          executed: List[Tuple[TransactionalHandler, Request]] = []
          current_request = request

          try:
          # Execute each handler
          for handler in self._handlers:
          current_request = handler.execute(current_request)
          executed.append((handler, current_request))

          return Response(200, {&quot;status&quot;: &quot;committed&quot;})

          except Exception as e:
          # Compensate in reverse order
          for handler, req in reversed(executed):
          try:
          handler.compensate(req, e)
          except Exception as comp_error:
          # Log but continue compensating
          logging.error(f&quot;Compensation failed: {comp_error}&quot;)

          return Response(500, {&quot;error&quot;: str(e), &quot;status&quot;: &quot;rolled_back&quot;})


          # Example: Transactional order processing
          class ReserveInventoryHandler(TransactionalHandler):
          def execute(self, request):
          item_id = request.body[&quot;item_id&quot;]
          self._inventory_service.reserve(item_id)
          request.context[&quot;inventory_reserved&quot;] = item_id
          return request

          def compensate(self, request, error):
          item_id = request.context.get(&quot;inventory_reserved&quot;)
          if item_id:
          self._inventory_service.release(item_id)

          class ChargePaymentHandler(TransactionalHandler):
          def execute(self, request):
          charge = self._payment_service.charge(
          request.body[&quot;amount&quot;],
          request.body[&quot;payment_method&quot;]
          )
          request.context[&quot;charge_id&quot;] = charge.id
          return request

          def compensate(self, request, error):
          charge_id = request.context.get(&quot;charge_id&quot;)
          if charge_id:
          self._payment_service.refund(charge_id)
          ```
</code></pre>
<p><strong>Key considerations:</strong></p>
<ul>
<li><strong>Compensation order matters:</strong> Compensate in reverse order of execution</li>
<li><strong>Compensation can fail:</strong> Need strategy for partial compensation failures</li>
<li><strong>Idempotency:</strong> Compensations must be idempotent (may run multiple times)</li>
<li><strong>State tracking:</strong> Must track what was done to know what to undo</li>
<li><strong>Timeout handling:</strong> What if compensation takes too long?</li>
</ul>
<p>See <a href="/topic/system-design/event-sourcing">[Event Sourcing]</a> and <a href="/topic/microservices/event-strategies">[Distributed Transactions]</a> for related patterns.</p>
</div>
</div>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<div>
<ol>
<li>
<p><strong><span>Decouples Sender from Receiver</span></strong> - Sender doesn't know which handler will process the request</p>
</li>
<li>
<p><strong><span>Dynamic Handler Selection</span></strong> - Chain determines the right handler at runtime</p>
</li>
<li>
<p><strong><span>Single Responsibility</span></strong> - Each handler focuses on one concern (auth, logging, validation)</p>
</li>
<li>
<p><strong><span>Order Matters</span></strong> - Handler sequence affects behavior (always auth before rate limit)</p>
</li>
<li>
<p><strong><span>Always Have a Default</span></strong> - Ensure requests don't fall through unhandled</p>
</li>
<li>
<p><strong><span>Pipeline vs First-Match</span></strong> - Understand whether all handlers should execute or just the first match</p>
</li>
<li>
<p><strong><span>Request Enrichment</span></strong> - Upstream handlers add context for downstream handlers</p>
</li>
<li>
<p><strong><span>Error Handling Strategy</span></strong> - Plan for failures at any point in the chain</p>
</li>
</ol>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<pre><code>      - [[Command]](/topic/design-patterns/command) - Encapsulates requests as objects for queuing, logging, undo
      - [[Decorator]](/topic/design-patterns/decorator) - Similar structure but all decorators always execute
      - [[Composite]](/topic/design-patterns/composite) - Can form tree of handlers for complex routing
      - [[Strategy]](/topic/design-patterns/strategy) - Single handler selection vs chain of handlers
      - [[Observer]](/topic/design-patterns/observer) - Multiple handlers notified of events (broadcast vs chain)
      - [[Mediator]](/topic/design-patterns/mediator) - Centralizes complex communications between objects
</code></pre>
