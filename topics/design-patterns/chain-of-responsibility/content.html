<h1 id="chain-of-responsibility-pattern">Chain of Responsibility Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Chain of Responsibility pattern passes requests along a chain of handlers. Each handler decides to process the request or pass it to the next handler in the chain. It decouples senders from receivers by giving multiple objects a chance to handle the request.</p>
<p><strong>Difficulty:</strong> Intermediate<br />
<strong>Category:</strong> Behavioral Pattern<br />
<strong>First Documented:</strong> GoF (1994)</p>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #22c55e; margin: 0 0 0.75rem 0">Core Insight</h4>
<p style="color: #eee; margin: 0; line-height: 1.6">Chain of Responsibility transforms <span style="color: #22c55e; font-weight: 600">hard-coded request routing</span> into a <span style="color: #22c55e; font-weight: 600">dynamic chain of potential handlers</span>. The sender doesn't know (or care) which handler will ultimately process the request - only that the request enters the chain. This is the foundation of <span style="color: #22c55e; font-weight: 600">middleware architectures</span> used in every major web framework.</p>
</div>
<hr />
<h2 id="simple-explanation-the-customer-support-escalation">Simple Explanation: The Customer Support Escalation</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<h3 style="color: #1e293b; margin-top: 0; font-size: 1.3rem">Think of Customer Support Escalation</h3>
<p style="color: #334155; font-size: 1rem; line-height: 1.7">
    When you contact customer support with a problem, your request goes through a chain:
</p>
<div style="display: flex; flex-wrap: wrap; gap: 8px; margin: 20px 0; align-items: center; justify-content: center">
<div style="background: #dbeafe; padding: 14px 18px; border-radius: 10px; text-align: center">
<div style="color: #1e40af; font-weight: 700; font-size: 0.9rem">Chatbot</div>
<div style="color: #1e3a8a; font-size: 0.75rem">FAQs, simple issues</div>
</div>
<div style="color: #64748b; font-size: 1.2rem">&#8594;</div>
<div style="background: #dcfce7; padding: 14px 18px; border-radius: 10px; text-align: center">
<div style="color: #166534; font-weight: 700; font-size: 0.9rem">L1 Support</div>
<div style="color: #14532d; font-size: 0.75rem">Common problems</div>
</div>
<div style="color: #64748b; font-size: 1.2rem">&#8594;</div>
<div style="background: #fef3c7; padding: 14px 18px; border-radius: 10px; text-align: center">
<div style="color: #92400e; font-weight: 700; font-size: 0.9rem">L2 Support</div>
<div style="color: #78350f; font-size: 0.75rem">Technical issues</div>
</div>
<div style="color: #64748b; font-size: 1.2rem">&#8594;</div>
<div style="background: #fce7f3; padding: 14px 18px; border-radius: 10px; text-align: center">
<div style="color: #9d174d; font-weight: 700; font-size: 0.9rem">Engineering</div>
<div style="color: #831843; font-size: 0.75rem">Complex bugs</div>
</div>
<div style="color: #64748b; font-size: 1.2rem">&#8594;</div>
<div style="background: #e0e7ff; padding: 14px 18px; border-radius: 10px; text-align: center">
<div style="color: #3730a3; font-weight: 700; font-size: 0.9rem">Management</div>
<div style="color: #312e81; font-size: 0.75rem">Escalations</div>
</div>
</div>
<p style="color: #334155; font-size: 1rem; line-height: 1.7">
    Each level tries to handle your issue. If they can't, they escalate to the next level. You don't need to know who will ultimately solve your problem - the chain figures it out.
</p>
<div style="background: #f1f5f9; padding: 16px; border-radius: 8px; margin-top: 16px">
<strong style="color: #0f172a">The Key Insight:</strong>
<span style="color: #334155"> The sender doesn't know (or care) which handler will process the request. Each handler decides: <span style="color: #22c55e; font-weight: 600">handle it</span>, <span style="color: #22c55e; font-weight: 600">pass it on</span>, or <span style="color: #22c55e; font-weight: 600">both</span>.</span>
</div>
</div>
<hr />
<h2 id="real-company-usage">Real Company Usage</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 24px; margin: 24px 0">
<table>
<thead>
<tr>
<th>Company/Framework</th>
<th>How They Use Chain of Responsibility</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Express.js</strong></td>
<td>Middleware chain (auth, logging, parsing, routing)</td>
</tr>
<tr>
<td><strong>Django</strong></td>
<td>Middleware pipeline for request/response processing</td>
</tr>
<tr>
<td><strong>Spring</strong></td>
<td>Filter chains for security, logging, compression</td>
</tr>
<tr>
<td><strong>AWS Lambda</strong></td>
<td>Event handlers in serverless pipelines</td>
</tr>
<tr>
<td><strong>Stripe</strong></td>
<td>Webhook handlers for different event types</td>
</tr>
<tr>
<td><strong>Logging (Python)</strong></td>
<td>Logger hierarchy with different handlers</td>
</tr>
<tr>
<td><strong>DOM Events</strong></td>
<td>Event bubbling from child to parent elements</td>
</tr>
</tbody>
</table>
</div>
<hr />
<h2 id="pattern-architecture-deep-dive">Pattern Architecture Deep Dive</h2>
<h3 id="the-three-handler-behaviors">The Three Handler Behaviors</h3>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 32px; margin: 24px 0">
<p style="color: #334155; margin-bottom: 20px">Every handler in a chain must decide one of three behaviors:</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px">
<div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); padding: 20px; border-radius: 12px">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px">
<div style="background: #22c55e; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: 700">1</div>
<h4 style="color: #166534; margin: 0">Handle and Stop</h4>
</div>
<p style="color: #14532d; font-size: 0.9rem; margin: 0">Process the request completely and <span style="color: #22c55e; font-weight: 600">terminate the chain</span>. No downstream handlers see the request.</p>
<div style="background: #166534; color: white; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 0.8rem; margin-top: 12px">
  return Response(200, body)
</div>
</div>
<div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); padding: 20px; border-radius: 12px">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px">
<div style="background: #3b82f6; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: 700">2</div>
<h4 style="color: #1e40af; margin: 0">Handle and Pass</h4>
</div>
<p style="color: #1e3a8a; font-size: 0.9rem; margin: 0">Do some processing (enrich, validate, log) then <span style="color: #22c55e; font-weight: 600">delegate to next handler</span>. May also process the response.</p>
<div style="background: #1e40af; color: white; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 0.8rem; margin-top: 12px">
  log(req); resp = next(req); log(resp)
</div>
</div>
<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); padding: 20px; border-radius: 12px">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px">
<div style="background: #f59e0b; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: 700">3</div>
<h4 style="color: #92400e; margin: 0">Pass Without Processing</h4>
</div>
<p style="color: #78350f; font-size: 0.9rem; margin: 0">Request doesn't match this handler's criteria. <span style="color: #22c55e; font-weight: 600">Forward unchanged</span> to next handler.</p>
<div style="background: #92400e; color: white; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 0.8rem; margin-top: 12px">
  return self._next.handle(request)
</div>
</div>
</div>
</div>
<h3 id="chain-flow-visualization">Chain Flow Visualization</h3>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 16px; padding: 32px; margin: 24px 0">
<div style="display: flex; flex-direction: column; gap: 24px">
<pre><code>&lt;!-- Request Flow --&gt;
</code></pre>
<div>
<div style="color: #22c55e; font-weight: 700; font-size: 0.9rem; margin-bottom: 12px">REQUEST FLOW (Inbound)</div>
<div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap">
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 12px 20px; border-radius: 10px; color: white; font-weight: 600">Client</div>
<div style="color: #22c55e; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #4ecdc4; font-weight: 600; font-size: 0.85rem">Logging</div>
<div style="color: #888; font-size: 0.7rem">log request</div>
</div>
<div style="color: #22c55e; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #f093fb; font-weight: 600; font-size: 0.85rem">Auth</div>
<div style="color: #888; font-size: 0.7rem">verify token</div>
</div>
<div style="color: #22c55e; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #ffd93d; font-weight: 600; font-size: 0.85rem">Rate Limit</div>
<div style="color: #888; font-size: 0.7rem">check quota</div>
</div>
<div style="color: #22c55e; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #74b9ff; font-weight: 600; font-size: 0.85rem">Validation</div>
<div style="color: #888; font-size: 0.7rem">check body</div>
</div>
<div style="color: #22c55e; font-size: 1.5rem">&#8594;</div>
<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 12px 20px; border-radius: 10px; color: white; font-weight: 600">Handler</div>
</div>
</div>
<pre><code>&lt;!-- Response Flow --&gt;
</code></pre>
<div>
<div style="color: #f093fb; font-weight: 700; font-size: 0.9rem; margin-bottom: 12px">RESPONSE FLOW (Outbound)</div>
<div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap">
<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 12px 20px; border-radius: 10px; color: white; font-weight: 600">Handler</div>
<div style="color: #f093fb; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #74b9ff; font-weight: 600; font-size: 0.85rem">Validation</div>
<div style="color: #888; font-size: 0.7rem">pass-through</div>
</div>
<div style="color: #f093fb; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #ffd93d; font-weight: 600; font-size: 0.85rem">Rate Limit</div>
<div style="color: #888; font-size: 0.7rem">add headers</div>
</div>
<div style="color: #f093fb; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #f093fb; font-weight: 600; font-size: 0.85rem">Auth</div>
<div style="color: #888; font-size: 0.7rem">pass-through</div>
</div>
<div style="color: #f093fb; font-size: 1.5rem">&#8594;</div>
<div style="background: #1e3a5f;padding: 12px 16px; border-radius: 10px">
<div style="color: #4ecdc4; font-weight: 600; font-size: 0.85rem">Logging</div>
<div style="color: #888; font-size: 0.7rem">log response</div>
</div>
<div style="color: #f093fb; font-size: 1.5rem">&#8594;</div>
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 12px 20px; border-radius: 10px; color: white; font-weight: 600">Client</div>
</div>
</div>
</div>
<div style="background: rgba(34, 197, 94, 0.1);padding: 16px; border-radius: 8px; margin-top: 20px">
<strong style="color: #22c55e">Key Observation:</strong>
<span style="color: #eee"> The response flows back through the <em>same handlers in reverse order</em>. This enables handlers like Logging to measure total request duration by capturing timestamps on both inbound and outbound passes.</span>
</div>
</div>
<hr />
<h2 id="handler-chain-termination-strategies">Handler Chain Termination Strategies</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<p style="color: #334155; margin-bottom: 20px">One of the most critical design decisions in Chain of Responsibility is <span style="color: #22c55e; font-weight: 600">how and when the chain terminates</span>. There are several strategies:</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px">
<div style="background: white; padding: 20px; border-radius: 12px">
<h4 style="color: #166534; margin-top: 0">1. First Match Wins</h4>
<p style="color: #334155; font-size: 0.9rem">Chain stops at the <span style="color: #22c55e; font-weight: 600">first handler that can process</span> the request. Common in routing.</p>
<pre style="background: #f1f5f9; padding: 12px; border-radius: 6px; font-size: 0.8rem; overflow-x: auto"><code>if self.can_handle(request):
  return self.process(request)
return self._next.handle(request)</code></pre>
</div>
<div style="background: white; padding: 20px; border-radius: 12px">
<h4 style="color: #1e40af; margin-top: 0">2. Pipeline (All Process)</h4>
<p style="color: #334155; font-size: 0.9rem"><span style="color: #22c55e; font-weight: 600">Every handler processes</span> and passes along. Chain ends at final handler. Used in middleware.</p>
<pre style="background: #f1f5f9; padding: 12px; border-radius: 6px; font-size: 0.8rem; overflow-x: auto"><code>self.before_processing(request)
  response = self._next.handle(request)
return self.after_processing(response)</code></pre>
</div>
<div style="background: white; padding: 20px; border-radius: 12px">
<h4 style="color: #92400e; margin-top: 0">3. Short-Circuit on Failure</h4>
<p style="color: #334155; font-size: 0.9rem">Chain stops immediately when a handler <span style="color: #22c55e; font-weight: 600">rejects the request</span>. Common in auth/validation.</p>
<pre style="background: #f1f5f9; padding: 12px; border-radius: 6px; font-size: 0.8rem; overflow-x: auto"><code>if not self.is_valid(request):
  return Response(400, "Invalid")
return self._next.handle(request)</code></pre>
</div>
<div style="background: white; padding: 20px; border-radius: 12px">
<h4 style="color: #9d174d; margin-top: 0">4. Default/Fallback Handler</h4>
<p style="color: #334155; font-size: 0.9rem">Chain always ends with a <span style="color: #22c55e; font-weight: 600">guaranteed handler</span> that catches unhandled requests.</p>
<pre style="background: #f1f5f9; padding: 12px; border-radius: 6px; font-size: 0.8rem; overflow-x: auto"><code>class DefaultHandler(Handler):
  def handle(self, request):
return Response(404, "Not Found")</code></pre>
</div>
</div>
</div>
<div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-radius: 12px; padding: 20px; margin: 20px 0">
<h4 style="color: #991b1b; margin-top: 0">Critical Design Decision: What Happens if No Handler Processes?</h4>
<p style="color: #7f1d1d; margin-bottom: 12px">If your chain can potentially have <em>no handler</em> process the request, you MUST handle this case:</p>
<ul style="color: #7f1d1d; margin: 0; padding-left: 20px">
<li><strong>Return null/None:</strong> Client must check and handle gracefully</li>
<li><strong>Throw exception:</strong> Explicit failure, caught at boundary</li>
<li><strong>Default handler:</strong> Catch-all at chain end (recommended)</li>
<li><strong>Return error response:</strong> HTTP 404, gRPC NOT_FOUND, etc.</li>
</ul>
</div>
<hr />
<h2 id="middleware-pattern-the-modern-chain-of-responsibility">Middleware Pattern: The Modern Chain of Responsibility</h2>
<div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<h4 style="color: #22c55e; margin: 0 0 0.75rem 0">Understanding Middleware</h4>
<p style="color: #eee; margin: 0; line-height: 1.6"><span style="color: #22c55e; font-weight: 600">Middleware</span> is Chain of Responsibility applied to HTTP request/response processing. Each middleware wraps the next, creating an "onion" architecture where requests pass inward through layers and responses pass outward through the same layers in reverse. This is the dominant pattern in web frameworks: Express.js, Koa, Django, Spring, ASP.NET Core, and virtually every modern HTTP framework.</p>
</div>
<h3 id="middleware-architecture-diagram">Middleware Architecture Diagram</h3>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 16px; padding: 32px; margin: 24px 0">
<div style="text-align: center; margin-bottom: 24px">
<span style="color: #475569; font-size: 0.9rem; font-weight: 600">The "Onion" Model of Middleware</span>
</div>
<div style="display: flex; justify-content: center; align-items: center">
<div style="position: relative; width: 400px; height: 400px">
  <!-- Outer layer - Logging -->
<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, rgba(78, 205, 196, 0.2) 0%, rgba(78, 205, 196, 0.1) 100%);border-radius: 50%; display: flex; align-items: center; justify-content: center">
<div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #4ecdc4; font-weight: 700; font-size: 0.85rem">LOGGING</div>
</div>
  <!-- Auth layer -->
<div style="position: absolute; top: 40px; left: 40px; right: 40px; bottom: 40px; background: linear-gradient(135deg, rgba(240, 147, 251, 0.2) 0%, rgba(240, 147, 251, 0.1) 100%);border-radius: 50%; display: flex; align-items: center; justify-content: center">
<div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #f093fb; font-weight: 700; font-size: 0.85rem">AUTH</div>
</div>
  <!-- Rate Limit layer -->
<div style="position: absolute; top: 80px; left: 80px; right: 80px; bottom: 80px; background: linear-gradient(135deg, rgba(255, 217, 61, 0.2) 0%, rgba(255, 217, 61, 0.1) 100%);border-radius: 50%; display: flex; align-items: center; justify-content: center">
<div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #ffd93d; font-weight: 700; font-size: 0.85rem">RATE LIMIT</div>
</div>
  <!-- Validation layer -->
<div style="position: absolute; top: 120px; left: 120px; right: 120px; bottom: 120px; background: linear-gradient(135deg, rgba(116, 185, 255, 0.2) 0%, rgba(116, 185, 255, 0.1) 100%);border-radius: 50%; display: flex; align-items: center; justify-content: center">
<div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #74b9ff; font-weight: 700; font-size: 0.85rem">VALIDATION</div>
</div>
  <!-- Core Handler -->
<div style="position: absolute; top: 160px; left: 160px; right: 160px; bottom: 160px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center">
<div style="color: white; font-weight: 700; font-size: 0.9rem; text-align: center">HANDLER<br><span style="font-size: 0.7rem; opacity: 0.8">Business Logic</span></div>
</div>
</div>
</div>
<div style="display: flex; justify-content: center; gap: 24px; margin-top: 24px; flex-wrap: wrap">
<div style="display: flex; align-items: center; gap: 8px">
<div style="width: 20px; height: 3px; background: #22c55e"></div>
<span style="color: #22c55e; font-size: 0.8rem">Request flows inward</span>
</div>
<div style="display: flex; align-items: center; gap: 8px">
<div style="width: 20px; height: 3px; background: #f093fb"></div>
<span style="color: #f093fb; font-size: 0.8rem">Response flows outward</span>
</div>
</div>
</div>
<h3 id="expressjs-vs-python-middleware-comparison">Express.js vs Python Middleware Comparison</h3>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin: 24px 0">
<div style="background: #1a1a2e; border-radius: 12px; padding: 20px">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px">
<div style="background: #f7df1e; color: black; padding: 4px 8px; border-radius: 4px; font-weight: 700; font-size: 0.8rem">JavaScript</div>
<span style="color: #f7df1e; font-weight: 600">Express.js Middleware</span>
</div>
<pre style="background: #0f172a; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; color: #e2e8f0; margin: 0"><code>// Middleware receives (req, res, next)
  function authMiddleware(req, res, next) {
  const token = req.headers.authorization;
<p>if (!validateToken(token)) {<br />
// Short-circuit: don't call next()<br />
return res.status(401).json({<br />
error: 'Unauthorized'<br />
});<br />
}</p>
<p>// Enrich request for downstream<br />
req.user = decodeToken(token);</p>
<p>// Pass to next middleware<br />
next();<br />
}</p>
<p>// Chain order = execution order<br />
app.use(loggingMiddleware);<br />
app.use(authMiddleware);<br />
app.use(rateLimitMiddleware);<br />
app.use('/api', router);</code></pre></p>
</div>
<div style="background: #1a1a2e; border-radius: 12px; padding: 20px">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 16px">
<div style="background: #3776ab; color: white; padding: 4px 8px; border-radius: 4px; font-weight: 700; font-size: 0.8rem">Python</div>
<span style="color: #3776ab; font-weight: 600">Class-Based Handler Chain</span>
</div>
<pre style="background: #0f172a; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; color: #e2e8f0; margin: 0"><code># Handler holds reference to next
  class AuthHandler(Handler):
  def handle(self, request):
  token = request.headers.get("Authorization")
<p>if not self.validate_token(token):</p>
<h1 id="short-circuit-return-without">Short-circuit: return without</h1>
<h1 id="calling-next">calling next</h1>
<p>return Response(<br />
status=401,<br />
body={&quot;error&quot;: &quot;Unauthorized&quot;}<br />
)</p>
<h1 id="enrich-request-for-downstream">Enrich request for downstream</h1>
<p>request.user = self.decode_token(token)</p>
<h1 id="pass-to-next-handler">Pass to next handler</h1>
<p>return self._next.handle(request)</p>
<h1 id="build-chain-via-set-next">Build chain via set_next()</h1>
<p>logging.set_next(auth).set_next(rate_limit)</code></pre></p>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-chain-fundamentals">Interview Deep-Dive: Chain Fundamentals</h2>
<div style="background: #f0f9ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #0369a1; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 1: What is the core problem Chain of Responsibility solves?</div>
<div style="color: #0c4a6e; line-height: 1.7">
<strong>Answer:</strong> It solves the problem of <span style="color: #22c55e; font-weight: 600">coupling the sender of a request to its receiver</span>. Without the pattern, the sender must know exactly which object can handle its request, leading to tight coupling and violations of the Open/Closed Principle.
  <br/><br/>
  With Chain of Responsibility, the sender only knows about a single entry point (the first handler). The chain itself determines which handler(s) process the request. This enables:
<ul style="margin: 8px 0 0 0; padding-left: 20px">
<li>Adding new handlers without modifying sender code</li>
<li>Reordering handlers without modifying sender code</li>
<li>Different chains for different contexts (testing, production)</li>
</ul>
</div>
</div>
<div style="background: #fdf4ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #a21caf; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 2: How does Chain of Responsibility differ from the [[Decorator]](/topic/design-patterns/decorator) pattern? They look structurally similar.</div>
<div style="color: #701a75; line-height: 1.7">
<strong>Answer:</strong> While both patterns involve chaining objects with similar interfaces, they differ in <span style="color: #22c55e; font-weight: 600">intent and behavior</span>:
  <br/><br/>
<strong>Chain of Responsibility:</strong>
<ul style="margin: 4px 0; padding-left: 20px">
<li>Handlers <em>decide</em> whether to process</li>
<li>Request may be handled by zero, one, or many handlers</li>
<li>Chain can be <em>short-circuited</em> at any point</li>
<li>Primary goal: <em>route</em> requests to appropriate handler</li>
</ul>
  <br/>
<strong>[[Decorator]](/topic/design-patterns/decorator):</strong>
<ul style="margin: 4px 0; padding-left: 20px">
<li>Decorators <em>always</em> add behavior</li>
<li>Every decorator in the chain executes</li>
<li>Chain cannot be short-circuited</li>
<li>Primary goal: <em>enhance</em> object capabilities</li>
</ul>
  <br/>
  The key tell: in Decorator, all wrappers execute. In Chain of Responsibility, handlers may pass without processing.
</div>
</div>
<div style="background: #fef2f2; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #b91c1c; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 3: Design a handler chain where handlers can execute in parallel for independent checks, then merge results. What are the tradeoffs?</div>
<div style="color: #7f1d1d; line-height: 1.7">
<strong>Answer:</strong> This is a <span style="color: #22c55e; font-weight: 600">Fan-Out/Fan-In</span> variant of Chain of Responsibility:
<pre><code class="language-python">  class ParallelHandler(Handler):
  def __init__(self, handlers: List[Handler]):
  self._handlers = handlers

  async def handle(self, request):
  # Fan-out: run handlers concurrently
  tasks = [h.handle(request) for h in self._handlers]
  results = await asyncio.gather(*tasks, return_exceptions=True)

  # Fan-in: merge results
  for result in results:
  if isinstance(result, Exception):
  return Response(500, f&quot;Handler failed: {result}&quot;)
  if result.status &gt;= 400:
  return result  # First failure wins

  # All passed, continue chain
  return self._next.handle(request)</code></pre>
<p><strong>Tradeoffs:</strong></p>
<ul style="margin: 8px 0 0 0; padding-left: 20px">
<li><strong>Pro:</strong> Reduced latency when handlers are I/O-bound (auth check + rate limit check in parallel)</li>
<li><strong>Pro:</strong> Better resource utilization under high concurrency</li>
<li><strong>Con:</strong> Wasted work if early handler would have rejected (can't short-circuit)</li>
<li><strong>Con:</strong> Complex error handling - what if 2 of 3 handlers fail?</li>
<li><strong>Con:</strong> Handlers can't enrich request for each other (no data flow between parallel handlers)</li>
<li><strong>Con:</strong> Debugging is harder - non-deterministic execution order</li>
</ul>
<p><strong>When to use:</strong> When handlers are independent, I/O-bound, and rejection is rare. Classic example: validating a request against multiple external services (fraud check, inventory check, payment pre-auth).</p>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-middleware-patterns">Interview Deep-Dive: Middleware Patterns</h2>
<div style="background: #f0f9ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #0369a1; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 1: Why does middleware order matter? Give a concrete example.</div>
<div style="color: #0c4a6e; line-height: 1.7">
<strong>Answer:</strong> Middleware order determines <span style="color: #22c55e; font-weight: 600">which cross-cutting concerns apply to which requests</span> and in what sequence.
  <br/><br/>
<strong>Example - Auth before Rate Limiting:</strong>
      ```
      CORRECT:  Logging -> Auth -> RateLimit -> Handler
      WRONG:    Logging -> RateLimit -> Auth -> Handler
      ```
<p>If rate limiting comes before auth:</p>
<ul style="margin: 4px 0; padding-left: 20px">
<li>Unauthenticated requests consume rate limit quota</li>
<li>Attacker can exhaust rate limit for legitimate users</li>
<li>Rate limits can't be per-user (user unknown yet)</li>
</ul>
<p>Another example - Compression and Encryption:<br />
<code>CORRECT:  Compress -&gt; Encrypt (compress plaintext, then encrypt) WRONG:    Encrypt -&gt; Compress (encrypted data doesn't compress well)</code></p>
</div>
</div>
<div style="background: #fdf4ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #a21caf; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 2: How do you handle errors that occur in the middle of a middleware chain? What about cleanup?</div>
<div style="color: #701a75; line-height: 1.7">
<strong>Answer:</strong> There are three main strategies:
  <br/><br/>
<strong>1. Error Handler Middleware (Recommended):</strong>
  <br/>
  Place an error-catching middleware at the <em>outermost</em> layer:
<pre><code class="language-python">  class ErrorHandlerMiddleware(Handler):
  def handle(self, request):
  try:
  return self._next.handle(request)
  except ValidationError as e:
  return Response(400, {&quot;error&quot;: str(e)})
  except AuthError as e:
  return Response(401, {&quot;error&quot;: str(e)})
  except Exception as e:
  log.exception(&quot;Unhandled error&quot;)
  return Response(500, {&quot;error&quot;: &quot;Internal error&quot;})</code></pre>
<p><strong>2. Result Objects Instead of Exceptions:</strong></p>
<pre><code class="language-python">  @dataclass
  class Result:
  success: bool
  value: Any = None
  error: str = None

  # Handlers return Result, never raise
  def handle(self, request) -&gt; Result:
  if not valid:
  return Result(success=False, error=&quot;Invalid&quot;)
  return self._next.handle(request)</code></pre>
<p><strong>3. Cleanup via Context Managers:</strong></p>
<pre><code class="language-python">  class ResourceHandler(Handler):
  def handle(self, request):
  with self.acquire_resource() as resource:
  request.context[&quot;resource&quot;] = resource
  return self._next.handle(request)
  # Resource automatically cleaned up, even on exception</code></pre>
<p><strong>Best Practice:</strong> Use error middleware at the boundary, Result objects for expected failures, exceptions for unexpected failures.</p>
</div>
</div>
<div style="background: #fef2f2; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #b91c1c; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 3: Design a middleware system that supports both synchronous and asynchronous handlers in the same chain. What are the challenges?</div>
<div style="color: #7f1d1d; line-height: 1.7">
<strong>Answer:</strong> This is a real challenge in mixed codebases. Here's an approach:
<pre><code class="language-python">  import asyncio
  import inspect

  class UnifiedHandler(ABC):
  @abstractmethod
  def handle(self, request) -&gt; Union[Response, Awaitable[Response]]:
  pass

  class ChainRunner:
  def __init__(self, handlers: List[UnifiedHandler]):
  self._handlers = handlers

  async def run_async(self, request) -&gt; Response:
  async def run_handler(handler, req, next_fn):
  # Wrap sync handlers in async
  result = handler.handle(req)
  if inspect.isawaitable(result):
  return await result
  return result

  # Build the chain from end to start
  async def terminal(req):
  return Response(404, &quot;Not Found&quot;)

  chain = terminal
  for handler in reversed(self._handlers):
  prev_chain = chain
  chain = lambda req, h=handler, p=prev_chain: run_handler(h, req, p)

  return await chain(request)

  def run_sync(self, request) -&gt; Response:
  # For sync-only chains, avoid async overhead
  return asyncio.run(self.run_async(request))</code></pre>
<p><strong>Challenges:</strong></p>
<ul style="margin: 8px 0 0 0; padding-left: 20px">
<li><strong>Colored function problem:</strong> Once you have one async handler, the entire chain must be async-aware</li>
<li><strong>Performance:</strong> Wrapping sync handlers in async adds overhead (~1-5 microseconds per handler)</li>
<li><strong>Context propagation:</strong> Python's contextvars work differently in sync vs async</li>
<li><strong>Testing:</strong> Need both sync and async test utilities</li>
<li><strong>Error handling:</strong> Async exceptions behave differently (unhandled exceptions, cancellation)</li>
</ul>
<p><strong>Recommendation:</strong> In new code, go fully async. For legacy, wrap the sync/async boundary at the outermost layer, not per-handler.</p>
<p>See <a href="/topic/system-design/concurrency-patterns">[Concurrency Patterns]</a> for more on async design.</p>
</div>
</div>
<hr />
<h2 id="interview-deep-dive-request-processing">Interview Deep-Dive: Request Processing</h2>
<div style="background: #f0f9ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #0369a1; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 1: How do handlers communicate data to downstream handlers?</div>
<div style="color: #0c4a6e; line-height: 1.7">
<strong>Answer:</strong> The standard approach is <span style="color: #22c55e; font-weight: 600">request enrichment</span> - handlers add data to the request object:
<pre><code class="language-python">  class AuthHandler(Handler):
  def handle(self, request):
  token = request.headers.get(&quot;Authorization&quot;)
  user = self.validate_and_decode(token)

  # Enrich request with user info
  request.user = user
  request.context[&quot;permissions&quot;] = user.permissions
  request.context[&quot;authenticated_at&quot;] = datetime.now()

  return self._next.handle(request)

  class AuthorizationHandler(Handler):
  def handle(self, request):
  # Use data from upstream handler
  if &quot;admin&quot; not in request.context[&quot;permissions&quot;]:
  return Response(403, &quot;Forbidden&quot;)
  return self._next.handle(request)</code></pre>
<p><strong>Alternative approaches:</strong></p>
<ul style="margin: 8px 0 0 0; padding-left: 20px">
<li><strong>Thread-local/Context variables:</strong> Implicit passing (Python's contextvars, Java's ThreadLocal)</li>
<li><strong>Return value chaining:</strong> Each handler returns modified request</li>
<li><strong>Separate context object:</strong> Pass (request, context) tuple through chain</li>
</ul>
</div>
</div>
<div style="background: #fdf4ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #a21caf; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 2: How do you implement request/response transformation in middleware?</div>
<div style="color: #701a75; line-height: 1.7">
<strong>Answer:</strong> The key is that middleware executes <span style="color: #22c55e; font-weight: 600">twice per request</span> - once on the way in, once on the way out:
<pre><code class="language-python">  class CompressionHandler(Handler):
  def handle(self, request):
  # INBOUND: Check if client accepts compression
  accepts_gzip = &quot;gzip&quot; in request.headers.get(&quot;Accept-Encoding&quot;, &quot;&quot;)

  # Pass request to next handler
  response = self._next.handle(request)

  # OUTBOUND: Compress response if client accepts and body is large
  if accepts_gzip and len(response.body) &gt; 1000:
  response.body = gzip.compress(response.body.encode())
  response.headers[&quot;Content-Encoding&quot;] = &quot;gzip&quot;

  return response

  class TimingHandler(Handler):
  def handle(self, request):
  start = time.perf_counter()

  response = self._next.handle(request)

  # Add timing to response headers
  elapsed_ms = (time.perf_counter() - start) * 1000
  response.headers[&quot;X-Response-Time&quot;] = f&quot;{elapsed_ms:.2f}ms&quot;

  return response</code></pre>
<p><strong>Critical insight:</strong> The order of inbound processing is opposite to outbound processing. If chain is A -&gt; B -&gt; C -&gt; Handler:</p>
<ul style="margin: 8px 0 0 0; padding-left: 20px">
<li>Inbound: A's pre-processing, B's pre-processing, C's pre-processing, Handler</li>
<li>Outbound: C's post-processing, B's post-processing, A's post-processing</li>
</ul>
</div>
</div>
<div style="background: #fef2f2; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #b91c1c; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 3: Design a handler that retries failed requests. What invariants must you maintain?</div>
<div style="color: #7f1d1d; line-height: 1.7">
<strong>Answer:</strong> Retry middleware is deceptively complex:
<pre><code class="language-python">  class RetryHandler(Handler):
  def __init__(self, max_retries=3, backoff_ms=100, retryable_statuses={500, 502, 503}):
  self._max_retries = max_retries
  self._backoff_ms = backoff_ms
  self._retryable = retryable_statuses

  def handle(self, request):
  # INVARIANT 1: Must buffer request body (streams can only be read once)
  if hasattr(request, 'body_stream'):
  request.body = request.body_stream.read()

  # INVARIANT 2: Idempotency - only retry safe/idempotent methods
  if request.method not in ('GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE'):
  # POST is not idempotent - don't retry
  return self._next.handle(request)

  last_response = None
  for attempt in range(self._max_retries + 1):
  # INVARIANT 3: Fresh request copy each attempt
  request_copy = self._clone_request(request)

  try:
  response = self._next.handle(request_copy)

  if response.status not in self._retryable:
  return response

  last_response = response

  except TransientError as e:
  # Network errors are retryable
  last_response = Response(503, str(e))

  # INVARIANT 4: Exponential backoff
  if attempt &lt; self._max_retries:
  sleep_ms = self._backoff_ms * (2 ** attempt)
  time.sleep(sleep_ms / 1000)

  # INVARIANT 5: Return last response, not raise
  return last_response</code></pre>
<p><strong>Critical Invariants:</strong></p>
<ol style="margin: 8px 0 0 0; padding-left: 20px">
<li><strong>Body buffering:</strong> Request body streams can only be read once - must buffer before retry</li>
<li><strong>Idempotency:</strong> Only retry idempotent operations (GET, PUT, DELETE). Never blindly retry POST</li>
<li><strong>Request isolation:</strong> Each retry must use a fresh request copy (prevents state leakage)</li>
<li><strong>Backoff:</strong> Exponential backoff prevents thundering herd on recovering service</li>
<li><strong>Timeout budget:</strong> Total retry time must fit within client's timeout</li>
<li><strong>Circuit breaker integration:</strong> Stop retrying if service is known-down (see [[Circuit Breaker]](/topic/system-design/removing-bottlenecks))</li>
</ol>
</div>
</div>
<hr />
<h2 id="real-world-example-authentication-middleware">Real-World Example: Authentication Middleware</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<h3 style="color: #1e293b; margin-top: 0">Complete JWT Authentication Handler</h3>
<p style="color: #334155; margin-bottom: 20px">This example demonstrates a production-quality authentication handler with <span style="color: #22c55e; font-weight: 600">multiple authentication strategies</span>, <span style="color: #22c55e; font-weight: 600">proper error handling</span>, and <span style="color: #22c55e; font-weight: 600">request enrichment</span>.</p>
<pre><code class="language-python">from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
import jwt
import hashlib
import re


@dataclass
class User:
&quot;&quot;&quot;Authenticated user information.&quot;&quot;&quot;
id: str
email: str
roles: List[str] = field(default_factory=list)
metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AuthResult:
&quot;&quot;&quot;Result of authentication attempt.&quot;&quot;&quot;
success: bool
user: Optional[User] = None
error: Optional[str] = None
auth_method: Optional[str] = None


class AuthStrategy(ABC):
&quot;&quot;&quot;Abstract authentication strategy.&quot;&quot;&quot;

@property
@abstractmethod
def name(self) -&gt; str:
pass

@abstractmethod
def authenticate(self, request) -&gt; AuthResult:
pass


class JWTAuthStrategy(AuthStrategy):
&quot;&quot;&quot;JWT Bearer token authentication.&quot;&quot;&quot;

def __init__(self, secret_key: str, algorithms: List[str] = None):
self._secret = secret_key
self._algorithms = algorithms or [&quot;HS256&quot;]

@property
def name(self) -&gt; str:
return &quot;jwt&quot;

def authenticate(self, request) -&gt; AuthResult:
auth_header = request.headers.get(&quot;Authorization&quot;, &quot;&quot;)

if not auth_header.startswith(&quot;Bearer &quot;):
return AuthResult(success=False, error=&quot;Missing Bearer token&quot;)

token = auth_header[7:]  # Strip &quot;Bearer &quot;

try:
payload = jwt.decode(
token,
self._secret,
algorithms=self._algorithms
)

# Validate expiration
if &quot;exp&quot; in payload:
exp = datetime.fromtimestamp(payload[&quot;exp&quot;])
if exp &lt; datetime.now():
return AuthResult(success=False, error=&quot;Token expired&quot;)

user = User(
id=payload.get(&quot;sub&quot;),
email=payload.get(&quot;email&quot;, &quot;&quot;),
roles=payload.get(&quot;roles&quot;, []),
metadata={&quot;token_issued&quot;: payload.get(&quot;iat&quot;)}
)

return AuthResult(success=True, user=user, auth_method=&quot;jwt&quot;)

except jwt.InvalidTokenError as e:
return AuthResult(success=False, error=f&quot;Invalid token: {e}&quot;)


class APIKeyAuthStrategy(AuthStrategy):
&quot;&quot;&quot;API key authentication for service-to-service calls.&quot;&quot;&quot;

def __init__(self, valid_keys: Dict[str, User]):
# Map of API key hash -&gt; User
self._keys = {self._hash_key(k): v for k, v in valid_keys.items()}

@property
def name(self) -&gt; str:
return &quot;api_key&quot;

def _hash_key(self, key: str) -&gt; str:
return hashlib.sha256(key.encode()).hexdigest()

def authenticate(self, request) -&gt; AuthResult:
api_key = request.headers.get(&quot;X-API-Key&quot;)

if not api_key:
return AuthResult(success=False, error=&quot;Missing API key&quot;)

key_hash = self._hash_key(api_key)
user = self._keys.get(key_hash)

if not user:
return AuthResult(success=False, error=&quot;Invalid API key&quot;)

return AuthResult(success=True, user=user, auth_method=&quot;api_key&quot;)


class AuthenticationHandler(Handler):
&quot;&quot;&quot;
Multi-strategy authentication handler.

Tries each authentication strategy in order.
Short-circuits on first successful auth or explicit rejection.
&quot;&quot;&quot;

def __init__(self, strategies: List[AuthStrategy], required: bool = True):
super().__init__()
self._strategies = strategies
self._required = required

def handle(self, request) -&gt; Response:
# Skip auth for certain paths (health checks, public endpoints)
if self._is_public_path(request.path):
return self._pass_to_next(request)

# Try each strategy
for strategy in self._strategies:
result = strategy.authenticate(request)

if result.success:
# Enrich request with user info
request.user = result.user
request.context[&quot;auth_method&quot;] = result.auth_method
request.context[&quot;authenticated&quot;] = True

return self._pass_to_next(request)

# If strategy explicitly rejected (vs just &quot;not applicable&quot;), stop
if self._is_explicit_rejection(result):
return Response(
status=401,
body={&quot;error&quot;: result.error, &quot;auth_method&quot;: strategy.name},
headers={&quot;WWW-Authenticate&quot;: self._get_challenge(strategy)}
)

# No strategy succeeded
if self._required:
return Response(
status=401,
body={&quot;error&quot;: &quot;Authentication required&quot;},
headers={&quot;WWW-Authenticate&quot;: self._get_challenges()}
)

# Auth optional, continue without user
request.context[&quot;authenticated&quot;] = False
return self._pass_to_next(request)

def _is_public_path(self, path: str) -&gt; bool:
public_patterns = [
r&quot;^/health$&quot;,
r&quot;^/metrics$&quot;,
r&quot;^/api/v\d+/public/&quot;,
]
return any(re.match(p, path) for p in public_patterns)

def _is_explicit_rejection(self, result: AuthResult) -&gt; bool:
# Distinguish &quot;wrong credentials&quot; from &quot;no credentials provided&quot;
explicit_errors = [&quot;Invalid token&quot;, &quot;Token expired&quot;, &quot;Invalid API key&quot;]
return result.error and any(e in result.error for e in explicit_errors)

def _get_challenge(self, strategy: AuthStrategy) -&gt; str:
if strategy.name == &quot;jwt&quot;:
return 'Bearer realm=&quot;api&quot;'
return f'{strategy.name} realm=&quot;api&quot;'

def _get_challenges(self) -&gt; str:
return &quot;, &quot;.join(self._get_challenge(s) for s in self._strategies)</code></pre>
</div>
<hr />
<h2 id="real-world-example-logging-middleware">Real-World Example: Logging Middleware</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<h3 style="color: #1e293b; margin-top: 0">Production Logging Handler with Structured Output</h3>
<pre><code class="language-python">import json
import time
import uuid
from dataclasses import dataclass, asdict
from typing import Optional, Dict, Any
from datetime import datetime


@dataclass
class RequestLog:
&quot;&quot;&quot;Structured log entry for request.&quot;&quot;&quot;
timestamp: str
request_id: str
method: str
path: str
query_params: Dict[str, str]
user_id: Optional[str]
user_agent: str
client_ip: str

def to_json(self) -&gt; str:
return json.dumps(asdict(self))


@dataclass
class ResponseLog:
&quot;&quot;&quot;Structured log entry for response.&quot;&quot;&quot;
timestamp: str
request_id: str
status_code: int
duration_ms: float
response_size: int
error: Optional[str]

def to_json(self) -&gt; str:
return json.dumps(asdict(self))


class LoggingHandler(Handler):
&quot;&quot;&quot;
Structured logging middleware with request correlation.

Features:
- Request ID generation/propagation
- Timing measurement
- Structured JSON output
- PII redaction
- Configurable log levels
&quot;&quot;&quot;

SENSITIVE_HEADERS = {&quot;authorization&quot;, &quot;x-api-key&quot;, &quot;cookie&quot;, &quot;set-cookie&quot;}
SENSITIVE_FIELDS = {&quot;password&quot;, &quot;token&quot;, &quot;secret&quot;, &quot;credit_card&quot;}

def __init__(self, logger, log_bodies: bool = False, max_body_size: int = 1000):
super().__init__()
self._logger = logger
self._log_bodies = log_bodies
self._max_body_size = max_body_size

def handle(self, request) -&gt; Response:
# Generate or propagate request ID
request_id = request.headers.get(&quot;X-Request-ID&quot;) or str(uuid.uuid4())
request.context[&quot;request_id&quot;] = request_id

# Capture start time
start_time = time.perf_counter()

# Log inbound request
self._log_request(request, request_id)

try:
# Process rest of chain
response = self._pass_to_next(request)

# Log outbound response
duration_ms = (time.perf_counter() - start_time) * 1000
self._log_response(response, request_id, duration_ms)

# Add correlation headers to response
response.headers[&quot;X-Request-ID&quot;] = request_id
response.headers[&quot;X-Response-Time&quot;] = f&quot;{duration_ms:.2f}ms&quot;

return response

except Exception as e:
# Log error
duration_ms = (time.perf_counter() - start_time) * 1000
self._log_error(request_id, e, duration_ms)
raise

def _log_request(self, request, request_id: str):
log_entry = RequestLog(
timestamp=datetime.utcnow().isoformat() + &quot;Z&quot;,
request_id=request_id,
method=request.method,
path=request.path,
query_params=self._redact_sensitive(dict(getattr(request, 'query', {}))),
user_id=getattr(request, 'user', None) and request.user.id,
user_agent=request.headers.get(&quot;User-Agent&quot;, &quot;&quot;),
client_ip=request.headers.get(&quot;X-Forwarded-For&quot;, &quot;unknown&quot;).split(&quot;,&quot;)[0],
)

self._logger.info(f&quot;REQUEST {log_entry.to_json()}&quot;)

if self._log_bodies and request.body:
safe_body = self._redact_body(request.body)
self._logger.debug(f&quot;REQUEST_BODY request_id={request_id} body={safe_body}&quot;)

def _log_response(self, response, request_id: str, duration_ms: float):
body_size = len(str(response.body)) if response.body else 0

log_entry = ResponseLog(
timestamp=datetime.utcnow().isoformat() + &quot;Z&quot;,
request_id=request_id,
status_code=response.status,
duration_ms=round(duration_ms, 2),
response_size=body_size,
error=response.body.get(&quot;error&quot;) if isinstance(response.body, dict) else None,
)

# Use appropriate log level based on status
if response.status &gt;= 500:
self._logger.error(f&quot;RESPONSE {log_entry.to_json()}&quot;)
elif response.status &gt;= 400:
self._logger.warning(f&quot;RESPONSE {log_entry.to_json()}&quot;)
else:
self._logger.info(f&quot;RESPONSE {log_entry.to_json()}&quot;)

def _log_error(self, request_id: str, error: Exception, duration_ms: float):
self._logger.error(
f&quot;ERROR request_id={request_id} &quot;
f&quot;duration_ms={duration_ms:.2f} &quot;
f&quot;error_type={type(error).__name__} &quot;
f&quot;error_message={str(error)}&quot;
)

def _redact_sensitive(self, data: Dict[str, Any]) -&gt; Dict[str, Any]:
&quot;&quot;&quot;Redact sensitive fields from dictionaries.&quot;&quot;&quot;
return {
k: &quot;[REDACTED]&quot; if k.lower() in self.SENSITIVE_FIELDS else v
for k, v in data.items()
}

def _redact_body(self, body: Any) -&gt; str:
&quot;&quot;&quot;Redact and truncate request/response bodies.&quot;&quot;&quot;
if isinstance(body, dict):
safe_body = self._redact_sensitive(body)
body_str = json.dumps(safe_body)
else:
body_str = str(body)

if len(body_str) &gt; self._max_body_size:
return body_str[:self._max_body_size] + &quot;...[TRUNCATED]&quot;
return body_str</code></pre>
</div>
<hr />
<h2 id="python-implementation-complete-middleware-chain">Python Implementation: Complete Middleware Chain</h2>
<h3 id="http-middleware-chain">HTTP Middleware Chain</h3>
<pre><code class="language-python">from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, Callable, List
from datetime import datetime
import json
import time


@dataclass
class Request:
&quot;&quot;&quot;HTTP-like request object.&quot;&quot;&quot;
path: str
method: str
headers: Dict[str, str] = field(default_factory=dict)
body: Optional[Any] = None
user: Optional[str] = None
context: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Response:
&quot;&quot;&quot;HTTP-like response object.&quot;&quot;&quot;
status: int
body: Any
headers: Dict[str, str] = field(default_factory=dict)


class Handler(ABC):
&quot;&quot;&quot;
Base handler in the chain.
Each handler can process the request and/or pass to next.
&quot;&quot;&quot;

def __init__(self):
self._next: Optional['Handler'] = None

def set_next(self, handler: 'Handler') -&gt; 'Handler':
&quot;&quot;&quot;Set the next handler and return it for chaining.&quot;&quot;&quot;
self._next = handler
return handler

def handle(self, request: Request) -&gt; Optional[Response]:
&quot;&quot;&quot;Process request. Override in subclasses.&quot;&quot;&quot;
return self._pass_to_next(request)

def _pass_to_next(self, request: Request) -&gt; Optional[Response]:
&quot;&quot;&quot;Pass request to next handler in chain.&quot;&quot;&quot;
if self._next:
return self._next.handle(request)
return None


class AuthenticationHandler(Handler):
&quot;&quot;&quot;Verify authentication token.&quot;&quot;&quot;

def __init__(self, valid_tokens: set = None):
super().__init__()
self.valid_tokens = valid_tokens or {&quot;token123&quot;, &quot;admin_token&quot;}

def handle(self, request: Request) -&gt; Optional[Response]:
auth_header = request.headers.get(&quot;Authorization&quot;, &quot;&quot;)

if not auth_header.startswith(&quot;Bearer &quot;):
return Response(
status=401,
body={&quot;error&quot;: &quot;Missing or invalid Authorization header&quot;}
)

token = auth_header.split(&quot; &quot;)[1]
if token not in self.valid_tokens:
return Response(
status=401,
body={&quot;error&quot;: &quot;Invalid token&quot;}
)

# Set user info for downstream handlers
request.user = f&quot;user_{token[:5]}&quot;
request.context[&quot;authenticated&quot;] = True

return self._pass_to_next(request)


class RateLimitHandler(Handler):
&quot;&quot;&quot;Limit requests per user/IP.&quot;&quot;&quot;

def __init__(self, max_requests: int = 100, window_seconds: int = 60):
super().__init__()
self.max_requests = max_requests
self.window_seconds = window_seconds
self._request_counts: Dict[str, List[float]] = {}

def handle(self, request: Request) -&gt; Optional[Response]:
identifier = request.user or request.headers.get(&quot;X-Forwarded-For&quot;, &quot;unknown&quot;)
current_time = time.time()

# Get or create request history
if identifier not in self._request_counts:
self._request_counts[identifier] = []

# Remove old requests outside window
cutoff = current_time - self.window_seconds
self._request_counts[identifier] = [
t for t in self._request_counts[identifier] if t &gt; cutoff
]

# Check rate limit
if len(self._request_counts[identifier]) &gt;= self.max_requests:
return Response(
status=429,
body={&quot;error&quot;: &quot;Rate limit exceeded&quot;},
headers={&quot;Retry-After&quot;: str(self.window_seconds)}
)

# Record this request
self._request_counts[identifier].append(current_time)
request.context[&quot;rate_limit_remaining&quot;] = (
self.max_requests - len(self._request_counts[identifier])
)

return self._pass_to_next(request)


class ValidationHandler(Handler):
&quot;&quot;&quot;Validate request data.&quot;&quot;&quot;

def handle(self, request: Request) -&gt; Optional[Response]:
# POST/PUT requests should have a body
if request.method in (&quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;):
if not request.body:
return Response(
status=400,
body={&quot;error&quot;: &quot;Request body required&quot;}
)

# Validate JSON if Content-Type indicates JSON
content_type = request.headers.get(&quot;Content-Type&quot;, &quot;&quot;)
if &quot;application/json&quot; in content_type:
if not isinstance(request.body, (dict, list)):
return Response(
status=400,
body={&quot;error&quot;: &quot;Invalid JSON body&quot;}
)

return self._pass_to_next(request)


class LoggingHandler(Handler):
&quot;&quot;&quot;Log request and response details.&quot;&quot;&quot;

def handle(self, request: Request) -&gt; Optional[Response]:
start_time = time.time()

# Log incoming request
print(f&quot;[{datetime.now().isoformat()}] --&gt; {request.method} {request.path}&quot;)
print(f&quot;    User: {request.user or 'anonymous'}&quot;)

# Process rest of chain
response = self._pass_to_next(request)

# Log response
duration_ms = (time.time() - start_time) * 1000
status = response.status if response else &quot;NO_RESPONSE&quot;
print(f&quot;[{datetime.now().isoformat()}] &lt;-- {status} ({duration_ms:.2f}ms)&quot;)

return response


class CORSHandler(Handler):
&quot;&quot;&quot;Handle Cross-Origin Resource Sharing.&quot;&quot;&quot;

def __init__(self, allowed_origins: List[str] = None):
super().__init__()
self.allowed_origins = allowed_origins or [&quot;*&quot;]

def handle(self, request: Request) -&gt; Optional[Response]:
origin = request.headers.get(&quot;Origin&quot;, &quot;&quot;)

# Handle preflight OPTIONS request
if request.method == &quot;OPTIONS&quot;:
return Response(
status=204,
body=None,
headers={
&quot;Access-Control-Allow-Origin&quot;: self._get_allowed_origin(origin),
&quot;Access-Control-Allow-Methods&quot;: &quot;GET, POST, PUT, DELETE, OPTIONS&quot;,
&quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type, Authorization&quot;,
&quot;Access-Control-Max-Age&quot;: &quot;86400&quot;
}
)

# Add CORS headers for regular requests
response = self._pass_to_next(request)
if response:
response.headers[&quot;Access-Control-Allow-Origin&quot;] = self._get_allowed_origin(origin)

return response

def _get_allowed_origin(self, origin: str) -&gt; str:
if &quot;*&quot; in self.allowed_origins:
return &quot;*&quot;
if origin in self.allowed_origins:
return origin
return self.allowed_origins[0] if self.allowed_origins else &quot;&quot;


class RoutingHandler(Handler):
&quot;&quot;&quot;Route requests to appropriate handlers.&quot;&quot;&quot;

def __init__(self):
super().__init__()
self._routes: Dict[str, Dict[str, Callable]] = {}

def route(self, path: str, method: str, handler: Callable):
&quot;&quot;&quot;Register a route handler.&quot;&quot;&quot;
if path not in self._routes:
self._routes[path] = {}
self._routes[path][method] = handler

def handle(self, request: Request) -&gt; Optional[Response]:
# Find matching route
path_handlers = self._routes.get(request.path)
if not path_handlers:
return Response(status=404, body={&quot;error&quot;: &quot;Not found&quot;})

method_handler = path_handlers.get(request.method)
if not method_handler:
return Response(
status=405,
body={&quot;error&quot;: &quot;Method not allowed&quot;},
headers={&quot;Allow&quot;: &quot;, &quot;.join(path_handlers.keys())}
)

# Execute route handler
try:
return method_handler(request)
except Exception as e:
return Response(
status=500,
body={&quot;error&quot;: str(e)}
)


# Build the middleware chain
def create_app():
&quot;&quot;&quot;Create application with middleware chain.&quot;&quot;&quot;

# Create handlers
logging = LoggingHandler()
cors = CORSHandler(allowed_origins=[&quot;https://example.com&quot;, &quot;http://localhost:3000&quot;])
auth = AuthenticationHandler()
rate_limit = RateLimitHandler(max_requests=10, window_seconds=60)
validation = ValidationHandler()
router = RoutingHandler()

# Build chain: logging -&gt; cors -&gt; auth -&gt; rate_limit -&gt; validation -&gt; router
logging.set_next(cors).set_next(auth).set_next(rate_limit).set_next(validation).set_next(router)

# Register routes
router.route(&quot;/api/users&quot;, &quot;GET&quot;, lambda req: Response(
status=200,
body={&quot;users&quot;: [{&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;}, {&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;}]}
))

router.route(&quot;/api/users&quot;, &quot;POST&quot;, lambda req: Response(
status=201,
body={&quot;created&quot;: req.body, &quot;id&quot;: 3}
))

return logging  # Return first handler in chain


# Usage
app = create_app()

print(&quot;=== Test 1: Valid GET request ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;GET&quot;,
headers={&quot;Authorization&quot;: &quot;Bearer token123&quot;}
))
print(f&quot;Response: {response}\n&quot;)

print(&quot;=== Test 2: Missing auth ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;GET&quot;,
headers={}
))
print(f&quot;Response: {response}\n&quot;)

print(&quot;=== Test 3: POST with body ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;POST&quot;,
headers={
&quot;Authorization&quot;: &quot;Bearer token123&quot;,
&quot;Content-Type&quot;: &quot;application/json&quot;
},
body={&quot;name&quot;: &quot;Charlie&quot;, &quot;email&quot;: &quot;charlie@example.com&quot;}
))
print(f&quot;Response: {response}\n&quot;)

print(&quot;=== Test 4: POST without body ===&quot;)
response = app.handle(Request(
path=&quot;/api/users&quot;,
method=&quot;POST&quot;,
headers={
&quot;Authorization&quot;: &quot;Bearer token123&quot;,
&quot;Content-Type&quot;: &quot;application/json&quot;
}
))
print(f&quot;Response: {response}\n&quot;)
</code></pre>
<hr />
<h2 id="chain-of-responsibility-vs-related-patterns">Chain of Responsibility vs Related Patterns</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 16px; padding: 28px; margin: 24px 0">
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px">
<div style="background: #dbeafe; padding: 20px; border-radius: 12px">
<h4 style="color: #1e40af; margin-top: 0">Chain of Responsibility</h4>
<p style="color: #1e3a8a; font-size: 0.9rem; margin-bottom: 12px">Passes request through handlers until processed.</p>
<div style="background: #eff6ff; padding: 12px; border-radius: 6px; font-size: 0.85rem">
<strong style="color: #1e40af">Handler decides:</strong> <span style="color: #1e3a8a">Process or pass</span><br>
<strong style="color: #1e40af">Result:</strong> <span style="color: #1e3a8a">0, 1, or many handlers process</span>
</div>
</div>
<div style="background: #dcfce7; padding: 20px; border-radius: 12px">
<h4 style="color: #166534; margin-top: 0">[[Decorator]](/topic/design-patterns/decorator)</h4>
<p style="color: #14532d; font-size: 0.9rem; margin-bottom: 12px">Wraps objects to add behavior.</p>
<div style="background: #f0fdf4; padding: 12px; border-radius: 6px; font-size: 0.85rem">
<strong style="color: #166534">All decorators:</strong> <span style="color: #14532d">Always execute</span><br>
<strong style="color: #166534">Result:</strong> <span style="color: #14532d">All enhance the object</span>
</div>
</div>
<div style="background: #fef3c7; padding: 20px; border-radius: 12px">
<h4 style="color: #92400e; margin-top: 0">[[Command]](/topic/design-patterns/command)</h4>
<p style="color: #78350f; font-size: 0.9rem; margin-bottom: 12px">Encapsulates request as object.</p>
<div style="background: #fffbeb; padding: 12px; border-radius: 6px; font-size: 0.85rem">
<strong style="color: #92400e">Request is:</strong> <span style="color: #78350f">Stored/queued</span><br>
<strong style="color: #92400e">Handler:</strong> <span style="color: #78350f">Known in advance</span>
</div>
</div>
<div style="background: #fce7f3; padding: 20px; border-radius: 12px">
<h4 style="color: #9d174d; margin-top: 0">[[Strategy]](/topic/design-patterns/strategy)</h4>
<p style="color: #831843; font-size: 0.9rem; margin-bottom: 12px">Selects one algorithm at runtime.</p>
<div style="background: #fdf2f8; padding: 12px; border-radius: 6px; font-size: 0.85rem">
<strong style="color: #9d174d">Selection:</strong> <span style="color: #831843">Explicit, single</span><br>
<strong style="color: #9d174d">Result:</strong> <span style="color: #831843">Exactly one strategy runs</span>
</div>
</div>
</div>
<div style="background: #f1f5f9; padding: 16px; border-radius: 8px; margin-top: 20px">
<strong style="color: #0f172a">Quick Decision Guide:</strong>
<ul style="color: #334155; margin-bottom: 0">
<li><strong>Chain of Responsibility:</strong> "I don't know who should handle this - let the chain decide"</li>
<li><strong>[[Decorator]](/topic/design-patterns/decorator):</strong> "I want to add features to this object"</li>
<li><strong>[[Command]](/topic/design-patterns/command):</strong> "I want to parameterize, queue, or log operations"</li>
<li><strong>[[Strategy]](/topic/design-patterns/strategy):</strong> "I want to swap algorithms without changing context"</li>
</ul>
</div>
</div>
<hr />
<h2 id="common-mistakes-and-anti-patterns">Common Mistakes and Anti-Patterns</h2>
<div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-radius: 12px; padding: 24px; margin: 20px 0">
<h3 id="mistake-1-forgetting-default-handler">Mistake 1: Forgetting Default Handler</h3>
<pre><code class="language-python">        # BAD: Request might not be handled
        chain = auth.set_next(validation).set_next(router)
        response = chain.handle(request)  # Could be None!

        # GOOD: Always have a fallback
        class NotFoundHandler(Handler):
        def handle(self, request):
        return Response(status=404, body={&quot;error&quot;: &quot;Not found&quot;})

        chain = auth.set_next(validation).set_next(router).set_next(NotFoundHandler())</code></pre>
<h3 id="mistake-2-circular-chain">Mistake 2: Circular Chain</h3>
<pre><code class="language-python">        # BAD: Infinite loop!
        handler_a.set_next(handler_b)
        handler_b.set_next(handler_a)  # Circular!

        # GOOD: Linear chain with termination
        handler_a.set_next(handler_b).set_next(handler_c)  # Ends at c</code></pre>
<h3 id="mistake-3-order-dependent-hidden-bugs">Mistake 3: Order-Dependent Hidden Bugs</h3>
<pre><code class="language-python">        # BAD: Auth after rate limit - can rate limit unauthenticated requests
        chain = rate_limit.set_next(auth)

        # GOOD: Auth before rate limit - rate limit per authenticated user
        chain = auth.set_next(rate_limit)</code></pre>
<h3 id="mistake-4-handlers-modifying-shared-state">Mistake 4: Handlers Modifying Shared State</h3>
<pre><code class="language-python">        # BAD: Handler modifies shared request object, affects other chains
        class BadHandler(Handler):
        def handle(self, request):
        request.headers[&quot;X-Modified&quot;] = &quot;true&quot;  # Mutates original!
        return self._pass_to_next(request)

        # GOOD: Create a copy if you need to modify
        class GoodHandler(Handler):
        def handle(self, request):
        enriched = Request(
        path=request.path,
        method=request.method,
        headers={**request.headers, &quot;X-Modified&quot;: &quot;true&quot;},
        body=request.body
        )
        return self._pass_to_next(enriched)</code></pre>
<h3 id="mistake-5-not-handling-exceptions">Mistake 5: Not Handling Exceptions</h3>
<pre><code class="language-python">        # BAD: Exception in handler breaks entire chain
        class FragileHandler(Handler):
        def handle(self, request):
        data = json.loads(request.body)  # Could raise!
        return self._pass_to_next(request)

        # GOOD: Wrap in error handling or use error middleware
        class RobustHandler(Handler):
        def handle(self, request):
        try:
        data = json.loads(request.body)
        except json.JSONDecodeError as e:
        return Response(400, {&quot;error&quot;: f&quot;Invalid JSON: {e}&quot;})
        return self._pass_to_next(request)</code></pre>
</div>
<hr />
<h2 id="interview-deep-dive-advanced-scenarios">Interview Deep-Dive: Advanced Scenarios</h2>
<div style="background: #f0f9ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #0369a1; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 1: How would you implement chain configuration that can be changed at runtime?</div>
<div style="color: #0c4a6e; line-height: 1.7">
<strong>Answer:</strong> Use a <span style="color: #22c55e; font-weight: 600">ChainBuilder</span> pattern that reconstructs the chain when configuration changes:
<pre><code class="language-python">          class ChainBuilder:
          def __init__(self):
          self._handlers = []

          def add(self, handler: Handler) -&gt; 'ChainBuilder':
          self._handlers.append(handler)
          return self

          def add_if(self, condition: bool, handler: Handler) -&gt; 'ChainBuilder':
          if condition:
          self._handlers.append(handler)
          return self

          def build(self) -&gt; Handler:
          if not self._handlers:
          raise ValueError(&quot;Chain must have at least one handler&quot;)

          for i in range(len(self._handlers) - 1):
          self._handlers[i].set_next(self._handlers[i + 1])

          return self._handlers[0]

          # Usage with runtime configuration
          def build_chain(config: dict) -&gt; Handler:
          builder = ChainBuilder()

          if config.get(&quot;enable_logging&quot;):
          builder.add(LoggingHandler())

          if config.get(&quot;require_auth&quot;):
          builder.add(AuthHandler())

          if config.get(&quot;rate_limit&quot;):
          builder.add(RateLimitHandler(
          max_requests=config[&quot;rate_limit&quot;][&quot;max&quot;],
          window_seconds=config[&quot;rate_limit&quot;][&quot;window&quot;]
          ))

          builder.add(ValidationHandler())
          builder.add(RouterHandler())

          return builder.build()</code></pre>
</div>
</div>
<div style="background: #fdf4ff; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #a21caf; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 2: How would you implement branching chains where a handler can route to different sub-chains?</div>
<div style="color: #701a75; line-height: 1.7">
<strong>Answer:</strong> Implement a <span style="color: #22c55e; font-weight: 600">CompositeHandler</span> that routes to sub-chains based on conditions:
<pre><code class="language-python">          class BranchingHandler(Handler):
          &quot;&quot;&quot;Routes to different chains based on request properties.&quot;&quot;&quot;

          def __init__(self):
          super().__init__()
          self._branches: Dict[str, Handler] = {}
          self._default: Optional[Handler] = None

          def add_branch(self, condition: str, chain: Handler) -&gt; 'BranchingHandler':
          self._branches[condition] = chain
          return self

          def set_default(self, chain: Handler) -&gt; 'BranchingHandler':
          self._default = chain
          return self

          def handle(self, request: Request) -&gt; Response:
          # Route based on path prefix
          for prefix, chain in self._branches.items():
          if request.path.startswith(prefix):
          return chain.handle(request)

          if self._default:
          return self._default.handle(request)

          return Response(404, {&quot;error&quot;: &quot;No matching route&quot;})

          # Usage: Different chains for different API versions
          branching = BranchingHandler()
          branching.add_branch(&quot;/api/v1/&quot;, v1_chain)
          branching.add_branch(&quot;/api/v2/&quot;, v2_chain)
          branching.add_branch(&quot;/internal/&quot;, internal_chain)
          branching.set_default(public_chain)</code></pre>
<p>This enables <span style="color: #22c55e; font-weight: 600">tree-like routing</span> where different paths get different middleware stacks.</p>
</div>
</div>
<div style="background: #fef2f2; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #b91c1c; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Level 3: Design a handler chain that supports transactional semantics - if any handler fails, all previous handlers' effects are rolled back.</div>
<div style="color: #7f1d1d; line-height: 1.7">
<strong>Answer:</strong> This requires a <span style="color: #22c55e; font-weight: 600">Saga-like pattern</span> with compensating actions:
<pre><code class="language-python">          from typing import Callable, List, Tuple
          from contextlib import contextmanager

          class TransactionalHandler(Handler):
          &quot;&quot;&quot;Handler that supports rollback on downstream failures.&quot;&quot;&quot;

          @abstractmethod
          def execute(self, request: Request) -&gt; Request:
          &quot;&quot;&quot;Forward action - modify request/state.&quot;&quot;&quot;
          pass

          @abstractmethod
          def compensate(self, request: Request, error: Exception):
          &quot;&quot;&quot;Rollback action - undo changes on failure.&quot;&quot;&quot;
          pass

          def handle(self, request: Request) -&gt; Response:
          try:
          # Execute forward action
          modified_request = self.execute(request)

          # Pass to next handler
          response = self._pass_to_next(modified_request)

          # If downstream failed, compensate
          if response and response.status &gt;= 500:
          self.compensate(request, Exception(f&quot;Downstream error: {response.status}&quot;))

          return response

          except Exception as e:
          # Compensate on exception
          self.compensate(request, e)
          raise


          class SagaCoordinator(Handler):
          &quot;&quot;&quot;Coordinates transactional chain with compensation.&quot;&quot;&quot;

          def __init__(self, handlers: List[TransactionalHandler]):
          super().__init__()
          self._handlers = handlers

          def handle(self, request: Request) -&gt; Response:
          executed: List[Tuple[TransactionalHandler, Request]] = []
          current_request = request

          try:
          # Execute each handler
          for handler in self._handlers:
          current_request = handler.execute(current_request)
          executed.append((handler, current_request))

          return Response(200, {&quot;status&quot;: &quot;committed&quot;})

          except Exception as e:
          # Compensate in reverse order
          for handler, req in reversed(executed):
          try:
          handler.compensate(req, e)
          except Exception as comp_error:
          # Log but continue compensating
          logging.error(f&quot;Compensation failed: {comp_error}&quot;)

          return Response(500, {&quot;error&quot;: str(e), &quot;status&quot;: &quot;rolled_back&quot;})


          # Example: Transactional order processing
          class ReserveInventoryHandler(TransactionalHandler):
          def execute(self, request):
          item_id = request.body[&quot;item_id&quot;]
          self._inventory_service.reserve(item_id)
          request.context[&quot;inventory_reserved&quot;] = item_id
          return request

          def compensate(self, request, error):
          item_id = request.context.get(&quot;inventory_reserved&quot;)
          if item_id:
          self._inventory_service.release(item_id)

          class ChargePaymentHandler(TransactionalHandler):
          def execute(self, request):
          charge = self._payment_service.charge(
          request.body[&quot;amount&quot;],
          request.body[&quot;payment_method&quot;]
          )
          request.context[&quot;charge_id&quot;] = charge.id
          return request

          def compensate(self, request, error):
          charge_id = request.context.get(&quot;charge_id&quot;)
          if charge_id:
          self._payment_service.refund(charge_id)</code></pre>
<p><strong>Key considerations:</strong></p>
<ul style="margin: 8px 0 0 0; padding-left: 20px">
<li><strong>Compensation order matters:</strong> Compensate in reverse order of execution</li>
<li><strong>Compensation can fail:</strong> Need strategy for partial compensation failures</li>
<li><strong>Idempotency:</strong> Compensations must be idempotent (may run multiple times)</li>
<li><strong>State tracking:</strong> Must track what was done to know what to undo</li>
<li><strong>Timeout handling:</strong> What if compensation takes too long?</li>
</ul>
<p>See <a href="/topic/system-design/event-sourcing">[Event Sourcing]</a> and <a href="/topic/microservices/event-strategies">[Distributed Transactions]</a> for related patterns.</p>
</div>
</div>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<div style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border-radius: 12px; padding: 24px; margin: 20px 0">
<ol>
<li>
<p><strong><span style="color: #22c55e">Decouples Sender from Receiver</span></strong> - Sender doesn't know which handler will process the request</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Dynamic Handler Selection</span></strong> - Chain determines the right handler at runtime</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Single Responsibility</span></strong> - Each handler focuses on one concern (auth, logging, validation)</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Order Matters</span></strong> - Handler sequence affects behavior (always auth before rate limit)</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Always Have a Default</span></strong> - Ensure requests don't fall through unhandled</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Pipeline vs First-Match</span></strong> - Understand whether all handlers should execute or just the first match</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Request Enrichment</span></strong> - Upstream handlers add context for downstream handlers</p>
</li>
<li>
<p><strong><span style="color: #22c55e">Error Handling Strategy</span></strong> - Plan for failures at any point in the chain</p>
</li>
</ol>
</div>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<pre><code>      - [[Command]](/topic/design-patterns/command) - Encapsulates requests as objects for queuing, logging, undo
      - [[Decorator]](/topic/design-patterns/decorator) - Similar structure but all decorators always execute
      - [[Composite]](/topic/design-patterns/composite) - Can form tree of handlers for complex routing
      - [[Strategy]](/topic/design-patterns/strategy) - Single handler selection vs chain of handlers
      - [[Observer]](/topic/design-patterns/observer) - Multiple handlers notified of events (broadcast vs chain)
      - [[Mediator]](/topic/design-patterns/mediator) - Centralizes complex communications between objects
</code></pre>
