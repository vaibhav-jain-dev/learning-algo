<style>
/* Mobile-specific styles for iPhone 15 and similar devices */
@media screen and (max-width: 480px) {
    /* Force all grid layouts to single column */
    [style*="grid-template-columns"] {
        display: block !important;
    }
    [style*="grid-template-columns"] > div {
        margin-bottom: 16px !important;
    }
    /* Adjust padding for mobile */
    [style*="padding: 32px"],
    [style*="padding: 24px"] {
        padding: 16px !important;
    }
    /* Smaller headings */
    h4[style*="font-size: 18px"],
    h4[style*="font-size: 16px"] {
        font-size: 15px !important;
    }
    /* Readable font sizes */
    [style*="font-size: 13px"],
    [style*="font-size: 12px"],
    [style*="font-size: 11px"],
    [style*="font-size: 10px"] {
        font-size: 13px !important;
        line-height: 1.6 !important;
    }
    /* Flex containers stack vertically */
    [style*="display: flex"][style*="gap"] {
        flex-direction: column !important;
    }
    /* Better spacing for nested content */
    [style*="padding-left: 64px"],
    [style*="padding-left: 48px"],
    [style*="padding-left: 40px"] {
        padding-left: 16px !important;
    }
    /* Code blocks */
    pre {
        font-size: 12px !important;
        padding: 12px !important;
        overflow-x: auto !important;
    }
    pre code {
        font-size: 12px !important;
    }
    /* Tables */
    table {
        font-size: 12px !important;
        display: block !important;
        overflow-x: auto !important;
    }
    th, td {
        padding: 8px !important;
        font-size: 12px !important;
    }
}
</style>
<h1 id="state-pattern">State Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The State pattern allows an object to alter its behavior when its internal state changes, making it appear as if the object changed its class. Rather than scattering conditional logic throughout your code, you encapsulate state-specific behavior in separate state classes, delegating all state-dependent operations to the current state object.</p>
<p><strong>Difficulty:</strong> Intermediate to Advanced<br />
<strong>Category:</strong> Behavioral Pattern<br />
<strong>Also Known As:</strong> Objects for States, Finite State Machine Pattern</p>
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; color: white">
<div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 0.75rem">Core Insight</div>
<div style="font-size: 0.95rem; line-height: 1.6">
    The State pattern transforms conditional behavior into polymorphic behavior. Instead of asking "what state am I in?" before every operation, you delegate to an object that <em>embodies</em> that state. The state object knows exactly what to do because it <em>is</em> the state.
</div>
</div>
<hr />
<h2 id="internal-mechanisms-and-architecture">Internal Mechanisms and Architecture</h2>
<h3 id="the-delegation-chain">The Delegation Chain</h3>
<p>At its core, the State pattern operates through a delegation chain:</p>
<ol>
<li><strong>Client</strong> calls a method on the <strong>Context</strong></li>
<li><strong>Context</strong> delegates to its current <strong>State</strong> object</li>
<li><strong>State</strong> executes behavior and potentially triggers a <strong>transition</strong></li>
<li><strong>Transition</strong> replaces the Context's state reference</li>
</ol>
<div style="background: #f8fafc; border-radius: 12px; padding: 2rem; margin: 2rem 0">
<div style="text-align: center; margin-bottom: 1.5rem; color: #1e293b; font-weight: 700; font-size: 1.1rem">State Pattern Execution Flow</div>
<div style="display: flex; flex-direction: column; gap: 1rem">
<div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap">
<div style="background: #dbeafe; padding: 0.75rem 1.25rem; border-radius: 8px; font-weight: 600; color: #1e40af;min-width: 100px; text-align: center">Client</div>
<div style="color: #64748b; font-size: 0.9rem">--request()--></div>
<div style="background: #dcfce7; padding: 0.75rem 1.25rem; border-radius: 8px; font-weight: 600; color: #166534;min-width: 100px; text-align: center">Context</div>
<div style="color: #64748b; font-size: 0.9rem">--handle()--></div>
<div style="background: #fef3c7; padding: 0.75rem 1.25rem; border-radius: 8px; font-weight: 600; color: #92400e;min-width: 100px; text-align: center">State</div>
</div>
<div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; margin-left: 2rem">
<div style="color: #64748b; font-size: 0.9rem">State executes behavior, may call:</div>
<div style="background: #fce7f3; padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.85rem; color: #9d174d">context.setState(newState)</div>
</div>
</div>
</div>
<h3 id="memory-layout-and-object-relationships">Memory Layout and Object Relationships</h3>
<div style="background: #1e293b; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; color: #e2e8f0; font-family: monospace; font-size: 0.9rem; line-height: 1.6">
<div style="color: #94a3b8; margin-bottom: 0.5rem">// Memory perspective</div>
<div>Context object:</div>
<div style="margin-left: 1rem">
<span style="color: #7dd3fc">_state</span>: <span style="color: #fde047">reference</span> --> State object in heap<br>
<span style="color: #7dd3fc">data</span>: context-specific data (order details, etc.)
</div>
<div style="margin-top: 1rem">State objects can be:</div>
<div style="margin-left: 1rem">
<span style="color: #4ade80">Flyweight</span>: Shared singleton (stateless states)<br>
<span style="color: #fb923c">Instance</span>: Per-context (stateful states with state-specific data)
</div>
</div>
<div style="background: #fffbeb;border-radius: 0 8px 8px 0; padding: 1rem 1.25rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #92400e; margin-bottom: 0.5rem">Critical Design Decision: Stateful vs Stateless States</div>
<div style="color: #78350f; font-size: 0.9rem; line-height: 1.6">
<strong>Stateless states</strong> contain no instance data and can be shared across contexts (flyweight pattern). This reduces memory but requires all state-specific data to live in the Context.
  <br><br>
<strong>Stateful states</strong> carry their own data (e.g., retry count, timeout timestamp). This encapsulates state-specific data but requires creating new state instances on each transition.
</div>
</div>
<hr />
<h2 id="state-vs-strategy-pattern">State vs Strategy Pattern</h2>
<p>This is one of the most common interview questions because the patterns are structurally identical but semantically different.</p>
<div style="display: flex; gap: 1.5rem; margin: 1.5rem 0; flex-wrap: wrap">
<div style="flex: 1; min-width: 300px; background: linear-gradient(180deg, #dbeafe 0%, #eff6ff 100%); border-radius: 12px; padding: 1.5rem">
<div style="font-weight: 700; font-size: 1.1rem; color: #1e40af; margin-bottom: 1rem; text-align: center;padding-bottom: 0.75rem">STATE PATTERN</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem">Intent:</div>
<div style="color: #1e3a8a; font-size: 0.9rem">Allow object to change behavior based on internal state changes</div>
</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem">Who Controls Transitions:</div>
<div style="color: #1e3a8a; font-size: 0.9rem">State objects or Context (internal)</div>
</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem">State Awareness:</div>
<div style="color: #1e3a8a; font-size: 0.9rem">States often know about other states for transitions</div>
</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem">Lifecycle:</div>
<div style="color: #1e3a8a; font-size: 0.9rem">States change throughout object lifetime automatically</div>
</div>
<div style="background: #bfdbfe; border-radius: 8px; padding: 0.75rem; font-size: 0.85rem; color: #1e40af">
<strong>Question answered:</strong> "What can I do right now?"
</div>
</div>
<div style="flex: 1; min-width: 300px; background: linear-gradient(180deg, #dcfce7 0%, #f0fdf4 100%); border-radius: 12px; padding: 1.5rem">
<div style="font-weight: 700; font-size: 1.1rem; color: #166534; margin-bottom: 1rem; text-align: center;padding-bottom: 0.75rem">STRATEGY PATTERN</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Intent:</div>
<div style="color: #14532d; font-size: 0.9rem">Allow client to choose algorithm at runtime</div>
</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Who Controls Selection:</div>
<div style="color: #14532d; font-size: 0.9rem">Client code (external)</div>
</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Strategy Awareness:</div>
<div style="color: #14532d; font-size: 0.9rem">Strategies are completely independent of each other</div>
</div>
<div style="margin-bottom: 1rem">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Lifecycle:</div>
<div style="color: #14532d; font-size: 0.9rem">Strategy typically set once or changed explicitly by client</div>
</div>
<div style="background: #bbf7d0; border-radius: 8px; padding: 0.75rem; font-size: 0.85rem; color: #166534">
<strong>Question answered:</strong> "How should I do this task?"
</div>
</div>
</div>
<h3 id="the-litmus-test">The Litmus Test</h3>
<pre><code class="language-python">    # STATE PATTERN - Transitions happen internally
    order.pay()  # Order decides: Pending -&gt; Paid
    order.ship() # Order decides: Paid -&gt; Shipped
    # Client doesn't choose the next state

    # STRATEGY PATTERN - Selection is external
    payment_processor.set_strategy(CreditCardStrategy())
    payment_processor.process(amount)  # Uses credit card
    payment_processor.set_strategy(PayPalStrategy())
    payment_processor.process(amount)  # Now uses PayPal
    # Client explicitly chooses the algorithm</code></pre>
<div style="background: #f0fdf4; border-radius: 12px; padding: 1.25rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #166534; margin-bottom: 0.75rem">Key Insight for Interviews</div>
<div style="color: #14532d; font-size: 0.9rem; line-height: 1.6">
  If you remove the pattern and use conditionals instead:<br>
<strong>State</strong> becomes: <code>if self.status == "pending": ... elif self.status == "shipped": ...</code><br>
<strong>Strategy</strong> becomes: <code>if payment_type == "credit": ... elif payment_type == "paypal": ...</code><br><br>
  The State conditional checks <em>internal object state</em>. The Strategy conditional checks <em>external configuration</em>.
</div>
</div>
<h3 id="3-level-recursive-interview-questions-state-vs-strategy">3-Level Recursive Interview Questions: State vs Strategy</h3>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.1rem">Level 1: Can you explain the difference between State and Strategy patterns?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Both patterns use composition to delegate behavior to interchangeable objects. The difference is in intent and control flow. State pattern manages internal behavior changes driven by the object's lifecycle - the object itself or its states control transitions. Strategy pattern lets external code choose algorithms - the client decides which strategy to use.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.75rem">Level 2: If they're structurally identical, how do you decide which to use when reviewing code or designing a system?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Ask three questions: (1) Who initiates changes - if internal events trigger changes, it's State; if client code sets the algorithm, it's Strategy. (2) Do the classes know about each other - State classes often reference other states for transitions; Strategy classes are isolated. (3) Is there a defined progression - State typically has valid/invalid transitions; Strategy allows arbitrary switching.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #6d28d9; margin-bottom: 0.75rem">Level 3: Can you describe a scenario where you might start with Strategy and refactor to State, or vice versa?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7">
<strong>Strategy to State:</strong> You build a document editor with rendering strategies (PlainTextRenderer, MarkdownRenderer). Later, you add modes (EditMode, PreviewMode, CommentMode) where the mode determines which renderer to use AND what editing operations are valid. The modes have transitions (Edit->Preview on Ctrl+P). Now you need State pattern because behavior depends on internal mode, not just rendering choice.
  <br><br>
<strong>State to Strategy:</strong> You have Order states (Pending, Processing, Shipped) but realize the shipping calculation varies by carrier independently of order state. Extract ShippingStrategy (FedExStrategy, UPSStrategy) - the shipping algorithm is a client choice, not a lifecycle stage.
</div>
</div>
</div>
</div>
<hr />
<h2 id="state-transitions-the-heart-of-the-pattern">State Transitions: The Heart of the Pattern</h2>
<h3 id="transition-ownership-models">Transition Ownership Models</h3>
<p>There are three models for who controls state transitions:</p>
<div style="display: flex; flex-direction: column; gap: 1rem; margin: 1.5rem 0">
<div style="background: #dbeafe; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.5rem">Model 1: State-Controlled Transitions</div>
<div style="color: #1e3a8a; font-size: 0.9rem; line-height: 1.6">
State objects call <code>context.setState(newState)</code>. States encapsulate transition logic. Used when transitions are complex and state-specific.
</div>
<div style="background: #bfdbfe; border-radius: 6px; padding: 0.5rem 0.75rem; margin-top: 0.75rem; font-size: 0.85rem; color: #1e40af">
<strong>Trade-off:</strong> States become coupled to each other. Changing transition rules requires modifying state classes.
</div>
</div>
<div style="background: #dcfce7; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #166534; margin-bottom: 0.5rem">Model 2: Context-Controlled Transitions</div>
<div style="color: #14532d; font-size: 0.9rem; line-height: 1.6">
  Context interprets state method return values and decides transitions. States are simpler and independent.
</div>
<div style="background: #bbf7d0; border-radius: 6px; padding: 0.5rem 0.75rem; margin-top: 0.75rem; font-size: 0.85rem; color: #166534">
<strong>Trade-off:</strong> Transition logic centralized in Context. Adding new states requires modifying Context.
</div>
</div>
<div style="background: #fef3c7; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #92400e; margin-bottom: 0.5rem">Model 3: Transition Table (External)</div>
<div style="color: #78350f; font-size: 0.9rem; line-height: 1.6">
  A separate transition table/configuration defines valid transitions. States and Context query the table.
</div>
<div style="background: #fde68a; border-radius: 6px; padding: 0.5rem 0.75rem; margin-top: 0.75rem; font-size: 0.85rem; color: #92400e">
<strong>Trade-off:</strong> Maximum flexibility and auditability. Adds complexity and indirection.
</div>
</div>
</div>
<h3 id="implementing-transition-guards">Implementing Transition Guards</h3>
<p>Transitions often have preconditions. Here's how to implement guards:</p>
<pre><code class="language-python">                from abc import ABC, abstractmethod
                from typing import Optional, Callable, List
                from dataclasses import dataclass
                from datetime import datetime


                @dataclass
                class TransitionResult:
                &quot;&quot;&quot;Result of a transition attempt.&quot;&quot;&quot;
                success: bool
                error_message: Optional[str] = None
                previous_state: Optional[str] = None
                new_state: Optional[str] = None


                class TransitionGuard:
                &quot;&quot;&quot;Encapsulates a transition precondition.&quot;&quot;&quot;

                def __init__(self, predicate: Callable[['Order'], bool], error_message: str):
                self.predicate = predicate
                self.error_message = error_message

                def check(self, context: 'Order') -&gt; Optional[str]:
                &quot;&quot;&quot;Returns error message if guard fails, None if passes.&quot;&quot;&quot;
                if not self.predicate(context):
                return self.error_message
                return None


                class OrderState(ABC):
                &quot;&quot;&quot;Abstract base for order states with guarded transitions.&quot;&quot;&quot;

                @property
                @abstractmethod
                def name(self) -&gt; str:
                pass

                @property
                def allowed_transitions(self) -&gt; List[str]:
                &quot;&quot;&quot;Override to specify valid target states.&quot;&quot;&quot;
                return []

                def get_transition_guards(self, target_state: str) -&gt; List[TransitionGuard]:
                &quot;&quot;&quot;Override to specify guards for specific transitions.&quot;&quot;&quot;
                return []

                def can_transition_to(self, target_state: str, context: 'Order') -&gt; TransitionResult:
                &quot;&quot;&quot;Check if transition is valid and all guards pass.&quot;&quot;&quot;
                if target_state not in self.allowed_transitions:
                return TransitionResult(
                success=False,
                error_message=f&quot;Transition from {self.name} to {target_state} not allowed&quot;
                )

                for guard in self.get_transition_guards(target_state):
                error = guard.check(context)
                if error:
                return TransitionResult(
                success=False,
                error_message=error
                )

                return TransitionResult(success=True)

                @abstractmethod
                def process(self, context: 'Order') -&gt; None:
                &quot;&quot;&quot;Execute state-specific processing.&quot;&quot;&quot;
                pass


                class PendingPaymentState(OrderState):
                &quot;&quot;&quot;Order awaiting payment.&quot;&quot;&quot;

                @property
                def name(self) -&gt; str:
                return &quot;pending_payment&quot;

                @property
                def allowed_transitions(self) -&gt; List[str]:
                return [&quot;paid&quot;, &quot;cancelled&quot;]

                def get_transition_guards(self, target_state: str) -&gt; List[TransitionGuard]:
                if target_state == &quot;paid&quot;:
                return [
                TransitionGuard(
                lambda o: o.payment_amount &gt;= o.total,
                &quot;Payment amount insufficient&quot;
                ),
                TransitionGuard(
                lambda o: o.payment_verified,
                &quot;Payment not verified by payment processor&quot;
                )
                ]
                elif target_state == &quot;cancelled&quot;:
                return [
                TransitionGuard(
                lambda o: not o.items_reserved,
                &quot;Cannot cancel: items already reserved in warehouse&quot;
                )
                ]
                return []

                def process(self, context: 'Order') -&gt; None:
                # Send payment reminder if pending &gt; 24 hours
                pass</code></pre>
<h3 id="entry-and-exit-actions">Entry and Exit Actions</h3>
<p>Robust state machines execute actions when entering or leaving states:</p>
<pre><code class="language-python">                class OrderState(ABC):
                &quot;&quot;&quot;State with entry/exit hooks.&quot;&quot;&quot;

                def on_enter(self, context: 'Order', previous_state: Optional['OrderState']) -&gt; None:
                &quot;&quot;&quot;Called immediately after transitioning INTO this state.&quot;&quot;&quot;
                pass

                def on_exit(self, context: 'Order', next_state: 'OrderState') -&gt; None:
                &quot;&quot;&quot;Called immediately before transitioning OUT of this state.&quot;&quot;&quot;
                pass


                class ShippedState(OrderState):
                &quot;&quot;&quot;Order has been shipped.&quot;&quot;&quot;

                @property
                def name(self) -&gt; str:
                return &quot;shipped&quot;

                def on_enter(self, context: 'Order', previous_state: Optional['OrderState']) -&gt; None:
                # Critical: These actions execute atomically with the transition
                context.shipped_at = datetime.now()
                context.tracking_number = self._generate_tracking()

                # Trigger async notifications (fire-and-forget)
                context.event_bus.publish(OrderShippedEvent(
                order_id=context.id,
                tracking_number=context.tracking_number,
                customer_email=context.customer_email
                ))

                def on_exit(self, context: 'Order', next_state: 'OrderState') -&gt; None:
                if next_state.name == &quot;delivered&quot;:
                context.delivery_confirmed_at = datetime.now()
                elif next_state.name == &quot;returned&quot;:
                # Initiate return shipping label generation
                context.return_label_requested = True</code></pre>
<div style="background: #fef2f2;border-radius: 0 8px 8px 0; padding: 1rem 1.25rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #991b1b; margin-bottom: 0.5rem">Edge Case: Failed Entry Actions</div>
<div style="color: #7f1d1d; font-size: 0.9rem; line-height: 1.6">
What if <code>on_enter</code> throws an exception? You have two choices:
  <br><br>
<strong>1. Rollback:</strong> Catch exception, revert to previous state, re-throw. Complex because <code>on_exit</code> already ran.
  <br>
<strong>2. Compensating state:</strong> Transition to an error/recovery state instead of the target state.
  <br><br>
  Most production systems use option 2 with an explicit "FailedTransition" or "Error" state that captures the exception details and allows retry or manual intervention.
</div>
</div>
<h3 id="3-level-recursive-interview-questions-state-transitions">3-Level Recursive Interview Questions: State Transitions</h3>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.1rem">Level 1: How do you decide whether states or the context should control transitions?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  State-controlled transitions work well when transition logic is complex and state-specific - the state knows best when it should end. Context-controlled works when transitions follow simple rules or when you need centralized transition validation. External transition tables work for highly configurable systems where business rules change frequently.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.75rem">Level 2: How do you handle transitions that can fail, especially when side effects have already occurred?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Use a two-phase approach: (1) Validation phase - check all guards and preconditions before any side effects. (2) Execution phase - perform side effects only after validation passes. For distributed systems, use the [[Saga pattern]](/topic/system-design/saga-pattern) with compensating transactions. The state machine itself should track whether it's in a "transitioning" meta-state to prevent concurrent modifications.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #6d28d9; margin-bottom: 0.75rem">Level 3: In a distributed system with eventual consistency, how do you handle state transitions when the state machine is replicated across services?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7">
  This is where [[Event Sourcing]](/topic/system-design/event-sourcing) becomes essential. Instead of storing current state, store the sequence of state transition events. Each service can rebuild the state machine by replaying events. Use [[optimistic locking]](/topic/system-design/distributed-locking) with version numbers - a transition includes the expected version, and conflicts are detected and retried. For strong consistency, use [[distributed consensus]](/topic/system-design/consensus-algorithms) (Raft/Paxos) to agree on transition order. The key insight is that the state machine becomes a projection of the event log rather than the source of truth.
</div>
</div>
</div>
</div>
<hr />
<h2 id="finite-state-machines-formal-foundations">Finite State Machines: Formal Foundations</h2>
<p>A Finite State Machine (FSM) is formally defined as a 5-tuple:</p>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-family: monospace; font-size: 1rem; color: #1e293b; text-align: center; margin-bottom: 1rem">
  M = (Q, &Sigma;, &delta;, q<sub>0</sub>, F)
</div>
<div style="display: grid; grid-template-columns: auto 1fr; gap: 0.75rem 1.5rem; font-size: 0.9rem">
<div style="font-weight: 600; color: #3b82f6">Q</div>
<div style="color: #334155">Finite set of states</div>
<div style="font-weight: 600; color: #3b82f6">&Sigma;</div>
<div style="color: #334155">Finite set of input symbols (events/triggers)</div>
<div style="font-weight: 600; color: #3b82f6">&delta;</div>
<div style="color: #334155">Transition function: Q x &Sigma; &rarr; Q</div>
<div style="font-weight: 600; color: #3b82f6">q<sub>0</sub></div>
<div style="color: #334155">Initial state (q<sub>0</sub> &isin; Q)</div>
<div style="font-weight: 600; color: #3b82f6">F</div>
<div style="color: #334155">Set of accepting/final states (F &sube; Q)</div>
</div>
</div>
<h3 id="types-of-state-machines">Types of State Machines</h3>
<div style="display: flex; gap: 1.5rem; margin: 1.5rem 0; flex-wrap: wrap">
<div style="flex: 1; min-width: 280px; background: #dbeafe; border-radius: 12px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.75rem">Moore Machine</div>
<div style="color: #1e3a8a; font-size: 0.9rem; line-height: 1.6; margin-bottom: 0.75rem">
  Output depends <em>only</em> on current state. Actions are associated with states (entry/exit actions).
</div>
<div style="background: #bfdbfe; border-radius: 6px; padding: 0.5rem; font-size: 0.85rem; color: #1e40af">
  Example: Vending machine display shows state (Insert Coin, Select Item, Dispensing)
</div>
</div>
<div style="flex: 1; min-width: 280px; background: #dcfce7; border-radius: 12px; padding: 1.25rem">
<div style="font-weight: 700; color: #166534; margin-bottom: 0.75rem">Mealy Machine</div>
<div style="color: #14532d; font-size: 0.9rem; line-height: 1.6; margin-bottom: 0.75rem">
  Output depends on current state <em>and</em> input. Actions are associated with transitions.
</div>
<div style="background: #bbf7d0; border-radius: 6px; padding: 0.5rem; font-size: 0.85rem; color: #166534">
  Example: Parser that emits tokens during specific transitions, not just at states
</div>
</div>
</div>
<h3 id="table-driven-state-machine-implementation">Table-Driven State Machine Implementation</h3>
<p>For complex state machines, a table-driven approach is more maintainable:</p>
<pre><code class="language-python">from dataclasses import dataclass, field
from typing import Dict, Set, Callable, Optional, Any
from enum import Enum, auto


class OrderEvent(Enum):
&quot;&quot;&quot;Events that trigger state transitions.&quot;&quot;&quot;
PAYMENT_RECEIVED = auto()
PAYMENT_FAILED = auto()
INVENTORY_RESERVED = auto()
INVENTORY_UNAVAILABLE = auto()
SHIPPED = auto()
DELIVERED = auto()
RETURN_REQUESTED = auto()
RETURN_RECEIVED = auto()
CANCELLED = auto()
REFUND_ISSUED = auto()


class OrderStatus(Enum):
&quot;&quot;&quot;Possible order states.&quot;&quot;&quot;
PENDING_PAYMENT = auto()
PAYMENT_PROCESSING = auto()
PAYMENT_FAILED = auto()
PAID = auto()
AWAITING_INVENTORY = auto()
INVENTORY_ALLOCATED = auto()
SHIPPED = auto()
DELIVERED = auto()
RETURN_PENDING = auto()
RETURNED = auto()
CANCELLED = auto()
REFUNDED = auto()


@dataclass
class Transition:
&quot;&quot;&quot;Represents a valid state transition.&quot;&quot;&quot;
target: OrderStatus
guard: Optional[Callable[['Order'], bool]] = None
action: Optional[Callable[['Order'], None]] = None


@dataclass
class StateMachineConfig:
&quot;&quot;&quot;Configuration for a table-driven state machine.&quot;&quot;&quot;
initial_state: OrderStatus
final_states: Set[OrderStatus]
transitions: Dict[OrderStatus, Dict[OrderEvent, Transition]]

def validate(self) -&gt; None:
&quot;&quot;&quot;Validate state machine configuration at startup.&quot;&quot;&quot;
# Check all states are reachable from initial
reachable = {self.initial_state}
changed = True
while changed:
changed = False
for state in list(reachable):
if state in self.transitions:
for event, transition in self.transitions[state].items():
if transition.target not in reachable:
reachable.add(transition.target)
changed = True

# Check final states are reachable
for final in self.final_states:
if final not in reachable:
raise ValueError(f&quot;Final state {final} is not reachable&quot;)

# Check for dead ends (non-final states with no outgoing transitions)
all_states = set(self.transitions.keys())
for state in all_states:
if state not in self.final_states:
if not self.transitions.get(state):
raise ValueError(f&quot;Non-final state {state} has no transitions&quot;)


# Define the order state machine configuration
ORDER_STATE_MACHINE = StateMachineConfig(
initial_state=OrderStatus.PENDING_PAYMENT,
final_states={
OrderStatus.DELIVERED,
OrderStatus.RETURNED,
OrderStatus.CANCELLED,
OrderStatus.REFUNDED,
},
transitions={
OrderStatus.PENDING_PAYMENT: {
OrderEvent.PAYMENT_RECEIVED: Transition(
target=OrderStatus.PAYMENT_PROCESSING,
action=lambda o: o.initiate_payment_processing()
),
OrderEvent.CANCELLED: Transition(
target=OrderStatus.CANCELLED,
guard=lambda o: not o.has_reserved_inventory,
action=lambda o: o.notify_cancellation()
),
},
OrderStatus.PAYMENT_PROCESSING: {
OrderEvent.PAYMENT_RECEIVED: Transition(
target=OrderStatus.PAID,
action=lambda o: o.record_payment()
),
OrderEvent.PAYMENT_FAILED: Transition(
target=OrderStatus.PAYMENT_FAILED,
action=lambda o: o.notify_payment_failure()
),
},
OrderStatus.PAYMENT_FAILED: {
OrderEvent.PAYMENT_RECEIVED: Transition(
target=OrderStatus.PAYMENT_PROCESSING
),
OrderEvent.CANCELLED: Transition(
target=OrderStatus.CANCELLED
),
},
OrderStatus.PAID: {
OrderEvent.INVENTORY_RESERVED: Transition(
target=OrderStatus.INVENTORY_ALLOCATED,
action=lambda o: o.confirm_inventory()
),
OrderEvent.INVENTORY_UNAVAILABLE: Transition(
target=OrderStatus.AWAITING_INVENTORY,
action=lambda o: o.backorder_items()
),
OrderEvent.CANCELLED: Transition(
target=OrderStatus.REFUNDED,
action=lambda o: o.process_refund()
),
},
OrderStatus.AWAITING_INVENTORY: {
OrderEvent.INVENTORY_RESERVED: Transition(
target=OrderStatus.INVENTORY_ALLOCATED
),
OrderEvent.CANCELLED: Transition(
target=OrderStatus.REFUNDED,
action=lambda o: o.process_refund()
),
},
OrderStatus.INVENTORY_ALLOCATED: {
OrderEvent.SHIPPED: Transition(
target=OrderStatus.SHIPPED,
action=lambda o: o.generate_tracking()
),
},
OrderStatus.SHIPPED: {
OrderEvent.DELIVERED: Transition(
target=OrderStatus.DELIVERED,
action=lambda o: o.confirm_delivery()
),
OrderEvent.RETURN_REQUESTED: Transition(
target=OrderStatus.RETURN_PENDING,
guard=lambda o: o.is_within_return_window,
action=lambda o: o.initiate_return()
),
},
OrderStatus.DELIVERED: {
OrderEvent.RETURN_REQUESTED: Transition(
target=OrderStatus.RETURN_PENDING,
guard=lambda o: o.is_within_return_window,
action=lambda o: o.initiate_return()
),
},
OrderStatus.RETURN_PENDING: {
OrderEvent.RETURN_RECEIVED: Transition(
target=OrderStatus.RETURNED,
action=lambda o: o.process_return_refund()
),
},
}
)


class StateMachine:
&quot;&quot;&quot;Generic table-driven state machine executor.&quot;&quot;&quot;

def __init__(self, config: StateMachineConfig):
self.config = config
config.validate()

def process_event(
self,
context: Any,
current_state: Enum,
event: Enum
) -&gt; tuple[Enum, bool]:
&quot;&quot;&quot;
Process an event and return (new_state, transition_occurred).

Raises ValueError for invalid transitions.
&quot;&quot;&quot;
state_transitions = self.config.transitions.get(current_state, {})
transition = state_transitions.get(event)

if transition is None:
raise ValueError(
f&quot;No transition defined for event {event} in state {current_state}&quot;
)

# Check guard condition
if transition.guard and not transition.guard(context):
return current_state, False

# Execute action
if transition.action:
transition.action(context)

return transition.target, True</code></pre>
<h3 id="3-level-recursive-interview-questions-state-machines">3-Level Recursive Interview Questions: State Machines</h3>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.1rem">Level 1: What are the advantages of a table-driven state machine over the classic State pattern implementation?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Table-driven machines centralize all transition logic in one place, making it easy to visualize, validate, and modify. You can validate the machine at startup (check reachability, dead ends). It's also easier to serialize/deserialize and to generate from configuration files. The classic pattern distributes logic across many classes, which can make the overall flow harder to understand but keeps state-specific logic encapsulated.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.75rem">Level 2: How would you implement a state machine that needs to support dynamic/runtime-configurable transitions?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Store transition rules in a database or configuration service. The state machine loads rules at startup and can reload on-demand. Use a versioned configuration to handle in-flight entities - an order created under v1 rules continues with v1 rules. Implement rule validation before accepting new configurations. For complex scenarios, use a workflow engine like Temporal or AWS Step Functions that provides this out of the box.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #6d28d9; margin-bottom: 0.75rem">Level 3: How do you test a state machine with hundreds of states and thousands of transitions?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7">
  Use multiple testing strategies:<br><br>
<strong>1. Model-based testing:</strong> Define the state machine formally and generate test cases automatically. Tools like QuickCheck can generate random event sequences and verify invariants hold.<br><br>
<strong>2. Property-based testing:</strong> Test properties like "final states are always reachable," "no transition leads to undefined state," "cancellation is always possible before shipping."<br><br>
<strong>3. Path coverage:</strong> Use graph algorithms to find all paths from initial to final states. Generate tests for each path. For large machines, use k-path coverage (paths up to length k).<br><br>
<strong>4. Mutation testing:</strong> Systematically remove or alter transitions and verify tests catch the changes.<br><br>
<strong>5. Production traffic replay:</strong> Capture real event sequences and replay them in test environments to catch edge cases.
</div>
</div>
</div>
</div>
<hr />
<h2 id="hierarchical-state-machines-statecharts">Hierarchical State Machines (Statecharts)</h2>
<p>Hierarchical State Machines (HSMs), formalized by David Harel as Statecharts, extend FSMs with:</p>
<ol>
<li><strong>Nested states</strong> (superstates containing substates)</li>
<li><strong>History</strong> (remembering which substate was active)</li>
<li><strong>Parallel regions</strong> (orthogonal states)</li>
</ol>
<div style="background: #f8fafc; border-radius: 12px; padding: 2rem; margin: 2rem 0">
<div style="text-align: center; margin-bottom: 1.5rem; color: #1e293b; font-weight: 700; font-size: 1.1rem">Hierarchical Order State Machine</div>
<div style="background: #dbeafe; border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 1rem; text-align: center">Processing (Superstate)</div>
<div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center">
<div style="background: white; padding: 0.75rem 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #1e40af">PaymentProcessing</div>
</div>
<div style="color: #3b82f6; align-self: center">&rarr;</div>
<div style="background: white; padding: 0.75rem 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #1e40af">InventoryAllocation</div>
</div>
<div style="color: #3b82f6; align-self: center">&rarr;</div>
<div style="background: white; padding: 0.75rem 1rem; border-radius: 8px">
<div style="font-weight: 600; color: #1e40af">Fulfillment</div>
</div>
</div>
<div style="text-align: center; margin-top: 1rem; font-size: 0.85rem; color: #1e40af">
Any substate can transition to <strong>Cancelled</strong> via "cancel" event (inherited transition)
</div>
</div>
<div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap">
<div style="background: #fef2f2; padding: 0.75rem 1.25rem; border-radius: 8px">
<div style="font-weight: 600; color: #991b1b">Cancelled</div>
</div>
<div style="background: #dcfce7; padding: 0.75rem 1.25rem; border-radius: 8px">
<div style="font-weight: 600; color: #166534">Completed</div>
</div>
</div>
</div>
<h3 id="benefits-of-hierarchical-states">Benefits of Hierarchical States</h3>
<div style="background: #f0fdf4; border-radius: 12px; padding: 1.25rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #166534; margin-bottom: 0.75rem">Key Benefits</div>
<ul style="margin: 0; padding-left: 1.5rem; color: #14532d; line-height: 1.8">
<li><strong>Transition inheritance:</strong> Define "cancel" once at the superstate level instead of in every substate</li>
<li><strong>State explosion prevention:</strong> N substates with M common transitions = N + M instead of N * M</li>
<li><strong>Logical grouping:</strong> Related states are visually and logically grouped</li>
<li><strong>History states:</strong> Resume where you left off after returning to a superstate</li>
</ul>
</div>
<h3 id="implementation-with-nested-states">Implementation with Nested States</h3>
<pre><code class="language-python">from abc import ABC, abstractmethod
from typing import Optional, Dict, Type
from dataclasses import dataclass, field
from enum import Enum, auto


class StateEventResult(Enum):
&quot;&quot;&quot;Result of processing an event in a state.&quot;&quot;&quot;
HANDLED = auto()      # Event was handled, no transition
TRANSITION = auto()   # Transition to another state
NOT_HANDLED = auto()  # Delegate to parent state


@dataclass
class HierarchicalState(ABC):
&quot;&quot;&quot;Base class for hierarchical states.&quot;&quot;&quot;

parent: Optional['HierarchicalState'] = None
_active_substate: Optional['HierarchicalState'] = None

@property
@abstractmethod
def name(self) -&gt; str:
pass

def get_substates(self) -&gt; Dict[str, Type['HierarchicalState']]:
&quot;&quot;&quot;Override to define nested states.&quot;&quot;&quot;
return {}

def get_initial_substate(self) -&gt; Optional[str]:
&quot;&quot;&quot;Override to specify which substate to enter by default.&quot;&quot;&quot;
return None

def handle_event(self, context: 'Order', event: str) -&gt; tuple[StateEventResult, Optional['HierarchicalState']]:
&quot;&quot;&quot;
Process event. Returns (result, new_state_or_none).
Default implementation delegates to active substate, then to self.
&quot;&quot;&quot;
# First, let active substate handle it
if self._active_substate:
result, new_state = self._active_substate.handle_event(context, event)
if result == StateEventResult.HANDLED:
return result, None
elif result == StateEventResult.TRANSITION:
return result, new_state

# Substate didn't handle it (or no substate), try handling here
handler = getattr(self, f'on_{event}', None)
if handler:
return handler(context)

# Event not handled at this level, bubble up
return StateEventResult.NOT_HANDLED, None

def enter(self, context: 'Order', history: bool = False) -&gt; None:
&quot;&quot;&quot;Called when entering this state.&quot;&quot;&quot;
self.on_enter(context)

# Enter initial substate if this is a composite state
initial = self.get_initial_substate()
if initial and not history:
substates = self.get_substates()
if initial in substates:
self._active_substate = substates[initial](parent=self)
self._active_substate.enter(context)

def exit(self, context: 'Order') -&gt; None:
&quot;&quot;&quot;Called when exiting this state.&quot;&quot;&quot;
# Exit active substate first (innermost to outermost)
if self._active_substate:
self._active_substate.exit(context)
self._active_substate = None
self.on_exit(context)

def on_enter(self, context: 'Order') -&gt; None:
&quot;&quot;&quot;Override for entry actions.&quot;&quot;&quot;
pass

def on_exit(self, context: 'Order') -&gt; None:
&quot;&quot;&quot;Override for exit actions.&quot;&quot;&quot;
pass


# Concrete implementation
class ProcessingState(HierarchicalState):
&quot;&quot;&quot;Composite state containing payment, inventory, and fulfillment substates.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;processing&quot;

def get_substates(self) -&gt; Dict[str, Type[HierarchicalState]]:
return {
&quot;payment&quot;: PaymentProcessingSubstate,
&quot;inventory&quot;: InventoryAllocationSubstate,
&quot;fulfillment&quot;: FulfillmentSubstate,
}

def get_initial_substate(self) -&gt; str:
return &quot;payment&quot;

def on_cancel(self, context: 'Order') -&gt; tuple[StateEventResult, HierarchicalState]:
&quot;&quot;&quot;
Cancel transition defined at superstate level.
This handles 'cancel' for ALL substates automatically.
&quot;&quot;&quot;
context.cancel_reason = &quot;Customer requested cancellation&quot;
return StateEventResult.TRANSITION, CancelledState()

def on_enter(self, context: 'Order') -&gt; None:
context.processing_started_at = datetime.now()
print(f&quot;Order {context.id} entering processing&quot;)


class PaymentProcessingSubstate(HierarchicalState):
&quot;&quot;&quot;Substate handling payment processing.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;processing.payment&quot;

def on_payment_confirmed(self, context: 'Order') -&gt; tuple[StateEventResult, HierarchicalState]:
context.paid_at = datetime.now()
# Transition to sibling substate
return StateEventResult.TRANSITION, InventoryAllocationSubstate(parent=self.parent)

def on_payment_failed(self, context: 'Order') -&gt; tuple[StateEventResult, HierarchicalState]:
return StateEventResult.TRANSITION, PaymentFailedState()


class InventoryAllocationSubstate(HierarchicalState):
&quot;&quot;&quot;Substate handling inventory allocation.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;processing.inventory&quot;

def on_inventory_allocated(self, context: 'Order') -&gt; tuple[StateEventResult, HierarchicalState]:
context.inventory_reserved = True
return StateEventResult.TRANSITION, FulfillmentSubstate(parent=self.parent)


class FulfillmentSubstate(HierarchicalState):
&quot;&quot;&quot;Substate handling order fulfillment.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;processing.fulfillment&quot;

def on_shipped(self, context: 'Order') -&gt; tuple[StateEventResult, HierarchicalState]:
# Transition out of the entire Processing superstate
return StateEventResult.TRANSITION, ShippedState()</code></pre>
<h3 id="history-states">History States</h3>
<p>History states remember which substate was active when exiting a composite state:</p>
<pre><code class="language-python">@dataclass
class CompositeStateWithHistory(HierarchicalState):
&quot;&quot;&quot;Composite state that remembers its last active substate.&quot;&quot;&quot;

_history: Optional[str] = None  # Name of last active substate

def exit(self, context: 'Order') -&gt; None:
# Remember which substate was active
if self._active_substate:
self._history = self._active_substate.name.split('.')[-1]
self._active_substate.exit(context)
self._active_substate = None
self.on_exit(context)

def enter_with_history(self, context: 'Order') -&gt; None:
&quot;&quot;&quot;Enter the composite state, resuming at the last active substate.&quot;&quot;&quot;
self.on_enter(context)

target = self._history or self.get_initial_substate()
if target:
substates = self.get_substates()
if target in substates:
self._active_substate = substates[target](parent=self)
self._active_substate.enter(context)


# Usage: Order returns from &quot;On Hold&quot; state
class OnHoldState(HierarchicalState):
&quot;&quot;&quot;Order is temporarily on hold.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;on_hold&quot;

def on_resume(self, context: 'Order') -&gt; tuple[StateEventResult, HierarchicalState]:
# Create processing state and enter with history
processing = ProcessingStateWithHistory()
processing._history = context.last_processing_substate
return StateEventResult.TRANSITION, processing</code></pre>
<h3 id="3-level-recursive-interview-questions-hierarchical-states">3-Level Recursive Interview Questions: Hierarchical States</h3>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.1rem">Level 1: When should you use hierarchical states instead of a flat state machine?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Use HSMs when you have groups of states that share common transitions (like "cancel" available in all processing substates), when your flat state machine would have many duplicated transitions, or when states have natural hierarchical relationships. The rule of thumb: if the same transition appears in 3+ states, consider a superstate.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.75rem">Level 2: How do you handle entry/exit actions in nested states? What's the correct order?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Entry actions execute from outermost to innermost (superstate first, then substate). Exit actions execute from innermost to outermost (substate first, then superstate). This follows the principle that you fully enter a context before entering its contents, and fully exit contents before leaving the context. For a transition from A.a1 to B.b1: exit a1, exit A, enter B, enter b1.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #6d28d9; margin-bottom: 0.75rem">Level 3: How would you implement orthogonal regions (parallel states) where an order is simultaneously in "payment processing" and "fraud check" states?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7">
  Orthogonal regions represent independent aspects of an entity that evolve in parallel. Implementation approaches:<br><br>
<strong>1. Multiple state references:</strong> The context maintains separate state references for each region. Events are broadcast to all regions. A "join" condition waits for all regions to reach specific states.<br><br>
<strong>2. Composite state tuple:</strong> State is represented as (PaymentState, FraudState). Transitions occur in one region without affecting the other. The state machine handles the cartesian product of possible combinations.<br><br>
<strong>3. Actor model:</strong> Each region becomes a separate actor/process. A coordinator actor manages synchronization points.<br><br>
  The key complexity is synchronization: what happens if payment succeeds but fraud check fails? You need clear semantics for conflicting outcomes and may need compensating actions.
</div>
</div>
</div>
</div>
<hr />
<h2 id="complete-order-workflow-implementation">Complete Order Workflow Implementation</h2>
<p>Here's a production-quality order state machine demonstrating all concepts:</p>
<pre><code class="language-python">from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any, Callable
from enum import Enum, auto
import logging

logger = logging.getLogger(__name__)


class OrderEvent(Enum):
&quot;&quot;&quot;All possible order events.&quot;&quot;&quot;
# Payment events
PAYMENT_INITIATED = auto()
PAYMENT_AUTHORIZED = auto()
PAYMENT_CAPTURED = auto()
PAYMENT_FAILED = auto()
PAYMENT_REFUNDED = auto()

# Inventory events
ITEMS_RESERVED = auto()
ITEMS_UNAVAILABLE = auto()
ITEMS_BACKORDERED = auto()

# Fulfillment events
PICKING_STARTED = auto()
PICKING_COMPLETED = auto()
PACKED = auto()
SHIPPED = auto()
OUT_FOR_DELIVERY = auto()
DELIVERED = auto()
DELIVERY_FAILED = auto()

# Customer events
CANCELLED_BY_CUSTOMER = auto()
RETURN_REQUESTED = auto()
RETURN_RECEIVED = auto()

# System events
FRAUD_DETECTED = auto()
EXPIRED = auto()


@dataclass
class TransitionContext:
&quot;&quot;&quot;Context passed to transition handlers.&quot;&quot;&quot;
order: 'Order'
event: OrderEvent
timestamp: datetime
metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class OrderState(ABC):
&quot;&quot;&quot;
Abstract base for order states.

Design choices:
- States are stateless (no instance variables) to allow sharing
- All order data lives in the Order context
- States define allowed transitions and guard conditions
&quot;&quot;&quot;

@property
@abstractmethod
def name(self) -&gt; str:
&quot;&quot;&quot;Canonical state name for persistence and logging.&quot;&quot;&quot;
pass

@property
def is_terminal(self) -&gt; bool:
&quot;&quot;&quot;Terminal states cannot transition further.&quot;&quot;&quot;
return False

@property
def allowed_events(self) -&gt; List[OrderEvent]:
&quot;&quot;&quot;Events that can be processed in this state.&quot;&quot;&quot;
return []

def can_process(self, event: OrderEvent) -&gt; bool:
&quot;&quot;&quot;Check if this state can process the given event.&quot;&quot;&quot;
return event in self.allowed_events

@abstractmethod
def process_event(
self,
ctx: TransitionContext
) -&gt; tuple[Optional['OrderState'], List[Dict]]:
&quot;&quot;&quot;
Process an event and return (new_state, side_effects).

Returns:
- (new_state, effects) if transition occurs
- (None, []) if event is handled but no transition

Side effects are returned as data, not executed, enabling:
- Transaction safety (effects executed after DB commit)
- Testing (verify effects without executing)
- Event sourcing (effects become events)
&quot;&quot;&quot;
pass

def on_enter(self, ctx: TransitionContext) -&gt; List[Dict]:
&quot;&quot;&quot;
Entry actions when transitioning INTO this state.
Returns side effects to execute.
&quot;&quot;&quot;
return []

def on_exit(self, ctx: TransitionContext, target: 'OrderState') -&gt; List[Dict]:
&quot;&quot;&quot;
Exit actions when transitioning OUT of this state.
Returns side effects to execute.
&quot;&quot;&quot;
return []


# === Concrete States ===

class PendingPaymentState(OrderState):
&quot;&quot;&quot;
Initial state: awaiting payment.

Edge cases handled:
- Customer cancellation before payment
- Payment timeout (order expiration)
- Fraud detection during payment
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;pending_payment&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.PAYMENT_INITIATED,
OrderEvent.CANCELLED_BY_CUSTOMER,
OrderEvent.EXPIRED,
OrderEvent.FRAUD_DETECTED,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PAYMENT_INITIATED:
return PaymentProcessingState(), [
{&quot;type&quot;: &quot;initiate_payment&quot;, &quot;amount&quot;: ctx.order.total}
]

elif ctx.event == OrderEvent.CANCELLED_BY_CUSTOMER:
ctx.order.cancelled_at = ctx.timestamp
ctx.order.cancel_reason = &quot;Customer cancelled before payment&quot;
return CancelledState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;order_cancelled&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.EXPIRED:
ctx.order.expired_at = ctx.timestamp
return CancelledState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;order_expired&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.FRAUD_DETECTED:
ctx.order.fraud_flag = True
return FraudReviewState(), [
{&quot;type&quot;: &quot;alert_fraud_team&quot;, &quot;order_id&quot;: ctx.order.id}
]

return None, []

def on_enter(self, ctx: TransitionContext) -&gt; List[Dict]:
# Schedule expiration check
expiry_time = ctx.timestamp + timedelta(hours=24)
return [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;order_confirmation&quot;, &quot;to&quot;: ctx.order.customer_email},
{&quot;type&quot;: &quot;schedule_event&quot;, &quot;event&quot;: &quot;EXPIRED&quot;, &quot;at&quot;: expiry_time}
]


class PaymentProcessingState(OrderState):
&quot;&quot;&quot;
Payment is being processed by payment gateway.

This is typically a transient state - we're waiting for
an async callback from the payment processor.

Edge cases:
- Payment processor timeout
- Partial authorization (auth for less than order total)
- 3D Secure / SCA challenges
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;payment_processing&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.PAYMENT_AUTHORIZED,
OrderEvent.PAYMENT_FAILED,
OrderEvent.FRAUD_DETECTED,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PAYMENT_AUTHORIZED:
ctx.order.payment_authorized_at = ctx.timestamp
ctx.order.authorization_code = ctx.metadata.get(&quot;auth_code&quot;)

# Check for partial authorization
authorized_amount = ctx.metadata.get(&quot;authorized_amount&quot;, ctx.order.total)
if authorized_amount &lt; ctx.order.total:
# Partial auth - need additional payment or cancel
ctx.order.partial_auth_amount = authorized_amount
return PartialPaymentState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;partial_payment&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return PaymentAuthorizedState(), [
{&quot;type&quot;: &quot;capture_payment&quot;, &quot;amount&quot;: ctx.order.total}
]

elif ctx.event == OrderEvent.PAYMENT_FAILED:
ctx.order.payment_failed_at = ctx.timestamp
ctx.order.payment_failure_reason = ctx.metadata.get(&quot;reason&quot;, &quot;Unknown&quot;)

# Allow retry up to 3 times
if ctx.order.payment_attempts &lt; 3:
return PendingPaymentState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;payment_failed_retry&quot;, &quot;to&quot;: ctx.order.customer_email}
]
else:
return CancelledState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;payment_failed_final&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.FRAUD_DETECTED:
# Void any authorization
ctx.order.fraud_flag = True
return FraudReviewState(), [
{&quot;type&quot;: &quot;void_authorization&quot;, &quot;auth_code&quot;: ctx.order.authorization_code},
{&quot;type&quot;: &quot;alert_fraud_team&quot;, &quot;order_id&quot;: ctx.order.id}
]

return None, []


class PaymentAuthorizedState(OrderState):
&quot;&quot;&quot;
Payment authorized, attempting capture.

Authorization != Capture:
- Authorization: &quot;Can this card pay $X?&quot; (hold on funds)
- Capture: &quot;Actually charge $X now&quot; (transfer funds)

Some merchants capture immediately, others wait until shipping.
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;payment_authorized&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.PAYMENT_CAPTURED,
OrderEvent.PAYMENT_FAILED,
OrderEvent.CANCELLED_BY_CUSTOMER,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PAYMENT_CAPTURED:
ctx.order.payment_captured_at = ctx.timestamp
return PaidState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;payment_received&quot;, &quot;to&quot;: ctx.order.customer_email},
{&quot;type&quot;: &quot;reserve_inventory&quot;, &quot;items&quot;: ctx.order.items}
]

elif ctx.event == OrderEvent.PAYMENT_FAILED:
# Capture failed after auth - rare but possible
return PendingPaymentState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;payment_issue&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.CANCELLED_BY_CUSTOMER:
ctx.order.cancelled_at = ctx.timestamp
return CancelledState(), [
{&quot;type&quot;: &quot;void_authorization&quot;, &quot;auth_code&quot;: ctx.order.authorization_code},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;order_cancelled&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class PaidState(OrderState):
&quot;&quot;&quot;
Payment captured, ready for fulfillment.

This triggers inventory reservation. If inventory
is unavailable, order moves to backorder state.
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;paid&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.ITEMS_RESERVED,
OrderEvent.ITEMS_UNAVAILABLE,
OrderEvent.ITEMS_BACKORDERED,
OrderEvent.CANCELLED_BY_CUSTOMER,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.ITEMS_RESERVED:
ctx.order.inventory_reserved_at = ctx.timestamp
return ReadyForFulfillmentState(), [
{&quot;type&quot;: &quot;create_pick_list&quot;, &quot;order_id&quot;: ctx.order.id}
]

elif ctx.event == OrderEvent.ITEMS_UNAVAILABLE:
# Complete stockout - refund and cancel
return CancelledState(), [
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;out_of_stock_cancelled&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.ITEMS_BACKORDERED:
ctx.order.backordered_at = ctx.timestamp
ctx.order.estimated_ship_date = ctx.metadata.get(&quot;estimated_date&quot;)
return BackorderedState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;backordered&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.CANCELLED_BY_CUSTOMER:
ctx.order.cancelled_at = ctx.timestamp
return CancelledState(), [
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;order_cancelled_refunded&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class BackorderedState(OrderState):
&quot;&quot;&quot;
Items on backorder, waiting for inventory.

Customer can cancel while backordered.
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;backordered&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.ITEMS_RESERVED,
OrderEvent.CANCELLED_BY_CUSTOMER,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.ITEMS_RESERVED:
ctx.order.inventory_reserved_at = ctx.timestamp
return ReadyForFulfillmentState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;backorder_filled&quot;, &quot;to&quot;: ctx.order.customer_email},
{&quot;type&quot;: &quot;create_pick_list&quot;, &quot;order_id&quot;: ctx.order.id}
]

elif ctx.event == OrderEvent.CANCELLED_BY_CUSTOMER:
ctx.order.cancelled_at = ctx.timestamp
return CancelledState(), [
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;backorder_cancelled&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class ReadyForFulfillmentState(OrderState):
&quot;&quot;&quot;
Inventory reserved, ready for warehouse picking.

This is where the order enters the physical fulfillment process.
Cancellation becomes more expensive here (restocking labor).
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;ready_for_fulfillment&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.PICKING_STARTED,
OrderEvent.CANCELLED_BY_CUSTOMER,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PICKING_STARTED:
ctx.order.picking_started_at = ctx.timestamp
return PickingState(), []

elif ctx.event == OrderEvent.CANCELLED_BY_CUSTOMER:
ctx.order.cancelled_at = ctx.timestamp
return CancelledState(), [
{&quot;type&quot;: &quot;release_inventory&quot;, &quot;items&quot;: ctx.order.items},
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;order_cancelled_refunded&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class PickingState(OrderState):
&quot;&quot;&quot;
Order is being picked in the warehouse.

Cancellation no longer allowed - too late in process.
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;picking&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.PICKING_COMPLETED,
OrderEvent.ITEMS_UNAVAILABLE,  # Item damaged/missing during pick
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PICKING_COMPLETED:
ctx.order.picking_completed_at = ctx.timestamp
return PackingState(), []

elif ctx.event == OrderEvent.ITEMS_UNAVAILABLE:
# Partial fulfillment scenario
unavailable_items = ctx.metadata.get(&quot;unavailable_items&quot;, [])
if len(unavailable_items) == len(ctx.order.items):
# Complete failure
return CancelledState(), [
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;fulfillment_failed&quot;, &quot;to&quot;: ctx.order.customer_email}
]
else:
# Partial shipment
ctx.order.partial_fulfillment = True
ctx.order.unfulfilled_items = unavailable_items
return PackingState(), [
{&quot;type&quot;: &quot;partial_refund&quot;, &quot;items&quot;: unavailable_items},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;partial_shipment&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class PackingState(OrderState):
&quot;&quot;&quot;Order is being packed.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;packing&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [OrderEvent.PACKED]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PACKED:
ctx.order.packed_at = ctx.timestamp
return AwaitingShipmentState(), [
{&quot;type&quot;: &quot;generate_shipping_label&quot;, &quot;order_id&quot;: ctx.order.id}
]
return None, []


class AwaitingShipmentState(OrderState):
&quot;&quot;&quot;Packed and labeled, waiting for carrier pickup.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;awaiting_shipment&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [OrderEvent.SHIPPED]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.SHIPPED:
ctx.order.shipped_at = ctx.timestamp
ctx.order.tracking_number = ctx.metadata.get(&quot;tracking_number&quot;)
ctx.order.carrier = ctx.metadata.get(&quot;carrier&quot;)
return ShippedState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;shipped&quot;, &quot;to&quot;: ctx.order.customer_email,
&quot;data&quot;: {&quot;tracking&quot;: ctx.order.tracking_number}}
]
return None, []


class ShippedState(OrderState):
&quot;&quot;&quot;
Order is in transit.

Now tracking carrier events (out for delivery, delivered, failed).
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;shipped&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.OUT_FOR_DELIVERY,
OrderEvent.DELIVERED,
OrderEvent.DELIVERY_FAILED,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.OUT_FOR_DELIVERY:
ctx.order.out_for_delivery_at = ctx.timestamp
return OutForDeliveryState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;out_for_delivery&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.DELIVERED:
ctx.order.delivered_at = ctx.timestamp
return DeliveredState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;delivered&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.DELIVERY_FAILED:
ctx.order.delivery_attempts = ctx.order.delivery_attempts + 1
if ctx.order.delivery_attempts &gt;= 3:
return ReturnToSenderState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;delivery_failed_returning&quot;, &quot;to&quot;: ctx.order.customer_email}
]
return self, [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;delivery_failed_retry&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class OutForDeliveryState(OrderState):
&quot;&quot;&quot;Order is out for delivery today.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;out_for_delivery&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.DELIVERED,
OrderEvent.DELIVERY_FAILED,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.DELIVERED:
ctx.order.delivered_at = ctx.timestamp
return DeliveredState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;delivered&quot;, &quot;to&quot;: ctx.order.customer_email}
]

elif ctx.event == OrderEvent.DELIVERY_FAILED:
ctx.order.delivery_attempts = ctx.order.delivery_attempts + 1
return ShippedState(), [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;delivery_failed_retry&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class DeliveredState(OrderState):
&quot;&quot;&quot;
Order successfully delivered.

Return window is now open. Customer can request return
within the return policy period (typically 30 days).
&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;delivered&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [OrderEvent.RETURN_REQUESTED]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.RETURN_REQUESTED:
# Check return window
days_since_delivery = (ctx.timestamp - ctx.order.delivered_at).days
if days_since_delivery &gt; 30:
# Return window closed - stay in delivered state
logger.info(f&quot;Return rejected for order {ctx.order.id}: outside return window&quot;)
return None, [
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;return_window_closed&quot;, &quot;to&quot;: ctx.order.customer_email}
]

ctx.order.return_requested_at = ctx.timestamp
ctx.order.return_reason = ctx.metadata.get(&quot;reason&quot;)
return ReturnRequestedState(), [
{&quot;type&quot;: &quot;generate_return_label&quot;, &quot;order_id&quot;: ctx.order.id},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;return_approved&quot;, &quot;to&quot;: ctx.order.customer_email}
]

return None, []


class ReturnRequestedState(OrderState):
&quot;&quot;&quot;Return requested, waiting for item to be received back.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;return_requested&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [OrderEvent.RETURN_RECEIVED]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.RETURN_RECEIVED:
ctx.order.return_received_at = ctx.timestamp
return ReturnedState(), [
{&quot;type&quot;: &quot;inspect_return&quot;, &quot;order_id&quot;: ctx.order.id},
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;send_email&quot;, &quot;template&quot;: &quot;return_complete&quot;, &quot;to&quot;: ctx.order.customer_email}
]
return None, []


# === Terminal States ===

class CancelledState(OrderState):
&quot;&quot;&quot;Order has been cancelled. Terminal state.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;cancelled&quot;

@property
def is_terminal(self) -&gt; bool:
return True

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
return None, []  # No transitions from terminal state


class ReturnedState(OrderState):
&quot;&quot;&quot;Order has been returned. Terminal state.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;returned&quot;

@property
def is_terminal(self) -&gt; bool:
return True

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
return None, []


class ReturnToSenderState(OrderState):
&quot;&quot;&quot;Package returned to sender after delivery failures. Terminal state.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;return_to_sender&quot;

@property
def is_terminal(self) -&gt; bool:
return True

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
return None, []

def on_enter(self, ctx: TransitionContext) -&gt; List[Dict]:
return [
{&quot;type&quot;: &quot;refund_payment&quot;, &quot;amount&quot;: ctx.order.total},
{&quot;type&quot;: &quot;release_inventory&quot;, &quot;items&quot;: ctx.order.items}
]


class FraudReviewState(OrderState):
&quot;&quot;&quot;Order flagged for fraud review. Manual intervention required.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;fraud_review&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
# Only manual review events, not modeled here
return []

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
return None, []


class PartialPaymentState(OrderState):
&quot;&quot;&quot;Partial authorization received, needs additional payment.&quot;&quot;&quot;

@property
def name(self) -&gt; str:
return &quot;partial_payment&quot;

@property
def allowed_events(self) -&gt; List[OrderEvent]:
return [
OrderEvent.PAYMENT_INITIATED,
OrderEvent.CANCELLED_BY_CUSTOMER,
]

def process_event(self, ctx: TransitionContext) -&gt; tuple[Optional[OrderState], List[Dict]]:
if ctx.event == OrderEvent.PAYMENT_INITIATED:
remaining = ctx.order.total - ctx.order.partial_auth_amount
return PaymentProcessingState(), [
{&quot;type&quot;: &quot;initiate_payment&quot;, &quot;amount&quot;: remaining}
]

elif ctx.event == OrderEvent.CANCELLED_BY_CUSTOMER:
return CancelledState(), [
{&quot;type&quot;: &quot;void_authorization&quot;, &quot;auth_code&quot;: ctx.order.authorization_code}
]

return None, []


# === State Machine Executor ===

# Registry for deserializing states
STATE_REGISTRY: Dict[str, type] = {
&quot;pending_payment&quot;: PendingPaymentState,
&quot;payment_processing&quot;: PaymentProcessingState,
&quot;payment_authorized&quot;: PaymentAuthorizedState,
&quot;paid&quot;: PaidState,
&quot;backordered&quot;: BackorderedState,
&quot;ready_for_fulfillment&quot;: ReadyForFulfillmentState,
&quot;picking&quot;: PickingState,
&quot;packing&quot;: PackingState,
&quot;awaiting_shipment&quot;: AwaitingShipmentState,
&quot;shipped&quot;: ShippedState,
&quot;out_for_delivery&quot;: OutForDeliveryState,
&quot;delivered&quot;: DeliveredState,
&quot;return_requested&quot;: ReturnRequestedState,
&quot;cancelled&quot;: CancelledState,
&quot;returned&quot;: ReturnedState,
&quot;return_to_sender&quot;: ReturnToSenderState,
&quot;fraud_review&quot;: FraudReviewState,
&quot;partial_payment&quot;: PartialPaymentState,
}


@dataclass
class Order:
&quot;&quot;&quot;Order entity with state machine integration.&quot;&quot;&quot;

id: str
customer_email: str
items: List[Dict]
total: float

# State tracking
_state: OrderState = field(default_factory=PendingPaymentState)
state_name: str = &quot;pending_payment&quot;  # For persistence

# Timestamps and metadata
created_at: datetime = field(default_factory=datetime.now)
payment_attempts: int = 0
delivery_attempts: int = 0

# State-specific data
authorization_code: Optional[str] = None
partial_auth_amount: Optional[float] = None
tracking_number: Optional[str] = None
carrier: Optional[str] = None
fraud_flag: bool = False
partial_fulfillment: bool = False
unfulfilled_items: List[Dict] = field(default_factory=list)

# Timestamps
payment_authorized_at: Optional[datetime] = None
payment_captured_at: Optional[datetime] = None
payment_failed_at: Optional[datetime] = None
inventory_reserved_at: Optional[datetime] = None
backordered_at: Optional[datetime] = None
picking_started_at: Optional[datetime] = None
picking_completed_at: Optional[datetime] = None
packed_at: Optional[datetime] = None
shipped_at: Optional[datetime] = None
out_for_delivery_at: Optional[datetime] = None
delivered_at: Optional[datetime] = None
cancelled_at: Optional[datetime] = None
expired_at: Optional[datetime] = None
return_requested_at: Optional[datetime] = None
return_received_at: Optional[datetime] = None

# Metadata
cancel_reason: Optional[str] = None
payment_failure_reason: Optional[str] = None
return_reason: Optional[str] = None
estimated_ship_date: Optional[datetime] = None

def process_event(
self,
event: OrderEvent,
metadata: Optional[Dict] = None
) -&gt; tuple[bool, List[Dict]]:
&quot;&quot;&quot;
Process an event and return (success, side_effects).

This is the main entry point for state transitions.
&quot;&quot;&quot;
if self._state.is_terminal:
logger.warning(f&quot;Attempted event {event} on terminal state {self.state_name}&quot;)
return False, []

if not self._state.can_process(event):
logger.warning(f&quot;Event {event} not allowed in state {self.state_name}&quot;)
return False, []

ctx = TransitionContext(
order=self,
event=event,
timestamp=datetime.now(),
metadata=metadata or {}
)

# Process event
new_state, effects = self._state.process_event(ctx)

if new_state is not None:
# Execute exit actions
exit_effects = self._state.on_exit(ctx, new_state)

# Transition
old_state_name = self.state_name
self._state = new_state
self.state_name = new_state.name

# Execute entry actions
entry_effects = new_state.on_enter(ctx)

logger.info(f&quot;Order {self.id}: {old_state_name} -&gt; {self.state_name} via {event.name}&quot;)

return True, exit_effects + effects + entry_effects

return True, effects

@classmethod
def from_persistence(cls, data: Dict) -&gt; 'Order':
&quot;&quot;&quot;Reconstruct order from persisted data.&quot;&quot;&quot;
order = cls(**{k: v for k, v in data.items() if k not in ['_state', 'state_name']})
order.state_name = data.get('state_name', 'pending_payment')
order._state = STATE_REGISTRY[order.state_name]()
return order</code></pre>
<h3 id="3-level-recursive-interview-questions-order-workflow">3-Level Recursive Interview Questions: Order Workflow</h3>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.1rem">Level 1: How do you handle the case where an order can be cancelled from multiple states (pending, paid, ready for fulfillment)?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Each state handles the CANCELLED_BY_CUSTOMER event with its own logic. PendingPayment just cancels. PaidState refunds payment. ReadyForFulfillment refunds AND releases inventory. This keeps cancellation logic close to the state-specific concerns. Alternatively, use hierarchical states with a "Cancellable" superstate that handles common cancellation logic.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #1e40af; margin-bottom: 0.75rem">Level 2: How do you ensure that side effects (sending emails, refunding payments) are only executed once, even if the state machine crashes mid-transition?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7; margin-bottom: 1rem">
  Return side effects as data, not actions. The state machine returns the list of effects, which the caller executes within a database transaction. If the transaction commits, effects are guaranteed to execute (via outbox pattern or transactional messaging). If it rolls back, effects are discarded. For critical effects, use [[idempotency keys]](/topic/system-design/api-gateway) - if a refund effect has ID "refund-order-123", the payment service ignores duplicate requests with that ID.
</div>
<div style="margin-left: 1.5rem;padding-left: 1rem; margin-top: 1rem">
<div style="font-weight: 700; color: #6d28d9; margin-bottom: 0.75rem">Level 3: How do you handle time-based transitions (order expiration, return window closing) in a distributed system where you can't rely on local timers?</div>
<div style="color: #334155; font-size: 0.95rem; line-height: 1.7">
  Several approaches:<br><br>
<strong>1. Delayed message queues:</strong> When entering PendingPayment, publish a message to a delayed queue that fires after 24 hours. If still pending, transition to expired. Use message deduplication to handle duplicate deliveries.<br><br>
<strong>2. Scheduled job polling:</strong> A cron job queries for orders in time-sensitive states past their deadline. Scales horizontally with partitioning.<br><br>
<strong>3. Event scheduling service:</strong> Dedicated service (like AWS EventBridge Scheduler) that fires events at specific times. More reliable than self-managed cron.<br><br>
<strong>4. Lazy evaluation:</strong> Don't transition proactively. When any event arrives, first check if time-based transitions should have occurred. "Order expired" is detected when customer tries to pay.<br><br>
  The choice depends on SLA requirements. Lazy evaluation is simplest but means expired orders appear valid until touched. Scheduled jobs provide eventual consistency within polling interval.
</div>
</div>
</div>
</div>
<hr />
<h2 id="trade-offs-and-design-decisions">Trade-offs and Design Decisions</h2>
<div style="display: flex; flex-direction: column; gap: 1.5rem; margin: 1.5rem 0">
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.05rem">Decision: Stateless vs Stateful State Objects</div>
<div style="display: flex; gap: 1rem; flex-wrap: wrap">
<div style="flex: 1; min-width: 200px">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Stateless (Flyweight)</div>
<ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #334155; line-height: 1.6">
<li>States can be singletons</li>
<li>Lower memory footprint</li>
<li>All data in Context</li>
<li>Simpler serialization</li>
</ul>
</div>
<div style="flex: 1; min-width: 200px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">Stateful (Per-instance)</div>
<ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #334155; line-height: 1.6">
<li>State-specific data encapsulated</li>
<li>Cleaner state classes</li>
<li>Must create new instances</li>
<li>Complex serialization</li>
</ul>
</div>
</div>
<div style="background: #f0f9ff; border-radius: 8px; padding: 0.75rem; margin-top: 1rem; font-size: 0.9rem; color: #0369a1">
<strong>Recommendation:</strong> Start stateless. Move data to states only when it clearly belongs there (e.g., retry count only relevant during RetryingPayment state).
</div>
</div>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.05rem">Decision: Event-Driven vs Direct Method Calls</div>
<div style="display: flex; gap: 1rem; flex-wrap: wrap">
<div style="flex: 1; min-width: 200px">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Event-Driven</div>
<ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #334155; line-height: 1.6">
<li>Decoupled, async-friendly</li>
<li>Natural for distributed systems</li>
<li>Easy to add logging/audit</li>
<li>States handle single event enum</li>
</ul>
</div>
<div style="flex: 1; min-width: 200px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">Direct Methods</div>
<ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #334155; line-height: 1.6">
<li>Compile-time safety</li>
<li>IDE autocomplete</li>
<li>States implement interface</li>
<li>Harder to extend</li>
</ul>
</div>
</div>
<div style="background: #f0f9ff; border-radius: 8px; padding: 0.75rem; margin-top: 1rem; font-size: 0.9rem; color: #0369a1">
<strong>Recommendation:</strong> Event-driven for systems that process async events (webhooks, message queues). Direct methods for synchronous, API-driven flows.
</div>
</div>
<div style="background: #f8fafc; border-radius: 12px; padding: 1.5rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 1rem; font-size: 1.05rem">Decision: Centralized vs Distributed State Logic</div>
<div style="display: flex; gap: 1rem; flex-wrap: wrap">
<div style="flex: 1; min-width: 200px">
<div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem">Centralized (Table-driven)</div>
<ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #334155; line-height: 1.6">
<li>All transitions visible at once</li>
<li>Easy to validate completeness</li>
<li>Configuration-driven</li>
<li>Less OOP encapsulation</li>
</ul>
</div>
<div style="flex: 1; min-width: 200px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">Distributed (State classes)</div>
<ul style="margin: 0; padding-left: 1.25rem; font-size: 0.9rem; color: #334155; line-height: 1.6">
<li>State behavior encapsulated</li>
<li>Complex state-specific logic</li>
<li>Harder to see full picture</li>
<li>Natural for OOP codebases</li>
</ul>
</div>
</div>
<div style="background: #f0f9ff; border-radius: 8px; padding: 0.75rem; margin-top: 1rem; font-size: 0.9rem; color: #0369a1">
<strong>Recommendation:</strong> Table-driven for simple FSMs with many states but simple transitions. Class-based for fewer states with complex per-state logic.
</div>
</div>
</div>
<hr />
<h2 id="common-pitfalls-and-edge-cases">Common Pitfalls and Edge Cases</h2>
<div style="background: #fef2f2; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="color: #991b1b; font-weight: 700; margin-bottom: 1rem; font-size: 1.1rem">Critical Edge Cases</div>
<div style="margin-bottom: 1.25rem">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">1. Race Conditions in State Transitions</div>
<div style="color: #7f1d1d; font-size: 0.9rem; line-height: 1.6">
  Two events arrive simultaneously: PAYMENT_RECEIVED and CANCELLED_BY_CUSTOMER. Without locking, both could be processed against the same initial state, leading to inconsistent outcomes.
  <br><br>
<strong>Solution:</strong> Use optimistic locking (version field) or database-level row locks. The second event will fail and can be retried against the new state.
</div>
</div>
<div style="margin-bottom: 1.25rem">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">2. Orphaned Transitional States</div>
<div style="color: #7f1d1d; font-size: 0.9rem; line-height: 1.6">
  Application crashes after entering "PaymentProcessing" but before receiving the webhook. Order is stuck in transitional state forever.
  <br><br>
<strong>Solution:</strong> Set timeouts for transitional states. A scheduled job checks for orders stuck in PaymentProcessing > 1 hour and triggers a timeout event.
</div>
</div>
<div style="margin-bottom: 1.25rem">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">3. Duplicate Events (At-Least-Once Delivery)</div>
<div style="color: #7f1d1d; font-size: 0.9rem; line-height: 1.6">
  Message queue delivers PAYMENT_RECEIVED twice. First delivery transitions Pending->Paid. Second delivery tries to process PAYMENT_RECEIVED in Paid state.
  <br><br>
<strong>Solution:</strong> Track processed event IDs. Or design states to be idempotent - PAYMENT_RECEIVED in Paid state is a no-op, not an error.
</div>
</div>
<div>
<div style="font-weight: 600; color: #991b1b; margin-bottom: 0.5rem">4. State Corruption During Partial Failures</div>
<div style="color: #7f1d1d; font-size: 0.9rem; line-height: 1.6">
  State transitions but side effect (email, refund) fails. Customer is refunded but email doesn't send, causing confusion and support tickets.
  <br><br>
<strong>Solution:</strong> Use [[transactional outbox pattern]](/topic/system-design/event-sourcing). Write side effects to database in same transaction as state change. Separate process reads outbox and executes effects with retries.
</div>
</div>
</div>
<hr />
<h2 id="testing-strategies">Testing Strategies</h2>
<pre><code class="language-python">import pytest
from datetime import datetime
from typing import List, Dict


class TestOrderStateMachine:
&quot;&quot;&quot;Comprehensive tests for order state machine.&quot;&quot;&quot;

def test_happy_path_to_delivery(self):
&quot;&quot;&quot;Test the complete successful order flow.&quot;&quot;&quot;
order = Order(
id=&quot;ORD-001&quot;,
customer_email=&quot;test@example.com&quot;,
items=[{&quot;sku&quot;: &quot;ABC123&quot;, &quot;qty&quot;: 1}],
total=99.99
)

# Process through complete flow
events = [
(OrderEvent.PAYMENT_INITIATED, {}),
(OrderEvent.PAYMENT_AUTHORIZED, {&quot;auth_code&quot;: &quot;AUTH123&quot;}),
(OrderEvent.PAYMENT_CAPTURED, {}),
(OrderEvent.ITEMS_RESERVED, {}),
(OrderEvent.PICKING_STARTED, {}),
(OrderEvent.PICKING_COMPLETED, {}),
(OrderEvent.PACKED, {}),
(OrderEvent.SHIPPED, {&quot;tracking_number&quot;: &quot;1Z999&quot;, &quot;carrier&quot;: &quot;UPS&quot;}),
(OrderEvent.OUT_FOR_DELIVERY, {}),
(OrderEvent.DELIVERED, {}),
]

for event, metadata in events:
success, effects = order.process_event(event, metadata)
assert success, f&quot;Event {event} should succeed&quot;

assert order.state_name == &quot;delivered&quot;
assert order.tracking_number == &quot;1Z999&quot;

def test_cancellation_at_various_states(self):
&quot;&quot;&quot;Test that cancellation behaves correctly in each state.&quot;&quot;&quot;
cancellable_states_and_effects = [
(&quot;pending_payment&quot;, []),  # No refund needed
(&quot;paid&quot;, [&quot;refund_payment&quot;]),  # Refund required
(&quot;ready_for_fulfillment&quot;, [&quot;release_inventory&quot;, &quot;refund_payment&quot;]),
]

for state_name, expected_effect_types in cancellable_states_and_effects:
order = self._create_order_in_state(state_name)
success, effects = order.process_event(OrderEvent.CANCELLED_BY_CUSTOMER)

assert success
assert order.state_name == &quot;cancelled&quot;

effect_types = [e[&quot;type&quot;] for e in effects]
for expected in expected_effect_types:
assert expected in effect_types

def test_cannot_cancel_after_shipping(self):
&quot;&quot;&quot;Orders cannot be cancelled once shipped.&quot;&quot;&quot;
order = self._create_order_in_state(&quot;shipped&quot;)
success, effects = order.process_event(OrderEvent.CANCELLED_BY_CUSTOMER)

assert not success
assert order.state_name == &quot;shipped&quot;  # State unchanged

def test_invalid_event_in_state(self):
&quot;&quot;&quot;Verify invalid events are rejected.&quot;&quot;&quot;
order = Order(
id=&quot;ORD-001&quot;,
customer_email=&quot;test@example.com&quot;,
items=[],
total=99.99
)

# Can't approve payment when pending payment
success, effects = order.process_event(OrderEvent.PAYMENT_CAPTURED)
assert not success
assert order.state_name == &quot;pending_payment&quot;

def test_return_window_enforcement(self):
&quot;&quot;&quot;Return requests outside window should be rejected.&quot;&quot;&quot;
order = self._create_order_in_state(&quot;delivered&quot;)
order.delivered_at = datetime.now() - timedelta(days=45)  # 45 days ago

success, effects = order.process_event(OrderEvent.RETURN_REQUESTED)

assert success  # Event processed but no transition
assert order.state_name == &quot;delivered&quot;  # Still delivered
assert any(e[&quot;type&quot;] == &quot;send_email&quot; and &quot;window_closed&quot; in e[&quot;template&quot;]
for e in effects)

def test_payment_retry_limit(self):
&quot;&quot;&quot;After 3 payment failures, order should be cancelled.&quot;&quot;&quot;
order = Order(
id=&quot;ORD-001&quot;,
customer_email=&quot;test@example.com&quot;,
items=[],
total=99.99
)
order.payment_attempts = 3  # Already failed 3 times

# Move to payment processing
order.process_event(OrderEvent.PAYMENT_INITIATED)

# Fail payment
success, effects = order.process_event(
OrderEvent.PAYMENT_FAILED,
{&quot;reason&quot;: &quot;Insufficient funds&quot;}
)

assert order.state_name == &quot;cancelled&quot;  # No more retries

def _create_order_in_state(self, target_state: str) -&gt; Order:
&quot;&quot;&quot;Helper to create order in a specific state for testing.&quot;&quot;&quot;
order = Order(
id=f&quot;ORD-{target_state}&quot;,
customer_email=&quot;test@example.com&quot;,
items=[{&quot;sku&quot;: &quot;TEST&quot;, &quot;qty&quot;: 1}],
total=99.99
)

# Define path to each state
paths = {
&quot;pending_payment&quot;: [],
&quot;payment_processing&quot;: [OrderEvent.PAYMENT_INITIATED],
&quot;paid&quot;: [
OrderEvent.PAYMENT_INITIATED,
OrderEvent.PAYMENT_AUTHORIZED,
OrderEvent.PAYMENT_CAPTURED
],
&quot;ready_for_fulfillment&quot;: [
OrderEvent.PAYMENT_INITIATED,
OrderEvent.PAYMENT_AUTHORIZED,
OrderEvent.PAYMENT_CAPTURED,
OrderEvent.ITEMS_RESERVED
],
&quot;shipped&quot;: [
OrderEvent.PAYMENT_INITIATED,
OrderEvent.PAYMENT_AUTHORIZED,
OrderEvent.PAYMENT_CAPTURED,
OrderEvent.ITEMS_RESERVED,
OrderEvent.PICKING_STARTED,
OrderEvent.PICKING_COMPLETED,
OrderEvent.PACKED,
OrderEvent.SHIPPED
],
&quot;delivered&quot;: [
OrderEvent.PAYMENT_INITIATED,
OrderEvent.PAYMENT_AUTHORIZED,
OrderEvent.PAYMENT_CAPTURED,
OrderEvent.ITEMS_RESERVED,
OrderEvent.PICKING_STARTED,
OrderEvent.PICKING_COMPLETED,
OrderEvent.PACKED,
OrderEvent.SHIPPED,
OrderEvent.DELIVERED
],
}

for event in paths.get(target_state, []):
metadata = {}
if event == OrderEvent.PAYMENT_AUTHORIZED:
metadata = {&quot;auth_code&quot;: &quot;TEST_AUTH&quot;}
elif event == OrderEvent.SHIPPED:
metadata = {&quot;tracking_number&quot;: &quot;TEST123&quot;, &quot;carrier&quot;: &quot;UPS&quot;}
order.process_event(event, metadata)

return order


class TestStateMachineProperties:
&quot;&quot;&quot;Property-based tests for state machine invariants.&quot;&quot;&quot;

def test_terminal_states_have_no_transitions(self):
&quot;&quot;&quot;Verify terminal states reject all events.&quot;&quot;&quot;
terminal_states = [CancelledState(), ReturnedState(), ReturnToSenderState()]

for state in terminal_states:
assert state.is_terminal
assert len(state.allowed_events) == 0

def test_all_states_reachable_from_initial(self):
&quot;&quot;&quot;Verify every state can be reached from initial state.&quot;&quot;&quot;
# This would use graph traversal in production
pass

def test_no_state_has_transition_to_itself(self):
&quot;&quot;&quot;Self-transitions should be explicit, not implicit.&quot;&quot;&quot;
# Verify states don't accidentally return themselves
pass</code></pre>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 1.5rem 0">
<div style="background: #f8fafc; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem">[[Strategy Pattern]](/topic/design-patterns/strategy)</div>
<div style="font-size: 0.9rem; color: #475569; line-height: 1.6">
  Structurally identical but client selects algorithm. Consider when behavior varies by configuration, not lifecycle.
</div>
</div>
<div style="background: #f8fafc; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem">[[Command Pattern]](/topic/design-patterns/command)</div>
<div style="font-size: 0.9rem; color: #475569; line-height: 1.6">
  Encapsulate state transitions as command objects for undo/redo, queueing, or logging.
</div>
</div>
<div style="background: #f8fafc; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem">[[Observer Pattern]](/topic/design-patterns/observer)</div>
<div style="font-size: 0.9rem; color: #475569; line-height: 1.6">
  Notify external systems of state changes. Often combined with State for event-driven architectures.
</div>
</div>
<div style="background: #f8fafc; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem">[[Memento Pattern]](/topic/design-patterns/memento)</div>
<div style="font-size: 0.9rem; color: #475569; line-height: 1.6">
  Capture and restore state snapshots. Essential for undo functionality or state persistence.
</div>
</div>
<div style="background: #f8fafc; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem">[[Saga Pattern]](/topic/system-design/saga-pattern)</div>
<div style="font-size: 0.9rem; color: #475569; line-height: 1.6">
  Orchestrate distributed transactions as a sequence of local transactions with compensating actions.
</div>
</div>
<div style="background: #f8fafc; border-radius: 10px; padding: 1.25rem">
<div style="font-weight: 700; color: #1e293b; margin-bottom: 0.5rem">[[Event Sourcing]](/topic/system-design/event-sourcing)</div>
<div style="font-size: 0.9rem; color: #475569; line-height: 1.6">
  Store state changes as events. The state machine becomes a projection of the event stream.
</div>
</div>
</div>
<hr />
<h2 id="key-interview-takeaways">Key Interview Takeaways</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0">
<div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 1rem;padding-bottom: 0.75rem; color: #1e293b">Summary for Interviews</div>
<ul style="margin: 0; padding-left: 1.5rem; line-height: 2; color: #475569">
<li><strong>State vs Strategy:</strong> State changes internally based on lifecycle; Strategy is selected externally by client</li>
<li><strong>Transition ownership:</strong> States (encapsulated), Context (centralized), or Table (configurable)</li>
<li><strong>Hierarchical states:</strong> Reduce transition duplication, enable history states for "resume where you left off"</li>
<li><strong>Side effects:</strong> Return as data, execute after persistence, use idempotency keys</li>
<li><strong>Testing:</strong> Test all paths from initial to terminal, verify guards, check race conditions</li>
<li><strong>Production concerns:</strong> Optimistic locking, timeout handling, duplicate event detection</li>
</ul>
</div>
