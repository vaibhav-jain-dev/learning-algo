<h1 id="prototype-pattern">Prototype Pattern</h1>
<h2 id="overview">Overview</h2>
<p>The Prototype pattern creates new objects by cloning existing instances rather than invoking constructors directly. This creational pattern delegates object instantiation to the objects themselves through a polymorphic <code>clone()</code> method, enabling runtime flexibility and eliminating the coupling between client code and concrete classes.</p>
<div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);border-radius: 8px; padding: 16px; margin: 20px 0">
<div style="font-weight: 700; color: #92400e; margin-bottom: 8px">Core Assumption</div>
<div style="color: #78350f; font-size: 0.95rem">
The Prototype pattern assumes that <strong>copying an object is cheaper than constructing it from scratch</strong>. This assumption breaks down when objects contain non-cloneable resources (network connections, file handles) or when the cost of deep copying exceeds constructor cost.
</div>
</div>
<p>At the language level, cloning involves memory allocation for the new object followed by field-by-field copying. The critical distinction lies in how reference-typed fields are handled: shallow copying duplicates pointers while deep copying recursively duplicates the entire object graph. This distinction drives most interview questions about the pattern.</p>
<h3 id="interview-questions-overview">Interview Questions: Overview</h3>
<p><strong>Level 1: Why would you choose Prototype over calling a constructor directly?</strong></p>
<p>Constructors couple client code to concrete classes and require knowledge of all initialization parameters. Prototype enables polymorphic object creation where the client only knows the abstract <code>Prototype</code> interface. Additionally, when initialization involves expensive operations (loading assets, parsing configurations, network calls), cloning pre-initialized objects provides significant performance benefits.</p>
<p><strong>Level 2: How does the Prototype pattern interact with object identity and equality semantics?</strong></p>
<p>Cloning creates a new object with distinct identity (<code>clone != original</code>) but potentially equal state (<code>clone.equals(original)</code> may return true). This distinction matters for collections using identity-based hashing, observer registrations, and any system tracking objects by reference. The clone method must decide which identity-linked attributes (unique IDs, timestamps, observer subscriptions) to reset versus preserve.</p>
<p><strong>Level 3: In a distributed system where objects are serialized across network boundaries, what challenges arise when implementing Prototype, and how would you address objects containing references to shared remote resources?</strong></p>
<p>Distributed cloning faces several challenges: (1) References to remote services cannot be meaningfully cloned - the clone needs new connections or shared references with explicit lifecycle management; (2) Object versions may differ across nodes, requiring version-aware deserialization; (3) Circular references spanning multiple services require distributed memo tracking; (4) Clone operations may need to be transactional if the object graph spans multiple data stores. Solutions include using <a href="/topic/design-patterns/proxy">[Proxy Pattern]</a> for remote references, implementing clone factories that inject appropriate service connections, and using serialization frameworks with pluggable reference resolution strategies.</p>
<hr />
<h2 id="shallow-vs-deep-copy-the-critical-distinction">Shallow vs Deep Copy: The Critical Distinction</h2>
<p>Understanding copy semantics is fundamental to implementing Prototype correctly. This distinction appears in nearly every interview discussing the pattern.</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0; text-align: center; font-size: 1.1rem">Copy Semantics Comparison</h4>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px">
<div style="background: #dbeafe;border-radius: 8px; padding: 16px">
<div style="font-weight: 700; color: #1e40af; text-align: center; margin-bottom: 12px">Shallow Copy</div>
<div style="background: #eff6ff; border-radius: 6px; padding: 12px; margin-bottom: 12px">
<div style="font-size: 0.85rem; color: #1e40af">
<strong>Mechanism:</strong> Allocates new object, copies field values directly. Reference fields point to same objects as original.
</div>
</div>
<div style="font-size: 0.8rem; color: #2563eb">
<div style="margin-bottom: 6px"><strong>Object A (original)</strong></div>
<div style="background: #bfdbfe; padding: 8px; border-radius: 4px; margin-bottom: 8px">
  name: "Doc1"<br>
  data: [ref] ----+
</div>
<div style="margin-bottom: 6px"><strong>Object B (shallow clone)</strong></div>
<div style="background: #bfdbfe; padding: 8px; border-radius: 4px">
  name: "Doc1"<br>
  data: [ref] ----+---> [Shared Array]
</div>
</div>
</div>
<div style="background: #d1fae5;border-radius: 8px; padding: 16px">
<div style="font-weight: 700; color: #065f46; text-align: center; margin-bottom: 12px">Deep Copy</div>
<div style="background: #ecfdf5; border-radius: 6px; padding: 12px; margin-bottom: 12px">
<div style="font-size: 0.85rem; color: #065f46">
<strong>Mechanism:</strong> Recursively copies entire object graph. Each reference field points to a new copy of the referenced object.
</div>
</div>
<div style="font-size: 0.8rem; color: #059669">
<div style="margin-bottom: 6px"><strong>Object A (original)</strong></div>
<div style="background: #a7f3d0; padding: 8px; border-radius: 4px; margin-bottom: 8px">
  name: "Doc1"<br>
  data: [ref] ----> [Array A]
</div>
<div style="margin-bottom: 6px"><strong>Object B (deep clone)</strong></div>
<div style="background: #a7f3d0; padding: 8px; border-radius: 4px">
  name: "Doc1"<br>
  data: [ref] ----> [Array B] (copy)
</div>
</div>
</div>
</div>
</div>
<h3 id="memory-layout-and-performance-implications">Memory Layout and Performance Implications</h3>
<p><strong>Shallow copy</strong> performs in O(1) relative to nested object graph size - it only copies the immediate object's fields regardless of how complex the referenced objects are. However, this creates <strong>aliasing</strong>: mutations through one reference affect all objects sharing that reference.</p>
<p><strong>Deep copy</strong> performs in O(n) where n is the total size of the object graph. Memory consumption doubles (or more, accounting for overhead). For large object graphs, this can cause significant GC pressure and latency spikes.</p>
<div style="background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);border-radius: 8px; padding: 16px; margin: 20px 0">
<div style="font-weight: 700; color: #9d174d; margin-bottom: 8px">Critical Trade-off</div>
<div style="color: #831843; font-size: 0.95rem">
The choice between shallow and deep copy is not binary. Production implementations often use <strong>hybrid approaches</strong>: deep copy for mutable state, shallow copy (or shared references) for immutable data and expensive-to-copy resources. This requires careful documentation of which fields are shared versus independent.
</div>
</div>
<h3 id="handling-circular-references">Handling Circular References</h3>
<p>Circular references create infinite recursion in naive deep copy implementations. The solution is <strong>memo-based copying</strong>: maintain a dictionary mapping original objects to their clones. Before copying any object, check if it already exists in the memo.</p>
<pre><code>    ```python
    def deep_copy_with_memo(obj, memo=None):
    if memo is None:
    memo = {}

    # Check if already copied
    obj_id = id(obj)
    if obj_id in memo:
    return memo[obj_id]

    # Create shell object and register BEFORE recursing
    clone = object.__new__(type(obj))
    memo[obj_id] = clone

    # Now safe to recursively copy fields
    for key, value in obj.__dict__.items():
    setattr(clone, key, deep_copy_with_memo(value, memo))

    return clone
    ```
</code></pre>
<p>Python's <code>copy.deepcopy()</code> implements this pattern internally. The critical insight is that the clone must be registered in the memo <strong>before</strong> recursively copying its fields - otherwise circular references will still cause infinite recursion.</p>
<h3 id="interview-questions-shallow-vs-deep-copy">Interview Questions: Shallow vs Deep Copy</h3>
<p><strong>Level 1: When is shallow copy sufficient, and when must you use deep copy?</strong></p>
<p>Shallow copy suffices when: (1) All nested objects are immutable (strings, frozen collections), (2) You intentionally want clones to share state (e.g., shared configuration), (3) Performance constraints prohibit deep copying. Deep copy is required when clones must be independently mutable without affecting each other's nested state.</p>
<p><strong>Level 2: How would you implement a copy strategy that deep-copies some fields while shallow-copying others, and what documentation would you provide?</strong></p>
<p>Implement a custom <code>clone()</code> method that explicitly handles each field category. Document using a &quot;clone contract&quot; specifying: (1) Which fields are deep-copied (independent after cloning), (2) Which fields are shallow-copied (shared references), (3) Which fields are reset (IDs, timestamps), (4) Which fields reference non-cloneable resources. Consider using annotations or builder patterns to make the strategy explicit in code.</p>
<p><strong>Level 3: In a system processing 10,000 clone operations per second on objects with 1MB average deep-copy size, what memory and GC implications arise, and how would you design the cloning strategy to minimize latency variance?</strong></p>
<p>At 10K ops/sec with 1MB copies, you're generating 10GB/sec of short-lived objects - catastrophic for GC. Solutions: (1) Use <a href="/topic/design-patterns/object-pool">[Object Pool Pattern]</a> with explicit recycling instead of cloning; (2) Implement copy-on-write semantics where clones share data until mutation; (3) Use structural sharing (persistent data structures) where unchanged subtrees are shared; (4) Implement region-based cloning where objects are allocated in arenas that can be bulk-freed; (5) Profile to identify the 20% of fields causing 80% of copy cost and consider lazy cloning for those. The key insight is that Prototype may be the wrong pattern at this scale - consider <a href="/topic/design-patterns/flyweight">[Flyweight]</a> for shared intrinsic state.</p>
<hr />
<h2 id="javas-cloneable-interface-a-cautionary-tale">Java's Cloneable Interface: A Cautionary Tale</h2>
<p>Java's built-in cloning mechanism via <code>Cloneable</code> interface and <code>Object.clone()</code> is one of the most criticized features in the language. Understanding its flaws is essential for Java interviews.</p>
<div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);border-radius: 12px; padding: 20px; margin: 20px 0">
<h4 style="color: #991b1b; margin-top: 0">Why Java's Cloneable is Broken</h4>
<div style="display: flex; flex-direction: column; gap: 12px; margin-top: 16px">
<div style="background: #fff; border-radius: 8px; padding: 12px">
<div style="font-weight: 600; color: #991b1b">1. Marker Interface Anti-pattern</div>
<div style="font-size: 0.9rem; color: #7f1d1d">Cloneable has no methods. The clone() method is defined in Object, not Cloneable. Implementing Cloneable just changes Object.clone()'s behavior from throwing CloneNotSupportedException to performing a shallow copy.</div>
</div>
<div style="background: #fff; border-radius: 8px; padding: 12px">
<div style="font-weight: 600; color: #991b1b">2. Extralinguistic Object Creation</div>
<div style="font-size: 0.9rem; color: #7f1d1d">clone() creates objects without calling constructors, bypassing initialization logic and invariant establishment. Final fields cannot be set after Object.clone() returns, breaking immutability patterns.</div>
</div>
<div style="background: #fff; border-radius: 8px; padding: 12px">
<div style="font-weight: 600; color: #991b1b">3. Inheritance Complexity</div>
<div style="font-size: 0.9rem; color: #7f1d1d">If a parent class overrides clone() but a child doesn't, the child's clone will have wrong runtime type unless using super.clone() chain. Covariant return types partially address this but add complexity.</div>
</div>
<div style="background: #fff; border-radius: 8px; padding: 12px">
<div style="font-weight: 600; color: #991b1b">4. Shallow Copy Default</div>
<div style="font-size: 0.9rem; color: #7f1d1d">Object.clone() performs shallow copy. Every Cloneable implementation must manually deep-copy mutable fields, which is error-prone and often forgotten.</div>
</div>
</div>
</div>
<h3 id="the-correct-way-to-implement-cloneable-if-you-must">The &quot;Correct&quot; Way to Implement Cloneable (If You Must)</h3>
<pre><code>    ```java
    public class Document implements Cloneable {
    private String title;                    // Immutable - shallow copy OK
    private Date createdAt;                  // Mutable - must deep copy
    private List&lt;Section&gt; sections;          // Mutable collection - must deep copy
      private final UUID id;                   // Final field problem!

      @Override
      public Document clone() {
      try {
      Document clone = (Document) super.clone();

      // Deep copy mutable fields
      clone.createdAt = (Date) this.createdAt.clone();
      clone.sections = new ArrayList&lt;&gt;();
      for (Section s : this.sections) {
      clone.sections.add(s.clone());  // Sections must also be Cloneable
      }

      // PROBLEM: Cannot reassign final field 'id'
      // clone.id = UUID.randomUUID();  // Compile error!

      return clone;
      } catch (CloneNotSupportedException e) {
      throw new AssertionError();  // Can't happen if we implement Cloneable
      }
      }
      }
      ```
</code></pre>
<h3 id="preferred-alternatives-to-cloneable">Preferred Alternatives to Cloneable</h3>
<div style="background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);border-radius: 12px; padding: 20px; margin: 20px 0">
<h4 style="color: #065f46; margin-top: 0">Better Approaches in Java</h4>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-top: 16px">
<div style="background: #fff; border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #065f46; margin-bottom: 8px">Copy Constructor</div>
<div style="font-size: 0.85rem; color: #047857">
<code>public Document(Document other)</code><br><br>
  Explicit, uses normal construction, can set final fields, no checked exceptions.
</div>
</div>
<div style="background: #fff; border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #065f46; margin-bottom: 8px">Static Factory Method</div>
<div style="font-size: 0.85rem; color: #047857">
<code>public static Document copyOf(Document d)</code><br><br>
  Can return subtype, can cache, descriptive naming, full control over construction.
</div>
</div>
<div style="background: #fff; border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #065f46; margin-bottom: 8px">Serialization Round-trip</div>
<div style="font-size: 0.85rem; color: #047857">
  Serialize to bytes, deserialize to new object. Handles entire object graph automatically. Slower but handles complex graphs.
</div>
</div>
<div style="background: #fff; border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #065f46; margin-bottom: 8px">Builder Pattern</div>
<div style="font-size: 0.85rem; color: #047857">
<code>Document.builder(original).withId(newId).build()</code><br><br>
  Maximum flexibility, explicit about modifications, works with immutable objects.
</div>
</div>
</div>
</div>
<h3 id="interview-questions-java-cloneable">Interview Questions: Java Cloneable</h3>
<p><strong>Level 1: Why is implementing Cloneable considered problematic in Java?</strong></p>
<p>Cloneable is a marker interface with no clone() method - the method lives in Object. Clone bypasses constructors, making it impossible to enforce invariants or initialize final fields. The default shallow copy behavior requires manual deep-copy code for every mutable field. The checked CloneNotSupportedException is almost always impossible when the class implements Cloneable, yet must still be caught.</p>
<p><strong>Level 2: How would you design a cloneable class hierarchy where both parent and child classes have mutable state that needs deep copying?</strong></p>
<p>Each class in the hierarchy must: (1) Call super.clone() to get proper runtime type, (2) Deep-copy its own mutable fields after super.clone() returns, (3) Document the clone contract for subclasses. The parent's clone() should be protected if not all subclasses should be cloneable. Consider making clone() final in the parent if the class hierarchy's cloning semantics shouldn't be overridden. Use covariant return types for type-safe cloning.</p>
<p><strong>Level 3: Given that Object.clone() bypasses constructors, how would you implement clone() for a class that uses constructor injection for dependencies, maintains invariants checked in the constructor, and has final fields that should differ between original and clone?</strong></p>
<p>This scenario exposes Cloneable's fundamental design flaw. Solutions: (1) Abandon Cloneable entirely - use copy constructor that takes both the source object and the dependencies to inject; (2) Use a static factory that creates a new instance via constructor, then copies state: <code>Document copyOf(Document src, IdGenerator idGen)</code>; (3) If forced to use clone(), make fields non-final and use a post-clone initialization method (breaks immutability); (4) Use <a href="/topic/design-patterns/builder">[Builder Pattern]</a> where <code>toBuilder()</code> returns a pre-populated builder that can be modified before building a new instance with proper construction.</p>
<hr />
<h2 id="prototype-registry-managing-prototype-collections">Prototype Registry: Managing Prototype Collections</h2>
<p>The Prototype Registry (also called Prototype Manager) centralizes prototype storage and provides named access to clones. This is essential when prototypes are expensive to create or configured at startup.</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0; text-align: center; font-size: 1.1rem">Prototype Registry Architecture</h4>
<div style="display: flex; flex-direction: column; gap: 20px; margin-top: 20px">
<div style="display: flex; justify-content: center; align-items: center; gap: 24px; flex-wrap: wrap">
<div style="background: #e0e7ff;border-radius: 8px; padding: 16px; text-align: center; min-width: 120px">
<div style="font-weight: 600; color: #3730a3">Client</div>
<div style="font-size: 0.75rem; color: #4f46e5; margin-top: 4px">Requests clones by name</div>
</div>
<div style="color: #64748b; font-size: 1.5rem">&#8594;</div>
<div style="background: #fef3c7;border-radius: 8px; padding: 16px; text-align: center; min-width: 180px">
<div style="font-weight: 600; color: #92400e">Prototype Registry</div>
<div style="font-size: 0.75rem; color: #b45309; margin-top: 4px">
  register(name, proto)<br>
  clone(name): Prototype<br>
  unregister(name)
</div>
</div>
<div style="color: #64748b; font-size: 1.5rem">&#8594;</div>
<div style="display: flex; flex-direction: column; gap: 8px">
<div style="background: #dbeafe;border-radius: 6px; padding: 8px 16px; text-align: center">
<div style="font-size: 0.8rem; color: #1e40af">"report" : ReportProto</div>
</div>
<div style="background: #d1fae5;border-radius: 6px; padding: 8px 16px; text-align: center">
<div style="font-size: 0.8rem; color: #065f46">"invoice" : InvoiceProto</div>
</div>
<div style="background: #fce7f3;border-radius: 6px; padding: 8px 16px; text-align: center">
<div style="font-size: 0.8rem; color: #9d174d">"memo" : MemoProto</div>
</div>
</div>
</div>
<div style="background: #f1f5f9; border-radius: 8px; padding: 12px">
<div style="font-size: 0.85rem; color: #475569">
<strong>Key Behaviors:</strong> (1) Clients decouple from concrete classes - only know prototype names; (2) Prototypes can be added/removed at runtime; (3) Registry can implement lazy initialization, caching, or pooling strategies.
</div>
</div>
</div>
</div>
<h3 id="registry-implementation-considerations">Registry Implementation Considerations</h3>
<p><strong>Thread Safety</strong>: In concurrent systems, the registry must handle simultaneous registrations and clone requests. Options include:<br />
- Concurrent hash maps for lock-free reads<br />
- Read-write locks for read-heavy workloads<br />
- Copy-on-write for rarely-modified registries</p>
<p><strong>Hierarchical Registries</strong>: Large systems may use registry hierarchies - local registries that fall back to parent registries, enabling context-specific prototypes with shared defaults.</p>
<p><strong>Lazy vs Eager Initialization</strong>: Prototypes can be created eagerly at startup (faster clone requests, longer startup) or lazily on first request (faster startup, first-request latency).</p>
<pre><code>                      ```python
                      class PrototypeRegistry:
                      def __init__(self, parent: 'PrototypeRegistry' = None):
                      self._prototypes: Dict[str, Prototype] = {}
                      self._factories: Dict[str, Callable[[], Prototype]] = {}  # Lazy init
                      self._parent = parent
                      self._lock = threading.RLock()

                      def register(self, name: str, prototype: Prototype) -&gt; None:
                      with self._lock:
                      self._prototypes[name] = prototype

                      def register_factory(self, name: str, factory: Callable[[], Prototype]) -&gt; None:
                      &quot;&quot;&quot;Register a factory for lazy prototype initialization.&quot;&quot;&quot;
                      with self._lock:
                      self._factories[name] = factory

                      def clone(self, name: str) -&gt; Prototype:
                      with self._lock:
                      # Check local prototypes
                      if name in self._prototypes:
                      return self._prototypes[name].clone()

                      # Check lazy factories
                      if name in self._factories:
                      self._prototypes[name] = self._factories[name]()
                      del self._factories[name]
                      return self._prototypes[name].clone()

                      # Fall back to parent registry
                      if self._parent:
                      return self._parent.clone(name)

                      raise KeyError(f&quot;Unknown prototype: {name}&quot;)
                      ```
</code></pre>
<h3 id="interview-questions-prototype-registry">Interview Questions: Prototype Registry</h3>
<p><strong>Level 1: What are the benefits of using a Prototype Registry versus having clients manage prototypes directly?</strong></p>
<p>The registry centralizes prototype lifecycle management, enabling: (1) Named access without clients knowing concrete types; (2) Runtime registration/modification of prototypes; (3) Centralized policies for caching, initialization, and access control; (4) Easier testing through registry mocking; (5) Decoupling between prototype creation and usage locations.</p>
<p><strong>Level 2: How would you design a registry that supports prototype versioning, allowing clients to request specific versions or &quot;latest&quot;?</strong></p>
<p>Extend the registry key to include version: <code>Map&lt;(name, version), Prototype&gt;</code>. Maintain a separate &quot;latest&quot; pointer per name. Implement version resolution strategies: exact match, compatible range (semver), or fallback chain. Consider whether clones should embed their source version for debugging. For audit requirements, log which version was cloned when. Handle version deprecation with grace periods and warnings.</p>
<p><strong>Level 3: Design a distributed prototype registry for a microservices architecture where prototypes may be defined in different services and need to be accessible across the cluster with consistency guarantees.</strong></p>
<p>Key challenges: (1) <strong>Discovery</strong>: Use service registry (Consul, etcd) to track which services offer which prototypes; (2) <strong>Serialization</strong>: Prototypes must be serializable across service boundaries - define a wire format and versioning scheme; (3) <strong>Caching</strong>: Local caches reduce latency but need invalidation strategies (TTL, pub/sub notifications); (4) <strong>Consistency</strong>: Choose between strong consistency (serialize through leader) or eventual consistency (acceptable staleness). Consider <a href="/topic/system-design/cqrs">[CQRS]</a> where prototype definitions are commands and local caches are eventually-consistent read models; (5) <strong>Failure handling</strong>: Define behavior when remote registry is unavailable - fail fast, use stale cache, or degrade to local-only prototypes.</p>
<hr />
<h2 id="cloning-complex-objects-advanced-scenarios">Cloning Complex Objects: Advanced Scenarios</h2>
<p>Real-world objects often contain elements that complicate cloning: circular references, external resource handles, lazy-loaded proxies, and observer relationships.</p>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0; text-align: center; font-size: 1.1rem">Complex Object Cloning Challenges</h4>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-top: 20px">
<div style="background: #fef2f2;border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">Circular References</div>
<div style="font-size: 0.85rem; color: #7f1d1d">
  Object A references B, B references A. Naive deep copy causes infinite recursion. Solution: memo-based copying with pre-registration.
</div>
</div>
<div style="background: #fef2f2;border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">External Resources</div>
<div style="font-size: 0.85rem; color: #7f1d1d">
  Database connections, file handles, sockets cannot be meaningfully copied. Options: share reference, create new connection, or null and lazy-reinitialize.
</div>
</div>
<div style="background: #fef2f2;border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">Lazy-Loaded Proxies</div>
<div style="font-size: 0.85rem; color: #7f1d1d">
  ORM proxies (Hibernate, SQLAlchemy) may trigger database loads during cloning. Decide: clone the proxy, force-load then clone, or clone only loaded state.
</div>
</div>
<div style="background: #fef2f2;border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">Observer Relationships</div>
<div style="font-size: 0.85rem; color: #7f1d1d">
  If original has registered listeners/observers, should clone inherit them? Usually no - clone should have empty observer list requiring explicit re-registration.
</div>
</div>
<div style="background: #fef2f2;border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">Transient/Derived State</div>
<div style="font-size: 0.85rem; color: #7f1d1d">
  Cached computations, memoized values. Options: copy cached state (faster but may be stale) or invalidate caches (slower but correct).
</div>
</div>
<div style="background: #fef2f2;border-radius: 8px; padding: 16px">
<div style="font-weight: 600; color: #991b1b; margin-bottom: 8px">Identity Fields</div>
<div style="font-size: 0.85rem; color: #7f1d1d">
  UUIDs, database IDs, creation timestamps must typically be regenerated for clones to avoid identity conflicts.
</div>
</div>
</div>
</div>
<h3 id="clone-contract-documentation">Clone Contract Documentation</h3>
<p>Complex objects need explicit documentation of cloning behavior:</p>
<pre><code>                      ```python
                      class Order(Prototype):
                      &quot;&quot;&quot;
                      Clone Contract:

                      DEEP COPIED (independent after clone):
                      - line_items: List[LineItem] - each item cloned
                      - shipping_address: Address - full copy
                      - custom_fields: Dict - deep copied

                      SHALLOW COPIED (shared reference):
                      - customer: Customer - references same customer
                      - product_catalog: Catalog - shared, immutable

                      RESET (new value for clone):
                      - id: regenerated UUID
                      - created_at: current timestamp
                      - status: reset to DRAFT
                      - observers: empty list (re-register if needed)

                      NOT COPIED (null in clone):
                      - payment_info: security-sensitive, must be re-entered
                      - audit_log: clone starts fresh audit trail
                      &quot;&quot;&quot;
                      ```
</code></pre>
<h3 id="implementing-cloneable-with-external-resources">Implementing Cloneable with External Resources</h3>
<pre><code>                      ```python
                      class DatabaseBackedDocument(Prototype):
                      def __init__(self, doc_id: str, connection_pool: ConnectionPool):
                      self.doc_id = doc_id
                      self._connection_pool = connection_pool  # External resource
                      self._content = None  # Lazy loaded
                      self._observers: List[Observer] = []
                      self._cache: Dict[str, Any] = {}

                      def clone(self) -&gt; 'DatabaseBackedDocument':
                      &quot;&quot;&quot;
                      Creates a new document that shares the connection pool
                      but has independent state.
                      &quot;&quot;&quot;
                      # Use new ID for the clone
                      new_id = str(uuid.uuid4())

                      # Create new instance - DON'T deepcopy the whole thing
                      clone = DatabaseBackedDocument(new_id, self._connection_pool)

                      # Deep copy the content if loaded
                      if self._content is not None:
                      clone._content = copy.deepcopy(self._content)

                      # Don't copy observers - clone starts with none
                      clone._observers = []

                      # Invalidate cache - clone computes fresh
                      clone._cache = {}

                      return clone
                      ```
</code></pre>
<h3 id="interview-questions-cloning-complex-objects">Interview Questions: Cloning Complex Objects</h3>
<p><strong>Level 1: What special handling is needed when cloning objects that contain database connections or file handles?</strong></p>
<p>These resources cannot be duplicated at the OS/network level. Options: (1) Share the reference if thread-safe and semantically appropriate; (2) Create a new connection for the clone from a connection pool; (3) Set to null in clone and lazy-initialize on first access; (4) Throw an exception if cloning resource-holding objects is prohibited by design. Document the chosen behavior clearly.</p>
<p><strong>Level 2: How would you implement clone() for an object graph where some objects should be shared between original and clone while others should be deeply copied?</strong></p>
<p>Implement a custom cloning visitor that traverses the object graph with explicit rules per type. Use annotations or a configuration map to specify clone strategy per field/type: <code>@CloneStrategy(DEEP)</code>, <code>@CloneStrategy(SHALLOW)</code>, <code>@CloneStrategy(RESET)</code>, <code>@CloneStrategy(SKIP)</code>. The visitor maintains a memo for already-cloned objects while respecting the per-field strategy. Consider implementing <code>CloneContext</code> that carries both the memo and the strategy configuration.</p>
<p><strong>Level 3: Design a cloning system for a domain model using an ORM (like Hibernate) where entities have lazy-loaded relationships, version fields for optimistic locking, and bidirectional associations. How do you handle detached vs managed entity cloning?</strong></p>
<p>This is a deeply challenging scenario: (1) <strong>Lazy loading</strong>: Decide whether to clone proxies as-is (clone will trigger load on access), force-initialize before cloning (N+1 queries), or explicitly load only needed relationships; (2) <strong>Versioning</strong>: Clone must have version=0 or null for new entities, otherwise optimistic locking fails; (3) <strong>Bidirectional associations</strong>: When cloning A-&gt;B and B-&gt;A, both clones must reference each other, not the originals - requires memo-based approach with post-processing to fix up back-references; (4) <strong>Managed vs detached</strong>: Cloning managed entities may require explicit detachment first; the clone should typically be transient (not yet persisted); (5) <strong>ID generation</strong>: Clear IDs so the ORM treats clones as new entities. Consider implementing as an ORM session extension: <code>session.clone(entity, depth_config)</code> that handles these concerns systematically. Use <a href="/topic/design-patterns/unit-of-work">[Unit of Work]</a> pattern awareness to track clone lifecycle.</p>
<hr />
<h2 id="real-world-implementation-patterns">Real-World Implementation Patterns</h2>
<h3 id="pattern-1-prototype-with-copy-on-write">Pattern 1: Prototype with Copy-on-Write</h3>
<p>For memory efficiency when clones rarely diverge:</p>
<pre><code>                      ```python
                      class CopyOnWriteDocument:
                      &quot;&quot;&quot;Shares state until modification, then copies.&quot;&quot;&quot;

                      def __init__(self, data=None, shared_data=None):
                      if shared_data is not None:
                      self._shared_data = shared_data
                      self._local_modifications = {}
                      self._is_copy = True
                      else:
                      self._shared_data = data or {}
                      self._local_modifications = {}
                      self._is_copy = False

                      def clone(self) -&gt; 'CopyOnWriteDocument':
                      # Clone shares original data, tracks own modifications
                      return CopyOnWriteDocument(shared_data=self._shared_data)

                      def __getitem__(self, key):
                      if key in self._local_modifications:
                      return self._local_modifications[key]
                      return self._shared_data[key]

                      def __setitem__(self, key, value):
                      # Modifications go to local storage only
                      self._local_modifications[key] = value

                      def materialize(self) -&gt; Dict:
                      &quot;&quot;&quot;Create fully independent copy of current state.&quot;&quot;&quot;
                      result = dict(self._shared_data)
                      result.update(self._local_modifications)
                      return result
                      ```
</code></pre>
<h3 id="pattern-2-versioned-prototype-registry">Pattern 2: Versioned Prototype Registry</h3>
<pre><code>                      ```python
                      class VersionedPrototypeRegistry:
                      &quot;&quot;&quot;Registry supporting multiple prototype versions.&quot;&quot;&quot;

                      def __init__(self):
                      self._versions: Dict[str, Dict[str, Prototype]] = defaultdict(dict)
                      self._latest: Dict[str, str] = {}  # name -&gt; latest version

                      def register(self, name: str, version: str, prototype: Prototype) -&gt; None:
                      self._versions[name][version] = prototype
                      # Update latest if this is newer
                      if name not in self._latest or version &gt; self._latest[name]:
                      self._latest[name] = version

                      def clone(self, name: str, version: str = None) -&gt; Prototype:
                      if version is None:
                      version = self._latest.get(name)
                      if version is None:
                      raise KeyError(f&quot;No versions registered for '{name}'&quot;)

                      prototype = self._versions[name].get(version)
                      if prototype is None:
                      raise KeyError(f&quot;Version '{version}' not found for '{name}'&quot;)

                      clone = prototype.clone()
                      # Embed source version metadata
                      if hasattr(clone, 'metadata'):
                      clone.metadata['_cloned_from_version'] = version
                      return clone
                      ```
</code></pre>
<h3 id="pattern-3-prototype-factory-integration">Pattern 3: Prototype Factory Integration</h3>
<p>Combining Prototype with <a href="/topic/design-patterns/factory-method">[Factory Method]</a> for flexible object creation:</p>
<pre><code>                      ```python
                      class DocumentFactory:
                      &quot;&quot;&quot;Factory that uses prototypes for common cases, construction for custom.&quot;&quot;&quot;

                      def __init__(self, registry: PrototypeRegistry):
                      self._registry = registry

                      def create(self, doc_type: str, **customizations) -&gt; Document:
                      try:
                      # Try to clone from registry first
                      doc = self._registry.clone(doc_type)
                      except KeyError:
                      # Fall back to construction for unknown types
                      doc = self._construct_custom(doc_type)

                      # Apply customizations
                      for key, value in customizations.items():
                      setattr(doc, key, value)

                      return doc

                      def _construct_custom(self, doc_type: str) -&gt; Document:
                      # Factory method for types without prototypes
                      return Document(title=f&quot;New {doc_type}&quot;, content=&quot;&quot;)
                      ```
</code></pre>
<hr />
<h2 id="code-implementation">Code Implementation</h2>
<h3 id="python-implementation">Python Implementation</h3>
<pre><code>                      ```python
                      &quot;&quot;&quot;
                      Prototype Pattern - Complete Implementation

                      Demonstrates:
                      - Deep vs shallow cloning
                      - Prototype registry with versioning
                      - Complex object cloning with external resources
                      - Copy-on-write optimization
                      - Thread-safe registry operations
                      &quot;&quot;&quot;

                      import copy
                      import uuid
                      import threading
                      from abc import ABC, abstractmethod
                      from typing import Dict, Any, Optional, Callable, List
                      from datetime import datetime
                      from collections import defaultdict


                      class Prototype(ABC):
                      &quot;&quot;&quot;
                      Abstract prototype interface.

                      Subclasses must implement clone() to create copies of themselves.
                      The implementation should document its clone contract explicitly.
                      &quot;&quot;&quot;

                      @abstractmethod
                      def clone(self) -&gt; 'Prototype':
                      &quot;&quot;&quot;
                      Create a copy of this object.

                      Returns:
                      A new instance that is a copy of this object.
                      The copy semantics (shallow vs deep) are implementation-specific.
                      &quot;&quot;&quot;
                      pass


                      class Document(Prototype):
                      &quot;&quot;&quot;
                      A document with complex nested structure demonstrating proper cloning.

                      Clone Contract:
                      - title, content: deep copied (new strings)
                      - metadata: deep copied (independent dict)
                      - sections: deep copied (independent list with copied sections)
                      - formatting: deep copied (independent nested structure)
                      - id: RESET to new UUID
                      - created_at: RESET to current time
                      - observers: RESET to empty list
                      &quot;&quot;&quot;

                      def __init__(self, title: str, content: str = &quot;&quot;):
                      self.id = str(uuid.uuid4())
                      self.title = title
                      self.content = content
                      self.metadata: Dict[str, Any] = {}
                      self.sections: List[Dict[str, str]] = []
                      self.formatting = {
                      'font': 'Arial',
                      'size': 12,
                      'margins': {'top': 1, 'bottom': 1, 'left': 1, 'right': 1}
                      }
                      self.created_at = datetime.now()
                      self._observers: List[Callable] = []  # Not cloned

                      def add_section(self, name: str, content: str) -&gt; None:
                      self.sections.append({'name': name, 'content': content})

                      def add_observer(self, callback: Callable) -&gt; None:
                      self._observers.append(callback)

                      def clone(self) -&gt; 'Document':
                      &quot;&quot;&quot;Create a deep copy with reset identity fields.&quot;&quot;&quot;
                      # Deep copy entire object graph
                      cloned = copy.deepcopy(self)

                      # Reset identity fields
                      cloned.id = str(uuid.uuid4())
                      cloned.created_at = datetime.now()

                      # Clear observers - clone starts fresh
                      cloned._observers = []

                      return cloned

                      def __repr__(self) -&gt; str:
                      return (f&quot;Document(id={self.id[:8]}..., title='{self.title}', &quot;
                      f&quot;sections={len(self.sections)}, created={self.created_at.isoformat()})&quot;)


                      class GameCharacter(Prototype):
                      &quot;&quot;&quot;
                      Game character demonstrating cloning with shared immutable resources.

                      Clone Contract:
                      - name, character_class, stats: deep copied
                      - skills, inventory, equipment: deep copied
                      - _loaded_assets: SHALLOW copied (immutable, expensive to load)
                      - position: RESET to spawn point
                      - entity_id: RESET to new UUID
                      &quot;&quot;&quot;

                      def __init__(self, name: str, character_class: str):
                      self.entity_id = str(uuid.uuid4())
                      self.name = name
                      self.character_class = character_class
                      self.level = 1
                      self.health = 100
                      self.mana = 50
                      self.skills: Dict[str, int] = {}
                      self.inventory: List[str] = []
                      self.equipment = {'weapon': None, 'armor': None, 'accessory': None}
                      self.position = {'x': 0.0, 'y': 0.0, 'z': 0.0}

                      # Expensive to load, immutable - will be shared
                      self._loaded_assets = self._load_assets()

                      def _load_assets(self) -&gt; Dict[str, str]:
                      &quot;&quot;&quot;Simulate expensive asset loading.&quot;&quot;&quot;
                      # In production: load 3D models, textures, animations
                      return {
                      'model': f'{self.character_class.lower()}_model.fbx',
                      'texture': f'{self.character_class.lower()}_texture.png',
                      'animations': f'{self.character_class.lower()}_anims.dat'
                      }

                      def clone(self) -&gt; 'GameCharacter':
                      &quot;&quot;&quot;
                      Clone character with deep copy of mutable state,
                      shallow copy of immutable assets.
                      &quot;&quot;&quot;
                      # Create new instance without expensive asset loading
                      clone = object.__new__(GameCharacter)

                      # Copy primitive fields
                      clone.name = self.name
                      clone.character_class = self.character_class
                      clone.level = self.level
                      clone.health = self.health
                      clone.mana = self.mana

                      # Deep copy mutable collections
                      clone.skills = dict(self.skills)
                      clone.inventory = list(self.inventory)
                      clone.equipment = dict(self.equipment)

                      # Reset position to spawn point
                      clone.position = {'x': 0.0, 'y': 0.0, 'z': 0.0}

                      # New entity ID
                      clone.entity_id = str(uuid.uuid4())

                      # SHALLOW copy - share immutable assets
                      clone._loaded_assets = self._loaded_assets

                      return clone

                      def __repr__(self) -&gt; str:
                      return (f&quot;GameCharacter(id={self.entity_id[:8]}..., name='{self.name}', &quot;
                      f&quot;class={self.character_class}, level={self.level})&quot;)


                      class PrototypeRegistry:
                      &quot;&quot;&quot;
                      Thread-safe registry for managing named prototypes.

                      Supports:
                      - Immediate registration with prototype instances
                      - Lazy registration with factory functions
                      - Hierarchical registries (parent fallback)
                      - Thread-safe operations
                      &quot;&quot;&quot;

                      def __init__(self, parent: 'PrototypeRegistry' = None):
                      self._prototypes: Dict[str, Prototype] = {}
                      self._factories: Dict[str, Callable[[], Prototype]] = {}
                      self._parent = parent
                      self._lock = threading.RLock()

                      def register(self, name: str, prototype: Prototype) -&gt; None:
                      &quot;&quot;&quot;Register a prototype instance.&quot;&quot;&quot;
                      with self._lock:
                      self._prototypes[name] = prototype
                      # Clear any factory for this name
                      self._factories.pop(name, None)

                      def register_lazy(self, name: str, factory: Callable[[], Prototype]) -&gt; None:
                      &quot;&quot;&quot;Register a factory for lazy prototype initialization.&quot;&quot;&quot;
                      with self._lock:
                      self._factories[name] = factory

                      def unregister(self, name: str) -&gt; bool:
                      &quot;&quot;&quot;Remove a prototype. Returns True if found and removed.&quot;&quot;&quot;
                      with self._lock:
                      removed = name in self._prototypes or name in self._factories
                      self._prototypes.pop(name, None)
                      self._factories.pop(name, None)
                      return removed

                      def clone(self, name: str) -&gt; Prototype:
                      &quot;&quot;&quot;
                      Clone a prototype by name.

                      Resolution order:
                      1. Local prototypes
                      2. Local factories (lazily initialized)
                      3. Parent registry (if exists)

                      Raises:
                      KeyError: If prototype not found in any registry
                      &quot;&quot;&quot;
                      with self._lock:
                      # Check local prototypes
                      if name in self._prototypes:
                      return self._prototypes[name].clone()

                      # Check lazy factories
                      if name in self._factories:
                      # Initialize and cache
                      self._prototypes[name] = self._factories[name]()
                      del self._factories[name]
                      return self._prototypes[name].clone()

                      # Try parent
                      if self._parent is not None:
                      return self._parent.clone(name)

                      raise KeyError(f&quot;Prototype '{name}' not found in registry&quot;)

                      def list_prototypes(self) -&gt; List[str]:
                      &quot;&quot;&quot;List all available prototype names including lazy ones.&quot;&quot;&quot;
                      with self._lock:
                      names = set(self._prototypes.keys()) | set(self._factories.keys())
                      if self._parent:
                      names |= set(self._parent.list_prototypes())
                      return sorted(names)

                      def __contains__(self, name: str) -&gt; bool:
                      &quot;&quot;&quot;Check if a prototype is registered.&quot;&quot;&quot;
                      with self._lock:
                      if name in self._prototypes or name in self._factories:
                      return True
                      if self._parent:
                      return name in self._parent
                      return False


                      class VersionedPrototypeRegistry:
                      &quot;&quot;&quot;
                      Registry supporting multiple versions of prototypes.

                      Supports:
                      - Multiple versions per prototype name
                      - &quot;Latest&quot; version tracking
                      - Version metadata embedding in clones
                      &quot;&quot;&quot;

                      def __init__(self):
                      self._versions: Dict[str, Dict[str, Prototype]] = defaultdict(dict)
                      self._latest: Dict[str, str] = {}
                      self._lock = threading.RLock()

                      def register(self, name: str, version: str, prototype: Prototype,
                      is_latest: bool = True) -&gt; None:
                      &quot;&quot;&quot;Register a prototype version.&quot;&quot;&quot;
                      with self._lock:
                      self._versions[name][version] = prototype
                      if is_latest or name not in self._latest:
                      self._latest[name] = version

                      def clone(self, name: str, version: str = None) -&gt; Prototype:
                      &quot;&quot;&quot;
                      Clone a prototype, optionally specifying version.

                      Args:
                      name: Prototype name
                      version: Specific version, or None for latest

                      Returns:
                      Cloned prototype with version metadata if supported
                      &quot;&quot;&quot;
                      with self._lock:
                      if version is None:
                      version = self._latest.get(name)
                      if version is None:
                      raise KeyError(f&quot;No versions registered for '{name}'&quot;)

                      versions = self._versions.get(name, {})
                      prototype = versions.get(version)
                      if prototype is None:
                      raise KeyError(f&quot;Version '{version}' not found for '{name}'&quot;)

                      clone = prototype.clone()

                      # Embed version metadata if possible
                      if hasattr(clone, 'metadata') and isinstance(clone.metadata, dict):
                      clone.metadata['_source_version'] = version
                      clone.metadata['_source_name'] = name

                      return clone

                      def list_versions(self, name: str) -&gt; List[str]:
                      &quot;&quot;&quot;List all versions for a prototype name.&quot;&quot;&quot;
                      with self._lock:
                      return sorted(self._versions.get(name, {}).keys())

                      def get_latest_version(self, name: str) -&gt; Optional[str]:
                      &quot;&quot;&quot;Get the latest version string for a name.&quot;&quot;&quot;
                      return self._latest.get(name)


                      # Usage demonstration
                      if __name__ == &quot;__main__&quot;:
                      print(&quot;=&quot; * 60)
                      print(&quot;PROTOTYPE PATTERN DEMONSTRATION&quot;)
                      print(&quot;=&quot; * 60)

                      # === Document Cloning ===
                      print(&quot;\n--- Document Cloning ---&quot;)

                      original_doc = Document(&quot;Quarterly Report Template&quot;)
                      original_doc.metadata = {'department': 'Engineering', 'confidential': True}
                      original_doc.add_section(&quot;Executive Summary&quot;, &quot;[Summary placeholder]&quot;)
                      original_doc.add_section(&quot;Metrics&quot;, &quot;[Metrics placeholder]&quot;)
                      original_doc.formatting['font'] = 'Times New Roman'

                      print(f&quot;Original: {original_doc}&quot;)

                      # Clone and customize
                      q4_report = original_doc.clone()
                      q4_report.title = &quot;Q4 2024 Engineering Report&quot;
                      q4_report.sections[0]['content'] = &quot;Q4 saw 15% improvement in deployment frequency...&quot;

                      print(f&quot;Clone: {q4_report}&quot;)
                      print(f&quot;Independent sections: {original_doc.sections[0]['content'] != q4_report.sections[0]['content']}&quot;)
                      print(f&quot;Different IDs: {original_doc.id != q4_report.id}&quot;)

                      # === Game Character Cloning ===
                      print(&quot;\n--- Game Character Cloning ---&quot;)

                      warrior_template = GameCharacter(&quot;Warrior Template&quot;, &quot;Warrior&quot;)
                      warrior_template.skills = {'slash': 10, 'block': 8, 'charge': 5}
                      warrior_template.inventory = ['iron_sword', 'leather_armor', 'health_potion']
                      warrior_template.equipment['weapon'] = 'Iron Sword'
                      warrior_template.equipment['armor'] = 'Chain Mail'

                      print(f&quot;Template: {warrior_template}&quot;)

                      # Spawn multiple warriors
                      player1 = warrior_template.clone()
                      player1.name = &quot;Thorin&quot;
                      player1.position = {'x': 10.0, 'y': 0.0, 'z': 5.0}

                      player2 = warrior_template.clone()
                      player2.name = &quot;Gimli&quot;
                      player2.skills['slash'] = 15  # Customize skills
                      player2.inventory.append('throwing_axe')

                      print(f&quot;Player 1: {player1}&quot;)
                      print(f&quot;Player 2: {player2}&quot;)
                      print(f&quot;Template skills unchanged: {warrior_template.skills['slash'] == 10}&quot;)
                      print(f&quot;Template inventory unchanged: {len(warrior_template.inventory) == 3}&quot;)
                      print(f&quot;Shared assets (memory optimization): {player1._loaded_assets is player2._loaded_assets}&quot;)

                      # === Prototype Registry ===
                      print(&quot;\n--- Prototype Registry ---&quot;)

                      registry = PrototypeRegistry()

                      # Register templates
                      registry.register(&quot;report&quot;, original_doc)
                      registry.register(&quot;warrior&quot;, warrior_template)

                      # Lazy registration
                      registry.register_lazy(&quot;mage&quot;, lambda: GameCharacter(&quot;Mage Template&quot;, &quot;Mage&quot;))

                      print(f&quot;Available prototypes: {registry.list_prototypes()}&quot;)

                      # Clone from registry
                      new_report = registry.clone(&quot;report&quot;)
                      new_warrior = registry.clone(&quot;warrior&quot;)
                      new_mage = registry.clone(&quot;mage&quot;)  # Triggers lazy initialization

                      print(f&quot;Cloned report: {new_report}&quot;)
                      print(f&quot;Cloned warrior: {new_warrior}&quot;)
                      print(f&quot;Cloned mage: {new_mage}&quot;)

                      # === Versioned Registry ===
                      print(&quot;\n--- Versioned Prototype Registry ---&quot;)

                      versioned = VersionedPrototypeRegistry()

                      # Register multiple versions
                      v1_doc = Document(&quot;Report v1&quot;)
                      v1_doc.metadata = {'version': '1.0', 'features': ['basic']}
                      versioned.register(&quot;report&quot;, &quot;1.0&quot;, v1_doc, is_latest=False)

                      v2_doc = Document(&quot;Report v2&quot;)
                      v2_doc.metadata = {'version': '2.0', 'features': ['basic', 'charts', 'export']}
                      v2_doc.add_section(&quot;Charts&quot;, &quot;[Chart section]&quot;)
                      versioned.register(&quot;report&quot;, &quot;2.0&quot;, v2_doc, is_latest=True)

                      print(f&quot;Report versions: {versioned.list_versions('report')}&quot;)
                      print(f&quot;Latest version: {versioned.get_latest_version('report')}&quot;)

                      # Clone specific version
                      v1_clone = versioned.clone(&quot;report&quot;, &quot;1.0&quot;)
                      latest_clone = versioned.clone(&quot;report&quot;)  # Gets 2.0

                      print(f&quot;v1 clone sections: {len(v1_clone.sections)}&quot;)
                      print(f&quot;Latest clone sections: {len(latest_clone.sections)}&quot;)
                      print(f&quot;Version metadata: {latest_clone.metadata.get('_source_version')}&quot;)

                      print(&quot;\n&quot; + &quot;=&quot; * 60)
                      print(&quot;DEMONSTRATION COMPLETE&quot;)
                      print(&quot;=&quot; * 60)
                      ```
</code></pre>
<h3 id="go-implementation">Go Implementation</h3>
<pre><code>                      ```go
                      package main

                      import (
                      &quot;fmt&quot;
                      &quot;sync&quot;
                      &quot;time&quot;

                      &quot;github.com/google/uuid&quot;
                      )

                      // Prototype defines the cloning interface.
                      // All cloneable types must implement this interface.
                      type Prototype interface {
                      Clone() Prototype
                      }

                      // Document represents a complex document with nested structures.
                      // Clone Contract:
                      // - Title, Content: copied (Go strings are immutable)
                      // - Metadata: deep copied (new map)
                      // - Sections: deep copied (new slice with copied structs)
                      // - Formatting: deep copied (new nested struct)
                      // - ID: RESET to new UUID
                      // - CreatedAt: RESET to current time
                      type Document struct {
                      ID         string
                      Title      string
                      Content    string
                      Metadata   map[string]string
                      Sections   []Section
                      Formatting Formatting
                      CreatedAt  time.Time
                      }

                      type Section struct {
                      Name    string
                      Content string
                      }

                      type Formatting struct {
                      Font    string
                      Size    int
                      Margins Margins
                      }

                      type Margins struct {
                      Top, Bottom, Left, Right int
                      }

                      // NewDocument creates a new document with default formatting.
                      func NewDocument(title string) *Document {
                      return &amp;Document{
                      ID:       uuid.New().String(),
                      Title:    title,
                      Metadata: make(map[string]string),
                      Sections: make([]Section, 0),
                      Formatting: Formatting{
                      Font: &quot;Arial&quot;,
                      Size: 12,
                      Margins: Margins{
                      Top: 1, Bottom: 1, Left: 1, Right: 1,
                      },
                      },
                      CreatedAt: time.Now(),
                      }
                      }

                      // Clone creates a deep copy of the document with reset identity fields.
                      func (d *Document) Clone() Prototype {
                      clone := &amp;Document{
                      ID:        uuid.New().String(), // New ID
                      Title:     d.Title,
                      Content:   d.Content,
                      CreatedAt: time.Now(), // Reset timestamp
                      Formatting: Formatting{
                      Font: d.Formatting.Font,
                      Size: d.Formatting.Size,
                      Margins: Margins{
                      Top:    d.Formatting.Margins.Top,
                      Bottom: d.Formatting.Margins.Bottom,
                      Left:   d.Formatting.Margins.Left,
                      Right:  d.Formatting.Margins.Right,
                      },
                      },
                      }

                      // Deep copy metadata map
                      clone.Metadata = make(map[string]string, len(d.Metadata))
                      for k, v := range d.Metadata {
                      clone.Metadata[k] = v
                      }

                      // Deep copy sections slice
                      clone.Sections = make([]Section, len(d.Sections))
                      copy(clone.Sections, d.Sections)

                      return clone
                      }

                      // AddSection adds a new section to the document.
                      func (d *Document) AddSection(name, content string) {
                      d.Sections = append(d.Sections, Section{Name: name, Content: content})
                      }

                      // GameCharacter represents a game entity with expensive-to-load assets.
                      // Clone Contract:
                      // - Name, CharacterClass, stats: copied
                      // - Skills: deep copied (new map)
                      // - Inventory: deep copied (new slice)
                      // - Equipment: deep copied (new struct)
                      // - LoadedAssets: SHALLOW copied (immutable, expensive)
                      // - Position: RESET to spawn point
                      // - EntityID: RESET to new UUID
                      type GameCharacter struct {
                      EntityID       string
                      Name           string
                      CharacterClass string
                      Level          int
                      Health         int
                      Mana           int
                      Skills         map[string]int
                      Inventory      []string
                      Equipment      Equipment
                      Position       Position
                      loadedAssets   *Assets // Shared between clones (immutable)
                      }

                      type Equipment struct {
                      Weapon    string
                      Armor     string
                      Accessory string
                      }

                      type Position struct {
                      X, Y, Z float64
                      }

                      type Assets struct {
                      Model      string
                      Texture    string
                      Animations string
                      }

                      // NewGameCharacter creates a new character with loaded assets.
                      func NewGameCharacter(name, class string) *GameCharacter {
                      c := &amp;GameCharacter{
                      EntityID:       uuid.New().String(),
                      Name:           name,
                      CharacterClass: class,
                      Level:          1,
                      Health:         100,
                      Mana:           50,
                      Skills:         make(map[string]int),
                      Inventory:      make([]string, 0),
                      Position:       Position{X: 0, Y: 0, Z: 0},
                      }
                      // Simulate expensive asset loading
                      c.loadedAssets = c.loadAssets()
                      return c
                      }

                      func (c *GameCharacter) loadAssets() *Assets {
                      // In production: load 3D models, textures, animations
                      return &amp;Assets{
                      Model:      fmt.Sprintf(&quot;%s_model.fbx&quot;, c.CharacterClass),
                      Texture:    fmt.Sprintf(&quot;%s_texture.png&quot;, c.CharacterClass),
                      Animations: fmt.Sprintf(&quot;%s_anims.dat&quot;, c.CharacterClass),
                      }
                      }

                      // Clone creates a copy with deep-copied mutable state and shared assets.
                      func (c *GameCharacter) Clone() Prototype {
                      clone := &amp;GameCharacter{
                      EntityID:       uuid.New().String(), // New ID
                      Name:           c.Name,
                      CharacterClass: c.CharacterClass,
                      Level:          c.Level,
                      Health:         c.Health,
                      Mana:           c.Mana,
                      Equipment:      c.Equipment, // Struct copied by value
                      Position:       Position{X: 0, Y: 0, Z: 0}, // Reset spawn
                      loadedAssets:   c.loadedAssets, // SHARED - immutable
                      }

                      // Deep copy skills map
                      clone.Skills = make(map[string]int, len(c.Skills))
                      for k, v := range c.Skills {
                      clone.Skills[k] = v
                      }

                      // Deep copy inventory slice
                      clone.Inventory = make([]string, len(c.Inventory))
                      copy(clone.Inventory, c.Inventory)

                      return clone
                      }

                      // PrototypeRegistry manages named prototypes with thread-safe operations.
                      type PrototypeRegistry struct {
                      prototypes map[string]Prototype
                      factories  map[string]func() Prototype
                      parent     *PrototypeRegistry
                      mu         sync.RWMutex
                      }

                      // NewPrototypeRegistry creates a new registry, optionally with a parent.
                      func NewPrototypeRegistry(parent *PrototypeRegistry) *PrototypeRegistry {
                      return &amp;PrototypeRegistry{
                      prototypes: make(map[string]Prototype),
                      factories:  make(map[string]func() Prototype),
                      parent:     parent,
                      }
                      }

                      // Register adds a prototype instance to the registry.
                      func (r *PrototypeRegistry) Register(name string, prototype Prototype) {
                      r.mu.Lock()
                      defer r.mu.Unlock()
                      r.prototypes[name] = prototype
                      delete(r.factories, name)
                      }

                      // RegisterLazy adds a factory for lazy prototype initialization.
                      func (r *PrototypeRegistry) RegisterLazy(name string, factory func() Prototype) {
                      r.mu.Lock()
                      defer r.mu.Unlock()
                      r.factories[name] = factory
                      }

                      // Clone creates a copy of a named prototype.
                      func (r *PrototypeRegistry) Clone(name string) (Prototype, error) {
                      r.mu.Lock()
                      defer r.mu.Unlock()

                      // Check local prototypes
                      if proto, ok := r.prototypes[name]; ok {
                      return proto.Clone(), nil
                      }

                      // Check lazy factories
                      if factory, ok := r.factories[name]; ok {
                      r.prototypes[name] = factory()
                      delete(r.factories, name)
                      return r.prototypes[name].Clone(), nil
                      }

                      // Try parent
                      if r.parent != nil {
                      return r.parent.Clone(name)
                      }

                      return nil, fmt.Errorf(&quot;prototype '%s' not found&quot;, name)
                      }

                      // List returns all available prototype names.
                      func (r *PrototypeRegistry) List() []string {
                      r.mu.RLock()
                      defer r.mu.RUnlock()

                      names := make(map[string]bool)
                      for name := range r.prototypes {
                      names[name] = true
                      }
                      for name := range r.factories {
                      names[name] = true
                      }
                      if r.parent != nil {
                      for _, name := range r.parent.List() {
                      names[name] = true
                      }
                      }

                      result := make([]string, 0, len(names))
                      for name := range names {
                      result = append(result, name)
                      }
                      return result
                      }

                      // VersionedPrototypeRegistry supports multiple versions of prototypes.
                      type VersionedPrototypeRegistry struct {
                      versions map[string]map[string]Prototype
                      latest   map[string]string
                      mu       sync.RWMutex
                      }

                      // NewVersionedPrototypeRegistry creates a versioned registry.
                      func NewVersionedPrototypeRegistry() *VersionedPrototypeRegistry {
                      return &amp;VersionedPrototypeRegistry{
                      versions: make(map[string]map[string]Prototype),
                      latest:   make(map[string]string),
                      }
                      }

                      // Register adds a versioned prototype.
                      func (r *VersionedPrototypeRegistry) Register(name, version string, proto Prototype, isLatest bool) {
                      r.mu.Lock()
                      defer r.mu.Unlock()

                      if _, ok := r.versions[name]; !ok {
                      r.versions[name] = make(map[string]Prototype)
                      }
                      r.versions[name][version] = proto

                      if isLatest || r.latest[name] == &quot;&quot; {
                      r.latest[name] = version
                      }
                      }

                      // Clone creates a copy, optionally from a specific version.
                      func (r *VersionedPrototypeRegistry) Clone(name string, version string) (Prototype, error) {
                      r.mu.RLock()
                      defer r.mu.RUnlock()

                      if version == &quot;&quot; {
                      version = r.latest[name]
                      if version == &quot;&quot; {
                      return nil, fmt.Errorf(&quot;no versions for '%s'&quot;, name)
                      }
                      }

                      versions, ok := r.versions[name]
                      if !ok {
                      return nil, fmt.Errorf(&quot;prototype '%s' not found&quot;, name)
                      }

                      proto, ok := versions[version]
                      if !ok {
                      return nil, fmt.Errorf(&quot;version '%s' not found for '%s'&quot;, version, name)
                      }

                      return proto.Clone(), nil
                      }

                      func main() {
                      fmt.Println(&quot;============================================================&quot;)
                      fmt.Println(&quot;PROTOTYPE PATTERN - GO IMPLEMENTATION&quot;)
                      fmt.Println(&quot;============================================================&quot;)

                      // === Document Cloning ===
                      fmt.Println(&quot;\n--- Document Cloning ---&quot;)

                      original := NewDocument(&quot;Quarterly Report Template&quot;)
                      original.Metadata[&quot;department&quot;] = &quot;Engineering&quot;
                      original.Metadata[&quot;confidential&quot;] = &quot;true&quot;
                      original.AddSection(&quot;Executive Summary&quot;, &quot;[Summary placeholder]&quot;)
                      original.AddSection(&quot;Metrics&quot;, &quot;[Metrics placeholder]&quot;)
                      original.Formatting.Font = &quot;Times New Roman&quot;

                      fmt.Printf(&quot;Original: ID=%s..., Title=%s, Sections=%d\n&quot;,
                      original.ID[:8], original.Title, len(original.Sections))

                      // Clone and customize
                      cloned := original.Clone().(*Document)
                      cloned.Title = &quot;Q4 2024 Engineering Report&quot;
                      cloned.Sections[0].Content = &quot;Q4 results exceeded expectations...&quot;

                      fmt.Printf(&quot;Clone: ID=%s..., Title=%s, Sections=%d\n&quot;,
                      cloned.ID[:8], cloned.Title, len(cloned.Sections))
                      fmt.Printf(&quot;Independent IDs: %v\n&quot;, original.ID != cloned.ID)
                      fmt.Printf(&quot;Independent sections: %v\n&quot;,
                      original.Sections[0].Content != cloned.Sections[0].Content)

                      // === Game Character Cloning ===
                      fmt.Println(&quot;\n--- Game Character Cloning ---&quot;)

                      warriorTemplate := NewGameCharacter(&quot;Warrior Template&quot;, &quot;Warrior&quot;)
                      warriorTemplate.Skills[&quot;slash&quot;] = 10
                      warriorTemplate.Skills[&quot;block&quot;] = 8
                      warriorTemplate.Inventory = []string{&quot;iron_sword&quot;, &quot;leather_armor&quot;}
                      warriorTemplate.Equipment.Weapon = &quot;Iron Sword&quot;

                      fmt.Printf(&quot;Template: %s (%s), Skills: %v\n&quot;,
                      warriorTemplate.Name, warriorTemplate.CharacterClass, warriorTemplate.Skills)

                      player1 := warriorTemplate.Clone().(*GameCharacter)
                      player1.Name = &quot;Thorin&quot;
                      player1.Position = Position{X: 10, Y: 0, Z: 5}

                      player2 := warriorTemplate.Clone().(*GameCharacter)
                      player2.Name = &quot;Gimli&quot;
                      player2.Skills[&quot;slash&quot;] = 15
                      player2.Inventory = append(player2.Inventory, &quot;throwing_axe&quot;)

                      fmt.Printf(&quot;Player1: %s, Skills: %v, Pos: %v\n&quot;, player1.Name, player1.Skills, player1.Position)
                      fmt.Printf(&quot;Player2: %s, Skills: %v, Inventory: %v\n&quot;, player2.Name, player2.Skills, player2.Inventory)
                      fmt.Printf(&quot;Template unchanged: skills[slash]=%d, inventory=%v\n&quot;,
                      warriorTemplate.Skills[&quot;slash&quot;], warriorTemplate.Inventory)
                      fmt.Printf(&quot;Shared assets (memory opt): %v\n&quot;,
                      player1.loadedAssets == player2.loadedAssets)

                      // === Prototype Registry ===
                      fmt.Println(&quot;\n--- Prototype Registry ---&quot;)

                      registry := NewPrototypeRegistry(nil)
                      registry.Register(&quot;report&quot;, original)
                      registry.Register(&quot;warrior&quot;, warriorTemplate)
                      registry.RegisterLazy(&quot;mage&quot;, func() Prototype {
                      return NewGameCharacter(&quot;Mage Template&quot;, &quot;Mage&quot;)
                      })

                      fmt.Printf(&quot;Available: %v\n&quot;, registry.List())

                      newReport, _ := registry.Clone(&quot;report&quot;)
                      newWarrior, _ := registry.Clone(&quot;warrior&quot;)
                      newMage, _ := registry.Clone(&quot;mage&quot;)

                      fmt.Printf(&quot;Cloned report: %s\n&quot;, newReport.(*Document).Title)
                      fmt.Printf(&quot;Cloned warrior: %s\n&quot;, newWarrior.(*GameCharacter).Name)
                      fmt.Printf(&quot;Cloned mage: %s\n&quot;, newMage.(*GameCharacter).Name)

                      // === Versioned Registry ===
                      fmt.Println(&quot;\n--- Versioned Prototype Registry ---&quot;)

                      versioned := NewVersionedPrototypeRegistry()

                      v1Doc := NewDocument(&quot;Report v1&quot;)
                      v1Doc.Metadata[&quot;version&quot;] = &quot;1.0&quot;
                      versioned.Register(&quot;report&quot;, &quot;1.0&quot;, v1Doc, false)

                      v2Doc := NewDocument(&quot;Report v2&quot;)
                      v2Doc.Metadata[&quot;version&quot;] = &quot;2.0&quot;
                      v2Doc.AddSection(&quot;Charts&quot;, &quot;[Charts section]&quot;)
                      versioned.Register(&quot;report&quot;, &quot;2.0&quot;, v2Doc, true)

                      v1Clone, _ := versioned.Clone(&quot;report&quot;, &quot;1.0&quot;)
                      latestClone, _ := versioned.Clone(&quot;report&quot;, &quot;&quot;)

                      fmt.Printf(&quot;v1 clone sections: %d\n&quot;, len(v1Clone.(*Document).Sections))
                      fmt.Printf(&quot;Latest clone sections: %d\n&quot;, len(latestClone.(*Document).Sections))

                      fmt.Println(&quot;\n============================================================&quot;)
                      fmt.Println(&quot;DEMONSTRATION COMPLETE&quot;)
                      fmt.Println(&quot;============================================================&quot;)
                      }
                      ```
</code></pre>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);border-radius: 12px; padding: 24px; margin: 20px 0">
<h4 style="color: #1e293b; margin-top: 0">Pattern Summary</h4>
<table style="width: 100%; border-collapse: collapse; margin-top: 16px">
<tr style="background: #e2e8f0">
<td style="padding: 12px; font-weight: 600">Aspect</td>
<td style="padding: 12px; font-weight: 600">Details</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Type</strong></td>
<td style="padding: 12px">Creational</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>Intent</strong></td>
<td style="padding: 12px">Create objects by cloning existing instances</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Key Mechanism</strong></td>
<td style="padding: 12px">Polymorphic clone() method with deep/shallow copy semantics</td>
</tr>
<tr style="background: #f8fafc">
<td style="padding: 12px"><strong>Use When</strong></td>
<td style="padding: 12px">Object construction is expensive; runtime type flexibility needed; many similar configurations required</td>
</tr>
<tr>
<td style="padding: 12px"><strong>Avoid When</strong></td>
<td style="padding: 12px">Simple construction; objects contain non-cloneable resources; deep copy exceeds construction cost</td>
</tr>
</table>
</div>
<h3 id="decision-matrix-clone-strategy-selection">Decision Matrix: Clone Strategy Selection</h3>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Recommended Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>All fields immutable</td>
<td>Shallow copy sufficient</td>
</tr>
<tr>
<td>Mutable nested objects</td>
<td>Deep copy required</td>
</tr>
<tr>
<td>External resources (DB, files)</td>
<td>Share reference or null + lazy init</td>
</tr>
<tr>
<td>Large object graphs, rare mutations</td>
<td>Copy-on-write</td>
</tr>
<tr>
<td>High-frequency cloning, memory constraints</td>
<td>Object pool instead of prototype</td>
</tr>
<tr>
<td>Identity fields (IDs, timestamps)</td>
<td>Always reset in clone</td>
</tr>
<tr>
<td>Observer/callback lists</td>
<td>Clear in clone, re-register explicitly</td>
</tr>
</tbody>
</table>
<h3 id="implementation-checklist">Implementation Checklist</h3>
<pre><code>                      - [ ] Define clone interface with clear contract documentation
                      - [ ] Decide shallow vs deep copy per field and document
                      - [ ] Handle circular references with memo-based copying
                      - [ ] Reset identity fields (UUIDs, timestamps)
                      - [ ] Clear transient state (observers, caches)
                      - [ ] Handle non-cloneable resources explicitly
                      - [ ] Consider thread safety for registry operations
                      - [ ] Test clone independence (mutations don't affect original)
                      - [ ] Consider copy-on-write for memory optimization
                      - [ ] Avoid Java Cloneable; use copy constructors instead
</code></pre>
<hr />
<h2 id="related-patterns">Related Patterns</h2>
<pre><code>                      - [[Factory Method]](/topic/design-patterns/factory-method) - Alternative creation approach; use Factory when construction logic is complex, Prototype when configuration is complex
                      - [[Abstract Factory]](/topic/design-patterns/abstract-factory) - Can use prototypes internally to create product families
                      - [[Builder]](/topic/design-patterns/builder) - Use toBuilder() pattern for immutable objects that need &quot;modified copies&quot;
                      - [[Singleton]](/topic/design-patterns/singleton) - Opposite intent: single instance vs multiple copies
                      - [[Memento]](/topic/design-patterns/memento) - Uses similar cloning mechanism for state snapshots
                      - [[Flyweight]](/topic/design-patterns/flyweight) - Alternative for memory optimization through sharing intrinsic state
                      - [[Object Pool]](/topic/design-patterns/object-pool) - Alternative when recycling is better than cloning
</code></pre>
