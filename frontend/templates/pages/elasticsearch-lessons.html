<div class="adhd-layout">
    <aside class="adhd-nav-panel">
        <div class="sidebar-header">
            <h2>Elasticsearch Curriculum</h2>
        </div>
        <div class="lesson-tree">
            <!-- Fundamentals -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('fundamentals')">
                    <span class="icon">&#128218;</span>
                    <span>1. Elasticsearch Fundamentals</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="fundamentals" class="category-content expanded">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('basics')">1.1 Basics</div>
                        <div id="basics" class="sub-content expanded">
                            <a class="lesson-link active" onclick="loadLesson('what-is-elasticsearch')">What is Elasticsearch?</a>
                            <a class="lesson-link" onclick="loadLesson('how-search-works')">How Search Works</a>
                            <a class="lesson-link" onclick="loadLesson('inverted-index')">Inverted Index</a>
                            <a class="lesson-link" onclick="loadLesson('documents-indices')">Documents & Indices</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('rest-api')">1.2 REST API</div>
                        <div id="rest-api" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('api-basics')">API Basics</a>
                            <a class="lesson-link" onclick="loadLesson('crud-operations')">CRUD Operations</a>
                            <a class="lesson-link" onclick="loadLesson('bulk-api')">Bulk API</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Indexing & Mappings -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('indexing')">
                    <span class="icon">&#128203;</span>
                    <span>2. Indexing & Mappings</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="indexing" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('mappings')">2.1 Mappings</div>
                        <div id="mappings" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('mapping-basics')">Mapping Basics</a>
                            <a class="lesson-link" onclick="loadLesson('field-types')">Field Types</a>
                            <a class="lesson-link" onclick="loadLesson('dynamic-mapping')">Dynamic Mapping</a>
                            <a class="lesson-link" onclick="loadLesson('multi-fields')">Multi-Fields</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('analysis')">2.2 Text Analysis</div>
                        <div id="analysis" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('analyzers')">Analyzers</a>
                            <a class="lesson-link" onclick="loadLesson('tokenizers')">Tokenizers</a>
                            <a class="lesson-link" onclick="loadLesson('filters')">Token Filters</a>
                            <a class="lesson-link" onclick="loadLesson('custom-analyzers')">Custom Analyzers</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Query DSL -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('query-dsl')">
                    <span class="icon">&#128269;</span>
                    <span>3. Query DSL</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="query-dsl" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('full-text')">3.1 Full-Text Queries</div>
                        <div id="full-text" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('match-query')">Match Query</a>
                            <a class="lesson-link" onclick="loadLesson('match-phrase')">Match Phrase</a>
                            <a class="lesson-link" onclick="loadLesson('multi-match')">Multi-Match</a>
                            <a class="lesson-link" onclick="loadLesson('query-string')">Query String</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('term-level')">3.2 Term-Level Queries</div>
                        <div id="term-level" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('term-query')">Term Query</a>
                            <a class="lesson-link" onclick="loadLesson('terms-query')">Terms Query</a>
                            <a class="lesson-link" onclick="loadLesson('range-query')">Range Query</a>
                            <a class="lesson-link" onclick="loadLesson('exists-query')">Exists Query</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('compound')">3.3 Compound Queries</div>
                        <div id="compound" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('bool-query')">Bool Query</a>
                            <a class="lesson-link" onclick="loadLesson('boosting')">Boosting Query</a>
                            <a class="lesson-link" onclick="loadLesson('constant-score')">Constant Score</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Search -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('advanced-search')">
                    <span class="icon">&#127919;</span>
                    <span>4. Advanced Search</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="advanced-search" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('wildcard-query')">Wildcard & Regexp</a>
                    <a class="lesson-link" onclick="loadLesson('fuzzy-query')">Fuzzy Search</a>
                    <a class="lesson-link" onclick="loadLesson('prefix-query')">Prefix Query</a>
                    <a class="lesson-link" onclick="loadLesson('nested-query')">Nested Queries</a>
                    <a class="lesson-link" onclick="loadLesson('highlighting')">Highlighting</a>
                    <a class="lesson-link" onclick="loadLesson('suggesters')">Suggesters</a>
                </div>
            </div>

            <!-- Aggregations -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('aggregations')">
                    <span class="icon">&#128202;</span>
                    <span>5. Aggregations</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="aggregations" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('bucket-aggs')">5.1 Bucket Aggregations</div>
                        <div id="bucket-aggs" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('terms-agg')">Terms Aggregation</a>
                            <a class="lesson-link" onclick="loadLesson('range-agg')">Range Aggregation</a>
                            <a class="lesson-link" onclick="loadLesson('histogram-agg')">Histogram</a>
                            <a class="lesson-link" onclick="loadLesson('date-histogram')">Date Histogram</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('metric-aggs')">5.2 Metric Aggregations</div>
                        <div id="metric-aggs" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('avg-sum-agg')">Avg, Sum, Min, Max</a>
                            <a class="lesson-link" onclick="loadLesson('stats-agg')">Stats & Extended Stats</a>
                            <a class="lesson-link" onclick="loadLesson('cardinality-agg')">Cardinality</a>
                            <a class="lesson-link" onclick="loadLesson('percentiles-agg')">Percentiles</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('pipeline-aggs')">5.3 Pipeline Aggregations</div>
                        <div id="pipeline-aggs" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('avg-bucket')">Avg Bucket</a>
                            <a class="lesson-link" onclick="loadLesson('derivative-agg')">Derivative</a>
                            <a class="lesson-link" onclick="loadLesson('cumulative-sum')">Cumulative Sum</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Scoring & Relevance -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('scoring')">
                    <span class="icon">&#9733;</span>
                    <span>6. Scoring & Relevance</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="scoring" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('relevance-scoring')">Relevance Scoring</a>
                    <a class="lesson-link" onclick="loadLesson('tf-idf')">TF-IDF & BM25</a>
                    <a class="lesson-link" onclick="loadLesson('explain-api')">Explain API</a>
                    <a class="lesson-link" onclick="loadLesson('function-score')">Function Score</a>
                    <a class="lesson-link" onclick="loadLesson('boosting-relevance')">Boosting Relevance</a>
                </div>
            </div>

            <!-- Complex Queries -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('complex')">
                    <span class="icon">&#129504;</span>
                    <span>7. Complex Query Examples</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="complex" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('search-as-you-type')">Search-as-You-Type</a>
                    <a class="lesson-link" onclick="loadLesson('faceted-search')">Faceted Search</a>
                    <a class="lesson-link" onclick="loadLesson('autocomplete')">Autocomplete</a>
                    <a class="lesson-link" onclick="loadLesson('geo-queries')">Geo Queries</a>
                    <a class="lesson-link" onclick="loadLesson('multi-index')">Multi-Index Search</a>
                </div>
            </div>

            <!-- Real-World Case Study -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('case-study')">
                    <span class="icon">&#127919;</span>
                    <span>8. Real-World Case Study</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="case-study" class="category-content">
                    <a class="lesson-link" href="/elasticsearch/search-architecture" style="color: #fbbf24;">
                        &#128293; Search Architecture Evolution
                    </a>
                    <p style="font-size: 0.75rem; color: #6b7280; padding: 0.25rem 0.75rem; margin: 0;">
                        From 200ms to Production Excellence
                    </p>
                </div>
            </div>
        </div>
    </aside>

    <main class="adhd-main-content">
        <div id="lesson-content">
            <!-- Default: What is Elasticsearch lesson -->
            <div class="lesson">
                <h1>What is Elasticsearch?</h1>
                <p class="lesson-meta">
                    <span class="category">Category: Fundamentals</span>
                    <span class="difficulty">Difficulty: Beginner</span>
                </p>

                <section class="lesson-section">
                    <h2>Overview</h2>
                    <p>Elasticsearch is a distributed, RESTful search and analytics engine built on Apache Lucene. It's designed for horizontal scalability, reliability, and real-time search.</p>

                    <div class="key-points">
                        <h3>Key Features:</h3>
                        <ul>
                            <li><strong>Full-Text Search:</strong> Powerful text analysis and search capabilities</li>
                            <li><strong>Near Real-Time:</strong> Documents are searchable within ~1 second of indexing</li>
                            <li><strong>Distributed:</strong> Scales horizontally across multiple nodes</li>
                            <li><strong>Schema-Free:</strong> JSON documents with dynamic mapping</li>
                            <li><strong>RESTful API:</strong> Simple HTTP/JSON interface</li>
                        </ul>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Core Concepts</h2>

                    <div class="concept-box">
                        <h3>Index</h3>
                        <p>An index is like a database in relational terms. It's a collection of documents with similar characteristics.</p>
                        <pre><code class="language-json">// Our sample indices:
tests     - Individual medical tests
packages  - Test packages (bundles of tests)</code></pre>
                    </div>

                    <div class="concept-box">
                        <h3>Document</h3>
                        <p>A document is a JSON object stored in an index. Each document has a unique ID.</p>
                        <pre><code class="language-json">{
  "id": 40,
  "testName": "Complete Blood Count (CBC)",
  "testAlias": ["Blood Test", "CBC"],
  "consumerPrice": 350,
  "frequency": 7969
}</code></pre>
                    </div>

                    <div class="concept-box">
                        <h3>Mapping</h3>
                        <p>A mapping defines how documents and their fields are stored and indexed - like a schema.</p>
                        <pre><code class="language-json">{
  "properties": {
    "testName": {
      "type": "text",
      "analyzer": "standard"
    },
    "consumerPrice": {
      "type": "float"
    }
  }
}</code></pre>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Elasticsearch vs SQL</h2>
                    <div class="comparison-table">
                        <table>
                            <thead>
                                <tr><th>SQL</th><th>Elasticsearch</th><th>Description</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Database</td>
                                    <td>Index</td>
                                    <td>Collection of documents</td>
                                </tr>
                                <tr>
                                    <td>Table</td>
                                    <td>Type (deprecated)</td>
                                    <td>Category of documents</td>
                                </tr>
                                <tr>
                                    <td>Row</td>
                                    <td>Document</td>
                                    <td>Single data record</td>
                                </tr>
                                <tr>
                                    <td>Column</td>
                                    <td>Field</td>
                                    <td>Data attribute</td>
                                </tr>
                                <tr>
                                    <td>Schema</td>
                                    <td>Mapping</td>
                                    <td>Data structure definition</td>
                                </tr>
                                <tr>
                                    <td>SELECT</td>
                                    <td>GET / _search</td>
                                    <td>Read data</td>
                                </tr>
                                <tr>
                                    <td>INSERT</td>
                                    <td>PUT / POST _doc</td>
                                    <td>Create data</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Interactive Example</h2>
                    <p>Try these queries in the Elasticsearch Dashboard:</p>

                    <div class="example-query">
                        <h4>Example 1: Check Cluster Health</h4>
                        <pre><code class="language-http">GET /_cluster/health</code></pre>
                        <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/_cluster/health', '')">Try it</button>
                    </div>

                    <div class="example-query">
                        <h4>Example 2: List All Indices</h4>
                        <pre><code class="language-http">GET /_cat/indices?format=json</code></pre>
                        <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/_cat/indices?format=json', '')">Try it</button>
                    </div>

                    <div class="example-query">
                        <h4>Example 3: Simple Search</h4>
                        <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match_all": {}
  },
  "size": 5
}</code></pre>
                        <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match_all&quot;:{}},&quot;size&quot;:5}')">Try it</button>
                    </div>
                </section>

                <div class="query-result-container" id="query-result" style="display:none;">
                    <h4>Result:</h4>
                    <pre id="query-result-content"></pre>
                </div>

                <section class="lesson-section">
                    <h2>Summary</h2>
                    <div class="summary-box">
                        <ul>
                            <li>&#10003; Elasticsearch is a distributed search and analytics engine</li>
                            <li>&#10003; Data is stored as JSON documents in indices</li>
                            <li>&#10003; Mappings define how fields are indexed and searched</li>
                            <li>&#10003; All operations use a RESTful HTTP API</li>
                            <li>&#10003; Near real-time search (~1 second latency)</li>
                        </ul>
                    </div>
                </section>

                <div class="lesson-nav">
                    <span></span>
                    <a class="btn btn-primary" onclick="loadLesson('how-search-works')">Next: How Search Works &#8594;</a>
                </div>
            </div>
        </div>
    </main>

    <aside class="adhd-quick-ref">
        <div class="quick-ref-card">
            <div class="quick-ref-header">Elasticsearch Quick Reference</div>
            <ul class="quick-ref-list">
                <li class="quick-ref-item">
                    <span class="quick-ref-key">GET</span>
                    <span class="quick-ref-value">Retrieve document by ID</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">POST</span>
                    <span class="quick-ref-value">Create document (auto ID)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">PUT</span>
                    <span class="quick-ref-value">Create/update document (manual ID)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">DELETE</span>
                    <span class="quick-ref-value">Delete document or index</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_search</span>
                    <span class="quick-ref-value">Search documents in index</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_bulk</span>
                    <span class="quick-ref-value">Batch operations</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">match</span>
                    <span class="quick-ref-value">Full-text search query</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">term</span>
                    <span class="quick-ref-value">Exact value match</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">terms</span>
                    <span class="quick-ref-value">Match any of multiple values</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">range</span>
                    <span class="quick-ref-value">Numeric/date range query</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">bool</span>
                    <span class="quick-ref-value">Combine queries (must, should, filter)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">match_phrase</span>
                    <span class="quick-ref-value">Exact phrase search</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">multi_match</span>
                    <span class="quick-ref-value">Search across multiple fields</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">exists</span>
                    <span class="quick-ref-value">Check if field exists</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">wildcard</span>
                    <span class="quick-ref-value">Pattern matching (* and ?)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">fuzzy</span>
                    <span class="quick-ref-value">Typo-tolerant search</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">aggs</span>
                    <span class="quick-ref-value">Aggregations (stats, buckets)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">sort</span>
                    <span class="quick-ref-value">Order search results</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">from/size</span>
                    <span class="quick-ref-value">Pagination parameters</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_source</span>
                    <span class="quick-ref-value">Include/exclude fields</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">highlight</span>
                    <span class="quick-ref-value">Highlight matching terms</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">filter</span>
                    <span class="quick-ref-value">Filter results (no scoring)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_mapping</span>
                    <span class="quick-ref-value">Get/set field mappings</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_settings</span>
                    <span class="quick-ref-value">Index configuration</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">analyzer</span>
                    <span class="quick-ref-value">Text analysis configuration</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_count</span>
                    <span class="quick-ref-value">Count matching documents</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_update</span>
                    <span class="quick-ref-value">Partial document update</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">_reindex</span>
                    <span class="quick-ref-value">Copy documents to new index</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">script</span>
                    <span class="quick-ref-value">Custom scripting (Painless)</span>
                </li>
                <li class="quick-ref-item">
                    <span class="quick-ref-key">scroll</span>
                    <span class="quick-ref-value">Paginate through large result sets</span>
                </li>
            </ul>
        </div>
    </aside>
</div>

<style>
.sql-lessons-page {
    display: grid;
    grid-template-columns: 300px 1fr;
    min-height: calc(100vh - 60px);
}

/* Dark theme for the entire adhd-layout on this page */
.adhd-layout {
    background: linear-gradient(180deg, #0f172a 0%, #020617 100%);
}

.adhd-nav-panel {
    background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
    border-right: 1px solid rgba(99, 102, 241, 0.15) !important;
}

.adhd-main-content {
    background: transparent;
}

.adhd-quick-ref {
    background: transparent;
}

.adhd-quick-ref .quick-ref-card {
    background: #1e293b !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
}

.adhd-quick-ref .quick-ref-header {
    color: #4ecdc4;
}

.adhd-quick-ref .quick-ref-key {
    background: #2d3748;
    color: #4ecdc4;
}

.adhd-quick-ref .quick-ref-value {
    color: #9ca3af;
}

.sidebar-header {
    padding: 1.5rem;
    border-bottom: 1px solid rgba(99, 102, 241, 0.15) !important;
    background: rgba(30, 41, 59, 0.5);
}

.sidebar-header h2 {
    margin: 0;
    font-size: 1.1rem;
    color: #fff;
}

.lesson-tree {
    padding: 0.5rem;
}

.lesson-category {
    margin-bottom: 0.25rem;
}

.category-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    cursor: pointer;
    border-radius: 4px;
    color: #fff;
    font-weight: 500;
}

.category-header:hover {
    background: rgba(99, 102, 241, 0.1);
}

.category-header .icon {
    font-size: 1.1rem;
}

.category-header .arrow {
    margin-left: auto;
    transition: transform 0.2s;
}

.category-content {
    display: none;
    padding-left: 1rem;
}

.category-content.expanded {
    display: block;
}

.sub-category {
    margin: 0.25rem 0;
}

.sub-header {
    padding: 0.5rem 0.75rem;
    color: #9ca3af;
    font-size: 0.9rem;
    cursor: pointer;
}

.sub-header:hover {
    color: #fff;
}

.sub-content {
    display: none;
    padding-left: 0.5rem;
}

.sub-content.expanded {
    display: block;
}

.lesson-link {
    display: block;
    padding: 0.4rem 0.75rem;
    color: #aaa;
    text-decoration: none;
    font-size: 0.85rem;
    border-radius: 4px;
    cursor: pointer;
}

.lesson-link:hover {
    color: #fff;
    background: rgba(99, 102, 241, 0.1);
}

.lesson-link.active {
    color: #6366f1;
    background: rgba(99, 102, 241, 0.15);
    border-left: 3px solid #6366f1;
    margin-left: -3px;
}

/* .content class removed - dark bg now on .adhd-layout */

.lesson {
    max-width: 900px;
    margin: 0 auto;
}

.lesson h1 {
    margin: 0 0 1rem 0;
    color: #fff;
    font-size: 2rem;
}

.lesson-meta {
    color: #9ca3af;
    margin-bottom: 2rem;
    display: flex;
    gap: 2rem;
}

.lesson-section {
    margin-bottom: 2.5rem;
}

.lesson-section h2 {
    color: #4ecdc4;
    font-size: 1.4rem;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #4b5563;
}

.lesson-section h3 {
    color: #fff;
    font-size: 1.1rem;
    margin: 1.5rem 0 0.75rem 0;
}

.lesson-section p {
    color: #ccc;
    line-height: 1.7;
}

.key-points, .info-box {
    background: #3b4c63;
    border-radius: 8px;
    padding: 1.25rem;
    margin: 1rem 0;
}

.key-points h3, .info-box h4 {
    margin: 0 0 0.75rem 0;
    color: #4ecdc4;
}

.key-points ul {
    margin: 0;
    padding-left: 1.5rem;
}

.key-points li {
    color: #ccc;
    margin-bottom: 0.5rem;
    line-height: 1.6;
}

.concept-box {
    background: #3b4c63;
    border-radius: 8px;
    padding: 1.25rem;
    margin: 1rem 0;
    border-left: 3px solid #4ecdc4;
}

.concept-box h3 {
    margin: 0 0 0.5rem 0;
    color: #4ecdc4;
}

.concept-box p {
    margin: 0 0 1rem 0;
}

pre {
    background: #2d3748;
    border-radius: 4px;
    padding: 1rem;
    overflow-x: auto;
    margin: 0;
}

code {
    font-family: 'Fira Code', 'Consolas', monospace;
    font-size: 0.9rem;
    color: #e0e0e0;
}

.comparison-table {
    overflow-x: auto;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

.comparison-table th,
.comparison-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #4b5563;
}

.comparison-table th {
    background: #3b4c63;
    color: #4ecdc4;
}

.comparison-table td {
    color: #ccc;
}

.comparison-table td:first-child {
    font-family: monospace;
    color: #ff6b6b;
}

.comparison-table td:nth-child(2) {
    font-family: monospace;
    color: #4ecdc4;
}

.example-query {
    background: #3b4c63;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
}

.example-query h4 {
    margin: 0 0 0.75rem 0;
    color: #fff;
}

.example-query pre {
    margin-bottom: 0.75rem;
}

.btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.2s;
}

.btn-primary {
    background: #4ecdc4;
    color: #000;
}

.btn-primary:hover {
    background: #45b7aa;
}

.btn-sm {
    padding: 0.35rem 0.75rem;
    font-size: 0.8rem;
}

.summary-box {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border-radius: 8px;
    padding: 1.25rem;
    border: 1px solid #4ecdc4;
}

.summary-box ul {
    margin: 0;
    padding-left: 0;
    list-style: none;
}

.summary-box li {
    color: #ccc;
    margin-bottom: 0.5rem;
    padding-left: 0.5rem;
}

.lesson-nav {
    display: flex;
    justify-content: space-between;
    margin-top: 3rem;
    padding-top: 1.5rem;
    border-top: 1px solid #333;
}

.query-result-container {
    background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
    border: 1px solid #30363d;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    max-height: 400px;
    overflow: auto;
}

.query-result-container h4 {
    margin: 0 0 0.5rem 0;
    color: #4ecdc4;
    font-size: 0.9rem;
}

.query-result-container pre {
    margin: 0;
    font-size: 0.8rem;
    color: #e6edf3;
    white-space: pre-wrap;
    word-break: break-word;
}

/* Override adhd-layout nuclear border removal for Elasticsearch page elements */
.adhd-layout .concept-box {
    border-left: 3px solid #4ecdc4 !important;
}

.adhd-layout .lesson-link.active {
    border-left: 3px solid #6366f1 !important;
}

.adhd-layout .sidebar-header {
    border-bottom: 1px solid rgba(99, 102, 241, 0.15) !important;
}

.adhd-layout .adhd-nav-panel {
    border-right: 1px solid rgba(99, 102, 241, 0.15) !important;
}

.adhd-layout .lesson-section h2 {
    border-bottom: 1px solid #4b5563 !important;
}

.adhd-layout .lesson-nav {
    border-top: 1px solid #333 !important;
}

.adhd-layout .summary-box {
    border: 1px solid #4ecdc4 !important;
}

.adhd-layout .comparison-table th,
.adhd-layout .comparison-table td {
    border-bottom: 1px solid #4b5563 !important;
}

.adhd-layout .query-result-container {
    border: 1px solid #30363d !important;
}

/* Ensure list item bullets are visible */
.adhd-layout .lesson-section ul {
    color: #ccc;
    padding-left: 1.5rem;
}

.adhd-layout .lesson-section li {
    color: #ccc;
    margin-bottom: 0.5rem;
    line-height: 1.6;
}
</style>

<script>
// Lesson content data
const lessons = {
    'what-is-elasticsearch': {
        title: 'What is Elasticsearch?',
        category: 'Fundamentals',
        difficulty: 'Beginner',
        content: `
            <h1>What is Elasticsearch? A Deep Dive</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>Understanding Search: The Problem</h2>
                <p>Before understanding Elasticsearch, let's understand why traditional databases struggle with search.</p>

                <div class="concept-box">
                    <h3>The SQL LIKE Problem</h3>
                    <p>When you search in SQL using LIKE:</p>
                    <pre><code class="language-sql">SELECT * FROM products WHERE name LIKE '%blood count%';</code></pre>
                    <p><strong>What happens internally:</strong></p>
                    <ul style="color: #ccc; padding-left: 1.5rem;">
                        <li>Database performs a <strong>full table scan</strong> - checking EVERY row</li>
                        <li>No index can help with leading wildcards (%blood)</li>
                        <li>Case sensitive by default ("Blood" ≠ "blood")</li>
                        <li>Can't match "bloods" when searching "blood" (no stemming)</li>
                        <li>Performance: O(n) - degrades linearly with data size</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h3>Real Numbers: The Scale Problem</h3>
                    <pre><code class="language-text">Data Size          SQL LIKE Search    Elasticsearch Search
─────────────────────────────────────────────────────────
100 rows           10ms               5ms
10,000 rows        100ms              5ms
1,000,000 rows     10+ seconds        5ms
100,000,000 rows   Minutes/Timeout    10ms</code></pre>
                    <p>Elasticsearch maintains <strong>constant-time lookups</strong> regardless of data size!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>What is Elasticsearch?</h2>
                <p>Elasticsearch is a <strong>distributed, full-text search engine</strong> built on Apache Lucene. It stores data in a fundamentally different way than SQL databases.</p>

                <div class="key-points">
                    <h3>Core Architecture</h3>
                    <ul>
                        <li><strong>Documents:</strong> JSON objects (like rows in SQL)</li>
                        <li><strong>Indices:</strong> Collections of documents (like tables)</li>
                        <li><strong>Shards:</strong> Horizontal partitions for scaling</li>
                        <li><strong>Replicas:</strong> Copies for fault tolerance</li>
                        <li><strong>Inverted Index:</strong> The magic behind fast search</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>&#128161; Key Insight</h4>
                    <p>The secret to Elasticsearch's speed is the <strong>Inverted Index</strong> - it pre-processes text at write time so search is just a lookup, not a scan.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>How Text Analysis Works (Tokenization)</h2>
                <p>When you index a document, Elasticsearch doesn't store the raw text. It <strong>analyzes</strong> the text into searchable tokens.</p>

                <div class="concept-box">
                    <h3>The Analysis Pipeline</h3>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 0.75rem; padding: 1rem; background: #0d1117; border-radius: 8px; margin-top: 1rem;">
                        <!-- Input -->
                        <div style="background: #2d3748; border: 2px solid #a0aec0; border-radius: 8px; padding: 0.75rem 1.25rem; color: #e2e8f0; text-align: center;">
                            <div style="font-size: 0.75rem; color: #a0aec0; margin-bottom: 0.25rem;">Input Text:</div>
                            <div style="font-family: monospace; font-size: 0.85rem;">"Complete Blood Count (CBC) - $50.00"</div>
                        </div>
                        <div style="color: #667eea; font-size: 1.25rem;">↓</div>
                        <!-- Step 1 -->
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; width: 100%; max-width: 400px;">
                            <div style="font-weight: 700;">1. CHARACTER FILTERS</div>
                            <div style="font-size: 0.8rem; opacity: 0.9;">Remove HTML, convert symbols</div>
                            <div style="font-family: monospace; font-size: 0.75rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">"Complete Blood Count CBC 50 00"</div>
                        </div>
                        <div style="color: #f093fb; font-size: 1.25rem;">↓</div>
                        <!-- Step 2 -->
                        <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; width: 100%; max-width: 400px;">
                            <div style="font-weight: 700;">2. TOKENIZER</div>
                            <div style="font-size: 0.8rem; opacity: 0.9;">Split into words (whitespace + punctuation)</div>
                            <div style="font-family: monospace; font-size: 0.75rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">["Complete", "Blood", "Count", "CBC", "50", "00"]</div>
                        </div>
                        <div style="color: #38ef7d; font-size: 1.25rem;">↓</div>
                        <!-- Step 3 -->
                        <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; width: 100%; max-width: 400px;">
                            <div style="font-weight: 700;">3. TOKEN FILTERS</div>
                            <div style="font-size: 0.8rem; opacity: 0.9;">Lowercase, stemming, synonyms, stop words</div>
                            <div style="font-family: monospace; font-size: 0.75rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">["complete", "blood", "count", "cbc", "50", "00"]</div>
                        </div>
                    </div>
                </div>

                <div class="example-query">
                    <h4>Try: Analyze Text</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "analyzer": "standard",
  "text": "Complete Blood Count (CBC) - $50.00"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;analyzer&quot;:&quot;standard&quot;,&quot;text&quot;:&quot;Complete Blood Count (CBC) - $50.00&quot;}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>The Inverted Index: The Magic</h2>
                <p>After analysis, Elasticsearch builds an <strong>inverted index</strong> - a map from terms to documents.</p>

                <div class="concept-box">
                    <h3>Traditional Index (like SQL)</h3>
                    <pre><code class="language-text">Doc 1 → ["complete", "blood", "count", "cbc"]
Doc 2 → ["liver", "function", "test", "lft"]
Doc 3 → ["blood", "glucose", "fasting"]

To find "blood": scan ALL docs → O(n) operations</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Inverted Index (Elasticsearch)</h3>
                    <pre><code class="language-text">Term          | Documents
──────────────────────────
"blood"       | Doc 1, Doc 3
"complete"    | Doc 1
"count"       | Doc 1
"cbc"         | Doc 1
"liver"       | Doc 2
"function"    | Doc 2
"test"        | Doc 2
"lft"         | Doc 2
"glucose"     | Doc 3
"fasting"     | Doc 3

To find "blood": lookup "blood" → [Doc 1, Doc 3] → O(1) operation!</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#128161; Why This is Fast</h4>
                    <p>Finding documents is now a <strong>dictionary lookup</strong>, not a scan. Like finding a word in a book's index vs reading every page!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Elasticsearch vs SQL vs MongoDB Search</h2>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>Feature</th><th>SQL LIKE</th><th>MongoDB Text</th><th>Elasticsearch</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Search Speed</td>
                                <td>O(n) full scan</td>
                                <td>O(log n) with index</td>
                                <td>O(1) inverted index</td>
                            </tr>
                            <tr>
                                <td>Case Insensitive</td>
                                <td>LOWER() function</td>
                                <td>$caseSensitive:false</td>
                                <td>Built-in (analyzer)</td>
                            </tr>
                            <tr>
                                <td>Fuzzy/Typo Tolerance</td>
                                <td>Not possible</td>
                                <td>Not built-in</td>
                                <td>fuzziness: "AUTO"</td>
                            </tr>
                            <tr>
                                <td>Synonyms</td>
                                <td>Manual mapping</td>
                                <td>Not built-in</td>
                                <td>Synonym filter</td>
                            </tr>
                            <tr>
                                <td>Relevance Scoring</td>
                                <td>None</td>
                                <td>Basic textScore</td>
                                <td>TF-IDF / BM25</td>
                            </tr>
                            <tr>
                                <td>Stemming</td>
                                <td>Not possible</td>
                                <td>Basic</td>
                                <td>Multiple algorithms</td>
                            </tr>
                            <tr>
                                <td>Highlighting</td>
                                <td>Not built-in</td>
                                <td>Basic</td>
                                <td>Advanced highlighting</td>
                            </tr>
                            <tr>
                                <td>Autocomplete</td>
                                <td>LIKE 'prefix%'</td>
                                <td>Regex (slow)</td>
                                <td>Edge n-grams, Completion</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="concept-box">
                    <h3>Example: Why "running" matches "run"</h3>
                    <p>In SQL: <code>WHERE text LIKE '%run%'</code> won't match "running"</p>
                    <p>In Elasticsearch with stemming analyzer:</p>
                    <ul style="color: #ccc; padding-left: 1.5rem;">
                        <li>"running" → stems to → "run"</li>
                        <li>"runs" → stems to → "run"</li>
                        <li>"ran" → stems to → "run"</li>
                    </ul>
                    <p>All variations automatically match!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>When to Use Elasticsearch</h2>
                <div class="key-points">
                    <h3>Perfect For:</h3>
                    <ul>
                        <li><strong>Full-text search</strong> - product search, document search</li>
                        <li><strong>Log analytics</strong> - searching through millions of log entries</li>
                        <li><strong>Autocomplete</strong> - as-you-type search suggestions</li>
                        <li><strong>Faceted search</strong> - filtering with counts (like e-commerce)</li>
                        <li><strong>Geospatial search</strong> - finding nearby locations</li>
                    </ul>
                </div>

                <div class="key-points">
                    <h3>Not Ideal For:</h3>
                    <ul>
                        <li><strong>Primary database</strong> - use SQL/MongoDB for transactions</li>
                        <li><strong>Complex joins</strong> - denormalize data instead</li>
                        <li><strong>Real-time analytics</strong> - slight delay in indexing</li>
                        <li><strong>Small datasets</strong> - overkill for &lt; 10,000 records</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Elasticsearch = distributed search engine built on Lucene</li>
                        <li>&#10003; Text analysis breaks text into searchable tokens</li>
                        <li>&#10003; Inverted index enables O(1) lookups vs O(n) scans</li>
                        <li>&#10003; Built-in fuzzy search, synonyms, stemming, highlighting</li>
                        <li>&#10003; Use ES for search-heavy features, SQL for transactions</li>
                    </ul>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <div class="lesson-nav">
                <span></span>
                <a class="btn btn-primary" onclick="loadLesson('how-search-works')">Next: How Search Works &#8594;</a>
            </div>
        `
    },
    'how-search-works': {
        title: 'How Search Works',
        category: 'Fundamentals',
        difficulty: 'Beginner',
        content: `
            <h1>How Search Works in Elasticsearch</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>The Search Process</h2>
                <p>When you search in Elasticsearch, several steps occur to find and rank relevant documents:</p>

                <!-- Query Execution Flow Diagram -->
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0;">
                    <h4 style="color: #4ecdc4; margin-bottom: 1rem;">Query Execution Flow: match query for "blood count"</h4>
                    <div style="display: flex; flex-direction: column; gap: 1rem; font-family: system-ui, sans-serif;">

                        <!-- Step 1: Query Parsing -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; min-width: 160px; text-align: center;">
                                <div style="font-weight: 700;">1. Query Parsing</div>
                                <div style="font-size: 0.75rem; opacity: 0.8;">Analyze Input</div>
                            </div>
                            <div style="flex: 1; padding: 0.5rem; background: #3d4a5c; border-radius: 6px; font-size: 0.85rem; color: #a0aec0;">
                                <span style="color: #f093fb;">"blood count"</span> → Analyzer →
                                <span style="color: #4ecdc4;">["blood", "count"]</span> (tokens)
                            </div>
                        </div>

                        <!-- Step 2: Index Lookup -->
                        <div style="display: flex; align-items: flex-start; gap: 1rem;">
                            <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; min-width: 160px; text-align: center;">
                                <div style="font-weight: 700;">2. Inverted Index</div>
                                <div style="font-size: 0.75rem; opacity: 0.8;">O(1) Lookup</div>
                            </div>
                            <div style="flex: 1; background: #0d1117; border: 1px solid #30363d; border-radius: 8px; padding: 0.75rem;">
                                <div style="display: flex; gap: 1rem; font-size: 0.8rem;">
                                    <div style="flex: 1;">
                                        <div style="color: #4ecdc4; font-weight: 600; margin-bottom: 0.5rem;">Term Dictionary</div>
                                        <div style="background: #161b22; padding: 0.5rem; border-radius: 4px;">
                                            <div><span style="color: #f093fb;">"blood"</span> → <span style="color: #38ef7d;">[doc1, doc3, doc7]</span></div>
                                            <div><span style="color: #f093fb;">"count"</span> → <span style="color: #38ef7d;">[doc1, doc2, doc5]</span></div>
                                        </div>
                                    </div>
                                    <div style="flex: 1;">
                                        <div style="color: #ffd93d; font-weight: 600; margin-bottom: 0.5rem;">Position Data</div>
                                        <div style="background: #161b22; padding: 0.5rem; border-radius: 4px; color: #a0aec0;">
                                            <div>doc1: positions [0, 1]</div>
                                            <div>doc3: positions [5]</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Step 3: Scoring -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; min-width: 160px; text-align: center;">
                                <div style="font-weight: 700;">3. BM25 Scoring</div>
                                <div style="font-size: 0.75rem; opacity: 0.8;">Relevance Calc</div>
                            </div>
                            <div style="flex: 1; padding: 0.5rem; background: #3d4a5c; border-radius: 6px; font-size: 0.8rem;">
                                <div style="color: #a0aec0;">
                                    Score = <span style="color: #4ecdc4;">TF</span> (term frequency) ×
                                    <span style="color: #f093fb;">IDF</span> (inverse doc frequency) ×
                                    <span style="color: #ffd93d;">fieldNorm</span>
                                </div>
                                <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                                    <span style="background: #065f46; padding: 0.25rem 0.5rem; border-radius: 4px; color: #34d399;">doc1: 8.5</span>
                                    <span style="background: #1e3a5f; padding: 0.25rem 0.5rem; border-radius: 4px; color: #4ecdc4;">doc3: 4.2</span>
                                    <span style="background: #1e3a5f; padding: 0.25rem 0.5rem; border-radius: 4px; color: #4ecdc4;">doc7: 3.1</span>
                                </div>
                            </div>
                        </div>

                        <!-- Step 4: Fetch -->
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <div style="background: linear-gradient(135deg, #ffd93d 0%, #ff6b6b 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: #1a1a2e; min-width: 160px; text-align: center;">
                                <div style="font-weight: 700;">4. Fetch & Return</div>
                                <div style="font-size: 0.75rem; opacity: 0.8;">Get Documents</div>
                            </div>
                            <div style="flex: 1; padding: 0.5rem; background: #3d4a5c; border-radius: 6px; font-size: 0.8rem; color: #a0aec0;">
                                Fetch _source from doc IDs → Sort by score → Return top N results
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Why Inverted Index is Fast -->
                <div style="background: linear-gradient(135deg, #0d1117 0%, #161b22 100%); border: 1px solid #30363d; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0;">
                    <h4 style="color: #f093fb; margin-bottom: 1rem;">Why Elasticsearch is O(1) Fast (vs SQL O(n))</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; font-size: 0.85rem;">
                        <!-- SQL Approach -->
                        <div>
                            <div style="color: #ff6b6b; font-weight: 600; margin-bottom: 0.5rem;">❌ SQL: Full Table Scan</div>
                            <div style="background: #2d3748; border-radius: 8px; padding: 1rem;">
                                <pre style="margin: 0; font-size: 0.75rem; color: #a0aec0;">WHERE name LIKE '%blood%'

Check row 1... no match
Check row 2... no match
Check row 3... MATCH!
...
Check row 1,000,000... no match</pre>
                                <div style="color: #ff6b6b; font-size: 0.75rem; margin-top: 0.5rem;">⏱️ Time: O(n) - scales with data</div>
                            </div>
                        </div>
                        <!-- ES Approach -->
                        <div>
                            <div style="color: #38ef7d; font-weight: 600; margin-bottom: 0.5rem;">✅ ES: Inverted Index Lookup</div>
                            <div style="background: #2d3748; border-radius: 8px; padding: 1rem;">
                                <pre style="margin: 0; font-size: 0.75rem; color: #a0aec0;">query: "blood"

Index["blood"] = [3, 47, 892, 1204]
                 ↓
Done! Here are all matches.</pre>
                                <div style="color: #38ef7d; font-size: 0.75rem; margin-top: 0.5rem;">⚡ Time: O(1) - constant time</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="concept-box">
                    <h3>1. Query Parsing</h3>
                    <p>Your JSON query is parsed and converted into a Lucene query structure. The search term is analyzed using the same analyzer that was used during indexing.</p>
                </div>

                <div class="concept-box">
                    <h3>2. Query Phase</h3>
                    <p>The coordinating node broadcasts the query to all relevant shards. Each shard executes the query locally and returns the top N document IDs with their scores.</p>
                </div>

                <div class="concept-box">
                    <h3>3. Fetch Phase</h3>
                    <p>The coordinating node merges results, sorts by score, and fetches the actual documents from the shards that hold them.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Query vs Filter Context</h2>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>Query Context</th><th>Filter Context</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Answers: "How well does this match?"</td>
                                <td>Answers: "Does this match? Yes/No"</td>
                            </tr>
                            <tr>
                                <td>Calculates relevance score</td>
                                <td>No scoring (faster)</td>
                            </tr>
                            <tr>
                                <td>Not cached by default</td>
                                <td>Results are cached</td>
                            </tr>
                            <tr>
                                <td>Use for: full-text search</td>
                                <td>Use for: exact matches, ranges</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="example-query">
                    <h4>Query Context Example</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": {
      "testName": "blood count"
    }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood count&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Filter Context Example</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "cityCode": "BLR" } },
        { "range": { "consumerPrice": { "lte": 500 } } }
      ]
    }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;filter&quot;:[{&quot;term&quot;:{&quot;cityCode&quot;:&quot;BLR&quot;}},{&quot;range&quot;:{&quot;consumerPrice&quot;:{&quot;lte&quot;:500}}}]}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Search involves Query Phase (find matches) and Fetch Phase (retrieve docs)</li>
                        <li>&#10003; Query context calculates relevance scores</li>
                        <li>&#10003; Filter context is binary (match/no match) and cached</li>
                        <li>&#10003; Use filters for exact matches, ranges, and boolean conditions</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('what-is-elasticsearch')">&#8592; Previous: What is Elasticsearch?</a>
                <a class="btn btn-primary" onclick="loadLesson('inverted-index')">Next: Inverted Index &#8594;</a>
            </div>
        `
    },
    'inverted-index': {
        title: 'Inverted Index',
        category: 'Fundamentals',
        difficulty: 'Beginner',
        content: `
            <h1>Understanding the Inverted Index</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is an Inverted Index?</h2>
                <p>An inverted index is a data structure that maps terms to the documents containing them. It's the foundation of how Elasticsearch enables fast full-text search.</p>

                <div class="concept-box">
                    <h3>Traditional Index vs Inverted Index</h3>
                    <pre><code class="language-text">Traditional Index (like a book index):
Document 1 -> ["blood", "test", "complete"]
Document 2 -> ["liver", "test", "function"]

Inverted Index (term -> documents):
"blood"    -> [Doc 1]
"test"     -> [Doc 1, Doc 2]
"complete" -> [Doc 1]
"liver"    -> [Doc 2]
"function" -> [Doc 2]</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>How Text is Analyzed</h2>
                <p>Before indexing, text goes through an analysis process:</p>

                <div class="key-points">
                    <h3>Analysis Pipeline:</h3>
                    <ul>
                        <li><strong>Character Filters:</strong> Transform characters (e.g., remove HTML)</li>
                        <li><strong>Tokenizer:</strong> Split text into tokens</li>
                        <li><strong>Token Filters:</strong> Transform tokens (lowercase, stemming, synonyms)</li>
                    </ul>
                </div>

                <div class="example-query">
                    <h4>See How Text is Analyzed</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "analyzer": "standard",
  "text": "Complete Blood Count (CBC)"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;analyzer&quot;:&quot;standard&quot;,&quot;text&quot;:&quot;Complete Blood Count (CBC)&quot;}')">Try it</button>
                </div>

                <div class="info-box">
                    <h4>&#128161; Key Insight</h4>
                    <p>The same analyzer must be used at both index time and search time for matching to work correctly. That's why "BLOOD" matches "blood" - both get lowercased.</p>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Inverted index maps terms to documents (opposite of traditional)</li>
                        <li>&#10003; Text analysis breaks text into searchable tokens</li>
                        <li>&#10003; Analysis happens at index time AND search time</li>
                        <li>&#10003; This enables fast full-text search across millions of documents</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('how-search-works')">&#8592; Previous: How Search Works</a>
                <a class="btn btn-primary" onclick="loadLesson('documents-indices')">Next: Documents & Indices &#8594;</a>
            </div>
        `
    },
    'documents-indices': {
        title: 'Documents & Indices',
        category: 'Fundamentals',
        difficulty: 'Beginner',
        content: `
            <h1>Documents & Indices: Elasticsearch Data Model</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>Elasticsearch Data Hierarchy</h2>
                <div class="concept-box">
                    <h3>The Structure</h3>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem; background: #0d1117; border-radius: 8px; margin-top: 1rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 6px; padding: 0.5rem 1rem; color: white; font-weight: 600;">Cluster</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 1.5rem;">
                            <span style="color: #667eea;">└──</span>
                            <div style="background: #1e3a5f; border: 2px solid #4ecdc4; border-radius: 6px; padding: 0.4rem 0.75rem; color: #4ecdc4; font-size: 0.9rem;">Nodes (servers)</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 3rem;">
                            <span style="color: #4ecdc4;">└──</span>
                            <div style="background: #1e3a5f; border: 2px solid #f093fb; border-radius: 6px; padding: 0.4rem 0.75rem; color: #f093fb; font-size: 0.9rem;">Indices (like databases)</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 4.5rem;">
                            <span style="color: #f093fb;">└──</span>
                            <div style="background: #1e3a5f; border: 2px solid #38ef7d; border-radius: 6px; padding: 0.4rem 0.75rem; color: #38ef7d; font-size: 0.9rem;">Shards (partitions)</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 6rem;">
                            <span style="color: #38ef7d;">└──</span>
                            <div style="background: #1e3a5f; border: 2px solid #ffd93d; border-radius: 6px; padding: 0.4rem 0.75rem; color: #ffd93d; font-size: 0.9rem;">Documents (JSON)</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-left: 7.5rem;">
                            <span style="color: #ffd93d;">└──</span>
                            <div style="background: #2d3748; border: 1px solid #a0aec0; border-radius: 6px; padding: 0.4rem 0.75rem; color: #a0aec0; font-size: 0.9rem;">Fields (key-value)</div>
                        </div>
                    </div>
                </div>

                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>SQL Concept</th><th>Elasticsearch Concept</th><th>Description</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Database</td>
                                <td>Index</td>
                                <td>Logical namespace for documents</td>
                            </tr>
                            <tr>
                                <td>Table</td>
                                <td>Index (or Type*)</td>
                                <td>*Types deprecated in ES 7+</td>
                            </tr>
                            <tr>
                                <td>Row</td>
                                <td>Document</td>
                                <td>A single JSON object</td>
                            </tr>
                            <tr>
                                <td>Column</td>
                                <td>Field</td>
                                <td>A key-value pair in document</td>
                            </tr>
                            <tr>
                                <td>Schema</td>
                                <td>Mapping</td>
                                <td>Field definitions & types</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Documents</h2>
                <p>A document is a JSON object that contains your data. Each document has:</p>

                <div class="key-points">
                    <h3>Document Metadata</h3>
                    <ul>
                        <li><strong>_index:</strong> Which index the document belongs to</li>
                        <li><strong>_id:</strong> Unique identifier (auto-generated or specified)</li>
                        <li><strong>_source:</strong> The original JSON body you indexed</li>
                        <li><strong>_version:</strong> Version number for optimistic concurrency</li>
                    </ul>
                </div>

                <div class="example-query">
                    <h4>Index a Document</h4>
                    <pre><code class="language-json">PUT /tests/_doc/custom-id-123
{
  "testName": "Complete Blood Count",
  "testCode": "CBC",
  "price": 350,
  "category": "Hematology"
}</code></pre>
                    <p>Creates/updates document with ID "custom-id-123"</p>
                </div>

                <div class="example-query">
                    <h4>Get a Document by ID</h4>
                    <pre><code class="language-json">GET /tests/_doc/custom-id-123</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/tests/_search', '{&quot;query&quot;:{&quot;match_all&quot;:{}},&quot;size&quot;:1}')">Try: Get Sample Doc</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Indices & Mappings</h2>
                <p>An index is a collection of documents. The <strong>mapping</strong> defines how documents and fields are stored and indexed.</p>

                <div class="concept-box">
                    <h3>Field Types</h3>
                    <pre><code class="language-text">Text Types (analyzed, full-text search):
  • text      - Full-text search, tokenized
  • keyword   - Exact match, aggregations, sorting

Numeric Types:
  • integer, long, short, byte
  • float, double, half_float
  • scaled_float

Date Types:
  • date      - ISO 8601 or custom formats

Boolean:
  • boolean   - true/false

Object Types:
  • object    - JSON object (flattened)
  • nested    - Arrays of objects (maintains independence)</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#128161; text vs keyword</h4>
                    <p><strong>text</strong>: For full-text search. "Hello World" → ["hello", "world"]</p>
                    <p><strong>keyword</strong>: For exact matches. "Hello World" stays as "Hello World"</p>
                    <p>By default, strings get BOTH: field.keyword for exact match</p>
                </div>

                <div class="example-query">
                    <h4>View Index Mapping</h4>
                    <pre><code class="language-json">GET /tests/_mapping</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/tests/_mapping', '')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Shards & Replicas</h2>
                <p>Elasticsearch distributes data across <strong>shards</strong> for horizontal scaling.</p>

                <div class="concept-box">
                    <h3>How Sharding Works</h3>
                    <div style="background: #0d1117; border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 6px; padding: 0.5rem 1rem; color: white; font-weight: 600; margin-bottom: 1rem; text-align: center;">
                            Index: "products" (1 million documents)
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-bottom: 1rem;">
                            <div style="background: #1a472a; border: 2px solid #38ef7d; border-radius: 8px; padding: 0.75rem; text-align: center;">
                                <div style="color: #38ef7d; font-weight: 600; font-size: 0.85rem;">Primary Shard 0</div>
                                <div style="color: #a0aec0; font-size: 0.75rem;">333K docs</div>
                                <div style="color: #4ecdc4; font-size: 0.7rem; margin-top: 0.25rem;">Node 1</div>
                            </div>
                            <div style="background: #1a472a; border: 2px solid #38ef7d; border-radius: 8px; padding: 0.75rem; text-align: center;">
                                <div style="color: #38ef7d; font-weight: 600; font-size: 0.85rem;">Primary Shard 1</div>
                                <div style="color: #a0aec0; font-size: 0.75rem;">333K docs</div>
                                <div style="color: #f093fb; font-size: 0.7rem; margin-top: 0.25rem;">Node 2</div>
                            </div>
                            <div style="background: #1a472a; border: 2px solid #38ef7d; border-radius: 8px; padding: 0.75rem; text-align: center;">
                                <div style="color: #38ef7d; font-weight: 600; font-size: 0.85rem;">Primary Shard 2</div>
                                <div style="color: #a0aec0; font-size: 0.75rem;">334K docs</div>
                                <div style="color: #ffd93d; font-size: 0.7rem; margin-top: 0.25rem;">Node 3</div>
                            </div>
                        </div>
                        <div style="background: #1e3a5f; border: 2px dashed #4ecdc4; border-radius: 8px; padding: 0.75rem; text-align: center; margin-bottom: 1rem;">
                            <div style="color: #4ecdc4; font-weight: 600;">Replica Shards</div>
                            <div style="color: #a0aec0; font-size: 0.75rem;">Copies on different nodes for fault tolerance</div>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.8rem;">
                            <span style="background: #065f46; padding: 0.25rem 0.5rem; border-radius: 4px; color: #34d399;">✓ Parallel processing</span>
                            <span style="background: #164e63; padding: 0.25rem 0.5rem; border-radius: 4px; color: #22d3ee;">✓ Fault tolerance</span>
                            <span style="background: #581c87; padding: 0.25rem 0.5rem; border-radius: 4px; color: #e879f9;">✓ Horizontal scaling</span>
                        </div>
                    </div>
                </div>

                <div class="key-points">
                    <h3>Shard Guidelines</h3>
                    <ul>
                        <li>Default: 1 primary shard, 1 replica (ES 7+)</li>
                        <li>Cannot change primary shards after index creation</li>
                        <li>Aim for shards between 10GB - 50GB</li>
                        <li>Too many small shards = overhead</li>
                        <li>Too few large shards = slow queries</li>
                    </ul>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Documents are JSON objects with _id, _index, _source</li>
                        <li>&#10003; Indices are collections of documents with mappings</li>
                        <li>&#10003; Mappings define field types (text, keyword, numeric, etc.)</li>
                        <li>&#10003; Shards enable horizontal scaling</li>
                        <li>&#10003; Replicas provide fault tolerance</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('inverted-index')">&#8592; Previous: Inverted Index</a>
                <a class="btn btn-primary" onclick="loadLesson('analyzers')">Next: Analyzers &#8594;</a>
            </div>
        `
    },
    'analyzers': {
        title: 'Analyzers',
        category: 'Fundamentals',
        difficulty: 'Intermediate',
        content: `
            <h1>Analyzers: How Text Becomes Searchable</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>The Analyzer Pipeline</h2>
                <p>Analyzers transform text into tokens. Understanding analyzers is <strong>critical</strong> for effective search.</p>

                <div class="concept-box">
                    <h3>Anatomy of an Analyzer</h3>
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 0.75rem; padding: 1rem; background: #0d1117; border-radius: 8px; margin-top: 1rem;">
                        <!-- Input -->
                        <div style="background: #2d3748; border: 2px solid #a0aec0; border-radius: 8px; padding: 0.75rem 1.25rem; color: #e2e8f0; text-align: center; font-family: monospace; font-size: 0.85rem;">
                            "The Quick-Brown Fox's 2nd Jump!"
                        </div>
                        <div style="color: #667eea; font-size: 1.25rem;">↓</div>
                        <!-- Character Filters -->
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; width: 100%; max-width: 350px;">
                            <div style="font-weight: 700; font-size: 0.9rem;">CHARACTER FILTERS <span style="opacity: 0.7; font-weight: 400;">(0+)</span></div>
                            <div style="font-size: 0.75rem; opacity: 0.9;">HTML strip, pattern replace</div>
                            <div style="font-family: monospace; font-size: 0.7rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">"The Quick-Brown Fox's 2nd Jump!"</div>
                        </div>
                        <div style="color: #f093fb; font-size: 1.25rem;">↓</div>
                        <!-- Tokenizer -->
                        <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; width: 100%; max-width: 350px;">
                            <div style="font-weight: 700; font-size: 0.9rem;">TOKENIZER <span style="opacity: 0.7; font-weight: 400;">(exactly 1)</span></div>
                            <div style="font-size: 0.75rem; opacity: 0.9;">Split text into tokens</div>
                            <div style="font-family: monospace; font-size: 0.7rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">["The", "Quick", "Brown", "Fox's", "2nd", "Jump"]</div>
                        </div>
                        <div style="color: #38ef7d; font-size: 1.25rem;">↓</div>
                        <!-- Token Filters -->
                        <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border-radius: 8px; padding: 0.75rem 1.25rem; color: white; width: 100%; max-width: 350px;">
                            <div style="font-weight: 700; font-size: 0.9rem;">TOKEN FILTERS <span style="opacity: 0.7; font-weight: 400;">(0+)</span></div>
                            <div style="font-size: 0.75rem; opacity: 0.9;">lowercase, stemmer, synonyms</div>
                            <div style="font-family: monospace; font-size: 0.7rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem;">["the", "quick", "brown", "fox", "2nd", "jump"]</div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Built-in Analyzers</h2>

                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>Analyzer</th><th>Input</th><th>Output Tokens</th><th>Use Case</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>standard</td>
                                <td>"Quick Brown-Fox"</td>
                                <td>["quick", "brown", "fox"]</td>
                                <td>General purpose (default)</td>
                            </tr>
                            <tr>
                                <td>simple</td>
                                <td>"Quick Brown-Fox"</td>
                                <td>["quick", "brown", "fox"]</td>
                                <td>Non-letter chars removed</td>
                            </tr>
                            <tr>
                                <td>whitespace</td>
                                <td>"Quick Brown-Fox"</td>
                                <td>["Quick", "Brown-Fox"]</td>
                                <td>Preserve case, split on spaces only</td>
                            </tr>
                            <tr>
                                <td>keyword</td>
                                <td>"Quick Brown-Fox"</td>
                                <td>["Quick Brown-Fox"]</td>
                                <td>No tokenization (exact match)</td>
                            </tr>
                            <tr>
                                <td>english</td>
                                <td>"running foxes"</td>
                                <td>["run", "fox"]</td>
                                <td>Stemming + stop words</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="example-query">
                    <h4>Compare Analyzers</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "analyzer": "standard",
  "text": "The Quick Brown-Fox JUMPED over 2 lazy dogs!"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;analyzer&quot;:&quot;standard&quot;,&quot;text&quot;:&quot;The Quick Brown-Fox JUMPED over 2 lazy dogs!&quot;}')">Standard</button>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;analyzer&quot;:&quot;whitespace&quot;,&quot;text&quot;:&quot;The Quick Brown-Fox JUMPED over 2 lazy dogs!&quot;}')">Whitespace</button>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;analyzer&quot;:&quot;english&quot;,&quot;text&quot;:&quot;The Quick Brown-Fox JUMPED over 2 lazy dogs!&quot;}')">English</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Why Analyzers Matter</h2>

                <div class="concept-box">
                    <h3>Case Sensitivity Problem</h3>
                    <pre><code class="language-text">Document: { "name": "Blood Count Test" }
Query:    { "match": { "name": "blood" } }

Without proper analyzer: NO MATCH ❌ (case mismatch)
With standard analyzer:  MATCH ✅ (both lowercased)

Indexed as: ["blood", "count", "test"]
Query analyzed as: ["blood"]
Match found!</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Stemming Problem</h3>
                    <pre><code class="language-text">Document: { "description": "Patient was running" }
Query:    { "match": { "description": "run" } }

Without stemming: NO MATCH ❌ ("run" ≠ "running")
With english analyzer: MATCH ✅

"running" → stemmed to → "run"
"run" → stemmed to → "run"
Both match!</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#128161; The Golden Rule</h4>
                    <p>The <strong>same analyzer must be used at index time and search time</strong>. Otherwise, tokens won't match!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Custom Analyzers</h2>
                <p>You can build custom analyzers for specific use cases.</p>

                <div class="example-query">
                    <h4>Custom Analyzer for Medical Terms</h4>
                    <pre><code class="language-json">PUT /medical_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "medical_analyzer": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "medical_synonyms",
            "english_stemmer"
          ]
        }
      },
      "filter": {
        "medical_synonyms": {
          "type": "synonym",
          "synonyms": [
            "cbc, complete blood count",
            "bp, blood pressure",
            "ekg, ecg, electrocardiogram"
          ]
        },
        "english_stemmer": {
          "type": "stemmer",
          "language": "english"
        }
      }
    }
  }
}</code></pre>
                    <p>Now searching "CBC" also matches "Complete Blood Count"!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Common Token Filters</h2>

                <div class="key-points">
                    <h3>Frequently Used Filters</h3>
                    <ul>
                        <li><strong>lowercase:</strong> "Hello" → "hello"</li>
                        <li><strong>stop:</strong> Remove common words ("the", "is", "at")</li>
                        <li><strong>stemmer:</strong> "running" → "run"</li>
                        <li><strong>synonym:</strong> "quick" → "quick, fast"</li>
                        <li><strong>edge_ngram:</strong> "quick" → ["q", "qu", "qui", "quic", "quick"]</li>
                        <li><strong>asciifolding:</strong> "café" → "cafe"</li>
                    </ul>
                </div>

                <div class="example-query">
                    <h4>Test Edge N-grams (for Autocomplete)</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "tokenizer": "standard",
  "filter": ["lowercase", {"type": "edge_ngram", "min_gram": 1, "max_gram": 10}],
  "text": "blood"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;tokenizer&quot;:&quot;standard&quot;,&quot;filter&quot;:[&quot;lowercase&quot;,{&quot;type&quot;:&quot;edge_ngram&quot;,&quot;min_gram&quot;:1,&quot;max_gram&quot;:10}],&quot;text&quot;:&quot;blood&quot;}')">Try it</button>
                    <p>Produces: ["b", "bl", "blo", "bloo", "blood"] - enables prefix matching!</p>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Analyzers = Character Filters + Tokenizer + Token Filters</li>
                        <li>&#10003; Standard analyzer: lowercase + word tokenization (default)</li>
                        <li>&#10003; Use stemming for matching word variations</li>
                        <li>&#10003; Use synonyms for domain-specific terminology</li>
                        <li>&#10003; Edge n-grams enable autocomplete functionality</li>
                        <li>&#10003; Same analyzer must be used at index and search time</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('documents-indices')">&#8592; Previous: Documents & Indices</a>
                <a class="btn btn-primary" onclick="loadLesson('match-query')">Next: Match Query &#8594;</a>
            </div>
        `
    },
    'match-query': {
        title: 'Match Query',
        category: 'Query DSL',
        difficulty: 'Beginner',
        content: `
            <h1>Match Query</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is Match Query?</h2>
                <p>The <code>match</code> query is the standard query for full-text search. It analyzes the search text and constructs a query from the resulting terms.</p>

                <div class="key-points">
                    <h3>How Match Query Works:</h3>
                    <ul>
                        <li>Analyzes the input text using the field's analyzer</li>
                        <li>Creates a boolean query with OR between terms (by default)</li>
                        <li>Calculates relevance scores for matching documents</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Match Query</h2>

                <div class="example-query">
                    <h4>Simple Match</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": {
      "testName": "blood count"
    }
  }
}</code></pre>
                    <p>Finds documents containing "blood" OR "count" (default behavior)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood count&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Match with AND operator</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": {
      "testName": {
        "query": "blood count",
        "operator": "and"
      }
    }
  }
}</code></pre>
                    <p>Finds documents containing BOTH "blood" AND "count"</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:{&quot;query&quot;:&quot;blood count&quot;,&quot;operator&quot;:&quot;and&quot;}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Match with Minimum Should Match</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": {
      "testName": {
        "query": "complete blood count test",
        "minimum_should_match": "75%"
      }
    }
  }
}</code></pre>
                    <p>At least 75% of terms must match (3 out of 4 terms)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:{&quot;query&quot;:&quot;complete blood count test&quot;,&quot;minimum_should_match&quot;:&quot;75%&quot;}}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Match Query Parameters</h2>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>Parameter</th><th>Description</th><th>Default</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>query</td>
                                <td>The search text</td>
                                <td>Required</td>
                            </tr>
                            <tr>
                                <td>operator</td>
                                <td>or | and</td>
                                <td>or</td>
                            </tr>
                            <tr>
                                <td>fuzziness</td>
                                <td>Allow typos (0, 1, 2, AUTO)</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>minimum_should_match</td>
                                <td>Min matching terms</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <td>analyzer</td>
                                <td>Override default analyzer</td>
                                <td>Field's analyzer</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Match query is the go-to for full-text search</li>
                        <li>&#10003; Default operator is OR (any term matches)</li>
                        <li>&#10003; Use operator: "and" when all terms must match</li>
                        <li>&#10003; minimum_should_match gives fine-grained control</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('analyzers')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('match-phrase')">Next: Match Phrase &#8594;</a>
            </div>
        `
    },
    'match-phrase': {
        title: 'Match Phrase Query',
        category: 'Query DSL',
        difficulty: 'Beginner',
        content: `
            <h1>Match Phrase Query</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is Match Phrase?</h2>
                <p>The <code>match_phrase</code> query matches documents containing an exact phrase - all terms in the exact order specified.</p>

                <div class="concept-box">
                    <h3>match vs match_phrase</h3>
                    <pre><code class="language-text">Document: "Complete Blood Count Test"

match query "blood count":
  ✅ Matches (contains both words, any order)

match_phrase query "blood count":
  ✅ Matches (exact phrase in order)

match_phrase query "count blood":
  ❌ No match (wrong order)

match_phrase query "complete count":
  ❌ No match (words not adjacent)</code></pre>
                </div>

                <div class="key-points">
                    <h3>Key Characteristics:</h3>
                    <ul>
                        <li>All terms must appear in the exact order</li>
                        <li>Terms must be adjacent (or within slop distance)</li>
                        <li>Uses same analyzer as the field</li>
                        <li>Perfect for searching quotes, titles, exact phrases</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Usage</h2>

                <div class="example-query">
                    <h4>Simple Match Phrase</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match_phrase": {
      "testName": "blood count"
    }
  }
}</code></pre>
                    <p>Finds documents with "blood count" as an exact phrase</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match_phrase&quot;:{&quot;testName&quot;:&quot;blood count&quot;}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Using Slop for Flexibility</h2>
                <p><strong>Slop</strong> allows terms to be a certain distance apart while still matching.</p>

                <div class="concept-box">
                    <h3>Understanding Slop</h3>
                    <pre><code class="language-text">Document: "Complete Blood Count Test"
Query: "complete count" with slop: 2

Position analysis:
  "complete" at position 0
  "blood" at position 1
  "count" at position 2

Slop needed: |2 - 0| - 1 = 1 move
With slop: 2, this MATCHES!</code></pre>
                </div>

                <div class="example-query">
                    <h4>Match Phrase with Slop</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match_phrase": {
      "testName": {
        "query": "complete test",
        "slop": 2
      }
    }
  }
}</code></pre>
                    <p>Allows up to 2 words between "complete" and "test"</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match_phrase&quot;:{&quot;testName&quot;:{&quot;query&quot;:&quot;complete test&quot;,&quot;slop&quot;:2}}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; match_phrase requires exact phrase order</li>
                        <li>&#10003; Use slop to allow flexible word positioning</li>
                        <li>&#10003; Perfect for searching exact titles, quotes</li>
                        <li>&#10003; More precise than match, less flexible</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('match-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('term-query')">Next: Term Query &#8594;</a>
            </div>
        `
    },
    'term-query': {
        title: 'Term Query',
        category: 'Query DSL',
        difficulty: 'Beginner',
        content: `
            <h1>Term Query</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is Term Query?</h2>
                <p>The <code>term</code> query finds documents containing an <strong>exact term</strong> in a field. Unlike match query, it does NOT analyze the search term.</p>

                <div class="concept-box">
                    <h3>match vs term - Critical Difference!</h3>
                    <pre><code class="language-text">Field value indexed: "Complete Blood Count"
(analyzed to tokens: ["complete", "blood", "count"])

match query "Complete":
  → Analyzed to "complete"
  → ✅ MATCHES (finds "complete" token)

term query "Complete":
  → NOT analyzed, searches for exact "Complete"
  → ❌ NO MATCH (no "Complete" token, only "complete")

term query "complete":
  → Searches for exact "complete"
  → ✅ MATCHES</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#9888; Important Warning</h4>
                    <p>Use <code>term</code> query ONLY on <code>keyword</code> fields, NOT on analyzed <code>text</code> fields. For text fields, use <code>match</code> query instead!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Usage</h2>

                <div class="example-query">
                    <h4>Term Query on Keyword Field</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "term": {
      "cityCode": "BLR"
    }
  }
}</code></pre>
                    <p>Exact match on keyword field</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;term&quot;:{&quot;cityCode&quot;:&quot;BLR&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Using .keyword for Text Fields</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "term": {
      "testName.keyword": "Complete Blood Count (CBC)"
    }
  }
}</code></pre>
                    <p>Use .keyword subfield for exact match on text fields</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;term&quot;:{&quot;testName.keyword&quot;:&quot;Complete Blood Count (CBC)&quot;}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Terms Query (Multiple Values)</h2>
                <p>Use <code>terms</code> to match any of multiple exact values (like SQL IN clause).</p>

                <div class="example-query">
                    <h4>Terms Query</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "terms": {
      "cityCode": ["BLR", "MUM", "DEL"]
    }
  }
}</code></pre>
                    <p>Matches documents where cityCode is BLR OR MUM OR DEL</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;terms&quot;:{&quot;cityCode&quot;:[&quot;BLR&quot;,&quot;MUM&quot;,&quot;DEL&quot;]}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; term query = exact match, NO analysis</li>
                        <li>&#10003; Use ONLY on keyword fields</li>
                        <li>&#10003; For text fields, use field.keyword or match query</li>
                        <li>&#10003; terms query for multiple values (OR logic)</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('query-string')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('terms-query')">Next: Terms Query &#8594;</a>
            </div>
        `
    },
    'terms-query': {
        title: 'Terms Query',
        category: 'Query DSL',
        difficulty: 'Beginner',
        content: `
            <h1>Terms Query: Match Multiple Exact Values</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is Terms Query?</h2>
                <p>The <code>terms</code> query finds documents containing one or more <strong>exact values</strong> in a field. Think of it as the Elasticsearch equivalent of SQL's <code>IN</code> clause.</p>

                <div class="concept-box">
                    <h3>term vs terms - What's the Difference?</h3>
                    <pre><code class="language-text">term query (singular):
  Match ONE exact value
  "Find tests in category 'hematology'"
  SQL: WHERE category = 'hematology'

terms query (plural):
  Match ANY of multiple exact values
  "Find tests in category 'hematology' OR 'biochemistry' OR 'immunology'"
  SQL: WHERE category IN ('hematology', 'biochemistry', 'immunology')</code></pre>
                    <p>Both queries work on <strong>exact, non-analyzed</strong> values. Use them on <code>keyword</code> fields, not <code>text</code> fields.</p>
                </div>

                <div class="info-box">
                    <h4>&#128161; Key Insight</h4>
                    <p>The <code>terms</code> query uses OR logic internally. A document matches if the field contains <strong>any one</strong> of the specified values. You do not need a bool/should wrapper for this.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Terms Query</h2>

                <div class="example-query">
                    <h4>Match Multiple Categories</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "terms": {
      "category.keyword": ["hematology", "biochemistry", "immunology"]
    }
  }
}</code></pre>
                    <p>Matches any test whose category is "hematology", "biochemistry", OR "immunology"</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;terms&quot;:{&quot;category.keyword&quot;:[&quot;hematology&quot;,&quot;biochemistry&quot;,&quot;immunology&quot;]}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Match Multiple Test Names (Keyword)</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "terms": {
      "testName.keyword": [
        "Complete Blood Count (CBC)",
        "Liver Function Test (LFT)",
        "Thyroid Profile"
      ]
    }
  }
}</code></pre>
                    <p>Exact match on multiple test names using the .keyword sub-field</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;terms&quot;:{&quot;testName.keyword&quot;:[&quot;Complete Blood Count (CBC)&quot;,&quot;Liver Function Test (LFT)&quot;,&quot;Thyroid Profile&quot;]}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Terms Lookup: Dynamic Value Lists</h2>
                <p>Instead of hardcoding values, you can fetch them from another document. This is called a <strong>terms lookup</strong>.</p>

                <div class="concept-box">
                    <h3>How Terms Lookup Works</h3>
                    <pre><code class="language-text">Step 1: You have a "favorites" index with a document:
{
  "userId": "user123",
  "favoriteCategories": ["hematology", "biochemistry"]
}

Step 2: Use terms lookup to dynamically fetch those values:
The terms query fetches "favoriteCategories" from the
document and uses them as the filter values.

This avoids hardcoding values and keeps queries dynamic!</code></pre>
                </div>

                <div class="example-query">
                    <h4>Terms Lookup Syntax</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "terms": {
      "category.keyword": {
        "index": "user_preferences",
        "id": "user123",
        "path": "favoriteCategories"
      }
    }
  }
}</code></pre>
                    <p>Dynamically fetches values from another index/document. The "path" field specifies which field to read values from.</p>
                </div>

                <div class="info-box">
                    <h4>&#128161; Terms Lookup Use Cases</h4>
                    <p><strong>Personalized search:</strong> Filter tests based on a user's saved preferences or past orders.</p>
                    <p><strong>Access control:</strong> Filter results based on a user's allowed categories stored in a permissions index.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Combining terms with bool</h2>

                <div class="example-query">
                    <h4>Terms in a Bool Filter</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "testName": "blood" } }
      ],
      "filter": [
        { "terms": { "category.keyword": ["hematology", "biochemistry"] } },
        { "range": { "consumerPrice": { "lte": 500 } } }
      ]
    }
  }
}</code></pre>
                    <p>Search for "blood" tests in specific categories, priced under 500. Using filter context for terms gives caching benefits.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}}],&quot;filter&quot;:[{&quot;terms&quot;:{&quot;category.keyword&quot;:[&quot;hematology&quot;,&quot;biochemistry&quot;]}},{&quot;range&quot;:{&quot;consumerPrice&quot;:{&quot;lte&quot;:500}}}]}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; terms query matches any of multiple exact values (like SQL IN)</li>
                        <li>&#10003; Use on keyword fields only, not analyzed text fields</li>
                        <li>&#10003; terms lookup fetches values dynamically from another document</li>
                        <li>&#10003; Combine with bool/filter for efficient cached filtering</li>
                        <li>&#10003; Difference from term: term = one value, terms = multiple values</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('term-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('range-query')">Next: Range Query &#8594;</a>
            </div>
        `
    },
    'range-query': {
        title: 'Range Query',
        category: 'Query DSL',
        difficulty: 'Beginner',
        content: `
            <h1>Range Query</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is Range Query?</h2>
                <p>The <code>range</code> query finds documents with field values within a specified range. Works on numeric, date, and string fields.</p>

                <div class="key-points">
                    <h3>Range Operators:</h3>
                    <ul>
                        <li><strong>gt:</strong> Greater than (>)</li>
                        <li><strong>gte:</strong> Greater than or equal (>=)</li>
                        <li><strong>lt:</strong> Less than (<)</li>
                        <li><strong>lte:</strong> Less than or equal (<=)</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Numeric Range</h2>

                <div class="example-query">
                    <h4>Price Range</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "range": {
      "price": {
        "gte": 100,
        "lte": 500
      }
    }
  }
}</code></pre>
                    <p>Find tests priced between 100 and 500</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;range&quot;:{&quot;price&quot;:{&quot;gte&quot;:100,&quot;lte&quot;:500}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Frequency Above Threshold</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "range": {
      "frequency": {
        "gt": 1000
      }
    }
  }
}</code></pre>
                    <p>Find popular tests (frequency > 1000)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;range&quot;:{&quot;frequency&quot;:{&quot;gt&quot;:1000}}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Date Range</h2>

                <div class="concept-box">
                    <h3>Date Math Expressions</h3>
                    <pre><code class="language-text">now          → Current time
now-1d       → Yesterday
now-1w       → 1 week ago
now-1M       → 1 month ago
now/d        → Start of today
2024-01-01   → Specific date

Examples:
  "gte": "now-7d"    → Last 7 days
  "lte": "now/d"     → Until end of today
  "gte": "2024-01-01", "lte": "2024-12-31"  → Year 2024</code></pre>
                </div>

                <div class="example-query">
                    <h4>Date Range Query</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "range": {
      "createdAt": {
        "gte": "now-30d",
        "lte": "now"
      }
    }
  }
}</code></pre>
                    <p>Find tests created in the last 30 days</p>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Range query for numeric, date, and string comparisons</li>
                        <li>&#10003; gt/gte for lower bound, lt/lte for upper bound</li>
                        <li>&#10003; Date math: now-1d, now/d, etc.</li>
                        <li>&#10003; Commonly used in filters for performance</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('terms-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('exists-query')">Next: Exists Query &#8594;</a>
            </div>
        `
    },
    'exists-query': {
        title: 'Exists Query',
        category: 'Query DSL',
        difficulty: 'Beginner',
        content: `
            <h1>Exists Query: Check Field Existence</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is Exists Query?</h2>
                <p>The <code>exists</code> query finds documents where a specific field has any non-null value. It is the Elasticsearch equivalent of SQL's <code>IS NOT NULL</code>.</p>

                <div class="concept-box">
                    <h3>When Does a Field "Exist"?</h3>
                    <pre><code class="language-text">A field EXISTS if it has any indexable value:
  &#10003; "testAlias": "CBC"            (string value)
  &#10003; "consumerPrice": 0             (zero is a value)
  &#10003; "consumerPrice": 150.50        (numeric value)
  &#10003; "category": ["hematology"]     (array with values)
  &#10003; "testDescription": ""          (empty string IS a value!)

A field does NOT exist if:
  &#10007; "testAlias": null              (explicit null)
  &#10007; "testAlias": []                (empty array)
  &#10007; Field is missing entirely from the document
  &#10007; Field mapped with "index": false and "doc_values": false</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#128161; Important Note About Empty Strings</h4>
                    <p>An empty string <code>""</code> is considered a valid value in Elasticsearch. A field with value <code>""</code> <strong>does exist</strong>. This is different from SQL where empty strings and NULLs are sometimes treated similarly.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Exists Query</h2>

                <div class="example-query">
                    <h4>Find Documents Where testAlias Exists</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "exists": {
      "field": "testAlias"
    }
  }
}</code></pre>
                    <p>Returns all tests that have a testAlias field with a non-null value</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;exists&quot;:{&quot;field&quot;:&quot;testAlias&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Check if testDescription Exists</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "exists": {
      "field": "testDescription"
    }
  }
}</code></pre>
                    <p>Find all tests that have a description</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;exists&quot;:{&quot;field&quot;:&quot;testDescription&quot;}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Finding Missing Fields (NOT Exists)</h2>
                <p>To find documents where a field is <strong>missing or null</strong>, wrap exists in a <code>bool/must_not</code> query.</p>

                <div class="concept-box">
                    <h3>SQL Comparison</h3>
                    <pre><code class="language-text">SQL:
  SELECT * FROM tests WHERE testAlias IS NULL;

Elasticsearch:
  Use bool/must_not with exists query

SQL:
  SELECT * FROM tests WHERE testAlias IS NOT NULL;

Elasticsearch:
  Use exists query directly</code></pre>
                </div>

                <div class="example-query">
                    <h4>Find Tests Missing testAlias (IS NULL)</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must_not": [
        { "exists": { "field": "testAlias" } }
      ]
    }
  }
}</code></pre>
                    <p>Returns tests where testAlias is null, empty array, or the field is completely missing</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must_not&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;testAlias&quot;}}]}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Find Tests Missing consumerPrice</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must_not": [
        { "exists": { "field": "consumerPrice" } }
      ]
    }
  }
}</code></pre>
                    <p>Find tests that do not have a price set</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must_not&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;consumerPrice&quot;}}]}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Practical Patterns with Exists</h2>

                <div class="example-query">
                    <h4>Data Quality Check: Find Incomplete Records</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "should": [
        { "bool": { "must_not": [{ "exists": { "field": "testDescription" } }] } },
        { "bool": { "must_not": [{ "exists": { "field": "consumerPrice" } }] } },
        { "bool": { "must_not": [{ "exists": { "field": "category" } }] } }
      ],
      "minimum_should_match": 1
    }
  }
}</code></pre>
                    <p>Find tests missing any of these fields - useful for data quality audits</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;should&quot;:[{&quot;bool&quot;:{&quot;must_not&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;testDescription&quot;}}]}},{&quot;bool&quot;:{&quot;must_not&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;consumerPrice&quot;}}]}},{&quot;bool&quot;:{&quot;must_not&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;category&quot;}}]}}],&quot;minimum_should_match&quot;:1}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Filter: Only Tests With Descriptions</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "testName": "blood" } }
      ],
      "filter": [
        { "exists": { "field": "testDescription" } }
      ]
    }
  }
}</code></pre>
                    <p>Search for "blood" tests, but only return results that have a description. Using filter context for exists is efficient and cacheable.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}}],&quot;filter&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;testDescription&quot;}}]}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; exists query finds documents where a field has any non-null value</li>
                        <li>&#10003; Empty strings ("") count as existing; null and empty arrays do not</li>
                        <li>&#10003; Use bool/must_not + exists to find missing/null fields (IS NULL equivalent)</li>
                        <li>&#10003; Great for data quality checks and filtering incomplete records</li>
                        <li>&#10003; Works efficiently in filter context with caching</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('range-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('bool-query')">Next: Bool Query &#8594;</a>
            </div>
        `
    },
    'bool-query': {
        title: 'Bool Query',
        category: 'Query DSL',
        difficulty: 'Intermediate',
        content: `
            <h1>Bool Query</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>Understanding Bool Query</h2>
                <p>The <code>bool</code> query combines multiple queries using boolean logic. It's the most important compound query in Elasticsearch.</p>

                <div class="key-points">
                    <h3>Bool Query Clauses:</h3>
                    <ul>
                        <li><strong>must:</strong> Query MUST match (AND). Contributes to score.</li>
                        <li><strong>filter:</strong> Query MUST match (AND). No scoring, cached.</li>
                        <li><strong>should:</strong> Query SHOULD match (OR). Contributes to score.</li>
                        <li><strong>must_not:</strong> Query must NOT match (NOT). No scoring.</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Bool Query Examples</h2>

                <div class="example-query">
                    <h4>Basic Bool Query</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "testName": "blood" } }
      ],
      "filter": [
        { "term": { "cityCode": "BLR" } }
      ],
      "must_not": [
        { "range": { "consumerPrice": { "gt": 1000 } } }
      ]
    }
  }
}</code></pre>
                    <p>Tests with "blood" in name, in BLR, priced under 1000</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}}],&quot;filter&quot;:[{&quot;term&quot;:{&quot;cityCode&quot;:&quot;BLR&quot;}}],&quot;must_not&quot;:[{&quot;range&quot;:{&quot;consumerPrice&quot;:{&quot;gt&quot;:1000}}}]}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Should with minimum_should_match</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "testName": "blood" } },
        { "match": { "testName": "liver" } },
        { "match": { "testName": "kidney" } }
      ],
      "minimum_should_match": 1
    }
  }
}</code></pre>
                    <p>Tests related to blood, liver, OR kidney</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;should&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}},{&quot;match&quot;:{&quot;testName&quot;:&quot;liver&quot;}},{&quot;match&quot;:{&quot;testName&quot;:&quot;kidney&quot;}}],&quot;minimum_should_match&quot;:1}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Nested Bool Queries</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "testName": "test" } }
      ],
      "should": [
        {
          "bool": {
            "must": [
              { "match": { "testName": "blood" } },
              { "range": { "frequency": { "gte": 1000 } } }
            ]
          }
        },
        {
          "bool": {
            "must": [
              { "match": { "testName": "liver" } }
            ]
          }
        }
      ]
    }
  }
}</code></pre>
                    <p>Complex query with nested boolean logic</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;test&quot;}}],&quot;should&quot;:[{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}},{&quot;range&quot;:{&quot;frequency&quot;:{&quot;gte&quot;:1000}}}]}},{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;liver&quot;}}]}}]}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>must vs filter</h2>
                <div class="info-box">
                    <h4>&#128161; When to use which?</h4>
                    <p><strong>Use must</strong> when the clause should affect relevance scoring (e.g., full-text search).</p>
                    <p><strong>Use filter</strong> for exact matches, ranges, and boolean conditions that don't need scoring. Filters are cached and faster!</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Bool query combines multiple queries with boolean logic</li>
                        <li>&#10003; must = AND with scoring, filter = AND without scoring (cached)</li>
                        <li>&#10003; should = OR, must_not = NOT</li>
                        <li>&#10003; Use filter for exact matches to improve performance</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('exists-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('boosting')">Next: Boosting Query &#8594;</a>
            </div>
        `
    },
    'boosting': {
        title: 'Boosting Query',
        category: 'Query DSL',
        difficulty: 'Intermediate',
        content: `
            <h1>Boosting Query: Demote Without Excluding</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is the Boosting Query?</h2>
                <p>The <code>boosting</code> query lets you return documents matching a <strong>positive</strong> query while <strong>reducing</strong> the relevance score of documents that also match a <strong>negative</strong> query. Unlike <code>must_not</code>, it does not exclude documents -- it just pushes them down in the results.</p>

                <div class="concept-box">
                    <h3>Boosting vs Bool must_not</h3>
                    <pre><code class="language-text">bool/must_not:
  "Show me blood tests, but NOT expensive ones"
  Expensive tests are COMPLETELY REMOVED from results
  You get fewer results

boosting query:
  "Show me blood tests, but rank expensive ones lower"
  Expensive tests STILL APPEAR, just ranked lower
  You get ALL matching results, with better ones on top

When to use boosting:
  - You want to demote, not exclude
  - "Prefer tests with descriptions over those without"
  - "Show all results but rank discontinued tests lower"</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#128161; Key Insight</h4>
                    <p>Boosting is perfect when you want to influence ranking without losing results. The user still sees everything, but the most relevant items appear first.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Boosting Query Structure</h2>

                <div class="concept-box">
                    <h3>Three Components</h3>
                    <pre><code class="language-text">boosting query has three parts:

1. positive (required):
   The main query - documents MUST match this
   These get their normal relevance score

2. negative (required):
   Documents matching this get their score reduced
   They are NOT excluded, just demoted

3. negative_boost (required):
   A multiplier between 0 and 1.0
   Applied to the score of documents matching the negative query
   0.5 = halve the score, 0.1 = reduce to 10%, 0 = score becomes 0</code></pre>
                </div>

                <div class="example-query">
                    <h4>Basic Boosting Query</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": { "testName": "blood" }
      },
      "negative": {
        "range": { "consumerPrice": { "gt": 500 } }
      },
      "negative_boost": 0.3
    }
  }
}</code></pre>
                    <p>Find all "blood" tests, but demote expensive ones (price > 500) by reducing their score to 30%</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;boosting&quot;:{&quot;positive&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}},&quot;negative&quot;:{&quot;range&quot;:{&quot;consumerPrice&quot;:{&quot;gt&quot;:500}}},&quot;negative_boost&quot;:0.3}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Demote Tests Without Descriptions</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": { "testName": "test" }
      },
      "negative": {
        "bool": {
          "must_not": [
            { "exists": { "field": "testDescription" } }
          ]
        }
      },
      "negative_boost": 0.2
    }
  }
}</code></pre>
                    <p>Find all tests matching "test", but push down results that lack a description (score reduced to 20%)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;boosting&quot;:{&quot;positive&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;test&quot;}},&quot;negative&quot;:{&quot;bool&quot;:{&quot;must_not&quot;:[{&quot;exists&quot;:{&quot;field&quot;:&quot;testDescription&quot;}}]}},&quot;negative_boost&quot;:0.2}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Understanding negative_boost Values</h2>

                <div class="concept-box">
                    <h3>Score Impact by negative_boost Value</h3>
                    <pre><code class="language-text">Original score of matching document: 2.5

negative_boost: 1.0  ->  Score: 2.5  (no change, useless)
negative_boost: 0.5  ->  Score: 1.25 (halved - mild demotion)
negative_boost: 0.3  ->  Score: 0.75 (moderate demotion)
negative_boost: 0.1  ->  Score: 0.25 (strong demotion)
negative_boost: 0.0  ->  Score: 0.0  (maximum demotion, pushed to bottom)

Guidelines:
  0.5 - 0.8  Gentle demotion (slightly less preferred)
  0.2 - 0.5  Moderate demotion (noticeably lower)
  0.0 - 0.2  Aggressive demotion (pushed to bottom)</code></pre>
                </div>

                <div class="example-query">
                    <h4>Aggressive Demotion</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match_all": {}
      },
      "negative": {
        "range": { "frequency": { "lt": 100 } }
      },
      "negative_boost": 0.1
    }
  }
}</code></pre>
                    <p>Return all tests but aggressively demote rarely ordered ones (frequency below 100)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;boosting&quot;:{&quot;positive&quot;:{&quot;match_all&quot;:{}},&quot;negative&quot;:{&quot;range&quot;:{&quot;frequency&quot;:{&quot;lt&quot;:100}}},&quot;negative_boost&quot;:0.1}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Boosting query demotes results without excluding them</li>
                        <li>&#10003; Three parts: positive (must match), negative (demote), negative_boost (multiplier)</li>
                        <li>&#10003; negative_boost is a 0-1 multiplier applied to scores of negative matches</li>
                        <li>&#10003; Use boosting when you want all results but prefer some over others</li>
                        <li>&#10003; Use bool/must_not when you want to completely exclude results</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('bool-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('constant-score')">Next: Constant Score &#8594;</a>
            </div>
        `
    },
    'constant-score': {
        title: 'Constant Score',
        category: 'Query DSL',
        difficulty: 'Intermediate',
        content: `
            <h1>Constant Score: Fixed Relevance Scoring</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Constant Score?</h2>
                <p>The <code>constant_score</code> query wraps a filter query and assigns a <strong>fixed, uniform score</strong> (the boost value) to every matching document. It skips relevance scoring entirely, making it both simpler and faster.</p>

                <div class="concept-box">
                    <h3>Why Skip Relevance Scoring?</h3>
                    <pre><code class="language-text">Normal query (match, multi_match, etc.):
  Each document gets a different score based on TF-IDF/BM25
  "How relevant is this document to the search?"
  Score: 3.21, 2.87, 1.45, 0.92...

constant_score query:
  Every matching document gets the SAME score
  "Does this document match? Yes/No"
  Score: 1.0, 1.0, 1.0, 1.0...

When you don't need relevance scoring:
  - Filtering by category (all matches are equally relevant)
  - Checking if a field exists
  - Exact value matches where rank doesn't matter
  - Binary yes/no conditions</code></pre>
                </div>

                <div class="info-box">
                    <h4>&#128161; Performance Benefit</h4>
                    <p>Because constant_score runs queries in <strong>filter context</strong>, Elasticsearch can cache the results. Cached filters are significantly faster on repeated queries. This is the same performance benefit you get from using bool/filter.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Constant Score</h2>

                <div class="example-query">
                    <h4>Simple Constant Score</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "term": { "category.keyword": "hematology" }
      },
      "boost": 1.0
    }
  }
}</code></pre>
                    <p>All hematology tests get the same score of 1.0. No relevance calculation needed.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;constant_score&quot;:{&quot;filter&quot;:{&quot;term&quot;:{&quot;category.keyword&quot;:&quot;hematology&quot;}},&quot;boost&quot;:1.0}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>With Custom Boost Value</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "range": { "consumerPrice": { "lte": 200 } }
      },
      "boost": 2.5
    }
  }
}</code></pre>
                    <p>All affordable tests (price 200 or less) get a fixed score of 2.5</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;constant_score&quot;:{&quot;filter&quot;:{&quot;range&quot;:{&quot;consumerPrice&quot;:{&quot;lte&quot;:200}}},&quot;boost&quot;:2.5}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Constant Score with Exists</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "exists": { "field": "testDescription" }
      },
      "boost": 1.0
    }
  }
}</code></pre>
                    <p>Find all tests that have a description, each with a uniform score</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;constant_score&quot;:{&quot;filter&quot;:{&quot;exists&quot;:{&quot;field&quot;:&quot;testDescription&quot;}},&quot;boost&quot;:1.0}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Combining Constant Score in Bool Queries</h2>
                <p>Constant score becomes powerful when combined with bool queries. You can use it in <code>should</code> clauses to give fixed bonus points for matching certain conditions.</p>

                <div class="example-query">
                    <h4>Tiered Scoring with Constant Score</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "testName": "blood" } }
      ],
      "should": [
        {
          "constant_score": {
            "filter": { "range": { "consumerPrice": { "lte": 200 } } },
            "boost": 5.0
          }
        },
        {
          "constant_score": {
            "filter": { "exists": { "field": "testDescription" } },
            "boost": 2.0
          }
        },
        {
          "constant_score": {
            "filter": { "range": { "frequency": { "gte": 500 } } },
            "boost": 3.0
          }
        }
      ]
    }
  }
}</code></pre>
                    <p>Search for "blood" tests, then award bonus points: +5 for affordable, +2 for having a description, +3 for popular tests. Scores are predictable and additive.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}}],&quot;should&quot;:[{&quot;constant_score&quot;:{&quot;filter&quot;:{&quot;range&quot;:{&quot;consumerPrice&quot;:{&quot;lte&quot;:200}}},&quot;boost&quot;:5.0}},{&quot;constant_score&quot;:{&quot;filter&quot;:{&quot;exists&quot;:{&quot;field&quot;:&quot;testDescription&quot;}},&quot;boost&quot;:2.0}},{&quot;constant_score&quot;:{&quot;filter&quot;:{&quot;range&quot;:{&quot;frequency&quot;:{&quot;gte&quot;:500}}},&quot;boost&quot;:3.0}}]}}}')">Try it</button>
                </div>

                <div class="concept-box">
                    <h3>constant_score vs bool/filter</h3>
                    <pre><code class="language-text">bool/filter:
  Runs in filter context, score is 0
  Used when you don't want the clause to affect scoring at all
  { "filter": [{ "term": { "category.keyword": "hematology" } }] }

constant_score:
  Runs in filter context, score = boost value
  Used when you want a FIXED score contribution
  { "constant_score": { "filter": {...}, "boost": 5.0 } }

When to use constant_score:
  - In bool/should to add predictable bonus points
  - When you want uniform scoring (no TF-IDF variation)
  - When building custom scoring without function_score</code></pre>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; constant_score wraps a filter and assigns a fixed score (the boost value)</li>
                        <li>&#10003; Runs in filter context: cacheable and faster than scoring queries</li>
                        <li>&#10003; Default boost is 1.0; set custom values for weighted scoring</li>
                        <li>&#10003; Combine in bool/should for predictable, tiered bonus scoring</li>
                        <li>&#10003; Use when relevance scoring is unnecessary or you need uniform scores</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('boosting')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('wildcard-query')">Next: Wildcard Query &#8594;</a>
            </div>
        `
    },
    'wildcard-query': {
        title: 'Wildcard & Regexp',
        category: 'Advanced Search',
        difficulty: 'Intermediate',
        content: `
            <h1>Wildcard & Regexp Queries</h1>
            <p class="lesson-meta">
                <span class="category">Category: Advanced Search</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>Wildcard Query</h2>
                <p>Wildcard queries allow you to use <code>*</code> (any characters) and <code>?</code> (single character) patterns.</p>

                <div class="info-box">
                    <h4>&#9888; Performance Warning</h4>
                    <p>Wildcard queries can be slow, especially with leading wildcards (*blood). Avoid patterns like <code>*text</code> on large datasets.</p>
                </div>

                <div class="example-query">
                    <h4>Wildcard with * (any characters)</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "wildcard": {
      "testName.keyword": "*Blood*"
    }
  }
}</code></pre>
                    <p>Find tests with "Blood" anywhere in the name</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;wildcard&quot;:{&quot;testName.keyword&quot;:&quot;*Blood*&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Wildcard with ? (single character)</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "wildcard": {
      "testName.keyword": "C?C*"
    }
  }
}</code></pre>
                    <p>Matches "CBC", "C1C", etc.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;wildcard&quot;:{&quot;testName.keyword&quot;:&quot;C?C*&quot;}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Regexp Query</h2>
                <p>Regular expression queries provide more powerful pattern matching than wildcards.</p>

                <div class="example-query">
                    <h4>Regexp Example</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "regexp": {
      "testName.keyword": ".*[Bb]lood.*[Cc]ount.*"
    }
  }
}</code></pre>
                    <p>Case-insensitive "blood" followed by "count"</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;regexp&quot;:{&quot;testName.keyword&quot;:&quot;.*[Bb]lood.*[Cc]ount.*&quot;}}}')">Try it</button>
                </div>

                <div class="key-points">
                    <h3>Supported Regexp Operators:</h3>
                    <ul>
                        <li><code>.</code> - Any single character</li>
                        <li><code>*</code> - Zero or more of preceding</li>
                        <li><code>+</code> - One or more of preceding</li>
                        <li><code>?</code> - Zero or one of preceding</li>
                        <li><code>[]</code> - Character class</li>
                        <li><code>|</code> - Alternation (OR)</li>
                        <li><code>()</code> - Grouping</li>
                    </ul>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Wildcard: * for any chars, ? for single char</li>
                        <li>&#10003; Use on keyword fields, not analyzed text</li>
                        <li>&#10003; Avoid leading wildcards (*text) for performance</li>
                        <li>&#10003; Regexp offers more powerful patterns but is slower</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('constant-score')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('fuzzy-query')">Next: Fuzzy Search &#8594;</a>
            </div>
        `
    },
    'terms-agg': {
        title: 'Terms Aggregation',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Terms Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Terms Aggregation?</h2>
                <p>Terms aggregation groups documents by unique values in a field - similar to SQL's <code>GROUP BY</code>.</p>

                <div class="example-query">
                    <h4>Basic Terms Aggregation</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "tests_by_city": {
      "terms": {
        "field": "cityCode",
        "size": 10
      }
    }
  }
}</code></pre>
                    <p>Count tests grouped by city</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;size&quot;:0,&quot;aggs&quot;:{&quot;tests_by_city&quot;:{&quot;terms&quot;:{&quot;field&quot;:&quot;cityCode&quot;,&quot;size&quot;:10}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Terms with Sub-Aggregation</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "by_city": {
      "terms": {
        "field": "cityCode"
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "consumerPrice"
          }
        }
      }
    }
  }
}</code></pre>
                    <p>Average price per city</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;size&quot;:0,&quot;aggs&quot;:{&quot;by_city&quot;:{&quot;terms&quot;:{&quot;field&quot;:&quot;cityCode&quot;},&quot;aggs&quot;:{&quot;avg_price&quot;:{&quot;avg&quot;:{&quot;field&quot;:&quot;consumerPrice&quot;}}}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Terms with Ordering</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "popular_tests": {
      "terms": {
        "field": "genderDescription",
        "order": { "_count": "desc" }
      }
    }
  }
}</code></pre>
                    <p>Group by gender, ordered by count</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;size&quot;:0,&quot;aggs&quot;:{&quot;popular_tests&quot;:{&quot;terms&quot;:{&quot;field&quot;:&quot;genderDescription&quot;,&quot;order&quot;:{&quot;_count&quot;:&quot;desc&quot;}}}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Terms agg groups by unique field values</li>
                        <li>&#10003; Use size: 0 to skip hits and only get aggregations</li>
                        <li>&#10003; Sub-aggregations allow nested calculations</li>
                        <li>&#10003; Order by _count, _key, or sub-aggregation values</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('suggesters')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('range-agg')">Next: Range Aggregation &#8594;</a>
            </div>
        `
    },
    'range-agg': {
        title: 'Range Aggregation',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Range Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Range Aggregation?</h2>
                <p>The range aggregation lets you define <strong>custom buckets</strong> based on numeric ranges. Unlike the histogram aggregation which creates fixed-width buckets, range aggregation gives you full control over where each bucket starts and ends.</p>

                <div class="concept-box">
                    <h3>Basic Range Aggregation</h3>
                    <p>Use <code>from</code> (inclusive) and <code>to</code> (exclusive) to define each range bucket. Documents are placed into whichever bucket their field value falls into.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "consumerPrice",
        "ranges": [
          { "to": 50 },
          { "from": 50, "to": 200 },
          { "from": 200, "to": 500 },
          { "from": 500 }
        ]
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>How from/to Boundaries Work</h3>
                    <p>The <code>from</code> value is <strong>inclusive</strong> and the <code>to</code> value is <strong>exclusive</strong>. This means a document with a price of exactly 200 falls into the "200 to 500" bucket, not the "50 to 200" bucket.</p>
                    <pre><code class="language-json">// Bucket boundaries:
// Bucket 1: price &lt; 50        (everything below 50)
// Bucket 2: 50 &lt;= price &lt; 200 (50 included, 200 excluded)
// Bucket 3: 200 &lt;= price &lt; 500
// Bucket 4: price &gt;= 500      (everything 500 and above)</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Custom Key Names</h2>
                <p>By default, Elasticsearch generates keys like <code>"*-50.0"</code> or <code>"50.0-200.0"</code>. You can assign meaningful names using the <code>key</code> parameter.</p>

                <div class="concept-box">
                    <h3>Named Range Buckets</h3>
                    <p>Adding a <code>key</code> to each range makes the response easier to work with programmatically and more readable in dashboards.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_tiers": {
      "range": {
        "field": "consumerPrice",
        "keyed": true,
        "ranges": [
          { "key": "budget", "to": 50 },
          { "key": "standard", "from": 50, "to": 200 },
          { "key": "premium", "from": 200, "to": 500 },
          { "key": "luxury", "from": 500 }
        ]
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Range with Sub-Aggregation</h3>
                    <p>You can nest other aggregations inside each range bucket to compute additional metrics per price tier.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_tiers": {
      "range": {
        "field": "consumerPrice",
        "ranges": [
          { "key": "affordable", "to": 100 },
          { "key": "moderate", "from": 100, "to": 300 },
          { "key": "expensive", "from": 300 }
        ]
      },
      "aggs": {
        "avg_price": {
          "avg": { "field": "consumerPrice" }
        }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Range aggregation creates custom-defined numeric buckets</li>
                        <li>&#10003; <code>from</code> is inclusive, <code>to</code> is exclusive</li>
                        <li>&#10003; Use <code>key</code> to assign readable names to each range bucket</li>
                        <li>&#10003; Set <code>keyed: true</code> to return buckets as an object instead of an array</li>
                        <li>&#10003; Nest sub-aggregations inside range buckets for per-tier metrics</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('terms-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('histogram-agg')">Next: Histogram Aggregation &#8594;</a>
            </div>
        `
    },
    'histogram-agg': {
        title: 'Histogram Aggregation',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Histogram Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Histogram Aggregation?</h2>
                <p>The histogram aggregation builds <strong>fixed-width buckets</strong> over a numeric field. You specify an <code>interval</code> and Elasticsearch automatically creates evenly spaced buckets spanning the data range.</p>

                <div class="concept-box">
                    <h3>Basic Histogram</h3>
                    <p>The <code>interval</code> parameter defines the width of each bucket. For example, an interval of 100 on consumerPrice creates buckets 0-100, 100-200, 200-300, etc.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_histogram": {
      "histogram": {
        "field": "consumerPrice",
        "interval": 100
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>How Buckets Are Calculated</h3>
                    <p>Each document is placed into a bucket using the formula: <code>bucket_key = Math.floor(value / interval) * interval</code>. A test priced at 275 with interval 100 goes into the bucket with key 200.</p>
                    <pre><code class="language-json">// With interval: 100
// Price 45   -> bucket key: 0
// Price 150  -> bucket key: 100
// Price 275  -> bucket key: 200
// Price 1050 -> bucket key: 1000</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Controlling Empty Buckets and Bounds</h2>
                <p>By default, Elasticsearch only returns buckets that contain at least one document. You can change this behavior with <code>min_doc_count</code> and <code>extended_bounds</code>.</p>

                <div class="concept-box">
                    <h3>min_doc_count</h3>
                    <p>Set <code>min_doc_count</code> to 0 to include empty buckets in the response. This is useful for creating complete charts without gaps.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_histogram": {
      "histogram": {
        "field": "consumerPrice",
        "interval": 50,
        "min_doc_count": 0
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>extended_bounds</h3>
                    <p>Use <code>extended_bounds</code> to force the histogram to cover a specific range, even if no documents exist at the edges. This ensures your chart always starts and ends at consistent points.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_histogram": {
      "histogram": {
        "field": "consumerPrice",
        "interval": 100,
        "min_doc_count": 0,
        "extended_bounds": {
          "min": 0,
          "max": 1000
        }
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Histogram with Sub-Aggregation</h3>
                    <p>Combine histogram buckets with metric aggregations to get statistics per bucket.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_histogram": {
      "histogram": {
        "field": "consumerPrice",
        "interval": 100
      },
      "aggs": {
        "test_count_by_category": {
          "terms": { "field": "category" }
        }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Histogram creates fixed-width buckets using the <code>interval</code> parameter</li>
                        <li>&#10003; Bucket key is computed as <code>floor(value / interval) * interval</code></li>
                        <li>&#10003; Use <code>min_doc_count: 0</code> to include empty buckets</li>
                        <li>&#10003; Use <code>extended_bounds</code> to force a specific min/max range</li>
                        <li>&#10003; Nest sub-aggregations inside histogram buckets for richer analysis</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('range-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('date-histogram')">Next: Date Histogram &#8594;</a>
            </div>
        `
    },
    'date-histogram': {
        title: 'Date Histogram',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Date Histogram Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Date Histogram?</h2>
                <p>The date histogram aggregation is similar to the regular histogram but designed specifically for <strong>date/time fields</strong>. It groups documents into time-based buckets such as days, weeks, months, or years.</p>

                <div class="concept-box">
                    <h3>calendar_interval vs fixed_interval</h3>
                    <p>Elasticsearch provides two interval types. <code>calendar_interval</code> respects calendar boundaries (e.g., months have varying days), while <code>fixed_interval</code> uses a strict, constant duration.</p>
                    <pre><code class="language-json">// calendar_interval: aware of calendar irregularities
// Supported values: minute, hour, day, week, month, quarter, year
POST /tests/_search
{
  "size": 0,
  "aggs": {
    "tests_over_time": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month"
      }
    }
  }
}

// fixed_interval: strict duration
// Supports: ms, s, m, h, d (e.g., "30d", "12h")
POST /tests/_search
{
  "size": 0,
  "aggs": {
    "tests_over_time": {
      "date_histogram": {
        "field": "createdDate",
        "fixed_interval": "7d"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>When to Use Which Interval</h3>
                    <p>Use <code>calendar_interval</code> when you need semantically correct grouping (e.g., "monthly" where February has 28-29 days). Use <code>fixed_interval</code> when you need exact, consistent durations (e.g., every 30 days regardless of month boundaries).</p>
                    <pre><code class="language-json">// calendar_interval: "month"
// January bucket: Jan 1 - Jan 31 (31 days)
// February bucket: Feb 1 - Feb 28/29 (28-29 days)
// March bucket: Mar 1 - Mar 31 (31 days)

// fixed_interval: "30d"
// Bucket 1: Day 0 - Day 30 (exactly 30 days)
// Bucket 2: Day 30 - Day 60 (exactly 30 days)
// Bucket 3: Day 60 - Day 90 (exactly 30 days)</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Formatting, Time Zones, and Missing Values</h2>
                <p>Date histogram provides several parameters to control how dates are displayed, how time zones are handled, and what happens when documents lack a date value.</p>

                <div class="concept-box">
                    <h3>Format and Time Zone</h3>
                    <p>The <code>format</code> parameter controls how bucket keys appear in the response. The <code>time_zone</code> parameter shifts bucket boundaries to align with a specific time zone.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly_tests": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month",
        "format": "yyyy-MM",
        "time_zone": "America/New_York"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Handling Missing Values</h3>
                    <p>Use the <code>missing</code> parameter to assign a default date for documents that do not have the date field. These documents will be bucketed according to the fallback value.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "tests_by_date": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "year",
        "missing": "2020-01-01"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Date Histogram with Metrics</h3>
                    <p>Combine date histogram with metric aggregations to track trends over time, such as average test price per month.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly_stats": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month",
        "format": "yyyy-MM"
      },
      "aggs": {
        "avg_price": {
          "avg": { "field": "consumerPrice" }
        },
        "test_count_by_category": {
          "terms": { "field": "category" }
        }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Date histogram groups documents into time-based buckets</li>
                        <li>&#10003; <code>calendar_interval</code> respects calendar boundaries (month, year)</li>
                        <li>&#10003; <code>fixed_interval</code> uses strict durations (7d, 12h)</li>
                        <li>&#10003; Use <code>format</code> to control how date keys are displayed</li>
                        <li>&#10003; Use <code>time_zone</code> to shift bucket boundaries for locale-aware grouping</li>
                        <li>&#10003; Use <code>missing</code> to include documents without a date field</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('histogram-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('avg-sum-agg')">Next: Avg, Sum, Min, Max &#8594;</a>
            </div>
        `
    },
    'avg-sum-agg': {
        title: 'Avg, Sum, Min, Max',
        category: 'Aggregations',
        difficulty: 'Beginner',
        content: `
            <h1>Avg, Sum, Min, Max Aggregations</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>Basic Metric Aggregations</h2>
                <p>Elasticsearch provides four fundamental single-value metric aggregations: <code>avg</code>, <code>sum</code>, <code>min</code>, and <code>max</code>. Each computes a single numeric result from a specified field across all matching documents.</p>

                <div class="concept-box">
                    <h3>Avg Aggregation</h3>
                    <p>Calculates the arithmetic mean of a numeric field across all documents.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "average_price": {
      "avg": {
        "field": "consumerPrice"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Sum Aggregation</h3>
                    <p>Computes the total sum of a numeric field. Useful for calculating total revenue, total tests ordered, etc.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "total_price": {
      "sum": {
        "field": "consumerPrice"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Min and Max Aggregations</h3>
                    <p>Find the lowest and highest values of a numeric field. These are often combined to understand the range of data.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "cheapest_test": {
      "min": {
        "field": "consumerPrice"
      }
    },
    "most_expensive_test": {
      "max": {
        "field": "consumerPrice"
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Combining Metrics and Handling Missing Values</h2>
                <p>You can run multiple metric aggregations in a single request and handle documents where the field is absent.</p>

                <div class="concept-box">
                    <h3>Multiple Metrics in One Query</h3>
                    <p>Define several aggregations at the same level to compute all metrics in a single round trip.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "avg_price": { "avg": { "field": "consumerPrice" } },
    "total_price": { "sum": { "field": "consumerPrice" } },
    "min_price": { "min": { "field": "consumerPrice" } },
    "max_price": { "max": { "field": "consumerPrice" } }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Handling Missing Values</h3>
                    <p>The <code>missing</code> parameter tells Elasticsearch what value to use when a document does not have the aggregated field. Without it, documents missing the field are simply ignored.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "avg_price_with_default": {
      "avg": {
        "field": "consumerPrice",
        "missing": 0
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Metrics Inside Bucket Aggregations</h3>
                    <p>Metric aggregations are most powerful when nested inside bucket aggregations like terms, giving you per-group statistics.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "by_category": {
      "terms": { "field": "category" },
      "aggs": {
        "avg_price": { "avg": { "field": "consumerPrice" } },
        "max_price": { "max": { "field": "consumerPrice" } }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; <code>avg</code> computes the arithmetic mean of a numeric field</li>
                        <li>&#10003; <code>sum</code> adds up all values of a numeric field</li>
                        <li>&#10003; <code>min</code> and <code>max</code> find the lowest and highest values</li>
                        <li>&#10003; Use <code>missing</code> to provide a default value for documents lacking the field</li>
                        <li>&#10003; Combine multiple metric aggregations in a single query for efficiency</li>
                        <li>&#10003; Nest metrics inside bucket aggregations for per-group statistics</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('date-histogram')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('stats-agg')">Next: Stats &amp; Extended Stats &#8594;</a>
            </div>
        `
    },
    'stats-agg': {
        title: 'Stats &amp; Extended Stats',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Stats &amp; Extended Stats Aggregations</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>Stats Aggregation</h2>
                <p>The <code>stats</code> aggregation is a multi-value metric that computes <strong>count, min, max, avg, and sum</strong> in a single request. Instead of running five separate aggregations, you get all basic statistics at once.</p>

                <div class="concept-box">
                    <h3>Basic Stats</h3>
                    <p>A single stats aggregation returns all five core metrics for the specified field.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_stats": {
      "stats": {
        "field": "consumerPrice"
      }
    }
  }
}

// Response:
{
  "aggregations": {
    "price_stats": {
      "count": 1250,
      "min": 5.99,
      "max": 899.0,
      "avg": 145.32,
      "sum": 181650.0
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Stats per Bucket</h3>
                    <p>Nest stats inside a bucket aggregation to get complete statistics for each group.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "by_category": {
      "terms": { "field": "category" },
      "aggs": {
        "price_stats": {
          "stats": { "field": "consumerPrice" }
        }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Extended Stats Aggregation</h2>
                <p>The <code>extended_stats</code> aggregation includes everything from <code>stats</code> plus additional statistical measures: <strong>sum_of_squares</strong>, <strong>variance</strong>, <strong>std_deviation</strong>, and <strong>std_deviation_bounds</strong>.</p>

                <div class="concept-box">
                    <h3>Extended Stats Query</h3>
                    <p>Extended stats adds variance and standard deviation calculations that are essential for understanding data distribution and identifying outliers.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_extended_stats": {
      "extended_stats": {
        "field": "consumerPrice"
      }
    }
  }
}

// Response includes additional fields:
{
  "aggregations": {
    "price_extended_stats": {
      "count": 1250,
      "min": 5.99,
      "max": 899.0,
      "avg": 145.32,
      "sum": 181650.0,
      "sum_of_squares": 4.56E7,
      "variance": 18234.5,
      "variance_population": 18234.5,
      "variance_sampling": 18249.1,
      "std_deviation": 135.03,
      "std_deviation_population": 135.03,
      "std_deviation_sampling": 135.09,
      "std_deviation_bounds": {
        "upper": 415.38,
        "lower": -124.74,
        "upper_population": 415.38,
        "lower_population": -124.74,
        "upper_sampling": 415.50,
        "lower_sampling": -124.86
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Custom Sigma for Standard Deviation Bounds</h3>
                    <p>By default, std_deviation_bounds uses 2 sigma (covering ~95% of data). You can customize this with the <code>sigma</code> parameter.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_outliers": {
      "extended_stats": {
        "field": "consumerPrice",
        "sigma": 3
      }
    }
  }
}
// sigma: 1 -> ~68% of data
// sigma: 2 -> ~95% of data (default)
// sigma: 3 -> ~99.7% of data</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; <code>stats</code> returns count, min, max, avg, and sum in one aggregation</li>
                        <li>&#10003; <code>extended_stats</code> adds variance, standard deviation, and deviation bounds</li>
                        <li>&#10003; Use <code>sigma</code> to control the standard deviation bounds range</li>
                        <li>&#10003; Nest either aggregation inside buckets for per-group statistics</li>
                        <li>&#10003; Prefer <code>stats</code> over multiple individual metric aggregations for efficiency</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('avg-sum-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('cardinality-agg')">Next: Cardinality Aggregation &#8594;</a>
            </div>
        `
    },
    'cardinality-agg': {
        title: 'Cardinality Aggregation',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Cardinality Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Cardinality Aggregation?</h2>
                <p>The cardinality aggregation calculates an <strong>approximate count of distinct values</strong> for a field - similar to SQL's <code>COUNT(DISTINCT field)</code>. It uses the <strong>HyperLogLog++ (HLL++)</strong> algorithm to provide fast, memory-efficient approximations.</p>

                <div class="concept-box">
                    <h3>Basic Cardinality</h3>
                    <p>Count the approximate number of unique categories in the tests index.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "unique_categories": {
      "cardinality": {
        "field": "category"
      }
    }
  }
}

// Response:
{
  "aggregations": {
    "unique_categories": {
      "value": 42
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Why Approximate?</h3>
                    <p>Computing exact distinct counts across a distributed system is extremely expensive (requires coordinating all data). HLL++ trades a small margin of error (typically &lt; 5%) for dramatically better performance and constant memory usage regardless of data size.</p>
                    <pre><code class="language-json">// Exact distinct count:
//   Memory: O(n) - must store every unique value
//   Speed: Slow on large datasets
//
// HyperLogLog++:
//   Memory: O(1) - fixed ~4KB regardless of cardinality
//   Speed: Very fast, single pass
//   Error: Typically &lt; 2% for most datasets</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Precision Threshold</h2>
                <p>The <code>precision_threshold</code> parameter controls the trade-off between accuracy and memory usage. Values below the threshold are counted almost exactly.</p>

                <div class="concept-box">
                    <h3>Configuring Precision</h3>
                    <p>The <code>precision_threshold</code> accepts values from 0 to 40000. The default is 3000. When the actual cardinality is below this threshold, the count is nearly exact.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "unique_test_names": {
      "cardinality": {
        "field": "testName.keyword",
        "precision_threshold": 10000
      }
    }
  }
}

// precision_threshold guidelines:
// Low (100):   Less memory, less accurate for high cardinality
// Default (3000): Good balance for most use cases
// High (40000): Maximum accuracy, more memory usage</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Cardinality per Bucket</h3>
                    <p>Nest cardinality inside a bucket aggregation to count distinct values within each group.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "by_category": {
      "terms": { "field": "category" },
      "aggs": {
        "unique_tests": {
          "cardinality": {
            "field": "testName.keyword"
          }
        }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Cardinality returns an approximate count of distinct values</li>
                        <li>&#10003; Uses the HyperLogLog++ algorithm for speed and constant memory</li>
                        <li>&#10003; <code>precision_threshold</code> controls accuracy vs. memory (default: 3000)</li>
                        <li>&#10003; Below the threshold, counts are nearly exact; above, expect small error</li>
                        <li>&#10003; Nest inside bucket aggregations to count distinct values per group</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('stats-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('percentiles-agg')">Next: Percentiles Aggregation &#8594;</a>
            </div>
        `
    },
    'percentiles-agg': {
        title: 'Percentiles Aggregation',
        category: 'Aggregations',
        difficulty: 'Intermediate',
        content: `
            <h1>Percentiles Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Percentiles Aggregation?</h2>
                <p>The percentiles aggregation calculates the values below which a given percentage of data falls. For example, the 95th percentile is the value below which 95% of data points lie. Elasticsearch uses the <strong>TDigest</strong> algorithm for approximate percentile computation.</p>

                <div class="concept-box">
                    <h3>Default Percentiles</h3>
                    <p>By default, Elasticsearch returns percentiles at 1, 5, 25, 50, 75, 95, and 99. These cover the most commonly needed distribution breakpoints.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_percentiles": {
      "percentiles": {
        "field": "consumerPrice"
      }
    }
  }
}

// Response:
{
  "aggregations": {
    "price_percentiles": {
      "values": {
        "1.0": 8.50,
        "5.0": 15.00,
        "25.0": 49.99,
        "50.0": 120.00,
        "75.0": 250.00,
        "95.0": 599.00,
        "99.0": 799.00
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Custom Percentile Values</h3>
                    <p>Specify exactly which percentiles you want using the <code>percents</code> parameter. This is useful when you only need specific breakpoints.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_percentiles": {
      "percentiles": {
        "field": "consumerPrice",
        "percents": [10, 25, 50, 75, 90, 99.9]
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Percentile Ranks and TDigest</h2>
                <p>While percentiles ask "what value is at the Nth percentile?", <code>percentile_ranks</code> asks the inverse: "what percentile does this value fall at?"</p>

                <div class="concept-box">
                    <h3>Percentile Ranks</h3>
                    <p>Given specific values, percentile_ranks tells you what percentage of documents fall below each value. For example: "What percent of tests cost less than $100?"</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "price_ranks": {
      "percentile_ranks": {
        "field": "consumerPrice",
        "values": [50, 100, 200, 500]
      }
    }
  }
}

// Response:
{
  "aggregations": {
    "price_ranks": {
      "values": {
        "50.0": 28.3,
        "100.0": 45.7,
        "200.0": 68.2,
        "500.0": 92.1
      }
    }
  }
}
// 45.7% of tests cost less than $100</code></pre>
                </div>

                <div class="concept-box">
                    <h3>TDigest Compression</h3>
                    <p>The TDigest algorithm uses a <code>compression</code> parameter (default: 100) that controls accuracy vs. memory. Higher compression means more accurate results at the cost of more memory.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "precise_percentiles": {
      "percentiles": {
        "field": "consumerPrice",
        "tdigest": {
          "compression": 200
        }
      }
    }
  }
}

// compression: 100 (default) - good balance
// compression: 200 - more accurate, more memory
// compression: 50  - less accurate, less memory
// Higher compression is more accurate at extreme percentiles (99th, 99.9th)</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Percentiles show the value below which N% of data falls</li>
                        <li>&#10003; Default percentiles: 1, 5, 25, 50, 75, 95, 99</li>
                        <li>&#10003; Use <code>percents</code> to specify custom percentile breakpoints</li>
                        <li>&#10003; <code>percentile_ranks</code> is the inverse: find the percentile for a given value</li>
                        <li>&#10003; TDigest <code>compression</code> controls accuracy vs. memory trade-off</li>
                        <li>&#10003; Higher compression improves accuracy at extreme percentiles</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('cardinality-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('avg-bucket')">Next: Avg Bucket &#8594;</a>
            </div>
        `
    },
    'avg-bucket': {
        title: 'Avg Bucket',
        category: 'Aggregations',
        difficulty: 'Advanced',
        content: `
            <h1>Avg Bucket (Pipeline Aggregation)</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>What are Pipeline Aggregations?</h2>
                <p>Pipeline aggregations work on the <strong>output of other aggregations</strong> rather than directly on documents. They take the results produced by sibling or parent aggregations and compute additional metrics. <code>avg_bucket</code> is one of the most common pipeline aggregations.</p>

                <div class="concept-box">
                    <h3>Sibling vs Parent Pipeline Aggregations</h3>
                    <p>There are two types of pipeline aggregations:</p>
                    <pre><code class="language-json">// SIBLING pipeline aggs:
// - Defined at the same level as the bucket aggregation
// - Compute a single value from all buckets
// - Examples: avg_bucket, max_bucket, min_bucket, sum_bucket
//
// PARENT pipeline aggs:
// - Defined inside the bucket aggregation
// - Compute a value for EACH bucket based on its parent
// - Examples: derivative, cumulative_sum, moving_avg

// Visual:
// aggs: {
//   my_buckets: { ... },            // bucket agg
//   my_sibling_pipeline: {          // sibling: same level
//     avg_bucket: { buckets_path: "my_buckets>metric" }
//   }
// }
//
// vs.
//
// aggs: {
//   my_buckets: {                   // bucket agg
//     aggs: {
//       my_parent_pipeline: {       // parent: nested inside
//         derivative: { buckets_path: "metric" }
//       }
//     }
//   }
// }</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Using avg_bucket</h2>
                <p>The <code>avg_bucket</code> aggregation computes the mean of a metric across all buckets produced by a sibling bucket aggregation. The <code>buckets_path</code> parameter uses <code>&gt;</code> notation to reference nested aggregation results.</p>

                <div class="concept-box">
                    <h3>Average Price Across Categories</h3>
                    <p>First, a terms aggregation groups tests by category and computes the average price per category. Then, <code>avg_bucket</code> calculates the overall average of those per-category averages.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "categories": {
      "terms": {
        "field": "category",
        "size": 20
      },
      "aggs": {
        "avg_price": {
          "avg": { "field": "consumerPrice" }
        }
      }
    },
    "avg_price_across_categories": {
      "avg_bucket": {
        "buckets_path": "categories>avg_price"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Understanding buckets_path</h3>
                    <p>The <code>buckets_path</code> syntax uses <code>&gt;</code> to navigate through aggregation levels. It references the metric aggregation inside the bucket aggregation whose output you want to average.</p>
                    <pre><code class="language-json">// buckets_path: "categories>avg_price"
//
// "categories"  -> the sibling bucket aggregation
// ">"           -> navigate into its sub-aggregations
// "avg_price"   -> the metric aggregation to average
//
// Result: average of each category's avg_price value

// You can also use special paths:
// "categories>_count"  -> average of document counts per bucket
// "categories>avg_price.value" -> explicit .value (usually optional)</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Gap Policy</h3>
                    <p>When buckets have missing values, the <code>gap_policy</code> parameter controls behavior. <code>skip</code> (default) ignores empty buckets; <code>insert_zeros</code> treats them as 0.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month"
      },
      "aggs": {
        "avg_price": {
          "avg": { "field": "consumerPrice" }
        }
      }
    },
    "overall_avg": {
      "avg_bucket": {
        "buckets_path": "monthly>avg_price",
        "gap_policy": "skip"
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Pipeline aggregations operate on the output of other aggregations</li>
                        <li>&#10003; <code>avg_bucket</code> is a sibling pipeline that averages a metric across all buckets</li>
                        <li>&#10003; Use <code>buckets_path</code> with <code>&gt;</code> notation to reference nested metrics</li>
                        <li>&#10003; Sibling pipelines sit at the same level; parent pipelines nest inside buckets</li>
                        <li>&#10003; Use <code>gap_policy</code> to control how empty buckets are handled</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('percentiles-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('derivative-agg')">Next: Derivative Aggregation &#8594;</a>
            </div>
        `
    },
    'derivative-agg': {
        title: 'Derivative Aggregation',
        category: 'Aggregations',
        difficulty: 'Advanced',
        content: `
            <h1>Derivative Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>What is the Derivative Aggregation?</h2>
                <p>The derivative aggregation is a <strong>parent pipeline aggregation</strong> that calculates the rate of change between consecutive buckets. It computes the difference between the current bucket's metric value and the previous bucket's metric value - essentially the first derivative.</p>

                <div class="concept-box">
                    <h3>Basic Derivative</h3>
                    <p>This example calculates the month-over-month change in average test price. The derivative is nested inside the date_histogram because it is a parent pipeline aggregation.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month",
        "format": "yyyy-MM"
      },
      "aggs": {
        "avg_price": {
          "avg": { "field": "consumerPrice" }
        },
        "price_change": {
          "derivative": {
            "buckets_path": "avg_price"
          }
        }
      }
    }
  }
}

// Response (simplified):
// { "key_as_string": "2024-01", "avg_price": { "value": 140 } }
// { "key_as_string": "2024-02", "avg_price": { "value": 155 },
//   "price_change": { "value": 15 } }       // 155 - 140 = +15
// { "key_as_string": "2024-03", "avg_price": { "value": 148 },
//   "price_change": { "value": -7 } }       // 148 - 155 = -7</code></pre>
                </div>

                <div class="concept-box">
                    <h3>How It Works</h3>
                    <p>For each bucket, the derivative value is: <code>current_value - previous_value</code>. The first bucket has no derivative because there is no previous bucket to compare with.</p>
                    <pre><code class="language-json">// Given buckets with values: [100, 120, 115, 130, 150]
//
// Derivatives:
// Bucket 0: 100 -> no derivative (first bucket)
// Bucket 1: 120 -> derivative = 120 - 100 = +20
// Bucket 2: 115 -> derivative = 115 - 120 = -5
// Bucket 3: 130 -> derivative = 130 - 115 = +15
// Bucket 4: 150 -> derivative = 150 - 130 = +20</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Gap Handling and Units</h2>
                <p>When buckets have missing data or irregular spacing, derivatives need special handling.</p>

                <div class="concept-box">
                    <h3>Gap Policy</h3>
                    <p>The <code>gap_policy</code> parameter controls what happens when a bucket has no value. <code>skip</code> (default) skips empty buckets and computes the derivative from the next available value. <code>insert_zeros</code> treats empty buckets as zero.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month"
      },
      "aggs": {
        "test_count": {
          "value_count": { "field": "testName.keyword" }
        },
        "count_change": {
          "derivative": {
            "buckets_path": "test_count",
            "gap_policy": "insert_zeros"
          }
        }
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Units for Normalized Derivatives</h3>
                    <p>When using date histograms, you can specify <code>unit</code> to normalize the derivative to a per-unit-of-time rate. This is useful when comparing rate of change across different interval sizes.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "weekly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "week"
      },
      "aggs": {
        "total_price": {
          "sum": { "field": "consumerPrice" }
        },
        "daily_rate_change": {
          "derivative": {
            "buckets_path": "total_price",
            "unit": "day"
          }
        }
      }
    }
  }
}

// Without unit: derivative = change per bucket (per week)
// With unit "day": derivative = change per day
// The normalized value divides the raw derivative by the
// number of days between bucket boundaries</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Derivative is a parent pipeline aggregation computing rate of change</li>
                        <li>&#10003; Calculates <code>current_value - previous_value</code> for each bucket</li>
                        <li>&#10003; The first bucket always has no derivative value</li>
                        <li>&#10003; Use <code>gap_policy</code> to handle missing bucket values (skip or insert_zeros)</li>
                        <li>&#10003; Use <code>unit</code> with date histograms to normalize to per-time-unit rates</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('avg-bucket')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('cumulative-sum')">Next: Cumulative Sum &#8594;</a>
            </div>
        `
    },
    'cumulative-sum': {
        title: 'Cumulative Sum',
        category: 'Aggregations',
        difficulty: 'Advanced',
        content: `
            <h1>Cumulative Sum Aggregation</h1>
            <p class="lesson-meta">
                <span class="category">Category: Aggregations</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>What is Cumulative Sum?</h2>
                <p>The cumulative sum aggregation is a <strong>parent pipeline aggregation</strong> that calculates a running total across ordered buckets. Each bucket's cumulative value is the sum of its own metric plus all previous buckets' metrics. This is invaluable for tracking cumulative revenue, growth, or running totals over time.</p>

                <div class="concept-box">
                    <h3>Basic Cumulative Sum</h3>
                    <p>This example computes a running total of test prices by month. The cumulative_sum references a sibling metric aggregation via <code>buckets_path</code>.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month",
        "format": "yyyy-MM"
      },
      "aggs": {
        "monthly_revenue": {
          "sum": { "field": "consumerPrice" }
        },
        "running_total": {
          "cumulative_sum": {
            "buckets_path": "monthly_revenue"
          }
        }
      }
    }
  }
}

// Response (simplified):
// 2024-01: revenue=5000,  running_total=5000
// 2024-02: revenue=7500,  running_total=12500  (5000+7500)
// 2024-03: revenue=6200,  running_total=18700  (12500+6200)
// 2024-04: revenue=8100,  running_total=26800  (18700+8100)</code></pre>
                </div>

                <div class="concept-box">
                    <h3>How It Works</h3>
                    <p>For each bucket at position i, the cumulative sum equals: <code>sum(metric[0] + metric[1] + ... + metric[i])</code>. Buckets must be ordered (typically by date histogram or histogram) for the running total to be meaningful.</p>
                    <pre><code class="language-json">// Given bucket values:  [100, 200, 150, 300, 250]
//
// Cumulative sums:
// Bucket 0: 100 -> cumulative = 100
// Bucket 1: 200 -> cumulative = 100 + 200 = 300
// Bucket 2: 150 -> cumulative = 300 + 150 = 450
// Bucket 3: 300 -> cumulative = 450 + 300 = 750
// Bucket 4: 250 -> cumulative = 750 + 250 = 1000</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Practical Use Cases</h2>
                <p>Cumulative sum is commonly combined with other aggregations and pipeline aggregations for rich analytical dashboards.</p>

                <div class="concept-box">
                    <h3>Cumulative Test Count Over Time</h3>
                    <p>Track the total number of tests added to the system cumulatively over time using <code>value_count</code> as the base metric.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month",
        "format": "yyyy-MM"
      },
      "aggs": {
        "new_tests": {
          "value_count": { "field": "testName.keyword" }
        },
        "total_tests_to_date": {
          "cumulative_sum": {
            "buckets_path": "new_tests"
          }
        }
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Combining Cumulative Sum with Derivative</h3>
                    <p>You can chain pipeline aggregations. Apply a derivative on top of a cumulative sum to verify the derivative brings you back to the original per-bucket values (useful for validation).</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "size": 0,
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "createdDate",
        "calendar_interval": "month"
      },
      "aggs": {
        "revenue": {
          "sum": { "field": "consumerPrice" }
        },
        "cumulative_revenue": {
          "cumulative_sum": {
            "buckets_path": "revenue"
          }
        },
        "revenue_acceleration": {
          "derivative": {
            "buckets_path": "cumulative_revenue"
          }
        }
      }
    }
  }
}
// revenue_acceleration derivative of cumulative_sum
// equals the original per-bucket revenue values</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Cumulative sum computes a running total across ordered buckets</li>
                        <li>&#10003; It is a parent pipeline aggregation nested inside a bucket aggregation</li>
                        <li>&#10003; Uses <code>buckets_path</code> to reference the metric to accumulate</li>
                        <li>&#10003; Requires ordered buckets (date_histogram or histogram) to be meaningful</li>
                        <li>&#10003; Chain with other pipeline aggregations like derivative for advanced analytics</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('derivative-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('relevance-scoring')">Next: Relevance Scoring &#8594;</a>
            </div>
        `
    },
    'prefix-query': {
        title: 'Prefix Query',
        category: 'Advanced Search',
        difficulty: 'Intermediate',
        content: `
            <h1>Prefix Query: Matching the Beginning of Terms</h1>
            <p class="lesson-meta">
                <span class="category">Category: Advanced Search</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is a Prefix Query?</h2>
                <p>The prefix query matches documents containing terms that <strong>start with</strong> a specified prefix. It's useful for autocomplete and type-ahead functionality.</p>

                <div style="background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #6ee7b7;">
                    <h4 style="color: #065f46; margin-bottom: 1rem;">Prefix Matching Visualization</h4>
                    <div style="display: flex; flex-direction: column; gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center;">
                            <div style="font-size: 0.85rem; color: #6b7280; margin-bottom: 0.5rem;">Query Prefix</div>
                            <div style="font-family: monospace; font-size: 1.25rem; color: #059669; font-weight: 600;">"blo"</div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem;">
                            <div style="background: white; border-radius: 8px; padding: 0.75rem; border: 2px solid #22c55e;">
                                <span style="color: #22c55e; font-weight: 600;">&#10003;</span>
                                <span style="font-family: monospace;"><span style="background: #bbf7d0; padding: 0 2px;">blo</span>od</span>
                            </div>
                            <div style="background: white; border-radius: 8px; padding: 0.75rem; border: 2px solid #22c55e;">
                                <span style="color: #22c55e; font-weight: 600;">&#10003;</span>
                                <span style="font-family: monospace;"><span style="background: #bbf7d0; padding: 0 2px;">blo</span>ating</span>
                            </div>
                            <div style="background: white; border-radius: 8px; padding: 0.75rem; border: 2px solid #22c55e;">
                                <span style="color: #22c55e; font-weight: 600;">&#10003;</span>
                                <span style="font-family: monospace;"><span style="background: #bbf7d0; padding: 0 2px;">blo</span>cker</span>
                            </div>
                            <div style="background: white; border-radius: 8px; padding: 0.75rem; border: 2px solid #ef4444;">
                                <span style="color: #ef4444; font-weight: 600;">&#10007;</span>
                                <span style="font-family: monospace;">hemoglobin</span>
                                <span style="font-size: 0.75rem; color: #6b7280;">(not at start)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="key-points">
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Term-level query:</strong> Works on exact terms, not analyzed text</li>
                        <li><strong>Case-sensitive:</strong> Unless field is lowercased at index time</li>
                        <li><strong>No scoring by default:</strong> All matches get same score</li>
                        <li><strong>Performance:</strong> Can be slow without proper indexing</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Prefix Query</h2>

                <div class="example-query">
                    <h4>Simple Prefix Search</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "prefix": {
      "testName": {
        "value": "blood"
      }
    }
  }
}</code></pre>
                    <p>Finds all tests whose name starts with "blood"</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;prefix&quot;:{&quot;testName&quot;:{&quot;value&quot;:&quot;blood&quot;}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Case-Insensitive Prefix</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "prefix": {
      "testName": {
        "value": "comp",
        "case_insensitive": true
      }
    }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;prefix&quot;:{&quot;testName&quot;:{&quot;value&quot;:&quot;comp&quot;,&quot;case_insensitive&quot;:true}}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Prefix vs Alternatives</h2>
                <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #93c5fd;">
                    <h4 style="color: #1e40af; margin-bottom: 1rem;">When to Use Each Approach</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem;">prefix query</div>
                            <ul style="margin: 0; padding-left: 1rem; font-size: 0.85rem; color: #475569;">
                                <li>Simple prefix matching</li>
                                <li>Small datasets</li>
                                <li>One-off queries</li>
                            </ul>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #7c3aed; margin-bottom: 0.5rem;">edge_ngram</div>
                            <ul style="margin: 0; padding-left: 1rem; font-size: 0.85rem; color: #475569;">
                                <li>Autocomplete feature</li>
                                <li>High-volume queries</li>
                                <li>Need scoring</li>
                            </ul>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #059669; margin-bottom: 0.5rem;">completion suggester</div>
                            <ul style="margin: 0; padding-left: 1rem; font-size: 0.85rem; color: #475569;">
                                <li>Search-as-you-type</li>
                                <li>Fastest performance</li>
                                <li>Limited flexibility</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Prefix query matches terms starting with a prefix</li>
                        <li>&#10003; Works on term level (use keyword fields for exact prefix)</li>
                        <li>&#10003; Can be case-insensitive with case_insensitive: true</li>
                        <li>&#10003; For production autocomplete, prefer edge_ngram tokenizer</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('wildcard-query')">&#8592; Previous: Wildcard</a>
                <a class="btn btn-primary" onclick="loadLesson('fuzzy-query')">Next: Fuzzy Search &#8594;</a>
            </div>
        `
    },
    'fuzzy-query': {
        title: 'Fuzzy Search',
        category: 'Advanced Search',
        difficulty: 'Intermediate',
        content: `
            <h1>Fuzzy Search: Handling Typos and Misspellings</h1>
            <p class="lesson-meta">
                <span class="category">Category: Advanced Search</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Fuzzy Search?</h2>
                <p>Fuzzy search finds documents that match terms similar to the search term, allowing for typos, misspellings, and minor variations using Levenshtein edit distance.</p>

                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #fcd34d;">
                    <h4 style="color: #92400e; margin-bottom: 1rem;">Edit Distance Examples</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">1 Edit Distance</div>
                            <div style="font-size: 0.9rem; color: #475569;">
                                <div>blood → <span style="color: #16a34a;">blod</span> (deletion)</div>
                                <div>blood → <span style="color: #16a34a;">bloood</span> (insertion)</div>
                                <div>blood → <span style="color: #16a34a;">bload</span> (substitution)</div>
                            </div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">2 Edit Distance</div>
                            <div style="font-size: 0.9rem; color: #475569;">
                                <div>blood → <span style="color: #16a34a;">blud</span></div>
                                <div>blood → <span style="color: #16a34a;">bleed</span></div>
                                <div>blood → <span style="color: #16a34a;">flood</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Using Fuzzy in Match Query</h2>

                <div class="example-query">
                    <h4>Fuzzy Match with AUTO</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": {
      "testName": {
        "query": "blod",
        "fuzziness": "AUTO"
      }
    }
  }
}</code></pre>
                    <p>AUTO adjusts fuzziness based on term length (0-2 chars: exact, 3-5: 1 edit, 6+: 2 edits)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:{&quot;query&quot;:&quot;blod&quot;,&quot;fuzziness&quot;:&quot;AUTO&quot;}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Explicit Fuzziness</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": {
      "testName": {
        "query": "complet blod count",
        "fuzziness": 1
      }
    }
  }
}</code></pre>
                    <p>Allow 1 edit per term</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:{&quot;query&quot;:&quot;complet blod count&quot;,&quot;fuzziness&quot;:1}}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Fuzziness Options</h2>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>Value</th><th>Description</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><code>0</code></td><td>Exact match only</td></tr>
                            <tr><td><code>1</code></td><td>Allow 1 edit</td></tr>
                            <tr><td><code>2</code></td><td>Allow 2 edits (max)</td></tr>
                            <tr><td><code>AUTO</code></td><td>Automatic based on term length</td></tr>
                            <tr><td><code>AUTO:3,6</code></td><td>Custom thresholds</td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Fuzzy search handles typos using edit distance</li>
                        <li>&#10003; Use fuzziness: "AUTO" for smart defaults</li>
                        <li>&#10003; Maximum edit distance is 2</li>
                        <li>&#10003; Fuzzy increases recall but may reduce precision</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('prefix-query')">&#8592; Previous: Prefix Query</a>
                <a class="btn btn-primary" onclick="loadLesson('nested-query')">Next: Nested Queries &#8594;</a>
            </div>
        `
    },
    'multi-match': {
        title: 'Multi-Match Query',
        category: 'Query DSL',
        difficulty: 'Intermediate',
        content: `
            <h1>Multi-Match Query: Search Across Multiple Fields</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Multi-Match?</h2>
                <p>Multi-match query searches the same text across multiple fields, combining scores to find the best matches.</p>

                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #86efac;">
                    <h4 style="color: #166534; margin-bottom: 1rem;">Multi-Field Search Flow</h4>
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center;">
                            <div style="font-size: 0.85rem; color: #6b7280;">Query</div>
                            <div style="font-family: monospace; color: #166534;">"blood test"</div>
                        </div>
                        <div style="color: #22c55e; font-size: 1.5rem;">&#8594;</div>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <div style="background: #dcfce7; padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.9rem;">testName</div>
                            <div style="background: #dcfce7; padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.9rem;">testAlias</div>
                            <div style="background: #dcfce7; padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.9rem;">description</div>
                        </div>
                        <div style="color: #22c55e; font-size: 1.5rem;">&#8594;</div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center;">
                            <div style="font-size: 0.85rem; color: #6b7280;">Combined</div>
                            <div style="font-weight: 600; color: #166534;">Score</div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Multi-Match</h2>

                <div class="example-query">
                    <h4>Search Multiple Fields</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "multi_match": {
      "query": "blood",
      "fields": ["testName", "testAlias"]
    }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;multi_match&quot;:{&quot;query&quot;:&quot;blood&quot;,&quot;fields&quot;:[&quot;testName&quot;,&quot;testAlias&quot;]}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>With Field Boosting</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "multi_match": {
      "query": "liver function",
      "fields": ["testName^3", "testAlias^2", "description"]
    }
  }
}</code></pre>
                    <p>testName matches are 3x more important</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;multi_match&quot;:{&quot;query&quot;:&quot;liver function&quot;,&quot;fields&quot;:[&quot;testName^3&quot;,&quot;testAlias^2&quot;]}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Multi-Match Types</h2>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr><th>Type</th><th>Behavior</th><th>Use Case</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><code>best_fields</code></td><td>Score from best matching field</td><td>Default, general search</td></tr>
                            <tr><td><code>most_fields</code></td><td>Combine scores from all fields</td><td>Same text, different analyzers</td></tr>
                            <tr><td><code>cross_fields</code></td><td>Treat fields as one big field</td><td>First name + last name</td></tr>
                            <tr><td><code>phrase</code></td><td>Run match_phrase on each field</td><td>Exact phrase search</td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Multi-match searches same query across multiple fields</li>
                        <li>&#10003; Use ^N for field boosting</li>
                        <li>&#10003; best_fields: uses highest scoring field</li>
                        <li>&#10003; cross_fields: treats all fields as one</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('match-phrase')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('query-string')">Next: Query String &#8594;</a>
            </div>
        `
    },
    'query-string': {
        title: 'Query String',
        category: 'Query DSL',
        difficulty: 'Intermediate',
        content: `
            <h1>Query String: Power User Search Syntax</h1>
            <p class="lesson-meta">
                <span class="category">Category: Query DSL</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Query String?</h2>
                <p>The <code>query_string</code> query parses a query text using Lucene query syntax. It supports field operators, boolean operators, wildcards, and more in a single query string. Think of it as the "power user" search query.</p>

                <div class="concept-box">
                    <h3>query_string vs match vs multi_match</h3>
                    <pre><code class="language-text">match query:
  Simple text search on a single field
  "blood count" searches in one field

multi_match query:
  Same text search across multiple fields
  "blood count" searches in testName, testAlias, etc.

query_string query:
  Full Lucene syntax with operators
  "testName:blood AND category:hematology"
  Supports AND, OR, NOT, wildcards, ranges, field targeting</code></pre>
                    <p>The <code>query_string</code> query is the most flexible but also the most error-prone if user input is not sanitized.</p>
                </div>

                <div class="info-box">
                    <h4>&#9888; Security Warning</h4>
                    <p>Never pass raw user input directly into a <code>query_string</code> query. Malformed syntax will throw errors. For user-facing search, prefer <code>simple_query_string</code> which never throws exceptions.</p>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic query_string Usage</h2>

                <div class="example-query">
                    <h4>Simple Query String</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "query_string": {
      "query": "blood count",
      "default_field": "testName"
    }
  }
}</code></pre>
                    <p>Searches for "blood" OR "count" in testName (default operator is OR)</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;blood count&quot;,&quot;default_field&quot;:&quot;testName&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>With Boolean Operators</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "query_string": {
      "query": "blood AND count",
      "default_field": "testName"
    }
  }
}</code></pre>
                    <p>Both "blood" AND "count" must appear in testName</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;blood AND count&quot;,&quot;default_field&quot;:&quot;testName&quot;}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Field-Specific Operators</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "query_string": {
      "query": "testName:blood AND consumerPrice:[100 TO 500]"
    }
  }
}</code></pre>
                    <p>Target specific fields inline: "blood" in testName AND price between 100-500</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;testName:blood AND consumerPrice:[100 TO 500]&quot;}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Lucene Query Syntax Reference</h2>

                <div class="concept-box">
                    <h3>Operators and Wildcards</h3>
                    <pre><code class="language-text">Boolean Operators:
  AND        Both terms must match        "blood AND count"
  OR         Either term matches          "blood OR liver"
  NOT        Exclude term                 "blood NOT glucose"
  +          Must include                 "+blood count"
  -          Must exclude                 "blood -glucose"

Wildcards:
  *          Any characters               "blo*"
  ?          Single character             "te?t"

Phrases:
  "..."      Exact phrase                 "blood count"
  "..."~N    Phrase with slop             "blood count"~2

Field Targeting:
  field:val  Search specific field        "testName:blood"
  field:(a OR b)  Group on a field        "category:(hematology OR biochemistry)"

Ranges:
  [A TO B]   Inclusive range              "consumerPrice:[100 TO 500]"
  {A TO B}   Exclusive range              "consumerPrice:{100 TO 500}"
  [A TO *]   Open-ended range             "consumerPrice:[100 TO *]"

Boosting:
  term^N     Boost a term                 "blood^3 count"

Grouping:
  (...)      Group expressions            "(blood OR liver) AND test"</code></pre>
                </div>

                <div class="example-query">
                    <h4>Wildcards in Query String</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "query_string": {
      "query": "testName:blo* AND category:hemat*",
      "analyze_wildcard": true
    }
  }
}</code></pre>
                    <p>Using wildcards with field targeting. Set <code>analyze_wildcard: true</code> to analyze wildcard terms.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;testName:blo*&quot;,&quot;analyze_wildcard&quot;:true}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Multi-Field with Default Operator</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "query_string": {
      "query": "complete blood count",
      "fields": ["testName^3", "testAlias", "testDescription"],
      "default_operator": "AND"
    }
  }
}</code></pre>
                    <p>Search multiple fields with AND as default operator. testName matches boosted 3x.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;query_string&quot;:{&quot;query&quot;:&quot;complete blood count&quot;,&quot;fields&quot;:[&quot;testName^3&quot;,&quot;testAlias&quot;,&quot;testDescription&quot;],&quot;default_operator&quot;:&quot;AND&quot;}}}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>simple_query_string: The Safe Alternative</h2>
                <p>The <code>simple_query_string</code> query uses a simpler syntax that never throws errors on invalid input. Perfect for user-facing search boxes.</p>

                <div class="concept-box">
                    <h3>Syntax Differences</h3>
                    <pre><code class="language-text">query_string          simple_query_string
─────────────────────────────────────────────
AND                   + (prefix)
OR                    | (default)
NOT                   - (prefix)
"phrase"              "phrase"
field:value           Not supported
[range TO range]      Not supported
Throws on errors      Never throws errors</code></pre>
                </div>

                <div class="example-query">
                    <h4>Simple Query String</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "simple_query_string": {
      "query": "blood + count -glucose",
      "fields": ["testName", "testAlias"],
      "default_operator": "AND"
    }
  }
}</code></pre>
                    <p>Must contain "blood" and "count", must not contain "glucose". Invalid syntax is silently ignored.</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;simple_query_string&quot;:{&quot;query&quot;:&quot;blood + count -glucose&quot;,&quot;fields&quot;:[&quot;testName&quot;,&quot;testAlias&quot;],&quot;default_operator&quot;:&quot;AND&quot;}}}')">Try it</button>
                </div>

                <div class="info-box">
                    <h4>&#128161; When to Use Which?</h4>
                    <p><strong>query_string:</strong> Internal tools, admin dashboards, power users who know Lucene syntax.</p>
                    <p><strong>simple_query_string:</strong> Public search bars, user-facing applications where invalid input should not cause errors.</p>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; query_string supports full Lucene syntax: AND, OR, NOT, field:value, ranges, wildcards</li>
                        <li>&#10003; Use default_field for single-field search or fields array for multi-field</li>
                        <li>&#10003; Wildcards (* and ?) work inline with analyze_wildcard option</li>
                        <li>&#10003; simple_query_string is the safe alternative that never throws parsing errors</li>
                        <li>&#10003; Always sanitize user input before using query_string, or use simple_query_string instead</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('multi-match')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('term-query')">Next: Term Query &#8594;</a>
            </div>
        `
    },
    'highlighting': {
        title: 'Highlighting',
        category: 'Advanced Search',
        difficulty: 'Intermediate',
        content: `
            <h1>Highlighting: Show Matching Text</h1>
            <p class="lesson-meta">
                <span class="category">Category: Advanced Search</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Highlighting?</h2>
                <p>Highlighting returns snippets of text from matching fields with the search terms wrapped in tags, helping users see why a document matched.</p>

                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #fcd34d;">
                    <h4 style="color: #92400e; margin-bottom: 1rem;">Highlighting Example</h4>
                    <div style="background: white; border-radius: 8px; padding: 1rem;">
                        <div style="font-size: 0.9rem; color: #475569;">Query: "blood count"</div>
                        <div style="margin-top: 0.75rem; font-size: 1rem;">
                            Complete <em style="background: #fef08a; padding: 0 4px; font-style: normal; font-weight: 600;">Blood</em> <em style="background: #fef08a; padding: 0 4px; font-style: normal; font-weight: 600;">Count</em> (CBC) Test
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Basic Highlighting</h2>

                <div class="example-query">
                    <h4>Simple Highlight</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "highlight": {
    "fields": {
      "testName": {}
    }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}},&quot;highlight&quot;:{&quot;fields&quot;:{&quot;testName&quot;:{}}}}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Custom Tags</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "highlight": {
    "pre_tags": ["<strong>"],
    "post_tags": ["</strong>"],
    "fields": {
      "testName": {}
    }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}},&quot;highlight&quot;:{&quot;pre_tags&quot;:[&quot;<strong>&quot;],&quot;post_tags&quot;:[&quot;</strong>&quot;],&quot;fields&quot;:{&quot;testName&quot;:{}}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Highlighting shows why documents matched</li>
                        <li>&#10003; Default tags are &lt;em&gt; tags</li>
                        <li>&#10003; Customize with pre_tags and post_tags</li>
                        <li>&#10003; Essential for search UX</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('nested-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('suggesters')">Next: Suggesters &#8594;</a>
            </div>
        `
    },
    'suggesters': {
        title: 'Suggesters',
        category: 'Advanced Search',
        difficulty: 'Intermediate',
        content: `
            <h1>Suggesters: Search Suggestions and Autocomplete</h1>
            <p class="lesson-meta">
                <span class="category">Category: Advanced Search</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>Types of Suggesters</h2>
                <div style="background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #d8b4fe;">
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #7c3aed; margin-bottom: 0.5rem;">Term Suggester</div>
                            <p style="font-size: 0.85rem; color: #475569; margin: 0;">Suggests corrections for misspelled terms based on edit distance</p>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #7c3aed; margin-bottom: 0.5rem;">Phrase Suggester</div>
                            <p style="font-size: 0.85rem; color: #475569; margin: 0;">Suggests corrections for entire phrases, considering word order</p>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #7c3aed; margin-bottom: 0.5rem;">Completion Suggester</div>
                            <p style="font-size: 0.85rem; color: #475569; margin: 0;">Optimized for autocomplete, extremely fast prefix-based suggestions</p>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Term Suggester</h2>
                <div class="example-query">
                    <h4>Spell Correction</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "suggest": {
    "test-suggest": {
      "text": "blod",
      "term": {
        "field": "testName"
      }
    }
  }
}</code></pre>
                    <p>Suggests "blood" for misspelled "blod"</p>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;suggest&quot;:{&quot;test-suggest&quot;:{&quot;text&quot;:&quot;blod&quot;,&quot;term&quot;:{&quot;field&quot;:&quot;testName&quot;}}}}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Term suggester: Spell correction for individual terms</li>
                        <li>&#10003; Phrase suggester: Correct entire phrases</li>
                        <li>&#10003; Completion suggester: Fast autocomplete</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('highlighting')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('terms-agg')">Next: Terms Aggregation &#8594;</a>
            </div>
        `
    },
    'api-basics': {
        title: 'API Basics',
        category: 'Fundamentals',
        difficulty: 'Beginner',
        content: `
            <h1>Elasticsearch REST API Basics</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>Understanding the REST API</h2>
                <p>Elasticsearch exposes all functionality through a RESTful API. Every operation uses HTTP requests with JSON.</p>

                <div style="background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #cbd5e1;">
                    <h4 style="color: #1e293b; margin-bottom: 1rem;">REST API Request Structure</h4>
                    <div style="background: white; border-radius: 8px; padding: 1rem; border-left: 4px solid #3b82f6;">
                        <div style="font-family: monospace; color: #1e40af; font-size: 0.95rem;">
                            <span style="background: #dbeafe; padding: 0.25rem 0.5rem; border-radius: 4px;">METHOD</span>
                            <span style="color: #64748b; margin: 0 0.5rem;">/</span>
                            <span style="background: #dcfce7; padding: 0.25rem 0.5rem; border-radius: 4px;">index</span>
                            <span style="color: #64748b; margin: 0 0.5rem;">/</span>
                            <span style="background: #fef3c7; padding: 0.25rem 0.5rem; border-radius: 4px;">_endpoint</span>
                        </div>
                    </div>
                </div>

                <div class="key-points">
                    <h3>HTTP Methods</h3>
                    <ul>
                        <li><strong>GET:</strong> Retrieve data (documents, mappings)</li>
                        <li><strong>POST:</strong> Create data or run queries</li>
                        <li><strong>PUT:</strong> Create or update with specific ID</li>
                        <li><strong>DELETE:</strong> Remove data</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Common Endpoints</h2>

                <div class="example-query">
                    <h4>Cluster Health</h4>
                    <pre><code class="language-http">GET /_cluster/health</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/_cluster/health', '')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>List Indices</h4>
                    <pre><code class="language-http">GET /_cat/indices?format=json</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/_cat/indices?format=json', '')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; ES uses RESTful HTTP API for all operations</li>
                        <li>&#10003; GET, POST, PUT, DELETE methods</li>
                        <li>&#10003; All data is JSON format</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('documents-indices')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('crud-operations')">Next: CRUD Operations &#8594;</a>
            </div>
        `
    },
    'crud-operations': {
        title: 'CRUD Operations',
        category: 'Fundamentals',
        difficulty: 'Beginner',
        content: `
            <h1>CRUD Operations in Elasticsearch</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>Create, Read, Update, Delete</h2>

                <div style="background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #fde047;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center; border: 2px solid #22c55e;">
                            <div style="font-size: 1.5rem;">C</div>
                            <div style="font-weight: 600; color: #166534;">CREATE</div>
                            <div style="font-family: monospace; font-size: 0.75rem; color: #475569;">POST /_doc</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center; border: 2px solid #3b82f6;">
                            <div style="font-size: 1.5rem;">R</div>
                            <div style="font-weight: 600; color: #1e40af;">READ</div>
                            <div style="font-family: monospace; font-size: 0.75rem; color: #475569;">GET /_doc/id</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center; border: 2px solid #f59e0b;">
                            <div style="font-size: 1.5rem;">U</div>
                            <div style="font-weight: 600; color: #b45309;">UPDATE</div>
                            <div style="font-family: monospace; font-size: 0.75rem; color: #475569;">POST /_update/id</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center; border: 2px solid #ef4444;">
                            <div style="font-size: 1.5rem;">D</div>
                            <div style="font-weight: 600; color: #dc2626;">DELETE</div>
                            <div style="font-family: monospace; font-size: 0.75rem; color: #475569;">DELETE /_doc/id</div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Examples</h2>

                <div class="example-query">
                    <h4>Create Document</h4>
                    <pre><code class="language-json">POST /tests/_doc
{
  "testName": "New Test",
  "consumerPrice": 299
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_doc', '{&quot;testName&quot;:&quot;New Test&quot;,&quot;consumerPrice&quot;:299}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Read Document</h4>
                    <pre><code class="language-json">GET /tests/_doc/40</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/tests/_doc/40', '')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; POST /_doc: Create with auto-ID</li>
                        <li>&#10003; GET /_doc/id: Retrieve document</li>
                        <li>&#10003; POST /_update/id: Partial update</li>
                        <li>&#10003; DELETE /_doc/id: Remove document</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('api-basics')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('bulk-api')">Next: Bulk API &#8594;</a>
            </div>
        `
    },
    'bulk-api': {
        title: 'Bulk API',
        category: 'Fundamentals',
        difficulty: 'Intermediate',
        content: `
            <h1>Bulk API: High-Performance Batch Operations</h1>
            <p class="lesson-meta">
                <span class="category">Category: Fundamentals</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>Why Bulk API?</h2>
                <p>Perform multiple operations in a single request for dramatically better performance.</p>

                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #86efac;">
                    <h4 style="color: #166534; margin-bottom: 1rem;">Performance: Single vs Bulk</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem; border: 2px solid #fca5a5;">
                            <div style="font-weight: 600; color: #dc2626;">Single (1000 docs)</div>
                            <div style="color: #475569;">1000 requests → ~60 seconds</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; border: 2px solid #86efac;">
                            <div style="font-weight: 600; color: #16a34a;">Bulk (1000 docs)</div>
                            <div style="color: #475569;">1-2 requests → ~2 seconds</div>
                        </div>
                    </div>
                </div>

                <div class="concept-box">
                    <h3>NDJSON Format</h3>
                    <pre><code class="language-json">{"index":{"_index":"tests","_id":"1"}}
{"testName":"Test 1","price":100}
{"index":{"_index":"tests","_id":"2"}}
{"testName":"Test 2","price":200}</code></pre>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Bulk API dramatically improves indexing speed</li>
                        <li>&#10003; Uses NDJSON format (action + optional body)</li>
                        <li>&#10003; Target 500-5000 docs per request</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('crud-operations')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('mapping-basics')">Next: Mapping Basics &#8594;</a>
            </div>
        `
    },
    'mapping-basics': {
        title: 'Mapping Basics',
        category: 'Indexing & Mappings',
        difficulty: 'Beginner',
        content: `
            <h1>Mapping Basics</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Beginner</span>
            </p>

            <section class="lesson-section">
                <h2>What is a Mapping?</h2>
                <p>A mapping defines how a document and its fields are stored and indexed. It is like a schema definition in a relational database, telling Elasticsearch the data type of each field and how it should be indexed.</p>

                <div class="concept-box">
                    <h3>Explicit vs Dynamic Mapping</h3>
                    <p><strong>Dynamic Mapping:</strong> Elasticsearch automatically detects and adds new fields when it encounters them in a document.</p>
                    <p><strong>Explicit Mapping:</strong> You define fields and their types upfront before indexing data. This gives you full control.</p>
                    <pre><code class="language-json">// View the current mapping of an index
GET /tests/_mapping</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Creating an Explicit Mapping</h2>
                <div class="example-query">
                    <h4>Define Mapping at Index Creation</h4>
                    <pre><code class="language-json">PUT /my_tests
{
  "mappings": {
    "properties": {
      "testName": {
        "type": "text",
        "analyzer": "standard"
      },
      "testAlias": {
        "type": "text"
      },
      "consumerPrice": {
        "type": "float"
      },
      "frequency": {
        "type": "integer"
      },
      "category": {
        "type": "keyword"
      },
      "isActive": {
        "type": "boolean"
      }
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>View Existing Mapping</h3>
                    <pre><code class="language-json">GET /tests/_mapping</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'GET', '/tests/_mapping', '')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Adding Fields to Existing Mapping</h2>
                <p>You can add new fields to an existing mapping, but you cannot change the type of an existing field. To change a field type, you must reindex your data.</p>
                <div class="example-query">
                    <h4>Add a New Field</h4>
                    <pre><code class="language-json">PUT /tests/_mapping
{
  "properties": {
    "newField": {
      "type": "keyword"
    }
  }
}</code></pre>
                </div>

                <div class="key-points">
                    <h3>Key Rules</h3>
                    <ul>
                        <li>You <strong>cannot</strong> change the mapping of an existing field</li>
                        <li>You <strong>can</strong> add new fields to an existing mapping</li>
                        <li>To change a field type, you must create a new index and reindex</li>
                        <li>Mappings are defined per-index, not globally</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Mappings define field types and how data is indexed</li>
                        <li>&#10003; Dynamic mapping auto-detects types; explicit mapping gives control</li>
                        <li>&#10003; Existing field types cannot be changed without reindexing</li>
                        <li>&#10003; Use GET /index/_mapping to inspect mappings</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('bulk-api')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('field-types')">Next: Field Types &#8594;</a>
            </div>
        `
    },
    'field-types': {
        title: 'Field Types',
        category: 'Indexing & Mappings',
        difficulty: 'Intermediate',
        content: `
            <h1>Field Types in Elasticsearch</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>Core Field Types</h2>

                <div class="concept-box">
                    <h3>text vs keyword</h3>
                    <p><strong>text:</strong> Analyzed for full-text search. The value is broken into tokens. Use for fields users will search with natural language (e.g., testName, testDescription).</p>
                    <p><strong>keyword:</strong> Not analyzed. Stored as-is for exact matching, sorting, and aggregations (e.g., category, status).</p>
                    <pre><code class="language-json">{
  "testName": { "type": "text" },
  "category": { "type": "keyword" }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Numeric Types</h3>
                    <p>Elasticsearch supports several numeric types optimized for different ranges:</p>
                    <pre><code class="language-json">{
  "frequency": { "type": "integer" },
  "consumerPrice": { "type": "float" },
  "totalRevenue": { "type": "long" },
  "preciseValue": { "type": "double" },
  "smallCount": { "type": "short" },
  "tinyFlag": { "type": "byte" }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Other Important Types</h2>

                <div class="concept-box">
                    <h3>date</h3>
                    <p>Stores dates internally as milliseconds since epoch. Supports multiple formats.</p>
                    <pre><code class="language-json">{
  "createdAt": {
    "type": "date",
    "format": "yyyy-MM-dd||epoch_millis"
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>boolean</h3>
                    <p>Accepts true/false, "true"/"false", and ""(empty string = false).</p>
                    <pre><code class="language-json">{
  "isActive": { "type": "boolean" }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>object and nested</h3>
                    <p><strong>object:</strong> Default for JSON objects. Fields are flattened internally, which can cause cross-object matching issues in arrays.</p>
                    <p><strong>nested:</strong> Like object but maintains the independence of each object in an array. Requires special nested queries.</p>
                    <pre><code class="language-json">{
  "address": { "type": "object" },
  "components": { "type": "nested" }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>geo_point</h3>
                    <p>Stores latitude/longitude pairs for geo queries.</p>
                    <pre><code class="language-json">{
  "location": { "type": "geo_point" }
}
// Document: { "location": { "lat": 28.6, "lon": 77.2 } }</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; text for full-text search, keyword for exact match/sorting/aggregations</li>
                        <li>&#10003; Use integer/float/long for numbers based on range needs</li>
                        <li>&#10003; date fields store as epoch millis with configurable formats</li>
                        <li>&#10003; Use nested (not object) when arrays of objects need independent querying</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('mapping-basics')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('dynamic-mapping')">Next: Dynamic Mapping &#8594;</a>
            </div>
        `
    },
    'dynamic-mapping': {
        title: 'Dynamic Mapping',
        category: 'Indexing & Mappings',
        difficulty: 'Intermediate',
        content: `
            <h1>Dynamic Mapping</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>How Dynamic Mapping Works</h2>
                <p>When you index a document with a field Elasticsearch hasn't seen before, it automatically detects the type and adds it to the mapping. This is dynamic mapping.</p>

                <div class="concept-box">
                    <h3>Type Detection Rules</h3>
                    <pre><code class="language-text">JSON Value          Detected ES Type
────────────────────────────────────
true / false        boolean
123                 long
1.23                float
"2024-01-15"        date (if date detection on)
"hello world"       text + keyword sub-field
{ "a": 1 }          object
[1, 2, 3]           long (arrays use element type)</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Controlling Dynamic Behavior</h2>
                <p>The <code>dynamic</code> setting controls what happens when new fields are found:</p>

                <div class="concept-box">
                    <h3>Dynamic Settings</h3>
                    <pre><code class="language-json">PUT /strict_index
{
  "mappings": {
    "dynamic": "strict",
    "properties": {
      "testName": { "type": "text" }
    }
  }
}

// dynamic: true    → Auto-add new fields (default)
// dynamic: false   → Ignore new fields (not indexed, still in _source)
// dynamic: "strict" → Reject documents with unknown fields</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Dynamic Templates</h3>
                    <p>Define rules for how dynamically detected fields should be mapped:</p>
                    <pre><code class="language-json">PUT /my_index
{
  "mappings": {
    "dynamic_templates": [
      {
        "strings_as_keywords": {
          "match_mapping_type": "string",
          "mapping": {
            "type": "keyword"
          }
        }
      },
      {
        "longs_as_integers": {
          "match_mapping_type": "long",
          "mapping": {
            "type": "integer"
          }
        }
      }
    ]
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Date Detection</h2>
                <div class="concept-box">
                    <h3>Disable Date Detection</h3>
                    <p>By default, strings that look like dates are mapped as date fields. You can disable this:</p>
                    <pre><code class="language-json">PUT /my_index
{
  "mappings": {
    "date_detection": false
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Dynamic mapping auto-detects field types from JSON values</li>
                        <li>&#10003; Use dynamic: "strict" in production to prevent mapping explosion</li>
                        <li>&#10003; Dynamic templates let you customize how new fields are mapped</li>
                        <li>&#10003; Date detection can be disabled to prevent unwanted date fields</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('field-types')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('multi-fields')">Next: Multi-Fields &#8594;</a>
            </div>
        `
    },
    'multi-fields': {
        title: 'Multi-Fields',
        category: 'Indexing & Mappings',
        difficulty: 'Intermediate',
        content: `
            <h1>Multi-Fields</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What are Multi-Fields?</h2>
                <p>Multi-fields let you index the same field in different ways for different purposes. A common pattern is indexing a string as both <code>text</code> (for full-text search) and <code>keyword</code> (for sorting and aggregations).</p>

                <div class="concept-box">
                    <h3>The fields Property</h3>
                    <pre><code class="language-json">PUT /healthcare
{
  "mappings": {
    "properties": {
      "testName": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          },
          "autocomplete": {
            "type": "text",
            "analyzer": "edge_ngram_analyzer"
          }
        }
      }
    }
  }
}

// Access as:
// testName        → full-text search
// testName.keyword → exact match, sorting, aggregations
// testName.autocomplete → autocomplete search</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Using Multi-Fields in Queries</h2>
                <div class="example-query">
                    <h4>Full-text search on testName</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": { "testName": "blood count" }
  }
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood count&quot;}},&quot;size&quot;:5}')">Try it</button>
                </div>

                <div class="example-query">
                    <h4>Sort by testName.keyword</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": { "match_all": {} },
  "sort": [
    { "testName.keyword": "asc" }
  ],
  "size": 5
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match_all&quot;:{}},&quot;sort&quot;:[{&quot;testName.keyword&quot;:&quot;asc&quot;}],&quot;size&quot;:5}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Multi-fields index the same data in multiple ways</li>
                        <li>&#10003; Common pattern: text + keyword sub-field</li>
                        <li>&#10003; Access sub-fields using dot notation (field.subfield)</li>
                        <li>&#10003; No additional storage overhead for the source data</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('dynamic-mapping')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('analyzers')">Next: Analyzers &#8594;</a>
            </div>
        `
    },
    'tokenizers': {
        title: 'Tokenizers',
        category: 'Indexing & Mappings',
        difficulty: 'Intermediate',
        content: `
            <h1>Tokenizers</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is a Tokenizer?</h2>
                <p>A tokenizer breaks text into individual tokens (words/terms). It is the core component of an analyzer, sitting between optional character filters and token filters.</p>

                <div class="concept-box">
                    <h3>Standard Tokenizer</h3>
                    <p>The default tokenizer. Splits on word boundaries (Unicode text segmentation), removes most punctuation.</p>
                    <pre><code class="language-text">Input:  "Complete Blood Count (CBC) - Rs.350"
Tokens: ["Complete", "Blood", "Count", "CBC", "Rs.350"]</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Whitespace Tokenizer</h3>
                    <p>Splits text only on whitespace characters. Preserves punctuation.</p>
                    <pre><code class="language-text">Input:  "Complete Blood Count (CBC)"
Tokens: ["Complete", "Blood", "Count", "(CBC)"]</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Keyword Tokenizer</h3>
                    <p>No-op tokenizer that keeps the entire input as a single token. Used when you want token filters without splitting.</p>
                    <pre><code class="language-text">Input:  "Complete Blood Count"
Tokens: ["Complete Blood Count"]</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>N-gram Tokenizers</h2>

                <div class="concept-box">
                    <h3>N-gram Tokenizer</h3>
                    <p>Produces sliding window tokens of specified length. Useful for substring matching.</p>
                    <pre><code class="language-text">Input:  "blood" (min_gram=3, max_gram=4)
Tokens: ["blo", "bloo", "loo", "lood", "ood"]</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Edge N-gram Tokenizer</h3>
                    <p>Like n-gram but only from the beginning of each token. Ideal for autocomplete.</p>
                    <pre><code class="language-text">Input:  "blood" (min_gram=2, max_gram=5)
Tokens: ["bl", "blo", "bloo", "blood"]</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Testing Tokenizers</h2>
                <div class="example-query">
                    <h4>Test with _analyze API</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "tokenizer": "standard",
  "text": "Complete Blood Count (CBC)"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;tokenizer&quot;:&quot;standard&quot;,&quot;text&quot;:&quot;Complete Blood Count (CBC)&quot;}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Tokenizers break text into individual tokens</li>
                        <li>&#10003; standard: splits on word boundaries (most common)</li>
                        <li>&#10003; keyword: keeps entire input as single token</li>
                        <li>&#10003; Edge n-gram: produces prefix tokens for autocomplete</li>
                        <li>&#10003; Use _analyze API to test how text gets tokenized</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('analyzers')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('filters')">Next: Token Filters &#8594;</a>
            </div>
        `
    },
    'filters': {
        title: 'Token Filters',
        category: 'Indexing & Mappings',
        difficulty: 'Intermediate',
        content: `
            <h1>Token Filters</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What are Token Filters?</h2>
                <p>Token filters process the stream of tokens produced by a tokenizer. They can modify, add, or remove tokens. Multiple filters can be chained together.</p>

                <div class="concept-box">
                    <h3>lowercase</h3>
                    <p>Converts all tokens to lowercase. Essential for case-insensitive search.</p>
                    <pre><code class="language-text">Input tokens:  ["Complete", "Blood", "Count"]
Output tokens: ["complete", "blood", "count"]</code></pre>
                </div>

                <div class="concept-box">
                    <h3>stop</h3>
                    <p>Removes common words (stop words) like "the", "is", "at", "which".</p>
                    <pre><code class="language-text">Input tokens:  ["this", "is", "a", "blood", "test"]
Output tokens: ["blood", "test"]</code></pre>
                </div>

                <div class="concept-box">
                    <h3>stemmer</h3>
                    <p>Reduces words to their root form. "running" becomes "run", "tests" becomes "test".</p>
                    <pre><code class="language-text">Input tokens:  ["testing", "blood", "counts"]
Output tokens: ["test", "blood", "count"]</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>More Useful Filters</h2>

                <div class="concept-box">
                    <h3>synonym</h3>
                    <p>Expands or replaces tokens with synonyms.</p>
                    <pre><code class="language-json">{
  "filter": {
    "medical_synonyms": {
      "type": "synonym",
      "synonyms": [
        "CBC, Complete Blood Count",
        "ECG, EKG, Electrocardiogram"
      ]
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>ascii_folding</h3>
                    <p>Converts Unicode characters to ASCII equivalents. "cafe\u0301" becomes "cafe".</p>
                </div>

                <div class="concept-box">
                    <h3>word_delimiter</h3>
                    <p>Splits tokens on case transitions, non-alphanumeric characters, etc.</p>
                    <pre><code class="language-text">Input:  "Wi-Fi" → ["Wi", "Fi"]
Input:  "PowerShot" → ["Power", "Shot"]</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Testing Filters</h2>
                <div class="example-query">
                    <h4>Test lowercase + stemmer</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "tokenizer": "standard",
  "filter": ["lowercase", "stemmer"],
  "text": "Blood Tests and Testing"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;tokenizer&quot;:&quot;standard&quot;,&quot;filter&quot;:[&quot;lowercase&quot;,&quot;stemmer&quot;],&quot;text&quot;:&quot;Blood Tests and Testing&quot;}')">Try it</button>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Token filters modify tokens after tokenization</li>
                        <li>&#10003; lowercase: case-insensitive search</li>
                        <li>&#10003; stemmer: matches word variations (test/tests/testing)</li>
                        <li>&#10003; synonym: expands medical abbreviations like CBC</li>
                        <li>&#10003; Filters are applied in order and can be chained</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('tokenizers')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('custom-analyzers')">Next: Custom Analyzers &#8594;</a>
            </div>
        `
    },
    'custom-analyzers': {
        title: 'Custom Analyzers',
        category: 'Indexing & Mappings',
        difficulty: 'Advanced',
        content: `
            <h1>Custom Analyzers</h1>
            <p class="lesson-meta">
                <span class="category">Category: Indexing &amp; Mappings</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>Anatomy of an Analyzer</h2>
                <p>An analyzer consists of three components applied in order:</p>
                <div class="concept-box">
                    <h3>Analysis Pipeline</h3>
                    <pre><code class="language-text">Character Filters → Tokenizer → Token Filters

1. Character Filters: Transform raw text before tokenization
   Example: html_strip removes HTML tags

2. Tokenizer: Breaks text into tokens
   Example: standard splits on word boundaries

3. Token Filters: Modify the token stream
   Example: lowercase, stemmer, synonyms</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Creating a Custom Analyzer</h2>
                <div class="example-query">
                    <h4>Medical Test Analyzer</h4>
                    <pre><code class="language-json">PUT /medical_tests
{
  "settings": {
    "analysis": {
      "char_filter": {
        "remove_special": {
          "type": "pattern_replace",
          "pattern": "[^a-zA-Z0-9\\\\s]",
          "replacement": " "
        }
      },
      "tokenizer": {
        "edge_ngram_tokenizer": {
          "type": "edge_ngram",
          "min_gram": 2,
          "max_gram": 15,
          "token_chars": ["letter", "digit"]
        }
      },
      "filter": {
        "medical_synonyms": {
          "type": "synonym",
          "synonyms": [
            "CBC, Complete Blood Count",
            "TSH, Thyroid Stimulating Hormone"
          ]
        }
      },
      "analyzer": {
        "medical_autocomplete": {
          "type": "custom",
          "char_filter": ["remove_special"],
          "tokenizer": "edge_ngram_tokenizer",
          "filter": ["lowercase", "medical_synonyms"]
        },
        "medical_search": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": ["lowercase", "medical_synonyms"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "testName": {
        "type": "text",
        "analyzer": "medical_autocomplete",
        "search_analyzer": "medical_search"
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Testing Your Analyzer</h2>
                <div class="example-query">
                    <h4>Test with _analyze API</h4>
                    <pre><code class="language-json">POST /_analyze
{
  "analyzer": "standard",
  "text": "Complete Blood Count (CBC) Test"
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/_analyze', '{&quot;analyzer&quot;:&quot;standard&quot;,&quot;text&quot;:&quot;Complete Blood Count (CBC) Test&quot;}')">Try it</button>
                </div>

                <div class="key-points">
                    <h3>Best Practices</h3>
                    <ul>
                        <li>Use different analyzers for index-time and search-time (search_analyzer)</li>
                        <li>Test your analyzer with _analyze before applying to production</li>
                        <li>Use edge_ngram for autocomplete, standard for normal search</li>
                        <li>Add synonyms specific to your domain (medical terms, abbreviations)</li>
                    </ul>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Custom analyzers = char filters + tokenizer + token filters</li>
                        <li>&#10003; Define in index settings under analysis</li>
                        <li>&#10003; Use search_analyzer for different index vs query analysis</li>
                        <li>&#10003; Test with POST /_analyze before production use</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('filters')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('match-query')">Next: Match Query &#8594;</a>
            </div>
        `
    },
    'nested-query': {
        title: 'Nested Queries',
        category: 'Advanced Search',
        difficulty: 'Advanced',
        content: `
            <h1>Nested Queries: Querying Nested Objects</h1>
            <p class="lesson-meta">
                <span class="category">Category: Advanced Search</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>What are Nested Objects?</h2>
                <p>Nested objects allow you to index arrays of objects and query them independently, maintaining their relationships.</p>

                <div style="background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #fca5a5;">
                    <h4 style="color: #991b1b; margin-bottom: 1rem;">The Problem with Object Arrays</h4>
                    <div style="background: white; border-radius: 8px; padding: 1rem;">
                        <pre style="margin: 0;"><code>{
  "name": "Lab Package",
  "tests": [
    { "name": "CBC", "price": 200 },
    { "name": "Lipid", "price": 500 }
  ]
}</code></pre>
                        <p style="margin-top: 1rem; color: #dc2626;">Without nested: ES flattens to tests.name: ["CBC", "Lipid"], tests.price: [200, 500] - cross-object matching breaks!</p>
                    </div>
                </div>

                <div class="concept-box">
                    <h3>Nested Mapping</h3>
                    <pre><code class="language-json">{
  "mappings": {
    "properties": {
      "tests": {
        "type": "nested",
        "properties": {
          "name": { "type": "text" },
          "price": { "type": "integer" }
        }
      }
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Nested Query Syntax</h2>
                <div class="concept-box">
                    <h3>Query Nested Objects</h3>
                    <pre><code class="language-json">POST /packages/_search
{
  "query": {
    "nested": {
      "path": "tests",
      "query": {
        "bool": {
          "must": [
            { "match": { "tests.name": "CBC" } },
            { "range": { "tests.price": { "lt": 300 } } }
          ]
        }
      }
    }
  }
}</code></pre>
                    <p style="margin-top: 1rem;">Finds packages with a test named "CBC" that costs less than 300 (same nested object).</p>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Nested type preserves object array relationships</li>
                        <li>&#10003; Must use nested query to search nested fields</li>
                        <li>&#10003; Each nested doc is indexed separately (impacts performance)</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('fuzzy-query')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('highlighting')">Next: Highlighting &#8594;</a>
            </div>
        `
    },
    'relevance-scoring': {
        title: 'Relevance Scoring',
        category: 'Scoring & Relevance',
        difficulty: 'Intermediate',
        content: `
            <h1>Relevance Scoring: How ES Ranks Results</h1>
            <p class="lesson-meta">
                <span class="category">Category: Scoring & Relevance</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>What is Relevance Scoring?</h2>
                <p>Elasticsearch calculates a _score for each matching document indicating how well it matches the query.</p>

                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #fcd34d;">
                    <h4 style="color: #92400e; margin-bottom: 1rem;">BM25 Scoring Factors</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center;">
                            <div style="font-weight: 600; color: #1e40af;">TF</div>
                            <div style="font-size: 0.85rem; color: #475569;">Term Frequency</div>
                            <div style="font-size: 0.75rem; color: #6b7280;">More occurrences = higher score</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center;">
                            <div style="font-weight: 600; color: #7c3aed;">IDF</div>
                            <div style="font-size: 0.85rem; color: #475569;">Inverse Doc Freq</div>
                            <div style="font-size: 0.75rem; color: #6b7280;">Rare terms = higher score</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem; text-align: center;">
                            <div style="font-weight: 600; color: #059669;">Field Length</div>
                            <div style="font-size: 0.85rem; color: #475569;">Normalization</div>
                            <div style="font-size: 0.75rem; color: #6b7280;">Shorter fields = higher score</div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Score Explanation</h2>
                <div class="example-query">
                    <h4>Search with Score</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "_source": ["testName"],
  "explain": false
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;match&quot;:{&quot;testName&quot;:&quot;blood&quot;}},&quot;_source&quot;:[&quot;testName&quot;],&quot;size&quot;:5}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; _score indicates match quality</li>
                        <li>&#10003; BM25 considers TF, IDF, and field length</li>
                        <li>&#10003; Use explain: true to debug scoring</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('terms-agg')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('tf-idf')">Next: TF-IDF & BM25 &#8594;</a>
            </div>
        `
    },
    'autocomplete': {
        title: 'Autocomplete',
        category: 'Complex Queries',
        difficulty: 'Advanced',
        content: `
            <h1>Autocomplete: Search-As-You-Type</h1>
            <p class="lesson-meta">
                <span class="category">Category: Complex Queries</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>Autocomplete Strategies</h2>

                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0; border: 1px solid #86efac;">
                    <h4 style="color: #166534; margin-bottom: 1rem;">Three Approaches</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #166534;">Prefix Query</div>
                            <div style="font-size: 0.85rem; color: #475569;">Simple but slow</div>
                            <div style="font-size: 0.75rem; color: #6b7280;">Good for small data</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #7c3aed;">Edge N-gram</div>
                            <div style="font-size: 0.85rem; color: #475569;">Fast, pre-indexed</div>
                            <div style="font-size: 0.75rem; color: #6b7280;">Best for most cases</div>
                        </div>
                        <div style="background: white; border-radius: 8px; padding: 1rem;">
                            <div style="font-weight: 600; color: #ea580c;">Completion</div>
                            <div style="font-size: 0.85rem; color: #475569;">Fastest (FST)</div>
                            <div style="font-size: 0.75rem; color: #6b7280;">Special field type</div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Edge N-gram Approach</h2>
                <div class="concept-box">
                    <h3>How Edge N-gram Works</h3>
                    <pre><code class="language-text">Input: "blood"

Edge N-grams (min=1, max=10):
"b" → "bl" → "blo" → "bloo" → "blood"

Search "blo" matches because "blo" is indexed!</code></pre>
                </div>

                <div class="example-query">
                    <h4>Prefix Search (Simple)</h4>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "prefix": {
      "testName": "blo"
    }
  },
  "size": 5
}</code></pre>
                    <button class="btn btn-sm btn-primary" onclick="runESExample(this, 'POST', '/tests/_search', '{&quot;query&quot;:{&quot;prefix&quot;:{&quot;testName&quot;:&quot;blo&quot;}},&quot;size&quot;:5}')">Try it</button>
                </div>
            </section>

            <div class="query-result-container" id="query-result" style="display:none;">
                <h4>Result:</h4>
                <pre id="query-result-content"></pre>
            </div>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Edge n-gram: Best balance of speed and flexibility</li>
                        <li>&#10003; Completion suggester: Fastest for simple cases</li>
                        <li>&#10003; Index time vs query time trade-off</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('faceted-search')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('geo-queries')">Next: Geo Queries &#8594;</a>
            </div>
        `
    },
    'tf-idf': {
        title: 'TF-IDF &amp; BM25',
        category: 'Scoring &amp; Relevance',
        difficulty: 'Advanced',
        content: `
            <h1>TF-IDF &amp; BM25: The Math Behind Search Scoring</h1>
            <p class="lesson-meta">
                <span class="category">Category: Scoring &amp; Relevance</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>Understanding TF-IDF</h2>
                <p>TF-IDF (Term Frequency-Inverse Document Frequency) is the foundational scoring algorithm for information retrieval. Elasticsearch used TF-IDF in earlier versions before switching to BM25 as the default in version 5.0. Understanding TF-IDF is essential to grasp how BM25 improves upon it.</p>

                <div class="concept-box">
                    <h3>Term Frequency (TF)</h3>
                    <p>Term Frequency measures how often a term appears in a document. The more times a search term appears, the more relevant that document is considered. In classic TF-IDF, TF is often calculated as the square root of the raw count.</p>
                    <pre><code class="language-json">// Example: searching for "blood" in the tests index
// Document A testDescription: "blood test for blood sugar and blood pressure"
//   TF("blood") = sqrt(3) = 1.73  (appears 3 times)
//
// Document B testDescription: "blood test for infection"
//   TF("blood") = sqrt(1) = 1.0   (appears 1 time)
//
// Document A scores higher on TF because "blood" appears more often</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Inverse Document Frequency (IDF)</h3>
                    <p>IDF measures how rare or common a term is across all documents. Rare terms are more important for distinguishing documents, so they get a higher weight. Common terms like "test" that appear in almost every document get a lower IDF score.</p>
                    <pre><code class="language-json">// IDF formula: log(1 + (N - df + 0.5) / (df + 0.5))
// where N = total documents, df = documents containing the term
//
// Suppose our tests index has 500 documents:
//   "test" appears in 480 documents
//   IDF("test") = log(1 + (500 - 480 + 0.5) / (480 + 0.5)) = very low
//
//   "hemoglobin" appears in 12 documents
//   IDF("hemoglobin") = log(1 + (500 - 12 + 0.5) / (12 + 0.5)) = high
//
// Searching for "hemoglobin test":
//   "hemoglobin" contributes much more to the score than "test"</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Field Length Normalization</h3>
                    <p>Shorter fields are considered more relevant when they contain a matching term. A match in a short testName field is more significant than the same match in a long testDescription field.</p>
                    <pre><code class="language-json">// Field length normalization example:
// Document A testName: "CBC" (1 token)
//   Match on "CBC" in a 1-token field = very high norm
//
// Document B testDescription: "The CBC test is a complete blood count
//   that measures red blood cells white blood cells..." (30+ tokens)
//   Match on "CBC" in a 30-token field = lower norm
//
// Document A ranks higher because the match is in a shorter field</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>BM25: The Modern Algorithm</h2>
                <p>BM25 (Best Matching 25) is the default scoring algorithm in Elasticsearch. It builds upon TF-IDF but introduces saturation for term frequency and configurable parameters to fine-tune relevance.</p>

                <div class="concept-box">
                    <h3>BM25 Formula and Parameters</h3>
                    <p>BM25 introduces two key parameters: <strong>k1</strong> controls term frequency saturation, and <strong>b</strong> controls field length normalization. The key innovation is that TF has a diminishing returns curve - a term appearing 10 times is not 10x more relevant than appearing once.</p>
                    <pre><code class="language-json">// BM25 score = IDF * (tf * (k1 + 1)) / (tf + k1 * (1 - b + b * (dl / avgdl)))
//
// Parameters:
//   k1 (default: 1.2) - Term frequency saturation
//     k1 = 0   : TF is completely ignored (binary model)
//     k1 = 1.2 : Default, good balance
//     k1 = 2.0 : TF matters more, slower saturation
//
//   b (default: 0.75) - Field length normalization
//     b = 0 : No length normalization
//     b = 1 : Full length normalization
//
//   dl = document length (number of terms in the field)
//   avgdl = average document length across all documents</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Customizing BM25 Parameters</h3>
                    <p>You can customize k1 and b at index creation time for specific use cases. For healthcare test data, you might want different settings depending on field characteristics.</p>
                    <pre><code class="language-json">PUT /tests
{
  "settings": {
    "index": {
      "similarity": {
        "custom_bm25": {
          "type": "BM25",
          "k1": 1.5,
          "b": 0.5
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "testName": {
        "type": "text",
        "similarity": "custom_bm25"
      },
      "testDescription": {
        "type": "text"
      }
    }
  }
}

// Lower b (0.5 vs default 0.75) for testName:
//   testName fields are mostly short, so less
//   normalization prevents penalizing slightly longer names
//
// Higher k1 (1.5 vs default 1.2) for testName:
//   Repeated terms in test names are more meaningful</code></pre>
                </div>

                <div class="concept-box">
                    <h3>BM25 vs TF-IDF: Key Differences</h3>
                    <p>BM25 handles edge cases better than classic TF-IDF, particularly for term frequency saturation.</p>
                    <pre><code class="language-json">// TF-IDF: TF = sqrt(termFreq) - grows without bound
// BM25:   TF saturates - adding more occurrences has diminishing returns
//
// Example with "blood" appearing N times:
//   N=1:  TF-IDF=1.0,  BM25=0.55
//   N=5:  TF-IDF=2.24, BM25=0.88
//   N=10: TF-IDF=3.16, BM25=0.94
//   N=50: TF-IDF=7.07, BM25=0.99
//
// BM25 saturates near 1.0, preventing term-stuffing from
// artificially inflating scores. TF-IDF keeps growing.
//
// Verify scoring with the Explain API:
POST /tests/_search
{
  "explain": true,
  "query": {
    "match": { "testName": "blood" }
  },
  "size": 3
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; TF-IDF combines term frequency and inverse document frequency to score documents</li>
                        <li>&#10003; BM25 improves on TF-IDF with term frequency saturation and tunable parameters</li>
                        <li>&#10003; k1 (default 1.2) controls how quickly TF saturates; b (default 0.75) controls length normalization</li>
                        <li>&#10003; IDF gives higher weight to rare terms like "hemoglobin" vs common terms like "test"</li>
                        <li>&#10003; BM25 is the default similarity algorithm in Elasticsearch since version 5.0</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('relevance-scoring')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('explain-api')">Next: Explain API &#8594;</a>
            </div>
        `
    },
    'explain-api': {
        title: 'Explain API',
        category: 'Scoring &amp; Relevance',
        difficulty: 'Intermediate',
        content: `
            <h1>Explain API: Debugging Search Relevance</h1>
            <p class="lesson-meta">
                <span class="category">Category: Scoring &amp; Relevance</span>
                <span class="difficulty">Difficulty: Intermediate</span>
            </p>

            <section class="lesson-section">
                <h2>The _explain Endpoint</h2>
                <p>The Explain API tells you exactly why a specific document matched (or did not match) a query and how its score was calculated. This is an essential debugging tool when search results are not ranked as expected.</p>

                <div class="concept-box">
                    <h3>Basic _explain Usage</h3>
                    <p>The _explain endpoint takes a document ID and a query, then returns a detailed breakdown of the scoring calculation for that specific document.</p>
                    <pre><code class="language-json">// Explain why document 40 matches a query for "blood count"
POST /tests/_explain/40
{
  "query": {
    "match": {
      "testName": "blood count"
    }
  }
}

// Response structure:
{
  "_index": "tests",
  "_id": "40",
  "matched": true,
  "explanation": {
    "value": 8.52,
    "description": "sum of:",
    "details": [
      {
        "value": 4.21,
        "description": "weight(testName:blood ...)",
        "details": [...]
      },
      {
        "value": 4.31,
        "description": "weight(testName:count ...)",
        "details": [...]
      }
    ]
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Reading the Explain Output</h3>
                    <p>The explain output is a tree structure. Each node has a value, a description, and optional child details. Understanding this tree is the key to debugging relevance.</p>
                    <pre><code class="language-json">// Detailed explanation breakdown for a BM25 match:
{
  "value": 4.21,
  "description": "weight(testName:blood in 0) [PerFieldSimilarity]",
  "details": [
    {
      "value": 4.21,
      "description": "score(freq=1.0), computed as boost * idf * tf from:",
      "details": [
        {
          "value": 2.2,
          "description": "boost"
        },
        {
          "value": 3.45,
          "description": "idf, computed as log(1 + (N - n + 0.5) / (n + 0.5))",
          "details": [
            { "value": 500, "description": "N, total number of documents" },
            { "value": 15, "description": "n, number of documents containing term" }
          ]
        },
        {
          "value": 0.55,
          "description": "tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl))",
          "details": [
            { "value": 1.0, "description": "freq, occurrences of term within document" },
            { "value": 1.2, "description": "k1, term saturation parameter" },
            { "value": 0.75, "description": "b, length normalization parameter" },
            { "value": 3.0, "description": "dl, length of field" },
            { "value": 4.2, "description": "avgdl, average length of field" }
          ]
        }
      ]
    }
  ]
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Debugging Match and Non-Match</h2>
                <p>The Explain API is especially useful when a document you expect to match does not appear in results, or when it appears lower than expected.</p>

                <div class="concept-box">
                    <h3>Debugging Why a Document Does Not Match</h3>
                    <p>When _explain returns "matched": false, the explanation tells you exactly where the query failed.</p>
                    <pre><code class="language-json">// Why doesn't document 55 match this query?
POST /tests/_explain/55
{
  "query": {
    "bool": {
      "must": [
        { "match": { "testName": "thyroid" } }
      ],
      "filter": [
        { "range": { "consumerPrice": { "lte": 200 } } }
      ]
    }
  }
}

// Response when document doesn't match:
{
  "matched": false,
  "explanation": {
    "value": 0.0,
    "description": "Failure to meet condition(s) of required/prohibited clause(s)",
    "details": [
      {
        "value": 0.0,
        "description": "no match on required clause (testName:thyroid)",
        "details": [...]
      }
      // or the filter condition failed:
      // "description": "consumerPrice:[* TO 200.0] doesn't match"
    ]
  }
}

// Common reasons for non-match:
// 1. Term was analyzed differently (e.g., "CBC" vs "cbc")
// 2. Filter clause excluded the document
// 3. Minimum_should_match not satisfied</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Using explain: true in _search</h3>
                    <p>You can also add "explain": true directly to a _search request to see score explanations for all returned documents. This is useful for comparing scores across results.</p>
                    <pre><code class="language-json">// Get explanations for all search results
POST /tests/_search
{
  "explain": true,
  "query": {
    "multi_match": {
      "query": "complete blood count",
      "fields": ["testName^3", "testDescription", "testAlias"]
    }
  },
  "size": 3,
  "_source": ["testName", "consumerPrice"]
}

// Each hit in the response will include an _explanation field:
// "hits": [
//   {
//     "_id": "40",
//     "_score": 15.7,
//     "_source": { "testName": "Complete Blood Count (CBC)", ... },
//     "_explanation": {
//       "value": 15.7,
//       "description": "max of:",
//       "details": [
//         { "value": 15.7, "description": "... testName^3 ..." },
//         { "value": 3.2,  "description": "... testDescription ..." },
//         { "value": 8.1,  "description": "... testAlias ..." }
//       ]
//     }
//   }
// ]</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Use POST /index/_explain/doc_id to debug scoring for a specific document</li>
                        <li>&#10003; The explain output is a tree showing boost, IDF, and TF components</li>
                        <li>&#10003; "matched": false tells you exactly which clause failed</li>
                        <li>&#10003; Add "explain": true in _search to see explanations for all results</li>
                        <li>&#10003; Essential for debugging unexpected ranking or missing results</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('tf-idf')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('function-score')">Next: Function Score &#8594;</a>
            </div>
        `
    },
    'function-score': {
        title: 'Function Score',
        category: 'Scoring &amp; Relevance',
        difficulty: 'Advanced',
        content: `
            <h1>Function Score: Custom Scoring Logic</h1>
            <p class="lesson-meta">
                <span class="category">Category: Scoring &amp; Relevance</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>What is function_score?</h2>
                <p>The function_score query lets you modify the score of documents retrieved by a query using one or more scoring functions. This is essential when you need to incorporate business logic (like popularity, recency, or pricing) into relevance ranking.</p>

                <div class="concept-box">
                    <h3>Basic function_score Structure</h3>
                    <p>A function_score wraps an existing query and applies scoring functions to modify the original _score. You control how the function output combines with the query score.</p>
                    <pre><code class="language-json">POST /tests/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": { "testName": "blood" }
      },
      "functions": [
        {
          "field_value_factor": {
            "field": "frequency",
            "modifier": "log1p",
            "factor": 0.5
          }
        }
      ],
      "boost_mode": "multiply",
      "score_mode": "sum"
    }
  }
}

// boost_mode: how function result combines with query score
//   multiply (default), sum, avg, first, max, min, replace
//
// score_mode: how multiple functions combine with each other
//   multiply (default), sum, avg, first, max, min</code></pre>
                </div>

                <div class="concept-box">
                    <h3>field_value_factor</h3>
                    <p>Use a numeric field value to influence scoring. For healthcare tests, the frequency field (how often a test is ordered) is a natural popularity signal.</p>
                    <pre><code class="language-json">// Boost popular tests higher in results
POST /tests/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": { "testName": "blood" }
      },
      "field_value_factor": {
        "field": "frequency",
        "modifier": "log1p",
        "factor": 0.1,
        "missing": 1
      }
    }
  }
}

// modifier options:
//   none     : field_value * factor
//   log      : log(field_value * factor)
//   log1p    : log(1 + field_value * factor)  -- safe for 0 values
//   log2p    : log(2 + field_value * factor)
//   ln       : ln(field_value * factor)
//   ln1p     : ln(1 + field_value * factor)
//   ln2p     : ln(2 + field_value * factor)
//   square   : (field_value * factor)^2
//   sqrt     : sqrt(field_value * factor)
//   reciprocal : 1 / (field_value * factor)
//
// "missing": 1 provides a default if the field is absent</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Advanced Scoring Functions</h2>

                <div class="concept-box">
                    <h3>script_score</h3>
                    <p>For complex scoring logic, use Painless scripts. This gives you full control over how the score is calculated using any document fields.</p>
                    <pre><code class="language-json">// Custom script: balance text relevance with price and popularity
POST /tests/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": { "testName": "blood" }
      },
      "script_score": {
        "script": {
          "source": "_score * Math.log(2 + doc['frequency'].value) / Math.log(2 + doc['consumerPrice'].value)",
          "params": {}
        }
      }
    }
  }
}

// This formula:
// - Keeps the original text relevance (_score)
// - Boosts by popularity (log of frequency)
// - Penalizes expensive tests (divides by log of price)
// - log(2 + x) avoids log(0) or log(1) issues</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Decay Functions (gauss, linear, exp)</h3>
                    <p>Decay functions reduce a score based on the distance of a numeric field from an origin value. This is perfect for scenarios like "prefer tests priced around 500 rupees."</p>
                    <pre><code class="language-json">// Prefer tests priced near 500, with gradual decay
POST /tests/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": { "category": "Hematology" }
      },
      "functions": [
        {
          "gauss": {
            "consumerPrice": {
              "origin": 500,
              "scale": 200,
              "offset": 50,
              "decay": 0.5
            }
          }
        }
      ],
      "boost_mode": "multiply"
    }
  }
}

// origin: The ideal value (price = 500)
// scale:  At origin +/- scale, the score decays to "decay" value
// offset: No decay within origin +/- offset
// decay:  Score at distance "scale" from origin (default 0.5)
//
// Decay types:
//   gauss:  Bell curve, smooth falloff
//   linear: Straight line decay
//   exp:    Exponential decay, steep falloff</code></pre>
                </div>

                <div class="concept-box">
                    <h3>weight and random_score</h3>
                    <p>Use weight to apply a static multiplier to specific filter conditions, and random_score for randomized results (useful for A/B testing or displaying varied results).</p>
                    <pre><code class="language-json">// Combine multiple scoring functions with weights
POST /tests/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": { "testName": "blood" }
      },
      "functions": [
        {
          "filter": { "term": { "category": "Hematology" } },
          "weight": 2
        },
        {
          "filter": { "range": { "consumerPrice": { "lte": 500 } } },
          "weight": 1.5
        },
        {
          "random_score": {
            "seed": 12345,
            "field": "_seq_no"
          },
          "weight": 0.1
        }
      ],
      "score_mode": "sum",
      "boost_mode": "multiply"
    }
  }
}

// weight: static multiplier applied when filter matches
// random_score: deterministic random value (0 to 1) per document
//   seed: same seed = same random order (reproducible)
//   field: used as additional seed input</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; function_score wraps a query and modifies scores with custom functions</li>
                        <li>&#10003; field_value_factor uses numeric fields like frequency or price to influence ranking</li>
                        <li>&#10003; script_score provides full Painless scripting for complex scoring formulas</li>
                        <li>&#10003; Decay functions (gauss, linear, exp) reduce scores based on distance from a target value</li>
                        <li>&#10003; Use boost_mode and score_mode to control how function scores combine</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('explain-api')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('boosting-relevance')">Next: Boosting Relevance &#8594;</a>
            </div>
        `
    },
    'boosting-relevance': {
        title: 'Boosting Relevance',
        category: 'Scoring &amp; Relevance',
        difficulty: 'Advanced',
        content: `
            <h1>Boosting Relevance: Controlling Search Rankings</h1>
            <p class="lesson-meta">
                <span class="category">Category: Scoring &amp; Relevance</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>Field-Level Boosting</h2>
                <p>Boosting lets you tell Elasticsearch that certain fields or conditions are more important than others. This is one of the most practical ways to tune relevance for your specific use case.</p>

                <div class="concept-box">
                    <h3>Query-Time Field Boosting</h3>
                    <p>The most common approach is boosting fields at query time using the caret (^) notation or the boost parameter. A match in testName should typically rank higher than a match in testDescription.</p>
                    <pre><code class="language-json">// Boost testName matches 3x over testDescription
POST /tests/_search
{
  "query": {
    "multi_match": {
      "query": "complete blood count",
      "fields": [
        "testName^3",
        "testAlias^2",
        "testDescription"
      ]
    }
  }
}

// Equivalent using explicit boost parameter:
POST /tests/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "testName": {
              "query": "complete blood count",
              "boost": 3
            }
          }
        },
        {
          "match": {
            "testAlias": {
              "query": "complete blood count",
              "boost": 2
            }
          }
        },
        {
          "match": {
            "testDescription": "complete blood count"
          }
        }
      ]
    }
  }
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Negative Boosting</h3>
                    <p>The boosting query lets you demote documents matching certain criteria without excluding them entirely. This is useful when you want to push down less relevant results instead of filtering them out.</p>
                    <pre><code class="language-json">// Demote expensive tests without removing them
POST /tests/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "testName": "blood"
        }
      },
      "negative": {
        "range": {
          "consumerPrice": { "gte": 2000 }
        }
      },
      "negative_boost": 0.3
    }
  }
}

// Matches where consumerPrice >= 2000 have their
// score multiplied by 0.3 (reduced to 30%)
// They still appear in results, just ranked lower
//
// negative_boost must be between 0 and 1:
//   0.0 = completely suppress (like exclude)
//   0.5 = half the score
//   1.0 = no effect</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Index-Level Boosting</h2>
                <p>When searching across multiple indices, you can boost entire indices to prefer results from one index over another.</p>

                <div class="concept-box">
                    <h3>indices_boost</h3>
                    <p>Use indices_boost to apply a multiplier to scores from specific indices. This is useful when searching across tests and packages indices simultaneously.</p>
                    <pre><code class="language-json">// Prefer results from tests index over packages
POST /tests,packages/_search
{
  "indices_boost": [
    { "tests": 1.5 },
    { "packages": 1.0 }
  ],
  "query": {
    "multi_match": {
      "query": "blood test",
      "fields": ["testName", "testDescription"]
    }
  }
}

// All scores from "tests" index are multiplied by 1.5
// All scores from "packages" index remain at 1.0
// This effectively prefers individual tests over packages</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Index-Time vs Query-Time Boosting</h3>
                    <p>Elasticsearch previously supported index-time boosting (boosting a field when the document is indexed), but this is now deprecated. Always prefer query-time boosting for flexibility and maintainability.</p>
                    <pre><code class="language-json">// DEPRECATED - Do NOT use index-time boosting:
PUT /tests
{
  "mappings": {
    "properties": {
      "testName": {
        "type": "text",
        "boost": 2     // DEPRECATED! Do not use
      }
    }
  }
}

// WHY query-time boosting is better:
// 1. Can be changed without reindexing
// 2. Can vary per query based on context
// 3. Easier to test and iterate
// 4. No hidden scoring surprises
//
// RECOMMENDED - Use query-time boosting:
POST /tests/_search
{
  "query": {
    "multi_match": {
      "query": "CBC",
      "fields": ["testName^3", "testAlias^2", "testDescription"]
    }
  }
}
// Boost values can change per request as needed</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Use ^ notation or boost parameter to weight fields at query time</li>
                        <li>&#10003; The boosting query demotes matching documents without excluding them</li>
                        <li>&#10003; indices_boost applies score multipliers across multiple indices</li>
                        <li>&#10003; Always prefer query-time over index-time boosting for flexibility</li>
                        <li>&#10003; Combine field boosting with function_score for maximum control</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('function-score')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('search-as-you-type')">Next: Search-as-You-Type &#8594;</a>
            </div>
        `
    },
    'search-as-you-type': {
        title: 'Search-as-You-Type',
        category: 'Complex Queries',
        difficulty: 'Advanced',
        content: `
            <h1>Search-as-You-Type: Instant Search Experience</h1>
            <p class="lesson-meta">
                <span class="category">Category: Complex Queries</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>The search_as_you_type Field Type</h2>
                <p>Elasticsearch provides a dedicated field type called search_as_you_type that automatically creates optimized subfields for prefix, infix, and shingle-based matching. This is the recommended approach for building instant search experiences.</p>

                <div class="concept-box">
                    <h3>Mapping Configuration</h3>
                    <p>When you map a field as search_as_you_type, Elasticsearch automatically creates subfields with n-gram and shingle analyzers optimized for partial matching.</p>
                    <pre><code class="language-json">// Create an index with search_as_you_type field
PUT /tests_autocomplete
{
  "mappings": {
    "properties": {
      "testName": {
        "type": "search_as_you_type",
        "max_shingle_size": 3
      }
    }
  }
}

// This automatically creates these subfields:
// testName                - root field (standard analyzed)
// testName._2gram         - shingle (2-word combinations)
// testName._3gram         - shingle (3-word combinations)
// testName._index_prefix  - edge n-gram of each term
//
// Example: "Complete Blood Count"
// _2gram tokens:  "Complete Blood", "Blood Count"
// _3gram tokens:  "Complete Blood Count"
// _index_prefix:  "C", "Co", "Com", "Comp", ... "B", "Bl", ...</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Querying with bool_prefix</h3>
                    <p>The multi_match query with type "bool_prefix" is designed to work with search_as_you_type fields. It treats the last term as a prefix and the preceding terms as full matches.</p>
                    <pre><code class="language-json">// User types "compl blo" - match "Complete Blood Count"
POST /tests/_search
{
  "query": {
    "multi_match": {
      "query": "compl blo",
      "type": "bool_prefix",
      "fields": [
        "testName",
        "testName._2gram",
        "testName._3gram"
      ]
    }
  }
}

// How bool_prefix works:
// Input: "compl blo"
// Terms: ["compl", "blo"]
//
// All terms except the last use "term" query:
//   term query for "compl" (doesn't match "complete")
// Last term uses "prefix" query:
//   prefix query for "blo" (matches "blood")
//
// Actually, with analyzed text, "compl" becomes a prefix match
// on the _index_prefix subfield, so partial terms DO match!</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Shingle Subfields Explained</h2>
                <p>Shingles are sliding windows of adjacent terms that enable phrase-like matching without requiring exact phrase queries.</p>

                <div class="concept-box">
                    <h3>How Shingles Improve Matching</h3>
                    <p>The _2gram and _3gram subfields index sequences of 2 and 3 adjacent words. This means searching for "blood count" matches the shingle "Blood Count" directly, producing better-ranked results than matching individual terms.</p>
                    <pre><code class="language-json">// Document: "Complete Blood Count (CBC)"
//
// Shingle analysis:
// _2gram tokens: ["Complete Blood", "Blood Count", "Count CBC"]
// _3gram tokens: ["Complete Blood Count", "Blood Count CBC"]
//
// When user searches "blood count":
// - Root field: matches "blood" and "count" individually
// - _2gram field: matches "Blood Count" as a unit (higher score!)
// - _3gram field: no 3-word match (no contribution)
//
// The _2gram match scores highest because it found
// the exact 2-word sequence, proving word order relevance

// Practical example with multiple subfields:
POST /tests/_search
{
  "query": {
    "multi_match": {
      "query": "blood count",
      "type": "bool_prefix",
      "fields": [
        "testName",
        "testName._2gram",
        "testName._3gram"
      ]
    }
  },
  "_source": ["testName", "category"],
  "size": 5
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Combining with Other Queries</h3>
                    <p>In production, you typically combine search_as_you_type with other filters to create a responsive, filtered search experience.</p>
                    <pre><code class="language-json">// Autocomplete with category filter and highlighting
POST /tests/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "multi_match": {
            "query": "thy",
            "type": "bool_prefix",
            "fields": [
              "testName",
              "testName._2gram",
              "testName._3gram"
            ]
          }
        }
      ],
      "filter": [
        {
          "range": {
            "consumerPrice": { "lte": 1000 }
          }
        }
      ]
    }
  },
  "highlight": {
    "fields": {
      "testName": {}
    }
  },
  "_source": ["testName", "consumerPrice", "category"],
  "size": 10
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; search_as_you_type creates optimized subfields automatically (_2gram, _3gram, _index_prefix)</li>
                        <li>&#10003; Use multi_match with type "bool_prefix" for instant search queries</li>
                        <li>&#10003; Shingles index adjacent word combinations for phrase-aware matching</li>
                        <li>&#10003; The last typed term is treated as a prefix, earlier terms as full matches</li>
                        <li>&#10003; Combine with bool filters for production-ready search-as-you-type</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('boosting-relevance')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('faceted-search')">Next: Faceted Search &#8594;</a>
            </div>
        `
    },
    'faceted-search': {
        title: 'Faceted Search',
        category: 'Complex Queries',
        difficulty: 'Advanced',
        content: `
            <h1>Faceted Search: Search with Navigable Filters</h1>
            <p class="lesson-meta">
                <span class="category">Category: Complex Queries</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>What is Faceted Search?</h2>
                <p>Faceted search combines full-text search with aggregation-based navigation. Think of any e-commerce site where you search for a product and then see filter counts on the left sidebar (e.g., "Hematology (25)", "Biochemistry (18)"). Those filter counts come from aggregations running alongside the search.</p>

                <div class="concept-box">
                    <h3>Basic Faceted Search Pattern</h3>
                    <p>Combine a search query with aggregations to return both search results and facet counts in a single request.</p>
                    <pre><code class="language-json">// Search for "blood" and get facet counts by category
POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "aggs": {
    "category_facets": {
      "terms": {
        "field": "category.keyword",
        "size": 10
      }
    },
    "price_ranges": {
      "range": {
        "field": "consumerPrice",
        "ranges": [
          { "key": "Budget (Under 300)", "to": 300 },
          { "key": "Mid-Range (300-1000)", "from": 300, "to": 1000 },
          { "key": "Premium (Over 1000)", "from": 1000 }
        ]
      }
    }
  },
  "size": 5
}

// Response includes:
// "hits": [ ... search results for "blood" ... ]
// "aggregations": {
//   "category_facets": {
//     "buckets": [
//       { "key": "Hematology", "doc_count": 12 },
//       { "key": "Biochemistry", "doc_count": 5 },
//       ...
//     ]
//   },
//   "price_ranges": {
//     "buckets": [
//       { "key": "Budget (Under 300)", "doc_count": 8 },
//       ...
//     ]
//   }
// }</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>post_filter for Facet Selection</h2>
                <p>The key challenge in faceted search is: when a user selects a facet (like "Hematology"), you want the search results to be filtered, but the other facet counts should still reflect the original search. This is where post_filter comes in.</p>

                <div class="concept-box">
                    <h3>Understanding post_filter</h3>
                    <p>post_filter applies a filter to search results AFTER aggregations have been calculated. This means aggregations see all matching documents, but the returned hits are filtered.</p>
                    <pre><code class="language-json">// User searched "blood" and then clicked "Hematology" facet
POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "aggs": {
    "category_facets": {
      "terms": {
        "field": "category.keyword",
        "size": 10
      }
    }
  },
  "post_filter": {
    "term": { "category.keyword": "Hematology" }
  },
  "size": 5
}

// Result:
// "hits": only Hematology tests matching "blood"
// "aggregations.category_facets": counts for ALL categories
//   matching "blood" (not just Hematology!)
//
// This is crucial! Without post_filter, selecting "Hematology"
// would make all other category counts disappear.
//
// Timeline of execution:
// 1. query runs: finds all docs matching "blood"
// 2. aggs run: compute facet counts on query results
// 3. post_filter runs: filter hits to Hematology only</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Global Aggregations</h3>
                    <p>Sometimes you want facet counts that ignore the search query entirely - showing total counts across all documents. The global aggregation breaks out of the query scope.</p>
                    <pre><code class="language-json">// Show both filtered and total category counts
POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "aggs": {
    "filtered_categories": {
      "terms": {
        "field": "category.keyword",
        "size": 10
      }
    },
    "all_categories": {
      "global": {},
      "aggs": {
        "categories": {
          "terms": {
            "field": "category.keyword",
            "size": 10
          }
        }
      }
    }
  },
  "size": 5
}

// "filtered_categories": counts from docs matching "blood"
//   { "Hematology": 12, "Biochemistry": 5, ... }
//
// "all_categories.categories": counts from ALL documents
//   { "Hematology": 45, "Biochemistry": 82, "Radiology": 30, ... }
//
// Use case: show "12 of 45" next to Hematology facet</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Advanced Faceted Patterns</h2>

                <div class="concept-box">
                    <h3>Multi-Select Facets with Filter Aggregations</h3>
                    <p>When users can select multiple facets simultaneously, each facet bucket must exclude its own filter from the count to remain accurate. This requires a combination of filter and aggs.</p>
                    <pre><code class="language-json">// User selected Hematology AND price under 500
// Show accurate counts for all other facet values
POST /tests/_search
{
  "query": {
    "match": { "testName": "blood" }
  },
  "aggs": {
    "categories_agg": {
      "filter": {
        "range": { "consumerPrice": { "lt": 500 } }
      },
      "aggs": {
        "categories": {
          "terms": { "field": "category.keyword" }
        }
      }
    },
    "price_agg": {
      "filter": {
        "term": { "category.keyword": "Hematology" }
      },
      "aggs": {
        "prices": {
          "range": {
            "field": "consumerPrice",
            "ranges": [
              { "to": 300 },
              { "from": 300, "to": 1000 },
              { "from": 1000 }
            ]
          }
        }
      }
    }
  },
  "post_filter": {
    "bool": {
      "must": [
        { "term": { "category.keyword": "Hematology" } },
        { "range": { "consumerPrice": { "lt": 500 } } }
      ]
    }
  },
  "size": 5
}

// categories_agg: filtered by price only (not category)
//   so Hematology count is accurate for price &lt; 500
// price_agg: filtered by category only (not price)
//   so each price range count is accurate for Hematology</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Faceted search combines queries with aggregations for filter-based navigation</li>
                        <li>&#10003; post_filter applies after aggregations, preserving facet counts while filtering results</li>
                        <li>&#10003; Global aggregations ignore the query scope for total document counts</li>
                        <li>&#10003; Multi-select facets require each facet to exclude its own filter from counts</li>
                        <li>&#10003; Always return facet counts alongside search results in a single request</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('search-as-you-type')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('autocomplete')">Next: Autocomplete &#8594;</a>
            </div>
        `
    },
    'geo-queries': {
        title: 'Geo Queries',
        category: 'Complex Queries',
        difficulty: 'Advanced',
        content: `
            <h1>Geo Queries: Location-Based Search</h1>
            <p class="lesson-meta">
                <span class="category">Category: Complex Queries</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>Geo Field Types</h2>
                <p>Elasticsearch supports geospatial data through special field types that enable location-based search. For healthcare, this is useful for finding nearby labs, clinics, or testing centers where patients can get their tests done.</p>

                <div class="concept-box">
                    <h3>Setting Up geo_point Fields</h3>
                    <p>The geo_point type stores latitude/longitude pairs. You need to explicitly map fields as geo_point since dynamic mapping will not detect them automatically.</p>
                    <pre><code class="language-json">// Create an index for lab locations with geo_point
PUT /labs
{
  "mappings": {
    "properties": {
      "labName": { "type": "text" },
      "location": { "type": "geo_point" },
      "testsOffered": { "type": "keyword" },
      "city": { "type": "keyword" }
    }
  }
}

// Index a lab with location data
POST /labs/_doc/1
{
  "labName": "City Diagnostics Central Lab",
  "location": {
    "lat": 28.6139,
    "lon": 77.2090
  },
  "testsOffered": ["CBC", "Thyroid Panel", "Lipid Panel"],
  "city": "Delhi"
}

// Alternative geo_point formats:
// String:   "location": "28.6139,77.2090"
// Array:    "location": [77.2090, 28.6139]  // Note: [lon, lat]
// GeoHash:  "location": "ttnfv2x"</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Geo Query Types</h2>

                <div class="concept-box">
                    <h3>geo_distance Query</h3>
                    <p>Find all documents within a specified distance from a point. This is the most common geo query - "find labs within 10km of me."</p>
                    <pre><code class="language-json">// Find labs within 10km of a location (e.g., patient's address)
POST /labs/_search
{
  "query": {
    "bool": {
      "must": {
        "match": { "testsOffered": "CBC" }
      },
      "filter": {
        "geo_distance": {
          "distance": "10km",
          "location": {
            "lat": 28.6139,
            "lon": 77.2090
          }
        }
      }
    }
  }
}

// Supported distance units:
// mi (miles), yd (yards), ft (feet), in (inches)
// km (kilometers), m (meters), cm (centimeters), mm (millimeters)
// nmi (nautical miles)
//
// distance_type options:
//   "arc" (default) - more accurate, uses great circle
//   "plane" - faster, less accurate for large distances</code></pre>
                </div>

                <div class="concept-box">
                    <h3>geo_bounding_box Query</h3>
                    <p>Find documents within a rectangular area defined by top-left and bottom-right coordinates. Faster than geo_distance for viewport-based searches (e.g., "show labs visible on this map").</p>
                    <pre><code class="language-json">// Find labs within a bounding box (map viewport)
POST /labs/_search
{
  "query": {
    "geo_bounding_box": {
      "location": {
        "top_left": {
          "lat": 28.75,
          "lon": 77.10
        },
        "bottom_right": {
          "lat": 28.50,
          "lon": 77.35
        }
      }
    }
  }
}

// The bounding box is a rectangle on the map
// top_left: northwest corner
// bottom_right: southeast corner
// Very efficient for map-based interfaces</code></pre>
                </div>

                <div class="concept-box">
                    <h3>geo_shape Query</h3>
                    <p>For complex geographic regions (polygons, circles, lines), use geo_shape. This requires a geo_shape field type instead of geo_point.</p>
                    <pre><code class="language-json">// Mapping with geo_shape for service areas
PUT /lab_coverage
{
  "mappings": {
    "properties": {
      "labName": { "type": "text" },
      "serviceArea": { "type": "geo_shape" }
    }
  }
}

// Index a lab with a polygon service area
POST /lab_coverage/_doc/1
{
  "labName": "Metro Diagnostics",
  "serviceArea": {
    "type": "polygon",
    "coordinates": [[
      [77.10, 28.75],
      [77.35, 28.75],
      [77.35, 28.50],
      [77.10, 28.50],
      [77.10, 28.75]
    ]]
  }
}

// Find labs whose service area contains a point
POST /lab_coverage/_search
{
  "query": {
    "geo_shape": {
      "serviceArea": {
        "shape": {
          "type": "point",
          "coordinates": [77.20, 28.63]
        },
        "relation": "contains"
      }
    }
  }
}

// relation options:
//   intersects (default) - shape overlaps with query
//   contains - shape fully contains the query
//   within - shape is fully within the query
//   disjoint - shape does not overlap with query</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Sorting by Distance</h2>

                <div class="concept-box">
                    <h3>Geo Distance Sort</h3>
                    <p>Sort results by distance from a reference point. This is essential for "nearest lab" functionality where users want results ordered by proximity.</p>
                    <pre><code class="language-json">// Find labs offering CBC, sorted by distance from user
POST /labs/_search
{
  "query": {
    "match": { "testsOffered": "CBC" }
  },
  "sort": [
    {
      "_geo_distance": {
        "location": {
          "lat": 28.6139,
          "lon": 77.2090
        },
        "order": "asc",
        "unit": "km",
        "mode": "min",
        "distance_type": "arc"
      }
    }
  ]
}

// Response includes sort value (distance in km):
// "hits": [
//   {
//     "_source": { "labName": "City Diagnostics Central Lab" },
//     "sort": [1.234]   // 1.234 km away
//   },
//   {
//     "_source": { "labName": "HealthFirst Diagnostics" },
//     "sort": [3.567]   // 3.567 km away
//   }
// ]
//
// mode: "min" | "max" | "median" | "avg"
//   Used when a document has multiple geo_points</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Use geo_point for lat/lon coordinates and geo_shape for complex geometries</li>
                        <li>&#10003; geo_distance finds documents within a radius from a point</li>
                        <li>&#10003; geo_bounding_box is efficient for rectangular map viewport searches</li>
                        <li>&#10003; geo_shape supports polygon, circle, and other complex shapes with relation operators</li>
                        <li>&#10003; _geo_distance sort orders results by proximity to a reference point</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('autocomplete')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('multi-index')">Next: Multi-Index Search &#8594;</a>
            </div>
        `
    },
    'multi-index': {
        title: 'Multi-Index Search',
        category: 'Complex Queries',
        difficulty: 'Advanced',
        content: `
            <h1>Multi-Index Search: Querying Across Indices</h1>
            <p class="lesson-meta">
                <span class="category">Category: Complex Queries</span>
                <span class="difficulty">Difficulty: Advanced</span>
            </p>

            <section class="lesson-section">
                <h2>Searching Multiple Indices</h2>
                <p>In real applications, data is often spread across multiple indices. Healthcare platforms might have separate indices for tests, packages, labs, and articles. Elasticsearch makes it easy to search across them all simultaneously.</p>

                <div class="concept-box">
                    <h3>Basic Multi-Index Search</h3>
                    <p>Specify multiple index names separated by commas, or use wildcard patterns to search across multiple indices in a single request.</p>
                    <pre><code class="language-json">// Search across both tests and packages indices
POST /tests,packages/_search
{
  "query": {
    "multi_match": {
      "query": "thyroid panel",
      "fields": ["testName", "testDescription", "packageName"]
    }
  },
  "size": 10
}

// Using wildcard patterns:
POST /test*/_search
{
  "query": {
    "match": { "testName": "blood" }
  }
}
// Matches: tests, tests_v2, tests_autocomplete, etc.

// Search all indices (use with caution):
POST /_all/_search
{
  "query": { "match": { "testName": "CBC" } }
}

// Exclude specific indices with minus sign:
POST /test*,-tests_archive/_search
{
  "query": { "match": { "testName": "blood" } }
}
// Searches test* indices but excludes tests_archive</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Index Boosting Across Indices</h3>
                    <p>When searching across multiple indices, different indices may have varying relevance. Use indices_boost to control which index's results rank higher.</p>
                    <pre><code class="language-json">// Prefer individual tests over packages in search results
POST /tests,packages/_search
{
  "indices_boost": [
    { "tests": 2.0 },
    { "packages": 1.0 }
  ],
  "query": {
    "multi_match": {
      "query": "complete blood count",
      "fields": ["testName^2", "testDescription", "packageName"]
    }
  },
  "_source": ["testName", "packageName", "consumerPrice"],
  "size": 10
}

// All scores from "tests" are doubled
// Scores from "packages" remain unchanged
// Useful for prioritizing certain content types

// You can also use wildcards in indices_boost:
{
  "indices_boost": [
    { "tests": 2.0 },
    { "packages*": 0.8 }
  ]
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>The _msearch API</h2>
                <p>The Multi Search (_msearch) API executes multiple independent search requests in a single HTTP call. This reduces network round trips and is more efficient than making separate requests.</p>

                <div class="concept-box">
                    <h3>_msearch Request Format</h3>
                    <p>Each search in _msearch is specified as two lines: a header line (specifying index and other metadata) followed by a body line (the search query). Lines are separated by newlines.</p>
                    <pre><code class="language-json">// _msearch sends multiple searches in one request
// Each pair of lines = one search (header + body)
POST /_msearch
{"index": "tests"}
{"query": {"match": {"testName": "blood"}}, "size": 3}
{"index": "packages"}
{"query": {"match": {"packageName": "health checkup"}}, "size": 3}
{"index": "tests"}
{"query": {"range": {"consumerPrice": {"lte": 200}}}, "size": 3}

// Response contains an array of responses:
{
  "responses": [
    {
      "hits": {
        "total": { "value": 15 },
        "hits": [ ... blood test results ... ]
      }
    },
    {
      "hits": {
        "total": { "value": 8 },
        "hits": [ ... health checkup packages ... ]
      }
    },
    {
      "hits": {
        "total": { "value": 42 },
        "hits": [ ... budget tests under 200 ... ]
      }
    }
  ]
}</code></pre>
                </div>

                <div class="concept-box">
                    <h3>Practical _msearch Use Case</h3>
                    <p>A healthcare search page might need to show test results, package suggestions, and popular tests all at once. _msearch handles this in a single network call.</p>
                    <pre><code class="language-json">// Single request for a search results page
POST /_msearch
{"index": "tests"}
{"query": {"multi_match": {"query": "thyroid", "fields": ["testName^3", "testDescription"]}}, "size": 10}
{"index": "packages"}
{"query": {"match": {"packageDescription": "thyroid"}}, "size": 5}
{"index": "tests"}
{"query": {"match_all": {}}, "sort": [{"frequency": "desc"}], "size": 5}

// Response[0]: Main test search results for "thyroid"
// Response[1]: Related packages containing thyroid tests
// Response[2]: Top 5 most popular tests (for sidebar)
//
// Benefits over three separate requests:
// - Single TCP connection and HTTP round trip
// - Elasticsearch can optimize execution internally
// - Atomic: all results returned together
// - Simpler error handling in application code</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Handling Different Mappings</h2>

                <div class="concept-box">
                    <h3>Field Mapping Conflicts Across Indices</h3>
                    <p>When searching across indices, fields with the same name may have different mappings. Elasticsearch handles this gracefully, but you should be aware of the behavior.</p>
                    <pre><code class="language-json">// "tests" index: consumerPrice is a float
// "packages" index: consumerPrice is an integer
// Elasticsearch handles compatible types automatically

// If field types are incompatible, use typed fields:
POST /tests,packages/_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "testName": "blood" } },
        { "match": { "packageName": "blood" } }
      ]
    }
  },
  "_source": {
    "includes": ["testName", "packageName", "consumerPrice"]
  },
  "size": 10
}

// Use _index field to distinguish result sources:
// Each hit includes "_index": "tests" or "_index": "packages"
// Your application can render them differently based on _index

// You can also filter by index within the query:
POST /tests,packages/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "bool": {
            "must": { "match": { "testName": "blood" } },
            "filter": { "term": { "_index": "tests" } }
          }
        },
        {
          "bool": {
            "must": { "match": { "packageName": "blood" } },
            "filter": { "term": { "_index": "packages" } }
          }
        }
      ]
    }
  }
}</code></pre>
                </div>
            </section>

            <section class="lesson-section">
                <h2>Summary</h2>
                <div class="summary-box">
                    <ul>
                        <li>&#10003; Search across multiple indices with comma-separated names or wildcard patterns</li>
                        <li>&#10003; Use indices_boost to prioritize results from specific indices</li>
                        <li>&#10003; _msearch executes multiple independent queries in a single HTTP request</li>
                        <li>&#10003; Each _msearch entry has a header line (index) and body line (query)</li>
                        <li>&#10003; Use the _index field to distinguish which index each result came from</li>
                    </ul>
                </div>
            </section>

            <div class="lesson-nav">
                <a class="btn btn-outline" onclick="loadLesson('geo-queries')">&#8592; Previous</a>
                <a class="btn btn-primary" onclick="loadLesson('what-is-elasticsearch')">Next: What is Elasticsearch &#8594;</a>
            </div>
        `
    }
};

function loadLesson(lessonId) {
    const lesson = lessons[lessonId];
    if (!lesson) {
        // For lessons without content yet, show placeholder
        document.getElementById('lesson-content').innerHTML = `
            <div class="lesson">
                <h1>${lessonId.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</h1>
                <p class="lesson-meta">
                    <span class="category">Category: Coming Soon</span>
                </p>
                <section class="lesson-section">
                    <h2>Content Coming Soon</h2>
                    <p>This lesson is being developed. Check back soon!</p>
                    <p>In the meantime, try the <a href="/elasticsearch">Elasticsearch Dashboard</a> to practice queries.</p>
                </section>
            </div>
        `;
    } else if (lesson.content) {
        document.getElementById('lesson-content').innerHTML = lesson.content;
    }

    // Update active state
    document.querySelectorAll('.lesson-link').forEach(link => link.classList.remove('active'));
    event.target.classList.add('active');

    // Hide any previous results
    const resultContainer = document.getElementById('query-result');
    if (resultContainer) resultContainer.style.display = 'none';
}

function toggleCategory(id) {
    const content = document.getElementById(id);
    content.classList.toggle('expanded');
}

function toggleSubCategory(id) {
    const content = document.getElementById(id);
    content.classList.toggle('expanded');
}

async function runESExample(button, method, path, body) {
    // Find the result container relative to the button (in the same section)
    const section = button.closest('.lesson-section') || button.closest('.content-section') || button.parentElement.parentElement;
    let resultContainer = section.querySelector('.query-result-container');
    let resultContent;

    // If no result container found in section, create one after the button
    if (!resultContainer) {
        resultContainer = document.createElement('div');
        resultContainer.className = 'query-result-container';
        resultContainer.innerHTML = '<h4>Result</h4><pre class="query-result-content"></pre>';
        button.parentElement.after(resultContainer);
    }

    resultContent = resultContainer.querySelector('pre');

    resultContainer.style.display = 'block';
    resultContent.textContent = 'Loading...';
    resultContent.style.color = '#aaa';
    button.disabled = true;
    button.textContent = 'Running...';

    try {
        const response = await fetch('/api/elasticsearch/execute', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                method: method,
                path: path,
                body: body
            })
        });

        const result = await response.json();

        if (result.success) {
            let respData = result.response;
            // Handle response whether it's a string or already an object
            if (typeof respData === 'string') {
                try {
                    respData = JSON.parse(respData);
                } catch (parseErr) {
                    // Not JSON, leave as string
                }
            }
            // Format the output
            if (typeof respData === 'object' && respData !== null) {
                resultContent.textContent = JSON.stringify(respData, null, 2);
            } else {
                resultContent.textContent = String(respData);
            }
            resultContent.style.color = '#4ecdc4';
        } else {
            let errorMsg = result.error;
            if (typeof errorMsg === 'object') {
                errorMsg = JSON.stringify(errorMsg, null, 2);
            }
            resultContent.textContent = 'Error: ' + errorMsg;
            resultContent.style.color = '#ff6b6b';
        }
    } catch (e) {
        resultContent.textContent = 'Request failed: ' + e.message;
        resultContent.style.color = '#ff6b6b';
    } finally {
        button.disabled = false;
        button.textContent = 'Try it';
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    // Expand first category by default
    toggleCategory('fundamentals');
    toggleSubCategory('basics');
});
</script>
