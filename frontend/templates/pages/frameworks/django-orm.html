<style>
    .fw-section { background: var(--bg-secondary, #f8fafc); padding: 24px; border-radius: 12px; margin-bottom: 24px; border: 1px solid var(--border-color, #e2e8f0); }
    .fw-section h2 { font-size: 1.5rem; margin-bottom: 12px; color: var(--accent-primary, #3b82f6); }
    .fw-section h3 { font-size: 1.2rem; margin-top: 20px; margin-bottom: 12px; color: var(--accent-secondary, #8b5cf6); }
    .diagram-container { background: var(--bg-tertiary, #f1f5f9); padding: 20px; border-radius: 10px; margin: 20px 0; overflow-x: auto; }
    .code-example { background: #1e293b; border-radius: 8px; padding: 16px; margin: 16px 0; overflow-x: auto; }
    .code-example pre { margin: 0; color: #e2e8f0; font-family: 'Fira Code', monospace; font-size: 0.9rem; }
    .concept-card { background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid var(--accent-secondary); }
    .concept-card h4 { color: var(--accent-secondary); margin-bottom: 10px; }
    .highlight-box { background: rgba(59, 130, 246, 0.08); padding: 16px; border-radius: 8px; border-left: 4px solid var(--accent-primary); margin: 16px 0; }
    .warning-box { background: rgba(239, 68, 68, 0.08); padding: 16px; border-radius: 8px; border-left: 4px solid #ef4444; margin: 16px 0; }
</style>

<div class="page-layout">
    <div class="page-main">
        <nav style="margin-bottom: 16px;"><a href="/frameworks/django" style="color: var(--accent-primary);">&larr; Back to Django</a></nav>

        <h1>Django ORM</h1>
        <p class="text-muted mb-4">Object-Relational Mapping - translate Python classes to database tables and queries</p>

        <div class="fw-section">
            <h2>ORM Query Flow</h2>
            <div class="diagram-container">
                <pre class="mermaid">
flowchart TB
    subgraph Python["Python Code"]
        Q["User.objects.filter(is_active=True)\n.select_related('profile')\n.order_by('-created')[:10]"]
    end

    subgraph QuerySet["QuerySet (Lazy)"]
        QS["QuerySet object created\nNo DB hit yet!"]
    end

    subgraph Evaluate["Evaluation Triggers"]
        E1["list(qs)"]
        E2["for item in qs"]
        E3["qs[0], len(qs)"]
        E4["if qs:"]
    end

    subgraph SQL["SQL Generation"]
        S["SELECT users.*, profiles.*\nFROM users\nJOIN profiles ON ...\nWHERE is_active = true\nORDER BY created DESC\nLIMIT 10"]
    end

    subgraph DB["Database"]
        D["Execute query\nReturn rows"]
    end

    subgraph Model["Model Instances"]
        M["List of User objects\nwith prefetched profiles"]
    end

    Q --> QS
    QS --> E1 & E2 & E3 & E4
    E1 & E2 & E3 & E4 --> S
    S --> D --> M

    style Q fill:#3b82f6,color:#fff
    style QS fill:#f59e0b,color:#fff
    style S fill:#8b5cf6,color:#fff
    style M fill:#10b981,color:#fff
                </pre>
            </div>
            <div class="highlight-box">
                <strong>Key Insight:</strong> QuerySets are lazy - they don't hit the database until evaluated. Chain filters freely without performance concerns until you actually need the data.
            </div>
        </div>

        <div class="fw-section">
            <h2>Model Definition</h2>

            <div class="concept-card">
                <h4>1. Basic Models & Fields</h4>
                <div class="code-example">
                    <pre><code class="language-python">from django.db import models
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    """Extended user model"""
    bio = models.TextField(blank=True, default='')
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'users'  # Custom table name
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['email']),
            models.Index(fields=['created_at', 'is_active']),
        ]

class Post(models.Model):
    class Status(models.TextChoices):
        DRAFT = 'draft', 'Draft'
        PUBLISHED = 'published', 'Published'
        ARCHIVED = 'archived', 'Archived'

    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    content = models.TextField()
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.DRAFT)
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='posts')
    tags = models.ManyToManyField('Tag', related_name='posts', blank=True)
    views_count = models.PositiveIntegerField(default=0)
    published_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['author', 'slug'], name='unique_author_slug'),
            models.CheckConstraint(check=models.Q(views_count__gte=0), name='positive_views'),
        ]

    def __str__(self):
        return self.title

class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h4>2. Relationships</h4>
                <div class="diagram-container">
                    <pre class="mermaid">
erDiagram
    User ||--o{ Post : "writes"
    User ||--o| Profile : "has"
    Post }o--o{ Tag : "tagged with"
    Post ||--o{ Comment : "has"
    User ||--o{ Comment : "writes"

    User {
        int id PK
        string username
        string email
    }
    Profile {
        int id PK
        int user_id FK
        string bio
    }
    Post {
        int id PK
        int author_id FK
        string title
        string content
    }
    Tag {
        int id PK
        string name
    }
    Comment {
        int id PK
        int post_id FK
        int author_id FK
        string text
    }
                    </pre>
                </div>
                <div class="code-example">
                    <pre><code class="language-python"># One-to-One
class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    website = models.URLField(blank=True)

# One-to-Many (ForeignKey)
class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    text = models.TextField()

# Many-to-Many with through model
class PostTag(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE)
    tag = models.ForeignKey(Tag, on_delete=models.CASCADE)
    added_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ['post', 'tag']

# Usage
Post.tags = models.ManyToManyField(Tag, through=PostTag, related_name='posts')</code></pre>
                </div>
            </div>
        </div>

        <div class="fw-section">
            <h2>QuerySet Methods</h2>

            <div class="concept-card">
                <h4>3. Filtering & Lookups</h4>
                <div class="code-example">
                    <pre><code class="language-python"># Basic filtering
User.objects.filter(is_active=True)
User.objects.exclude(role='admin')
User.objects.get(pk=1)  # Raises DoesNotExist or MultipleObjectsReturned

# Field lookups (double underscore)
Post.objects.filter(title__icontains='django')      # Case-insensitive contains
Post.objects.filter(created_at__year=2024)          # Date parts
Post.objects.filter(created_at__gte=last_week)      # Greater than or equal
Post.objects.filter(author__username='john')        # Related field lookup
Post.objects.filter(tags__name__in=['python', 'web'])  # Through relationships

# Complex queries with Q objects
from django.db.models import Q

Post.objects.filter(
    Q(status='published') | Q(author=request.user),  # OR
    Q(created_at__gte=last_month)  # AND (positional after keyword)
)

# Negation
Post.objects.filter(~Q(status='draft'))  # NOT draft

# Chaining (all AND)
Post.objects.filter(status='published').filter(author__is_active=True).exclude(views_count=0)</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h4>4. Aggregation & Annotation</h4>
                <div class="code-example">
                    <pre><code class="language-python">from django.db.models import Count, Avg, Sum, Max, Min, F, Value
from django.db.models.functions import Concat, Lower, Coalesce

# Aggregate - returns dict
Post.objects.aggregate(
    total=Count('id'),
    avg_views=Avg('views_count'),
    max_views=Max('views_count')
)
# {'total': 100, 'avg_views': 250.5, 'max_views': 10000}

# Annotate - adds field to each object
users = User.objects.annotate(
    post_count=Count('posts'),
    total_views=Sum('posts__views_count')
).filter(post_count__gt=5)

for user in users:
    print(f"{user.username}: {user.post_count} posts, {user.total_views} views")

# F expressions - reference model fields
Post.objects.update(views_count=F('views_count') + 1)  # Atomic increment
Post.objects.filter(updated_at__gt=F('created_at'))    # Compare fields

# Conditional expressions
from django.db.models import Case, When

Post.objects.annotate(
    priority=Case(
        When(status='published', views_count__gt=1000, then=Value('high')),
        When(status='published', then=Value('medium')),
        default=Value('low')
    )
)

# Subqueries
from django.db.models import Subquery, OuterRef

latest_comment = Comment.objects.filter(
    post=OuterRef('pk')
).order_by('-created_at')

Post.objects.annotate(
    latest_comment_text=Subquery(latest_comment.values('text')[:1])
)</code></pre>
                </div>
            </div>

            <div class="concept-card">
                <h4>5. Performance Optimization</h4>
                <div class="warning-box">
                    <strong>N+1 Query Problem:</strong> Accessing related objects in a loop causes one query per object. Always use select_related or prefetch_related.
                </div>
                <div class="code-example">
                    <pre><code class="language-python"># BAD - N+1 queries (1 + N queries)
posts = Post.objects.all()
for post in posts:
    print(post.author.username)  # Each access = 1 query!

# GOOD - select_related for ForeignKey/OneToOne (SQL JOIN)
posts = Post.objects.select_related('author', 'author__profile').all()
for post in posts:
    print(post.author.username)  # No extra queries!

# GOOD - prefetch_related for ManyToMany/reverse FK (2 queries)
posts = Post.objects.prefetch_related('tags', 'comments').all()
for post in posts:
    print([tag.name for tag in post.tags.all()])  # No extra queries!

# Custom prefetch with filtering
from django.db.models import Prefetch

posts = Post.objects.prefetch_related(
    Prefetch(
        'comments',
        queryset=Comment.objects.filter(is_approved=True).select_related('author'),
        to_attr='approved_comments'  # Access as post.approved_comments
    )
)

# Only/Defer - limit fields loaded
Post.objects.only('title', 'slug')     # Only load these fields
Post.objects.defer('content')          # Load all except content

# Values/Values_list - return dicts/tuples instead of objects
Post.objects.values('title', 'author__username')  # [{'title': '...', 'author__username': '...'}]
Post.objects.values_list('id', flat=True)         # [1, 2, 3, 4, ...]

# Exists - efficient existence check
if Post.objects.filter(author=user).exists():
    pass

# Count - efficient counting
count = Post.objects.filter(status='published').count()</code></pre>
                </div>
            </div>
        </div>

        <div class="fw-section">
            <h2>CRUD Operations</h2>
            <div class="code-example">
                <pre><code class="language-python"># CREATE
user = User.objects.create(username='john', email='john@example.com')
# or
user = User(username='john', email='john@example.com')
user.save()

# Bulk create (much faster for many objects)
User.objects.bulk_create([
    User(username='user1', email='user1@example.com'),
    User(username='user2', email='user2@example.com'),
], batch_size=1000)

# Get or create
user, created = User.objects.get_or_create(
    email='john@example.com',
    defaults={'username': 'john'}
)

# UPDATE
Post.objects.filter(status='draft').update(status='published')  # Bulk update

# Update or create
obj, created = Post.objects.update_or_create(
    slug='my-post',
    defaults={'title': 'My Post', 'content': '...'}
)

# DELETE
Post.objects.filter(status='archived').delete()

# Soft delete pattern
class Post(models.Model):
    deleted_at = models.DateTimeField(null=True, blank=True)

    class Manager(models.Manager):
        def get_queryset(self):
            return super().get_queryset().filter(deleted_at__isnull=True)

    objects = Manager()
    all_objects = models.Manager()  # Include deleted</code></pre>
            </div>
        </div>

        <div class="fw-section">
            <h2>Transactions</h2>
            <div class="code-example">
                <pre><code class="language-python">from django.db import transaction

# Context manager
with transaction.atomic():
    user = User.objects.create(username='john')
    Profile.objects.create(user=user, bio='...')
    # If any error occurs, both are rolled back

# Decorator
@transaction.atomic
def create_user_with_profile(data):
    user = User.objects.create(**data['user'])
    Profile.objects.create(user=user, **data['profile'])
    return user

# Savepoints
with transaction.atomic():
    user = User.objects.create(username='john')

    try:
        with transaction.atomic():
            # Nested atomic block = savepoint
            do_something_risky()
    except Exception:
        # Only the nested block is rolled back
        pass

    # user creation is still committed

# Select for update (row-level locking)
with transaction.atomic():
    post = Post.objects.select_for_update().get(pk=1)
    post.views_count += 1
    post.save()</code></pre>
            </div>
        </div>

        <div class="fw-section">
            <h2>Raw SQL & Database Functions</h2>
            <div class="code-example">
                <pre><code class="language-python"># Raw queries (use sparingly)
users = User.objects.raw('SELECT * FROM users WHERE karma > %s', [100])

# Extra SQL (deprecated, use annotations instead)
# Post.objects.extra(select={'is_recent': 'created_at > NOW() - INTERVAL 1 DAY'})

# Database functions
from django.db.models.functions import Now, ExtractYear, Coalesce, Length

Post.objects.annotate(
    year=ExtractYear('created_at'),
    title_length=Length('title'),
    display_name=Coalesce('title', Value('Untitled'))
).filter(created_at__lt=Now())

# Custom database function
from django.db.models import Func

class FullTextSearch(Func):
    function = 'to_tsvector'
    template = "%(function)s('english', %(expressions)s)"</code></pre>
            </div>
        </div>
    </div>

    <aside class="page-sidebar">
        <div class="panel">
            <div class="panel-header">QuerySet Methods</div>
            <div class="quick-ref-item"><span class="quick-ref-key">filter()</span><span class="quick-ref-value">WHERE clause</span></div>
            <div class="quick-ref-item"><span class="quick-ref-key">exclude()</span><span class="quick-ref-value">NOT WHERE</span></div>
            <div class="quick-ref-item"><span class="quick-ref-key">annotate()</span><span class="quick-ref-value">Add computed</span></div>
            <div class="quick-ref-item"><span class="quick-ref-key">aggregate()</span><span class="quick-ref-value">Total stats</span></div>
        </div>
        <div class="panel mt-4">
            <div class="panel-header">Optimization</div>
            <div class="quick-ref-item"><span class="quick-ref-key">select_related</span><span class="quick-ref-value">FK/O2O JOIN</span></div>
            <div class="quick-ref-item"><span class="quick-ref-key">prefetch_related</span><span class="quick-ref-value">M2M/reverse</span></div>
            <div class="quick-ref-item"><span class="quick-ref-key">only/defer</span><span class="quick-ref-value">Limit fields</span></div>
        </div>
        <div class="panel mt-4">
            <div class="panel-header">Related</div>
            <a href="/frameworks/django" class="quick-ref-item" style="display:block;text-decoration:none;">Django Basics</a>
            <a href="/frameworks/django-rest" class="quick-ref-item" style="display:block;text-decoration:none;">Django REST</a>
        </div>
    </aside>
</div>

<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true, theme: 'base' });</script>
