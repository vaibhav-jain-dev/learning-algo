<div class="guide-page">
    <nav class="breadcrumb">
        <a href="/">Home</a> <span class="breadcrumb-sep">/</span> <span>Python Asyncio</span>
    </nav>

    <div class="guide-header">
        <div class="guide-header-content">
            <span class="guide-badge python-badge">Python 3.10+</span>
            <h1>Python Asyncio Complete Guide</h1>
            <p class="guide-description">Master asynchronous programming in Python - from language basics to production-ready patterns</p>
            <div class="guide-stats">
                <div class="stat-item">
                    <span class="stat-icon">&#128218;</span>
                    <span class="stat-text">4 Sections</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">&#9889;</span>
                    <span class="stat-text">Interactive Code</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">&#128200;</span>
                    <span class="stat-text">Beginner to Advanced</span>
                </div>
            </div>
        </div>
    </div>

    <div class="guide-nav">
        <a href="#python-basics" class="guide-nav-link active" data-section="python-basics">
            <span class="nav-icon">&#128013;</span> Python Basics
        </a>
        <a href="#basic" class="guide-nav-link" data-section="basic">
            <span class="nav-icon">&#9881;</span> Async Basics
        </a>
        <a href="#intermediate" class="guide-nav-link" data-section="intermediate">
            <span class="nav-icon">&#128295;</span> Intermediate
        </a>
        <a href="#advanced" class="guide-nav-link" data-section="advanced">
            <span class="nav-icon">&#128640;</span> Advanced
        </a>
    </div>

    <!-- PYTHON BASICS SECTION -->
    <section id="python-basics" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#128013;</span> Python Language Fundamentals</h2>
            <p class="section-description">Essential Python concepts you need before diving into asyncio</p>
        </div>

        <div class="topic-block highlight-block">
            <div class="block-header">
                <span class="block-icon">&#128161;</span>
                <h3>Why Learn Python Basics First?</h3>
            </div>
            <p>Before mastering asyncio, you need a solid foundation in Python fundamentals. Understanding functions, classes, generators, and decorators will make async concepts much clearer.</p>

            <div class="concept-grid">
                <div class="concept-card">
                    <span class="concept-icon">&#128221;</span>
                    <h4>Variables & Types</h4>
                    <p>Dynamic typing, type hints, data structures</p>
                </div>
                <div class="concept-card">
                    <span class="concept-icon">&#9881;</span>
                    <h4>Functions</h4>
                    <p>First-class functions, *args, **kwargs</p>
                </div>
                <div class="concept-card">
                    <span class="concept-icon">&#128230;</span>
                    <h4>Classes</h4>
                    <p>OOP, dunder methods, context managers</p>
                </div>
                <div class="concept-card">
                    <span class="concept-icon">&#127922;</span>
                    <h4>Generators</h4>
                    <p>yield, iterators, lazy evaluation</p>
                </div>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128221;</span>
                <h3>Variables, Types, and Data Structures</h3>
            </div>
            <p>Python is dynamically typed but supports type hints for better code quality.</p>

            <div class="code-example">
                <pre><code class="language-python"># Python Variables and Type Hints
from typing import List, Dict, Optional, Tuple

# Basic types
name: str = "Alice"
age: int = 30
price: float = 19.99
is_active: bool = True

# Collections
numbers: List[int] = [1, 2, 3, 4, 5]
user_data: Dict[str, str] = {"name": "Alice", "email": "alice@example.com"}
coordinates: Tuple[int, int] = (10, 20)

# Optional (can be None)
middle_name: Optional[str] = None

# List comprehensions - Pythonic way to create lists
squares = [x**2 for x in range(10)]
print(f"Squares: {squares}")

# Dict comprehension
word_lengths = {word: len(word) for word in ["apple", "banana", "cherry"]}
print(f"Word lengths: {word_lengths}")

# Set comprehension
unique_chars = {char for char in "hello world" if char != " "}
print(f"Unique chars: {unique_chars}")

# Unpacking
first, *middle, last = [1, 2, 3, 4, 5]
print(f"First: {first}, Middle: {middle}, Last: {last}")

# Dictionary unpacking
config = {"host": "localhost", "port": 8080}
print("Host: {host}, Port: {port}".format(**config))</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#9881;</span>
                <h3>Functions - First-Class Citizens</h3>
            </div>
            <p>In Python, functions are first-class objects - they can be passed around, returned, and stored in variables. This is fundamental to understanding async callbacks and handlers.</p>

            <div class="code-example">
                <pre><code class="language-python">from typing import Callable

# Functions are objects
def greet(name: str) -> str:
    return f"Hello, {name}!"

# Assign function to variable
say_hello = greet
print(say_hello("World"))

# Functions with *args and **kwargs
def flexible_function(*args, **kwargs):
    print(f"Positional args: {args}")
    print(f"Keyword args: {kwargs}")

flexible_function(1, 2, 3, name="Alice", age=30)

# Higher-order functions (take or return functions)
def create_multiplier(factor: int) -> Callable[[int], int]:
    def multiplier(x: int) -> int:
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)
print(f"Double 5: {double(5)}")
print(f"Triple 5: {triple(5)}")

# Lambda functions (anonymous functions)
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_nums = sorted(numbers, key=lambda x: -x)  # Sort descending
print(f"Sorted descending: {sorted_nums}")

# Map, filter, reduce
from functools import reduce

nums = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, nums))
evens = list(filter(lambda x: x % 2 == 0, nums))
total = reduce(lambda a, b: a + b, nums)

print(f"Squared: {squared}")
print(f"Evens: {evens}")
print(f"Total: {total}")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Classes and OOP</h3>
            </div>
            <p>Understanding classes is essential for async context managers and custom async iterators.</p>

            <div class="code-example">
                <pre><code class="language-python">from typing import Optional

class User:
    """A simple User class demonstrating Python OOP."""

    # Class variable (shared by all instances)
    user_count: int = 0

    def __init__(self, name: str, email: str):
        # Instance variables
        self.name = name
        self.email = email
        self._password: Optional[str] = None  # Convention: _ means "private"
        User.user_count += 1

    # Instance method
    def greet(self) -> str:
        return f"Hi, I'm {self.name}!"

    # Property decorator for getter
    @property
    def password(self) -> str:
        return "****" if self._password else "Not set"

    # Property setter
    @password.setter
    def password(self, value: str):
        if len(value) < 8:
            raise ValueError("Password must be at least 8 characters")
        self._password = value

    # Class method (operates on class, not instance)
    @classmethod
    def get_user_count(cls) -> int:
        return cls.user_count

    # Static method (utility function, no access to self or cls)
    @staticmethod
    def validate_email(email: str) -> bool:
        return "@" in email and "." in email

    # String representation
    def __repr__(self) -> str:
        return f"User(name={self.name!r}, email={self.email!r})"

# Using the class
user1 = User("Alice", "alice@example.com")
user2 = User("Bob", "bob@example.com")

print(user1.greet())
print(f"Total users: {User.get_user_count()}")
print(f"Valid email: {User.validate_email('test@test.com')}")

# Using property
user1.password = "secure123"
print(f"Password: {user1.password}")

print(f"Repr: {user1!r}")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128268;</span>
                <h3>Context Managers (with statement)</h3>
            </div>
            <p>Context managers handle setup/teardown automatically. Understanding them is crucial for <code>async with</code>.</p>

            <div class="code-example">
                <pre><code class="language-python">import time

# Context manager using class
class Timer:
    """Measure execution time of a code block."""

    def __init__(self, name: str = "Operation"):
        self.name = name
        self.start_time = None

    def __enter__(self):
        self.start_time = time.time()
        print(f"{self.name}: Starting...")
        return self  # Value bound to 'as' variable

    def __exit__(self, exc_type, exc_val, exc_tb):
        elapsed = time.time() - self.start_time
        print(f"{self.name}: Completed in {elapsed:.4f}s")

        # Handle exceptions (return True to suppress)
        if exc_type is not None:
            print(f"{self.name}: Error occurred - {exc_val}")
        return False  # Don't suppress exceptions

# Using the context manager
with Timer("Calculation") as t:
    total = sum(range(100000))
    print(f"Sum: {total}")

# Context manager using contextlib (simpler)
from contextlib import contextmanager

@contextmanager
def temp_directory_context(name: str):
    """Simulates creating and cleaning up a temp directory."""
    print(f"Creating temp directory: {name}")
    try:
        yield name  # Value for 'as' clause
    finally:
        print(f"Cleaning up temp directory: {name}")

with temp_directory_context("my_temp") as dirname:
    print(f"Working in: {dirname}")
    # Do work...

print("\nDone!")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#127922;</span>
                <h3>Generators and Iterators</h3>
            </div>

            <div class="info-box">
                <div class="info-header">
                    <span class="info-icon">&#128161;</span>
                    <span>Key Insight</span>
                </div>
                <p><strong>Generators are the foundation of async/await!</strong> The <code>yield</code> keyword in generators is conceptually similar to <code>await</code> - both pause execution and can resume later.</p>
            </div>

            <div class="code-example">
                <pre><code class="language-python"># Simple generator function
def countdown(n: int):
    """Yields numbers from n down to 1."""
    print("Starting countdown...")
    while n > 0:
        yield n  # Pause here, return value
        n -= 1
    print("Blastoff!")

# Using the generator
print("=== Countdown Generator ===")
for num in countdown(3):
    print(f"T-minus {num}")

# Generator expression (like list comprehension but lazy)
print("\n=== Generator Expression ===")
squares_gen = (x**2 for x in range(5))  # Not evaluated yet!
print(f"Generator object: {squares_gen}")
print(f"Values: {list(squares_gen)}")

# Generators for memory efficiency
def read_large_file_lines(filename: str):
    """Simulates reading a large file line by line."""
    for i in range(1000000):
        yield f"Line {i}: Some data here"

# Only processes one line at a time - no memory explosion!
line_gen = read_large_file_lines("huge.txt")
print("\n=== First 3 lines ===")
for i, line in enumerate(line_gen):
    if i >= 3:
        break
    print(line)

# yield from - delegate to another generator
def combined_generator():
    yield from range(3)
    yield from ['a', 'b', 'c']
    yield from (x**2 for x in range(3, 6))

print("\n=== Combined Generator ===")
print(list(combined_generator()))

# Two-way communication with send()
def accumulator():
    """Generator that accumulates values sent to it."""
    total = 0
    while True:
        value = yield total  # Receive value, yield total
        if value is None:
            break
        total += value

print("\n=== Accumulator ===")
acc = accumulator()
next(acc)  # Prime the generator
print(f"Send 10: {acc.send(10)}")
print(f"Send 20: {acc.send(20)}")
print(f"Send 5: {acc.send(5)}")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#127873;</span>
                <h3>Decorators</h3>
            </div>
            <p>Decorators wrap functions to add behavior. Many async patterns use decorators.</p>

            <div class="code-example">
                <pre><code class="language-python">import time
from functools import wraps
from typing import Callable, Any

# Basic decorator
def timer_decorator(func: Callable) -> Callable:
    """Decorator that times function execution."""
    @wraps(func)  # Preserves function metadata
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"{func.__name__} took {elapsed:.4f}s")
        return result
    return wrapper

@timer_decorator
def slow_function():
    """A slow function."""
    time.sleep(0.1)
    return "Done"

print("=== Timer Decorator ===")
result = slow_function()
print(f"Result: {result}")
print(f"Function name preserved: {slow_function.__name__}")

# Decorator with arguments
def retry(max_attempts: int = 3, delay: float = 0.1):
    """Decorator that retries a function on failure."""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_error = None
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_error = e
                    print(f"Attempt {attempt} failed: {e}")
                    if attempt < max_attempts:
                        time.sleep(delay)
            raise last_error
        return wrapper
    return decorator

attempt_count = 0

@retry(max_attempts=3, delay=0.05)
def flaky_function():
    """Fails twice, then succeeds."""
    global attempt_count
    attempt_count += 1
    if attempt_count < 3:
        raise ValueError("Random failure!")
    return "Success!"

print("\n=== Retry Decorator ===")
try:
    result = flaky_function()
    print(f"Final result: {result}")
except Exception as e:
    print(f"All attempts failed: {e}")

# Class-based decorator
class CacheDecorator:
    """Simple memoization cache."""

    def __init__(self, func: Callable):
        self.func = func
        self.cache = {}

    def __call__(self, *args):
        if args not in self.cache:
            self.cache[args] = self.func(*args)
        return self.cache[args]

@CacheDecorator
def fibonacci(n: int) -> int:
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print("\n=== Cache Decorator ===")
print(f"fib(10) = {fibonacci(10)}")
print(f"fib(20) = {fibonacci(20)}")
print(f"fib(30) = {fibonacci(30)}")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>
    </section>

    <!-- ASYNC BASICS SECTION -->
    <section id="basic" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#9881;</span> Understanding Python's Concurrency Model</h2>
            <p class="section-description">How asyncio works under the hood and why it exists</p>
        </div>

        <div class="topic-block highlight-block">
            <div class="block-header">
                <span class="block-icon">&#128274;</span>
                <h3>What is the GIL (Global Interpreter Lock)?</h3>
            </div>
            <p>The GIL is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecode simultaneously. This is why Python is often called "single-threaded" despite having a <code>threading</code> module.</p>

            <div class="diagram-container">
                <div class="diagram-title">GIL Impact on Threading</div>
                <div class="mermaid">
flowchart LR
    subgraph "CPU-Bound (GIL Blocks)"
        T1[Thread 1] -->|Blocked| GIL[GIL Lock]
        T2[Thread 2] -->|Blocked| GIL
        GIL -->|Only 1| CPU[CPU Core]
    end

    subgraph "I/O-Bound (GIL Released)"
        T3[Thread 1] -->|Released| IO1[Network I/O]
        T4[Thread 2] -->|Released| IO2[Disk I/O]
    end
                </div>
            </div>

            <h4>Why Does Python Have the GIL?</h4>
            <div class="feature-list">
                <div class="feature-item">
                    <span class="feature-icon">&#128190;</span>
                    <div>
                        <strong>Memory Management</strong>
                        <p>Python uses reference counting. The GIL prevents race conditions when modifying reference counts.</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">&#128268;</span>
                    <div>
                        <strong>C Extensions</strong>
                        <p>Many C extensions are not thread-safe. The GIL makes it easier to integrate C libraries.</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">&#9889;</span>
                    <div>
                        <strong>Simplicity</strong>
                        <p>Single-threaded execution simplifies the interpreter implementation.</p>
                    </div>
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-python">import threading
import time

# This demonstrates the GIL limitation
# CPU-bound tasks don't benefit from threading

counter = 0

def cpu_bound_task(iterations):
    global counter
    for _ in range(iterations):
        counter += 1

# Single threaded
start = time.time()
counter = 0
cpu_bound_task(1000000)
cpu_bound_task(1000000)
single_time = time.time() - start
print(f"Single-threaded: {single_time:.3f}s, counter={counter}")

# Multi-threaded (GIL prevents true parallelism)
start = time.time()
counter = 0
t1 = threading.Thread(target=cpu_bound_task, args=(1000000,))
t2 = threading.Thread(target=cpu_bound_task, args=(1000000,))
t1.start()
t2.start()
t1.join()
t2.join()
multi_time = time.time() - start
print(f"Multi-threaded: {multi_time:.3f}s, counter={counter}")
print(f"Note: Multi-threaded may be slower due to GIL contention!")
print(f"Counter may be less than 2M due to race conditions")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>When Threading DOES Help</h4>
            <p>Threading helps with I/O-bound tasks because the GIL is released during I/O operations.</p>

            <div class="code-example">
                <pre><code class="language-python">import threading
import time

def io_bound_task(name, duration):
    """Simulates I/O operation - GIL is released during sleep"""
    print(f"Task {name}: Starting")
    time.sleep(duration)  # GIL released here!
    print(f"Task {name}: Done")

# Sequential
start = time.time()
io_bound_task("A", 0.2)
io_bound_task("B", 0.2)
sequential_time = time.time() - start
print(f"Sequential: {sequential_time:.3f}s\n")

# Threaded - actually runs in parallel!
start = time.time()
threads = [
    threading.Thread(target=io_bound_task, args=("C", 0.2)),
    threading.Thread(target=io_bound_task, args=("D", 0.2)),
]
for t in threads:
    t.start()
for t in threads:
    t.join()
threaded_time = time.time() - start
print(f"Threaded: {threaded_time:.3f}s")
print(f"Speedup: {sequential_time/threaded_time:.1f}x")</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <div class="info-box info-success">
                <div class="info-header">
                    <span class="info-icon">&#128640;</span>
                    <span>Future of Python: Free-Threading (PEP 703)</span>
                </div>
                <p>Python 3.13+ introduces experimental free-threading mode (no GIL). This is a major step toward true parallelism. For now, use <strong>asyncio for I/O-bound</strong> and <strong>multiprocessing for CPU-bound</strong> tasks.</p>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128260;</span>
                <h3>Why Asyncio? The Event Loop Model</h3>
            </div>
            <p>Asyncio uses cooperative multitasking - tasks voluntarily yield control. This avoids GIL issues and thread overhead while handling thousands of concurrent I/O operations.</p>

            <div class="diagram-container">
                <div class="diagram-title">Event Loop - Cooperative Multitasking</div>
                <div class="mermaid">
sequenceDiagram
    participant EL as Event Loop
    participant T1 as Task 1
    participant T2 as Task 2
    participant T3 as Task 3

    EL->>T1: Start
    T1->>T1: Run until await
    T1-->>EL: Yield (await sleep)
    EL->>T2: Start
    T2->>T2: Run until await
    T2-->>EL: Yield (await fetch)
    EL->>T3: Start
    T3->>T3: Run until await
    T3-->>EL: Yield (await read)
    Note over EL: All waiting on I/O
    EL->>T1: Resume (sleep done)
    T1->>T1: Continue
    T1-->>EL: Complete
                </div>
            </div>

            <div class="comparison-table">
                <div class="comparison-header">
                    <div class="comparison-title">Threading vs Asyncio</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Threading</th>
                            <th>Asyncio</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Switching</td>
                            <td>Preemptive (OS decides)</td>
                            <td>Cooperative (code decides)</td>
                        </tr>
                        <tr>
                            <td>Memory</td>
                            <td>~8MB per thread</td>
                            <td>~KB per task</td>
                        </tr>
                        <tr>
                            <td>Scalability</td>
                            <td>Hundreds of threads</td>
                            <td>Millions of tasks</td>
                        </tr>
                        <tr>
                            <td>Race Conditions</td>
                            <td>Common (need locks)</td>
                            <td>Rare (single thread)</td>
                        </tr>
                        <tr>
                            <td>Best For</td>
                            <td>Blocking I/O libs</td>
                            <td>Modern async I/O</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="code-example">
                <pre><code class="language-python">import asyncio
import time

async def fetch_data(name, delay):
    """Simulates async I/O operation"""
    print(f"Task {name}: Starting fetch")
    await asyncio.sleep(delay)  # Yields control to event loop
    print(f"Task {name}: Data received")
    return f"Data from {name}"

async def main():
    start = time.time()

    # Run concurrently with gather
    results = await asyncio.gather(
        fetch_data("API-1", 0.2),
        fetch_data("API-2", 0.2),
        fetch_data("API-3", 0.2),
    )

    elapsed = time.time() - start
    print(f"\nResults: {results}")
    print(f"Total time: {elapsed:.3f}s (not 0.6s!)")

# Run the async function
asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128273;</span>
                <h3>Essential Asyncio Keywords and Functions</h3>
            </div>

            <h4>async def - Define Coroutine</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

# Regular function
def regular_function():
    return "I'm synchronous"

# Coroutine function - must be awaited
async def async_function():
    return "I'm asynchronous"

async def main():
    # Regular function - call directly
    result1 = regular_function()
    print(f"Regular: {result1}")

    # Async function - must await
    result2 = await async_function()
    print(f"Async: {result2}")

    # Calling without await returns coroutine object (not the result!)
    coro = async_function()
    print(f"Without await: {coro}")
    print(f"Type: {type(coro)}")

    # Must await to get actual result
    result3 = await coro
    print(f"After await: {result3}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>await - Pause and Wait</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio
import time

async def step1():
    print("Step 1: Starting")
    await asyncio.sleep(0.1)  # Pause here, let other tasks run
    print("Step 1: Done")
    return "Result 1"

async def step2():
    print("Step 2: Starting")
    await asyncio.sleep(0.1)
    print("Step 2: Done")
    return "Result 2"

async def main():
    start = time.time()

    # Sequential await - runs one after another
    print("=== Sequential ===")
    r1 = await step1()
    r2 = await step2()
    print(f"Sequential time: {time.time() - start:.3f}s\n")

    # Concurrent - use asyncio.gather
    start = time.time()
    print("=== Concurrent ===")
    r1, r2 = await asyncio.gather(step1(), step2())
    print(f"Concurrent time: {time.time() - start:.3f}s")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>asyncio.gather - Run Multiple Coroutines</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

async def fetch_user(user_id):
    await asyncio.sleep(0.05)
    return {"id": user_id, "name": f"User {user_id}"}

async def fetch_with_error(user_id):
    await asyncio.sleep(0.05)
    if user_id == 3:
        raise ValueError(f"User {user_id} not found")
    return {"id": user_id, "name": f"User {user_id}"}

async def main():
    # Basic gather
    print("=== Basic gather ===")
    users = await asyncio.gather(
        fetch_user(1),
        fetch_user(2),
        fetch_user(3),
    )
    print(f"Users: {users}\n")

    # Gather with error handling
    print("=== With return_exceptions ===")
    results = await asyncio.gather(
        fetch_with_error(1),
        fetch_with_error(2),
        fetch_with_error(3),  # This will raise
        fetch_with_error(4),
        return_exceptions=True  # Don't stop on error
    )

    for i, result in enumerate(results, 1):
        if isinstance(result, Exception):
            print(f"User {i}: ERROR - {result}")
        else:
            print(f"User {i}: {result}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>asyncio.create_task - Fire and Forget</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

async def background_task(name, duration):
    print(f"Background {name}: Started")
    await asyncio.sleep(duration)
    print(f"Background {name}: Completed")
    return f"Result from {name}"

async def main():
    print("Creating tasks...")

    # Create tasks - they start running immediately
    task1 = asyncio.create_task(background_task("A", 0.2))
    task2 = asyncio.create_task(background_task("B", 0.1))

    print("Tasks created, doing other work...")
    await asyncio.sleep(0.05)
    print("Other work done\n")

    # Now wait for results
    result1 = await task1
    result2 = await task2

    print(f"\nResults: {result1}, {result2}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header warning-header">
                <span class="block-icon">&#9888;</span>
                <h3>Important: What to Take Care of</h3>
            </div>

            <h4>1. Never Block the Event Loop</h4>
            <div class="warning-box">
                <p><strong>Critical:</strong> Using blocking calls like <code>time.sleep()</code> or synchronous I/O will freeze ALL async tasks!</p>
            </div>

            <div class="code-example">
                <pre><code class="language-python">import asyncio
import time

# BAD: This blocks the entire event loop
async def bad_blocking():
    print("Bad: Starting blocking operation")
    time.sleep(0.2)  # BLOCKS everything!
    print("Bad: Done")

# GOOD: Use async sleep
async def good_async():
    print("Good: Starting async operation")
    await asyncio.sleep(0.2)  # Yields control
    print("Good: Done")

async def other_task():
    for i in range(3):
        print(f"  Other task: tick {i}")
        await asyncio.sleep(0.05)

async def demo_bad():
    print("=== BAD: Blocking call ===")
    await asyncio.gather(
        bad_blocking(),
        other_task(),  # This won't run until bad_blocking finishes!
    )

async def demo_good():
    print("\n=== GOOD: Async call ===")
    await asyncio.gather(
        good_async(),
        other_task(),  # Runs concurrently!
    )

asyncio.run(demo_bad())
asyncio.run(demo_good())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>2. Run Blocking Code in Executor</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio
import time

def blocking_io_operation(name, duration):
    """Simulates a blocking I/O operation (like a sync HTTP library)"""
    print(f"  Blocking {name}: Starting")
    time.sleep(duration)  # Blocking!
    print(f"  Blocking {name}: Done")
    return f"Result from {name}"

async def run_in_executor_demo():
    print("Running blocking code in executor...")
    loop = asyncio.get_event_loop()

    start = time.time()

    # Run blocking functions in thread pool
    results = await asyncio.gather(
        loop.run_in_executor(None, blocking_io_operation, "A", 0.1),
        loop.run_in_executor(None, blocking_io_operation, "B", 0.1),
        loop.run_in_executor(None, blocking_io_operation, "C", 0.1),
    )

    print(f"\nResults: {results}")
    print(f"Time: {time.time() - start:.3f}s (concurrent!)")

asyncio.run(run_in_executor_demo())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>3. Handle Exceptions Properly</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

async def risky_operation(should_fail):
    await asyncio.sleep(0.05)
    if should_fail:
        raise ValueError("Something went wrong!")
    return "Success"

async def main():
    # Method 1: Try/except around await
    print("=== Method 1: try/except ===")
    try:
        result = await risky_operation(True)
    except ValueError as e:
        print(f"Caught error: {e}")

    # Method 2: gather with return_exceptions
    print("\n=== Method 2: return_exceptions ===")
    results = await asyncio.gather(
        risky_operation(False),
        risky_operation(True),
        risky_operation(False),
        return_exceptions=True
    )
    for i, r in enumerate(results):
        if isinstance(r, Exception):
            print(f"Task {i}: Error - {r}")
        else:
            print(f"Task {i}: {r}")

    # Method 3: asyncio.wait with FIRST_EXCEPTION
    print("\n=== Method 3: asyncio.wait ===")
    tasks = [
        asyncio.create_task(risky_operation(False)),
        asyncio.create_task(risky_operation(True)),
    ]
    done, pending = await asyncio.wait(
        tasks,
        return_when=asyncio.FIRST_EXCEPTION
    )

    print(f"Done: {len(done)}, Pending: {len(pending)}")
    for task in done:
        if task.exception():
            print(f"Task failed: {task.exception()}")
        else:
            print(f"Task succeeded: {task.result()}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>
    </section>

    <!-- INTERMEDIATE SECTION -->
    <section id="intermediate" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#128295;</span> Intermediate - Practical Async Patterns</h2>
            <p class="section-description">Real-world patterns for building async applications</p>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Async Context Managers</h3>
            </div>
            <p>Use <code>async with</code> for resources that need async setup/teardown.</p>

            <div class="code-example">
                <pre><code class="language-python">import asyncio

class AsyncDatabaseConnection:
    def __init__(self, name):
        self.name = name
        self.connected = False

    async def __aenter__(self):
        print(f"DB {self.name}: Connecting...")
        await asyncio.sleep(0.05)  # Simulate connection
        self.connected = True
        print(f"DB {self.name}: Connected")
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print(f"DB {self.name}: Disconnecting...")
        await asyncio.sleep(0.02)  # Simulate cleanup
        self.connected = False
        print(f"DB {self.name}: Disconnected")
        return False  # Don't suppress exceptions

    async def query(self, sql):
        if not self.connected:
            raise RuntimeError("Not connected!")
        await asyncio.sleep(0.03)
        return f"Results for: {sql}"

async def main():
    # Using async context manager
    async with AsyncDatabaseConnection("primary") as db:
        result = await db.query("SELECT * FROM users")
        print(f"Query result: {result}")

    print("\nConnection automatically closed!")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128260;</span>
                <h3>Async Iterators and Generators</h3>
            </div>
            <p>Use <code>async for</code> to iterate over async data streams.</p>

            <div class="code-example">
                <pre><code class="language-python">import asyncio

class AsyncCounter:
    """Async iterator - implements __aiter__ and __anext__"""
    def __init__(self, stop):
        self.current = 0
        self.stop = stop

    def __aiter__(self):
        return self

    async def __anext__(self):
        if self.current >= self.stop:
            raise StopAsyncIteration
        await asyncio.sleep(0.05)  # Simulate async data fetch
        self.current += 1
        return self.current

async def async_generator(n):
    """Async generator - simpler syntax"""
    for i in range(n):
        await asyncio.sleep(0.05)
        yield i * 2

async def main():
    # Using async iterator
    print("=== Async Iterator ===")
    async for num in AsyncCounter(3):
        print(f"Got: {num}")

    # Using async generator
    print("\n=== Async Generator ===")
    async for num in async_generator(4):
        print(f"Generated: {num}")

    # Collecting all values
    print("\n=== Collecting to list ===")
    values = [x async for x in async_generator(5)]
    print(f"All values: {values}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#9200;</span>
                <h3>Timeouts and Cancellation</h3>
            </div>

            <h4>asyncio.timeout (Python 3.11+) / asyncio.wait_for</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

async def slow_operation(duration):
    print(f"Starting operation (will take {duration}s)")
    await asyncio.sleep(duration)
    print("Operation completed")
    return "Success"

async def main():
    # Method 1: wait_for (works in all Python 3 versions)
    print("=== wait_for with timeout ===")
    try:
        result = await asyncio.wait_for(
            slow_operation(0.5),
            timeout=0.1  # Only wait 0.1 seconds
        )
        print(f"Result: {result}")
    except asyncio.TimeoutError:
        print("Operation timed out!")

    # Successful case
    print("\n=== Successful operation ===")
    result = await asyncio.wait_for(slow_operation(0.05), timeout=0.2)
    print(f"Result: {result}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>

            <h4>Task Cancellation</h4>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

async def long_running_task(name):
    try:
        print(f"Task {name}: Starting")
        for i in range(10):
            await asyncio.sleep(0.05)
            print(f"Task {name}: Step {i+1}")
        print(f"Task {name}: Completed")
        return f"Result from {name}"
    except asyncio.CancelledError:
        print(f"Task {name}: Cancelled! Cleaning up...")
        # Perform cleanup here
        raise  # Re-raise to properly cancel

async def main():
    # Create task
    task = asyncio.create_task(long_running_task("Worker"))

    # Let it run for a bit
    await asyncio.sleep(0.15)

    # Cancel it
    print("\nMain: Cancelling task...")
    task.cancel()

    # Wait for cancellation
    try:
        await task
    except asyncio.CancelledError:
        print("Main: Task was cancelled")

    print(f"Task cancelled: {task.cancelled()}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Queues for Producer-Consumer Pattern</h3>
            </div>

            <div class="diagram-container">
                <div class="diagram-title">Producer-Consumer with Queue</div>
                <div class="mermaid">
flowchart LR
    P1[Producer 1] -->|put| Q[(Async Queue)]
    P2[Producer 2] -->|put| Q
    Q -->|get| C1[Consumer 1]
    Q -->|get| C2[Consumer 2]
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-python">import asyncio
import random

async def producer(queue, name, count):
    """Produces items and puts them in the queue"""
    for i in range(count):
        item = f"{name}-item-{i}"
        await asyncio.sleep(random.uniform(0.01, 0.05))
        await queue.put(item)
        print(f"Producer {name}: Added {item}")
    print(f"Producer {name}: Done")

async def consumer(queue, name):
    """Consumes items from the queue"""
    while True:
        try:
            item = await asyncio.wait_for(queue.get(), timeout=0.2)
            print(f"  Consumer {name}: Processing {item}")
            await asyncio.sleep(0.03)  # Process time
            queue.task_done()
        except asyncio.TimeoutError:
            print(f"  Consumer {name}: No more items, exiting")
            break

async def main():
    queue = asyncio.Queue(maxsize=5)  # Bounded queue

    # Start consumers first
    consumers = [
        asyncio.create_task(consumer(queue, "C1")),
        asyncio.create_task(consumer(queue, "C2")),
    ]

    # Start producers
    producers = [
        asyncio.create_task(producer(queue, "P1", 3)),
        asyncio.create_task(producer(queue, "P2", 3)),
    ]

    # Wait for producers to finish
    await asyncio.gather(*producers)
    print("\nAll producers done")

    # Wait for queue to be fully processed
    await queue.join()
    print("Queue empty")

    # Consumers will exit on timeout
    await asyncio.gather(*consumers)
    print("\nAll done!")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128274;</span>
                <h3>Locks and Synchronization</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

class AsyncCounter:
    def __init__(self):
        self.value = 0
        self.lock = asyncio.Lock()

    async def increment_unsafe(self):
        # Race condition possible!
        temp = self.value
        await asyncio.sleep(0.001)  # Simulate some work
        self.value = temp + 1

    async def increment_safe(self):
        async with self.lock:
            temp = self.value
            await asyncio.sleep(0.001)
            self.value = temp + 1

async def main():
    counter = AsyncCounter()

    # Unsafe - race condition
    print("=== Unsafe increment ===")
    counter.value = 0
    tasks = [asyncio.create_task(counter.increment_unsafe()) for _ in range(10)]
    await asyncio.gather(*tasks)
    print(f"Expected: 10, Got: {counter.value}")

    # Safe - with lock
    print("\n=== Safe increment ===")
    counter.value = 0
    tasks = [asyncio.create_task(counter.increment_safe()) for _ in range(10)]
    await asyncio.gather(*tasks)
    print(f"Expected: 10, Got: {counter.value}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128295;</span>
                <h3>Semaphores for Rate Limiting</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-python">import asyncio
import time

async def fetch_url(semaphore, url):
    async with semaphore:  # Only N concurrent requests
        print(f"Fetching: {url}")
        await asyncio.sleep(0.1)  # Simulate network request
        print(f"Done: {url}")
        return f"Data from {url}"

async def main():
    # Limit to 3 concurrent requests
    semaphore = asyncio.Semaphore(3)

    urls = [f"https://api.example.com/item/{i}" for i in range(10)]

    start = time.time()

    tasks = [fetch_url(semaphore, url) for url in urls]
    results = await asyncio.gather(*tasks)

    elapsed = time.time() - start
    print(f"\nFetched {len(results)} URLs in {elapsed:.2f}s")
    print(f"(With limit of 3 concurrent, 10 URLs at 0.1s each = ~0.4s)")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>
    </section>

    <!-- ADVANCED SECTION -->
    <section id="advanced" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#128640;</span> Advanced - Production-Ready Patterns</h2>
            <p class="section-description">Battle-tested patterns for production async applications</p>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Connection Pool Pattern</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-python">import asyncio
from collections import deque

class AsyncConnectionPool:
    def __init__(self, max_size=5):
        self.max_size = max_size
        self.pool = deque()
        self.size = 0
        self.lock = asyncio.Lock()
        self.available = asyncio.Condition(self.lock)

    async def _create_connection(self):
        """Create a new connection"""
        await asyncio.sleep(0.05)  # Simulate connection setup
        return {"id": self.size, "status": "connected"}

    async def acquire(self):
        """Get a connection from the pool"""
        async with self.available:
            while not self.pool and self.size >= self.max_size:
                print("  Pool exhausted, waiting...")
                await self.available.wait()

            if self.pool:
                conn = self.pool.popleft()
                print(f"  Reusing connection {conn['id']}")
                return conn

            self.size += 1
            conn = await self._create_connection()
            print(f"  Created new connection {conn['id']}")
            return conn

    async def release(self, conn):
        """Return a connection to the pool"""
        async with self.available:
            self.pool.append(conn)
            self.available.notify()
            print(f"  Released connection {conn['id']}")

async def worker(pool, name):
    print(f"Worker {name}: Requesting connection")
    conn = await pool.acquire()
    print(f"Worker {name}: Got connection {conn['id']}")

    await asyncio.sleep(0.1)  # Do work

    await pool.release(conn)
    print(f"Worker {name}: Done")

async def main():
    pool = AsyncConnectionPool(max_size=2)

    # Start 5 workers with only 2 connections
    workers = [worker(pool, f"W{i}") for i in range(5)]
    await asyncio.gather(*workers)

    print(f"\nFinal pool size: {len(pool.pool)} available, {pool.size} total")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128260;</span>
                <h3>Retry Pattern with Exponential Backoff</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-python">import asyncio
import random

class RetryError(Exception):
    pass

async def unreliable_api_call(attempt):
    """Simulates an unreliable API that fails sometimes"""
    await asyncio.sleep(0.05)
    if attempt < 3:  # Fail first 2 attempts
        raise ConnectionError(f"API unavailable (attempt {attempt})")
    return "API Response"

async def retry_with_backoff(
    coro_func,
    max_retries=5,
    base_delay=0.1,
    max_delay=2.0,
    exponential_base=2
):
    """Retry a coroutine with exponential backoff"""
    last_exception = None

    for attempt in range(1, max_retries + 1):
        try:
            return await coro_func(attempt)
        except Exception as e:
            last_exception = e

            if attempt == max_retries:
                break

            # Calculate delay with jitter
            delay = min(
                base_delay * (exponential_base ** (attempt - 1)),
                max_delay
            )
            delay *= (0.5 + random.random())  # Add jitter

            print(f"Attempt {attempt} failed: {e}")
            print(f"Retrying in {delay:.2f}s...")
            await asyncio.sleep(delay)

    raise RetryError(f"Failed after {max_retries} retries") from last_exception

async def main():
    print("=== Retry with exponential backoff ===")
    try:
        result = await retry_with_backoff(unreliable_api_call)
        print(f"Success: {result}")
    except RetryError as e:
        print(f"Failed: {e}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#9889;</span>
                <h3>Circuit Breaker Pattern</h3>
            </div>

            <div class="diagram-container">
                <div class="diagram-title">Circuit Breaker State Machine</div>
                <div class="mermaid">
stateDiagram-v2
    [*] --> Closed
    Closed --> Open : Failures >= Threshold
    Open --> HalfOpen : Timeout Elapsed
    HalfOpen --> Closed : Success
    HalfOpen --> Open : Failure
    Closed --> Closed : Success (reset count)
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-python">import asyncio
import time
from enum import Enum

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    def __init__(self, failure_threshold=3, reset_timeout=0.5):
        self.failure_threshold = failure_threshold
        self.reset_timeout = reset_timeout
        self.state = CircuitState.CLOSED
        self.failures = 0
        self.last_failure_time = None
        self.lock = asyncio.Lock()

    async def call(self, coro):
        async with self.lock:
            if self.state == CircuitState.OPEN:
                if time.time() - self.last_failure_time > self.reset_timeout:
                    print("Circuit: OPEN -> HALF_OPEN")
                    self.state = CircuitState.HALF_OPEN
                else:
                    raise Exception("Circuit breaker is OPEN")

        try:
            result = await coro
            async with self.lock:
                if self.state == CircuitState.HALF_OPEN:
                    print("Circuit: HALF_OPEN -> CLOSED")
                    self.state = CircuitState.CLOSED
                self.failures = 0
            return result
        except Exception as e:
            async with self.lock:
                self.failures += 1
                self.last_failure_time = time.time()

                if self.failures >= self.failure_threshold:
                    print(f"Circuit: -> OPEN (failures: {self.failures})")
                    self.state = CircuitState.OPEN
            raise

async def unreliable_service(call_num):
    await asyncio.sleep(0.05)
    if call_num <= 4:  # First 4 calls fail
        raise ConnectionError("Service unavailable")
    return f"Success (call {call_num})"

async def main():
    cb = CircuitBreaker(failure_threshold=3, reset_timeout=0.3)

    for i in range(1, 8):
        print(f"\nCall {i}:")
        try:
            result = await cb.call(unreliable_service(i))
            print(f"  Result: {result}")
        except Exception as e:
            print(f"  Error: {e}")

        await asyncio.sleep(0.1)

    # Wait for reset
    print("\nWaiting for circuit reset...")
    await asyncio.sleep(0.4)

    print("\nRetrying after reset:")
    try:
        result = await cb.call(unreliable_service(10))
        print(f"  Result: {result}")
    except Exception as e:
        print(f"  Error: {e}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128721;</span>
                <h3>Graceful Shutdown with Signal Handling</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

class GracefulServer:
    def __init__(self):
        self.running = True
        self.active_tasks = set()

    async def handle_request(self, request_id):
        task = asyncio.current_task()
        self.active_tasks.add(task)

        try:
            print(f"Request {request_id}: Processing")
            await asyncio.sleep(0.2)  # Simulate work
            print(f"Request {request_id}: Done")
            return f"Response {request_id}"
        except asyncio.CancelledError:
            print(f"Request {request_id}: Cancelled, cleaning up")
            raise
        finally:
            self.active_tasks.discard(task)

    async def shutdown(self):
        print("\nShutting down gracefully...")
        self.running = False

        if self.active_tasks:
            print(f"Waiting for {len(self.active_tasks)} active tasks...")
            await asyncio.gather(*self.active_tasks, return_exceptions=True)

        print("Shutdown complete")

    async def run(self):
        # Start some "requests"
        for i in range(5):
            if not self.running:
                break
            asyncio.create_task(self.handle_request(i))
            await asyncio.sleep(0.05)

        # Simulate shutdown after some time
        await asyncio.sleep(0.1)
        print("\n--- Initiating shutdown ---")
        await self.shutdown()

async def main():
    server = GracefulServer()
    await server.run()

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128276;</span>
                <h3>Async Event for Coordination</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-python">import asyncio

async def waiter(event, name):
    print(f"Waiter {name}: Waiting for event...")
    await event.wait()
    print(f"Waiter {name}: Event received!")
    return f"Waiter {name} done"

async def setter(event, delay):
    print(f"Setter: Will set event in {delay}s")
    await asyncio.sleep(delay)
    print("Setter: Setting event now!")
    event.set()

async def main():
    event = asyncio.Event()

    # Start waiters and setter concurrently
    results = await asyncio.gather(
        waiter(event, "A"),
        waiter(event, "B"),
        waiter(event, "C"),
        setter(event, 0.2),
    )

    print(f"\nResults: {results[:3]}")  # Only waiter results
    print(f"Event is set: {event.is_set()}")

    # Clear and reuse
    print("\n--- Reset event ---")
    event.clear()
    print(f"Event is set after clear: {event.is_set()}")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128336;</span>
                <h3>Async Debounce Pattern</h3>
            </div>
            <p>Useful for rate-limiting rapid events (like search-as-you-type).</p>

            <div class="code-example">
                <pre><code class="language-python">import asyncio

class AsyncDebouncer:
    def __init__(self, delay):
        self.delay = delay
        self.pending_task = None

    async def debounce(self, coro):
        """Cancel previous pending call and schedule new one"""
        if self.pending_task:
            self.pending_task.cancel()
            try:
                await self.pending_task
            except asyncio.CancelledError:
                pass

        self.pending_task = asyncio.create_task(self._delayed_call(coro))
        return await self.pending_task

    async def _delayed_call(self, coro):
        await asyncio.sleep(self.delay)
        return await coro

async def search_api(query):
    print(f"  API: Searching for '{query}'")
    await asyncio.sleep(0.05)
    return f"Results for: {query}"

async def main():
    debouncer = AsyncDebouncer(delay=0.1)

    # Simulate rapid typing
    queries = ["p", "py", "pyt", "pyth", "pytho", "python"]

    print("Simulating rapid search queries...")
    tasks = []
    for query in queries:
        print(f"User typed: {query}")
        # Only the last query should actually execute
        task = asyncio.create_task(debouncer.debounce(search_api(query)))
        tasks.append(task)
        await asyncio.sleep(0.03)  # User types fast

    # Wait a bit for debounced call to complete
    await asyncio.sleep(0.2)

    print("\nOnly the final query was executed!")

asyncio.run(main())</code></pre>
                <button class="run-code-btn" data-language="python">Run Code</button>
            </div>
        </div>
    </section>
</div>

<style>
/* Enhanced Guide Page Styles */
.guide-page {
    max-width: 1100px;
    margin: 0 auto;
    padding: 2rem;
}

/* Breadcrumb */
.breadcrumb {
    margin-bottom: 1.5rem;
    font-size: 0.9rem;
}

.breadcrumb a {
    color: #3776AB;
    text-decoration: none;
}

.breadcrumb a:hover {
    text-decoration: underline;
}

.breadcrumb-sep {
    margin: 0 0.5rem;
    color: var(--color-text-muted, #94a3b8);
}

/* Guide Header */
.guide-header {
    text-align: center;
    margin-bottom: 2.5rem;
    padding: 2.5rem;
    background: linear-gradient(135deg, #3776AB10 0%, #FFD43B10 100%);
    border-radius: 1rem;
    border: 1px solid #3776AB30;
}

.guide-badge {
    display: inline-block;
    padding: 0.35rem 1rem;
    background: linear-gradient(135deg, #3776AB 0%, #FFD43B 100%);
    color: white;
    border-radius: 2rem;
    font-size: 0.85rem;
    font-weight: 600;
    margin-bottom: 1rem;
}

.guide-header h1 {
    margin: 0.5rem 0;
    font-size: 2.5rem;
    background: linear-gradient(135deg, #3776AB 0%, #2c5d87 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.guide-description {
    color: var(--color-text-secondary, #475569);
    font-size: 1.15rem;
    margin-bottom: 1.5rem;
}

.guide-stats {
    display: flex;
    justify-content: center;
    gap: 2rem;
    flex-wrap: wrap;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--color-text-secondary, #475569);
    font-size: 0.9rem;
}

.stat-icon {
    font-size: 1.1rem;
}

/* Navigation */
.guide-nav {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    margin-bottom: 2rem;
    padding: 0.75rem;
    background: var(--color-bg-primary, #ffffff);
    border-radius: 1rem;
    border: 1px solid var(--color-border, #e2e8f0);
    position: sticky;
    top: 70px;
    z-index: 50;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    flex-wrap: wrap;
}

.guide-nav-link {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.6rem 1.2rem;
    border-radius: 0.5rem;
    text-decoration: none;
    color: var(--color-text-secondary, #475569);
    font-weight: 500;
    font-size: 0.9rem;
    transition: all 0.2s;
}

.guide-nav-link:hover {
    background: var(--color-bg-secondary, #f8fafc);
    color: var(--color-text-primary, #0f172a);
}

.guide-nav-link.active {
    background: linear-gradient(135deg, #3776AB 0%, #2c5d87 100%);
    color: white;
}

.nav-icon {
    font-size: 1rem;
}

/* Section Headers */
.section-header {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 3px solid #3776AB;
}

.section-header h2 {
    font-size: 1.75rem;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.section-icon {
    font-size: 1.5rem;
}

.section-description {
    color: var(--color-text-secondary, #475569);
    font-size: 1.05rem;
    margin: 0;
}

/* Guide Section */
.guide-section {
    margin-bottom: 3rem;
    padding-top: 1rem;
}

/* Topic Block */
.topic-block {
    background: var(--color-bg-primary, #ffffff);
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 1rem;
    padding: 1.75rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.topic-block.highlight-block {
    background: linear-gradient(135deg, #3776AB08 0%, #ffffff 100%);
    border-color: #3776AB40;
}

.block-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1rem;
}

.block-header.warning-header {
    color: #f59e0b;
}

.block-icon {
    font-size: 1.5rem;
}

.topic-block h3 {
    font-size: 1.3rem;
    margin: 0;
    color: var(--color-text-primary, #0f172a);
}

.topic-block h4 {
    font-size: 1.1rem;
    margin-top: 1.75rem;
    margin-bottom: 0.75rem;
    color: #3776AB;
}

.topic-block p {
    color: var(--color-text-secondary, #475569);
    margin-bottom: 1rem;
    line-height: 1.7;
}

.topic-block ul, .topic-block ol {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
    color: var(--color-text-secondary, #475569);
}

.topic-block li {
    margin-bottom: 0.5rem;
    line-height: 1.6;
}

.topic-block code {
    background: #3776AB15;
    padding: 0.2rem 0.5rem;
    border-radius: 0.25rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.875rem;
    color: #3776AB;
}

/* Concept Grid */
.concept-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1.5rem;
}

.concept-card {
    background: var(--color-bg-secondary, #f8fafc);
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 0.75rem;
    padding: 1.25rem;
    text-align: center;
    transition: all 0.2s;
}

.concept-card:hover {
    border-color: #3776AB;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(55, 118, 171, 0.15);
}

.concept-icon {
    font-size: 2rem;
    display: block;
    margin-bottom: 0.75rem;
}

.concept-card h4 {
    margin: 0 0 0.5rem 0;
    color: var(--color-text-primary, #0f172a);
    font-size: 1rem;
}

.concept-card p {
    margin: 0;
    font-size: 0.85rem;
    color: var(--color-text-muted, #94a3b8);
}

/* Feature List */
.feature-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin: 1.5rem 0;
}

.feature-item {
    display: flex;
    gap: 1rem;
    align-items: flex-start;
    padding: 1rem;
    background: var(--color-bg-secondary, #f8fafc);
    border-radius: 0.75rem;
    border-left: 4px solid #3776AB;
}

.feature-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.feature-item strong {
    color: var(--color-text-primary, #0f172a);
    display: block;
    margin-bottom: 0.25rem;
}

.feature-item p {
    margin: 0;
    font-size: 0.9rem;
}

/* Info Box */
.info-box {
    background: linear-gradient(135deg, #3b82f610 0%, #06b6d410 100%);
    border: 1px solid #3b82f640;
    border-radius: 0.75rem;
    padding: 1.25rem;
    margin: 1.5rem 0;
}

.info-box.info-success {
    background: linear-gradient(135deg, #10b98110 0%, #06b6d410 100%);
    border-color: #10b98140;
}

.info-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: #3b82f6;
}

.info-box.info-success .info-header {
    color: #10b981;
}

.info-icon {
    font-size: 1.25rem;
}

.info-box p {
    margin: 0;
    line-height: 1.6;
}

/* Warning Box */
.warning-box {
    background: #fef3c710;
    border: 1px solid #f59e0b40;
    border-left: 4px solid #f59e0b;
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
}

.warning-box p {
    margin: 0;
    color: #92400e;
}

/* Diagram Container */
.diagram-container {
    background: var(--color-bg-secondary, #f8fafc);
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin: 1.5rem 0;
    overflow-x: auto;
}

.diagram-title {
    font-weight: 600;
    color: var(--color-text-primary, #0f172a);
    margin-bottom: 1rem;
    text-align: center;
}

/* Comparison Table */
.comparison-table {
    margin: 1.5rem 0;
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 0.75rem;
    overflow: hidden;
}

.comparison-header {
    background: linear-gradient(135deg, #3776AB 0%, #2c5d87 100%);
    padding: 0.75rem 1rem;
}

.comparison-title {
    color: white;
    font-weight: 600;
    margin: 0;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
}

.comparison-table th,
.comparison-table td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border, #e2e8f0);
}

.comparison-table th {
    background: var(--color-bg-secondary, #f8fafc);
    font-weight: 600;
    color: var(--color-text-primary, #0f172a);
}

.comparison-table td {
    color: var(--color-text-secondary, #475569);
    font-size: 0.9rem;
}

.comparison-table tr:last-child td {
    border-bottom: none;
}

/* Code Example */
.code-example {
    position: relative;
    margin: 1.25rem 0;
}

.code-example pre {
    background: #1e293b;
    border-radius: 0.75rem;
    padding: 1.25rem;
    padding-top: 3rem;
    overflow-x: auto;
    margin: 0;
    border: 1px solid #334155;
}

.code-example pre code {
    background: none;
    padding: 0;
    color: #e2e8f0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    line-height: 1.6;
}

.run-code-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    padding: 0.5rem 1.25rem;
    background: linear-gradient(135deg, #3776AB 0%, #2c5d87 100%);
    color: white;
    border: none;
    border-radius: 0.5rem;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 600;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 0.4rem;
}

.run-code-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(55, 118, 171, 0.4);
}

.run-code-btn:disabled {
    background: #64748b;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Code Output */
.code-output {
    margin-top: 0.5rem;
}

.code-output pre {
    padding: 1rem;
    border-radius: 0.5rem;
    font-size: 0.85rem;
    max-height: 300px;
    overflow-y: auto;
}

.success-output {
    background: #0f172a;
    border: 1px solid #10b98140;
    color: #4ade80;
}

.error-output {
    background: #1e0a0a;
    border: 1px solid #ef444440;
    color: #f87171;
}

/* Mermaid diagrams */
.mermaid {
    display: flex;
    justify-content: center;
}

/* Responsive */
@media (max-width: 768px) {
    .guide-page {
        padding: 1rem;
    }

    .guide-header {
        padding: 1.5rem;
    }

    .guide-header h1 {
        font-size: 1.75rem;
    }

    .guide-stats {
        gap: 1rem;
    }

    .guide-nav {
        position: static;
        flex-direction: column;
    }

    .guide-nav-link {
        justify-content: center;
    }

    .concept-grid {
        grid-template-columns: 1fr;
    }

    .comparison-table {
        font-size: 0.85rem;
    }

    .code-example pre {
        padding-top: 3.5rem;
    }
}

/* Syntax highlighting colors for Python code */
.code-example pre code .hljs-keyword,
.code-example pre code .token.keyword {
    color: #ff7b72;
}

.code-example pre code .hljs-built_in,
.code-example pre code .hljs-type,
.code-example pre code .token.builtin {
    color: #79c0ff;
}

.code-example pre code .hljs-string,
.code-example pre code .token.string {
    color: #a5d6ff !important;
}

.code-example pre code .hljs-number,
.code-example pre code .token.number {
    color: #79c0ff;
}

.code-example pre code .hljs-comment,
.code-example pre code .token.comment {
    color: #8b949e;
    font-style: italic;
}

.code-example pre code .hljs-function,
.code-example pre code .hljs-title,
.code-example pre code .token.function {
    color: #d2a8ff;
}

.code-example pre code .hljs-params,
.code-example pre code .token.parameter {
    color: #e6edf3;
}

.code-example pre code .hljs-variable,
.code-example pre code .token.variable {
    color: #ffa657;
}

.code-example pre code .hljs-operator,
.code-example pre code .token.operator {
    color: #ff7b72;
}

/* Ensure string literals are visible */
.code-example pre code span[class*="string"] {
    color: #a5d6ff !important;
}
</style>

<script>
(function() {
    // Navigation highlighting
    const navLinks = document.querySelectorAll('.guide-nav-link');
    const sections = document.querySelectorAll('.guide-section');

    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            navLinks.forEach(l => l.classList.remove('active'));
            this.classList.add('active');
        });
    });

    // Scroll spy
    window.addEventListener('scroll', function() {
        let current = '';
        sections.forEach(section => {
            const sectionTop = section.offsetTop - 150;
            if (pageYOffset >= sectionTop) {
                current = section.getAttribute('id');
            }
        });

        navLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('data-section') === current) {
                link.classList.add('active');
            }
        });
    });

    // Run code buttons
    document.querySelectorAll('.run-code-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const codeBlock = this.parentElement.querySelector('code');
            let code = codeBlock.textContent;
            const language = this.dataset.language || 'python';

            // Wrap Python code in main() if it doesn't have one
            if (language === 'python' && !code.includes('def main(')) {
                // Indent the code and wrap in main()
                const indentedCode = code.split('\n').map(line => '    ' + line).join('\n');
                code = `def main():\n${indentedCode}\n    return None`;
            }

            this.disabled = true;
            this.textContent = 'Running...';

            fetch('/api/run', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({code: code, language: language})
            })
            .then(response => response.json())
            .then(data => {
                if (data.id) {
                    let pollCount = 0;
                    const maxPolls = 120;
                    const checkResult = () => {
                        pollCount++;
                        fetch('/api/execution/' + data.id)
                        .then(r => r.json())
                        .then(result => {
                            if (result.state === 'complete' || result.state === 'error' || result.state === 'stopped') {
                                this.disabled = false;
                                this.textContent = 'Run Code';

                                let outputDiv = this.parentElement.querySelector('.code-output');
                                if (!outputDiv) {
                                    outputDiv = document.createElement('div');
                                    outputDiv.className = 'code-output';
                                    this.parentElement.appendChild(outputDiv);
                                }

                                if (result.error) {
                                    outputDiv.innerHTML = '<pre class="error-output">' + escapeHtml(result.error) + '</pre>';
                                } else {
                                    outputDiv.innerHTML = '<pre class="success-output">' + escapeHtml(result.output || 'No output') + '</pre>';
                                }
                            } else if (pollCount >= maxPolls) {
                                this.disabled = false;
                                this.textContent = 'Run Code';
                                let outputDiv = this.parentElement.querySelector('.code-output');
                                if (!outputDiv) {
                                    outputDiv = document.createElement('div');
                                    outputDiv.className = 'code-output';
                                    this.parentElement.appendChild(outputDiv);
                                }
                                outputDiv.innerHTML = '<pre class="error-output">Execution timed out</pre>';
                            } else {
                                setTimeout(checkResult, 500);
                            }
                        });
                    };
                    checkResult();
                }
            })
            .catch(err => {
                this.disabled = false;
                this.textContent = 'Run Code';
                alert('Error: ' + err.message);
            });
        });
    });

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Initialize Mermaid if available
    if (typeof mermaid !== 'undefined') {
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    }

    // Highlight code if hljs available
    if (typeof hljs !== 'undefined') {
        document.querySelectorAll('.code-example pre code').forEach(block => {
            hljs.highlightElement(block);
        });
    }
})();
</script>
