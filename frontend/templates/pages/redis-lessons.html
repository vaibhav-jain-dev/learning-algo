{{define "title"}}{{.Title}}{{end}}

{{define "content"}}
<div class="container mx-auto px-4 py-8 max-w-7xl">
    <!-- Header -->
    <div class="mb-8">
        <div class="flex items-center gap-4 mb-4">
            <a href="/redis" class="text-gray-400 hover:text-white transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
            </a>
            <h1 class="text-3xl font-bold text-white">Redis Lessons</h1>
        </div>
        <p class="text-gray-400">Master Redis in-memory data structures and commands</p>
    </div>

    <!-- Lessons Navigation -->
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
        <!-- Sidebar -->
        <div class="lg:col-span-1">
            <nav class="bg-gray-800 rounded-lg p-4 sticky top-4">
                <h3 class="text-lg font-semibold text-white mb-4">Curriculum</h3>
                <ul class="space-y-2">
                    <li>
                        <a href="#fundamentals" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            1. Redis Fundamentals
                        </a>
                    </li>
                    <li>
                        <a href="#strings" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            2. Strings
                        </a>
                    </li>
                    <li>
                        <a href="#lists" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            3. Lists
                        </a>
                    </li>
                    <li>
                        <a href="#sets" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            4. Sets
                        </a>
                    </li>
                    <li>
                        <a href="#hashes" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            5. Hashes
                        </a>
                    </li>
                    <li>
                        <a href="#sorted-sets" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            6. Sorted Sets
                        </a>
                    </li>
                    <li>
                        <a href="#keys" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            7. Key Management
                        </a>
                    </li>
                    <li>
                        <a href="#expiration" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            8. Expiration & TTL
                        </a>
                    </li>
                    <li>
                        <a href="#transactions" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            9. Transactions
                        </a>
                    </li>
                    <li>
                        <a href="#pubsub" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            10. Pub/Sub
                        </a>
                    </li>
                    <li>
                        <a href="#patterns" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            11. Common Patterns
                        </a>
                    </li>
                    <li>
                        <a href="#distributed" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            12. Distributed Systems
                        </a>
                    </li>
                    <li>
                        <a href="#caching-strategies" class="block text-gray-300 hover:text-red-400 transition-colors py-1">
                            13. Caching Strategies
                        </a>
                    </li>
                </ul>
            </nav>
        </div>

        <!-- Main Content -->
        <div class="lg:col-span-3 space-y-12">
            <!-- Lesson 1: Fundamentals -->
            <section id="fundamentals" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">1. Redis Fundamentals</h2>

                <div class="prose prose-invert max-w-none">
                    <h3 class="text-xl font-semibold text-red-400 mb-3">What is Redis?</h3>
                    <p class="text-gray-300 mb-4">
                        Redis (Remote Dictionary Server) is an open-source, in-memory data structure store used as a database,
                        cache, message broker, and streaming engine. It provides sub-millisecond response times and supports
                        millions of requests per second.
                    </p>

                    <!-- Deep Dive: Why is Redis So Fast? -->
                    <div class="bg-gray-900 border-l-4 border-red-500 rounded-r-lg p-4 mb-6">
                        <h4 class="text-lg font-semibold text-red-400 mb-2">Why is Redis So Fast?</h4>
                        <div class="text-gray-300 text-sm space-y-2">
                            <p><strong>1. In-Memory Storage:</strong> RAM is ~100,000x faster than disk. A typical HDD reads at 100 MB/s, while RAM operates at 20,000+ MB/s.</p>
                            <pre class="bg-gray-950 rounded p-3 my-2 text-xs overflow-x-auto"><code>Latency Comparison:
┌─────────────────┬──────────────────┬─────────────────┐
│ Operation       │ Time             │ Redis Advantage │
├─────────────────┼──────────────────┼─────────────────┤
│ L1 cache        │ 0.5 ns           │ -               │
│ L2 cache        │ 7 ns             │ -               │
│ RAM access      │ 100 ns           │ Redis lives here│
│ SSD read        │ 150,000 ns       │ 1,500x faster   │
│ HDD seek        │ 10,000,000 ns    │ 100,000x faster │
│ Network (DC)    │ 500,000 ns       │ -               │
└─────────────────┴──────────────────┴─────────────────┘</code></pre>
                            <p><strong>2. Single-Threaded Event Loop:</strong> No context switching, no locks, no race conditions. Redis processes commands sequentially using an efficient event loop (epoll/kqueue).</p>
                            <p><strong>3. Optimized Data Structures:</strong> Redis uses specialized data structures (like Skip Lists for Sorted Sets) that are optimized for the operations they support.</p>
                            <p><strong>4. Simple Protocol:</strong> RESP (Redis Serialization Protocol) is a simple text protocol with minimal parsing overhead.</p>
                        </div>
                    </div>

                    <!-- Redis vs SQL vs Memcached -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-6">
                        <h4 class="text-lg font-semibold text-red-400 mb-3">Redis vs SQL vs Memcached</h4>
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-700">
                                    <th class="text-left py-2">Feature</th>
                                    <th class="text-left py-2">SQL Database</th>
                                    <th class="text-left py-2">Memcached</th>
                                    <th class="text-left py-2">Redis</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-300">
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Speed</td>
                                    <td>~1-10ms</td>
                                    <td>&lt;1ms</td>
                                    <td class="text-red-400">&lt;1ms</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Data Types</td>
                                    <td>Tables/Rows</td>
                                    <td>Strings only</td>
                                    <td class="text-red-400">Multiple (Lists, Sets, Hashes...)</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Persistence</td>
                                    <td>Yes (ACID)</td>
                                    <td>No</td>
                                    <td class="text-red-400">Optional (RDB/AOF)</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Pub/Sub</td>
                                    <td>Limited</td>
                                    <td>No</td>
                                    <td class="text-red-400">Yes</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Transactions</td>
                                    <td>Full ACID</td>
                                    <td>No</td>
                                    <td class="text-red-400">MULTI/EXEC (no rollback)</td>
                                </tr>
                                <tr>
                                    <td class="py-2">Use Case</td>
                                    <td>Primary storage</td>
                                    <td>Simple caching</td>
                                    <td class="text-red-400">Caching, queues, real-time</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Key Features</h3>
                    <ul class="list-disc list-inside text-gray-300 mb-4 space-y-2">
                        <li><strong>In-Memory Storage:</strong> All data is stored in RAM for ultra-fast access</li>
                        <li><strong>Persistence Options:</strong> RDB snapshots and AOF (Append Only File) for durability</li>
                        <li><strong>Rich Data Types:</strong> Strings, Lists, Sets, Hashes, Sorted Sets, Streams, and more</li>
                        <li><strong>Atomic Operations:</strong> All operations are atomic, ensuring data consistency</li>
                        <li><strong>Pub/Sub Messaging:</strong> Built-in publish/subscribe messaging paradigm</li>
                        <li><strong>Lua Scripting:</strong> Server-side scripting for complex operations</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Data Types Overview</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-700">
                                    <th class="text-left py-2">Type</th>
                                    <th class="text-left py-2">Description</th>
                                    <th class="text-left py-2">Use Cases</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-300">
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-red-400">String</td>
                                    <td>Binary-safe strings up to 512MB</td>
                                    <td>Caching, counters, sessions</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-red-400">List</td>
                                    <td>Linked list of strings</td>
                                    <td>Queues, timelines, logs</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-red-400">Set</td>
                                    <td>Unordered collection of unique strings</td>
                                    <td>Tags, unique visitors, relationships</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-red-400">Hash</td>
                                    <td>Map of field-value pairs</td>
                                    <td>Objects, user profiles</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-red-400">Sorted Set</td>
                                    <td>Set with scores for ordering</td>
                                    <td>Leaderboards, rate limiting</td>
                                </tr>
                                <tr>
                                    <td class="py-2 font-mono text-red-400">Stream</td>
                                    <td>Append-only log data structure</td>
                                    <td>Event sourcing, messaging</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Basic Commands</h3>
                    <div class="bg-gray-900 rounded-lg p-4">
                        <pre class="text-green-400 text-sm"><code># Check connection
PING
# Response: PONG

# Get server information
INFO

# Select database (0-15)
SELECT 0

# Clear current database
FLUSHDB

# Clear all databases
FLUSHALL</code></pre>
                    </div>
                    <button onclick="tryCommand('PING')" class="mt-3 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Try PING
                    </button>
                </div>
            </section>

            <!-- Lesson 2: Strings -->
            <section id="strings" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">2. Strings</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Strings are the most basic Redis data type. They're binary-safe, meaning they can contain any data:
                        text, serialized objects, or binary data up to 512MB.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Basic String Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Set a key
SET name "John Doe"

# Get a key
GET name
# Response: "John Doe"

# Set with expiration (seconds)
SET session:123 "user_data" EX 3600

# Set with expiration (milliseconds)
SET session:123 "user_data" PX 3600000

# Set only if key doesn't exist (NX)
SET lock:resource "locked" NX

# Set only if key exists (XX)
SET counter 100 XX

# Set multiple keys
MSET key1 "value1" key2 "value2" key3 "value3"

# Get multiple keys
MGET key1 key2 key3</code></pre>
                    </div>
                    <button onclick="tryCommand('SET greeting \"Hello Redis\"')" class="mt-3 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Try SET
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Numeric Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Increment by 1
SET counter 10
INCR counter
# Response: 11

# Increment by specific amount
INCRBY counter 5
# Response: 16

# Increment float
INCRBYFLOAT price 0.50
# Response: "10.50"

# Decrement by 1
DECR counter

# Decrement by specific amount
DECRBY counter 3</code></pre>
                    </div>
                    <button onclick="tryCommand('SET demo:counter 0')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Initialize Counter
                    </button>
                    <button onclick="tryCommand('INCR demo:counter')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Try INCR
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">String Manipulation</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Append to string
SET message "Hello"
APPEND message " World"
GET message
# Response: "Hello World"

# Get string length
STRLEN message
# Response: 11

# Get substring
GETRANGE message 0 4
# Response: "Hello"

# Set substring
SETRANGE message 6 "Redis"
GET message
# Response: "Hello Redis"</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 3: Lists -->
            <section id="lists" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">3. Lists</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis Lists are linked lists of strings. They're perfect for implementing queues, stacks,
                        and maintaining ordered collections. Operations at the head and tail are O(1).
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Push and Pop Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Push to the left (head)
LPUSH tasks "task1" "task2" "task3"
# List: [task3, task2, task1]

# Push to the right (tail)
RPUSH tasks "task4" "task5"
# List: [task3, task2, task1, task4, task5]

# Pop from the left
LPOP tasks
# Response: "task3"

# Pop from the right
RPOP tasks
# Response: "task5"

# Pop multiple elements
LPOP tasks 2
# Response: ["task2", "task1"]</code></pre>
                    </div>
                    <button onclick="tryCommand('RPUSH demo:queue \"item1\" \"item2\" \"item3\"')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Create Queue
                    </button>
                    <button onclick="tryCommand('LPOP demo:queue')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Pop from Queue
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Range and Index Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Get range of elements (0-indexed)
LRANGE tasks 0 -1  # All elements
LRANGE tasks 0 2   # First 3 elements

# Get element by index
LINDEX tasks 0
# Response: first element

# Get list length
LLEN tasks

# Set element at index
LSET tasks 0 "updated_task"

# Insert before/after element
LINSERT tasks BEFORE "task2" "new_task"
LINSERT tasks AFTER "task2" "another_task"</code></pre>
                    </div>
                    <button onclick="tryCommand('LRANGE demo:queue 0 -1')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        View Queue
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Blocking Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Blocking pop (wait for element)
BLPOP queue 30  # Wait up to 30 seconds
BRPOP queue 30

# Move element between lists (blocking)
BLMOVE source dest LEFT RIGHT 10

# Useful for worker queues:
# Producer: RPUSH jobs "job_data"
# Consumer: BLPOP jobs 0  # Wait forever</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Message Queue</h4>
                        <pre class="text-gray-300 text-sm"><code># Producer adds messages
RPUSH message_queue '{"type":"email","to":"user@example.com"}'

# Consumer processes messages (blocking)
BLPOP message_queue 0</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 4: Sets -->
            <section id="sets" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">4. Sets</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis Sets are unordered collections of unique strings. They support fast O(1) membership testing
                        and powerful set operations like union, intersection, and difference.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Basic Set Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Add members
SADD tags "python" "redis" "docker" "golang"

# Check membership
SISMEMBER tags "python"
# Response: 1 (true)

SISMEMBER tags "java"
# Response: 0 (false)

# Get all members
SMEMBERS tags

# Get random member(s)
SRANDMEMBER tags      # One random
SRANDMEMBER tags 3    # Three random

# Remove members
SREM tags "docker"

# Pop random member
SPOP tags</code></pre>
                    </div>
                    <button onclick="tryCommand('SADD demo:skills \"python\" \"javascript\" \"go\" \"rust\"')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Create Set
                    </button>
                    <button onclick="tryCommand('SMEMBERS demo:skills')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        View Set
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Set Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Setup example sets
SADD user:1:skills "python" "redis" "sql"
SADD user:2:skills "python" "javascript" "react"

# Union (all unique elements from both)
SUNION user:1:skills user:2:skills
# [python, redis, sql, javascript, react]

# Intersection (common elements)
SINTER user:1:skills user:2:skills
# [python]

# Difference (in first but not second)
SDIFF user:1:skills user:2:skills
# [redis, sql]

# Store results in new set
SUNIONSTORE all:skills user:1:skills user:2:skills
SINTERSTORE common:skills user:1:skills user:2:skills

# Get set cardinality (size)
SCARD tags</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Tracking Unique Visitors</h4>
                        <pre class="text-gray-300 text-sm"><code># Add visitor to today's set
SADD visitors:2024-01-15 "user:123"
SADD visitors:2024-01-15 "user:456"

# Count unique visitors today
SCARD visitors:2024-01-15

# Find visitors who came both days
SINTER visitors:2024-01-14 visitors:2024-01-15</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 5: Hashes -->
            <section id="hashes" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">5. Hashes</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis Hashes are maps of field-value pairs, perfect for representing objects.
                        They're memory-efficient and allow you to modify individual fields without fetching the entire object.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Basic Hash Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Set single field
HSET user:1000 name "John Doe"

# Set multiple fields
HSET user:1000 email "john@example.com" age 30 city "NYC"

# Alternative: HMSET (deprecated but works)
HMSET user:1000 name "John" email "john@example.com"

# Get single field
HGET user:1000 name
# Response: "John Doe"

# Get multiple fields
HMGET user:1000 name email city

# Get all fields and values
HGETALL user:1000

# Get all field names
HKEYS user:1000

# Get all values
HVALS user:1000</code></pre>
                    </div>
                    <button onclick="tryCommand('HSET demo:user name \"Alice\" email \"alice@example.com\" role \"admin\"')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Create Hash
                    </button>
                    <button onclick="tryCommand('HGETALL demo:user')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        View Hash
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Advanced Hash Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Check if field exists
HEXISTS user:1000 email
# Response: 1

# Delete fields
HDEL user:1000 age city

# Get number of fields
HLEN user:1000

# Increment numeric field
HINCRBY user:1000 login_count 1
HINCRBYFLOAT user:1000 balance 10.50

# Set only if field doesn't exist
HSETNX user:1000 created_at "2024-01-15"

# Get field string length
HSTRLEN user:1000 name</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Session Storage</h4>
                        <pre class="text-gray-300 text-sm"><code># Store session data
HSET session:abc123 user_id 1000 username "john" role "admin" last_access "2024-01-15T10:30:00Z"

# Update last access
HSET session:abc123 last_access "2024-01-15T10:45:00Z"

# Set expiration on entire hash
EXPIRE session:abc123 3600  # 1 hour</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 6: Sorted Sets -->
            <section id="sorted-sets" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">6. Sorted Sets</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Sorted Sets combine features of Sets and ordered lists. Each member has an associated score
                        that determines its position. Perfect for leaderboards, priority queues, and range queries.
                    </p>

                    <!-- Deep Dive: How Sorted Sets Work Internally -->
                    <div class="bg-gray-900 border-l-4 border-red-500 rounded-r-lg p-4 mb-6">
                        <h4 class="text-lg font-semibold text-red-400 mb-2">How Sorted Sets Work Internally (Skip Lists)</h4>
                        <div class="text-gray-300 text-sm space-y-2">
                            <p>Redis uses a <strong>Skip List</strong> + <strong>Hash Table</strong> for Sorted Sets:</p>
                            <pre class="bg-gray-950 rounded p-3 my-2 text-xs overflow-x-auto"><code>Skip List Structure (simplified):
Level 3: [HEAD] ────────────────────────────────> [90:charlie] ────────> [NULL]
Level 2: [HEAD] ────────> [50:bob] ────────────> [90:charlie] ────────> [NULL]
Level 1: [HEAD] ─> [30:alice] ─> [50:bob] ─> [70:david] ─> [90:charlie] ─> [NULL]

+ Hash Table: member → score
  {"alice": 30, "bob": 50, "david": 70, "charlie": 90}

Operations:
┌────────────────┬─────────────┬──────────────────────────────────────┐
│ Operation      │ Time        │ Why                                  │
├────────────────┼─────────────┼──────────────────────────────────────┤
│ ZADD           │ O(log n)    │ Skip list insertion                  │
│ ZSCORE         │ O(1)        │ Hash table lookup                    │
│ ZRANK          │ O(log n)    │ Skip list traversal                  │
│ ZRANGE         │ O(log n + m)│ Skip to start, then traverse m items │
│ ZRANGEBYSCORE  │ O(log n + m)│ Binary search + traverse             │
└────────────────┴─────────────┴──────────────────────────────────────┘</code></pre>
                            <p><strong>Why Skip Lists instead of Balanced Trees?</strong></p>
                            <ul class="list-disc list-inside text-gray-400 pl-2">
                                <li>Simpler to implement correctly</li>
                                <li>Easier to modify concurrently</li>
                                <li>Better cache locality for range queries</li>
                                <li>Same O(log n) complexity as trees</li>
                            </ul>
                        </div>
                    </div>

                    <!-- When to use which data structure -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-6">
                        <h4 class="text-lg font-semibold text-red-400 mb-3">Choosing the Right Data Structure</h4>
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-700">
                                    <th class="text-left py-2">Need</th>
                                    <th class="text-left py-2">Use</th>
                                    <th class="text-left py-2">Example</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-300">
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Simple key-value</td>
                                    <td class="text-red-400">String</td>
                                    <td>Session data, counters</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Object with fields</td>
                                    <td class="text-red-400">Hash</td>
                                    <td>User profile, product details</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">FIFO queue</td>
                                    <td class="text-red-400">List (LPUSH/RPOP)</td>
                                    <td>Task queue, message queue</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Unique items, no order</td>
                                    <td class="text-red-400">Set</td>
                                    <td>Tags, unique visitors</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Ranked/scored items</td>
                                    <td class="text-red-400">Sorted Set</td>
                                    <td>Leaderboard, scheduling</td>
                                </tr>
                                <tr>
                                    <td class="py-2">Event log/stream</td>
                                    <td class="text-red-400">Stream</td>
                                    <td>Activity feed, audit log</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Basic Sorted Set Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Add members with scores
ZADD leaderboard 100 "player1" 85 "player2" 92 "player3"

# Add with options
ZADD leaderboard NX 80 "player4"  # Only if not exists
ZADD leaderboard XX 95 "player1"  # Only if exists
ZADD leaderboard GT 90 "player2"  # Only if new score > current

# Get score
ZSCORE leaderboard "player1"
# Response: "100"

# Get rank (0-indexed, lowest score = 0)
ZRANK leaderboard "player2"

# Get reverse rank (highest score = 0)
ZREVRANK leaderboard "player1"

# Count members
ZCARD leaderboard</code></pre>
                    </div>
                    <button onclick="tryCommand('ZADD demo:leaderboard 1500 \"alice\" 1200 \"bob\" 1800 \"charlie\" 900 \"david\"')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Create Leaderboard
                    </button>
                    <button onclick="tryCommand('ZREVRANGE demo:leaderboard 0 -1 WITHSCORES')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        View Rankings
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Range Queries</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Get by rank range (low to high)
ZRANGE leaderboard 0 2
ZRANGE leaderboard 0 2 WITHSCORES

# Get by rank range (high to low)
ZREVRANGE leaderboard 0 2 WITHSCORES

# Get by score range
ZRANGEBYSCORE leaderboard 80 100
ZRANGEBYSCORE leaderboard 80 100 WITHSCORES

# Get by score range (descending)
ZREVRANGEBYSCORE leaderboard 100 80

# Count in score range
ZCOUNT leaderboard 80 100

# Remove by rank range
ZREMRANGEBYRANK leaderboard 0 1

# Remove by score range
ZREMRANGEBYSCORE leaderboard 0 50</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Score Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Increment score
ZINCRBY leaderboard 10 "player1"
# Response: new score

# Union of sorted sets (combine leaderboards)
ZUNIONSTORE combined 2 leaderboard1 leaderboard2 WEIGHTS 1 1 AGGREGATE SUM

# Intersection with scores
ZINTERSTORE common 2 set1 set2 AGGREGATE MIN</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Rate Limiting</h4>
                        <pre class="text-gray-300 text-sm"><code># Sliding window rate limiter
# Score = timestamp, Member = request ID

# Add request
ZADD requests:user:123 1705312800 "req:1"

# Remove old requests (older than 1 minute)
ZREMRANGEBYSCORE requests:user:123 0 1705312740

# Count recent requests
ZCARD requests:user:123

# Block if > 100 requests per minute</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 7: Key Management -->
            <section id="keys" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">7. Key Management</h2>

                <div class="prose prose-invert max-w-none">
                    <h3 class="text-xl font-semibold text-red-400 mb-3">Key Operations</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Check if key exists
EXISTS mykey
EXISTS key1 key2 key3  # Returns count of existing keys

# Delete keys
DEL mykey
DEL key1 key2 key3  # Delete multiple

# Unlink (async delete for large keys)
UNLINK large_key

# Get key type
TYPE mykey
# Response: string, list, set, zset, hash, stream

# Rename key
RENAME oldkey newkey
RENAMENX oldkey newkey  # Only if newkey doesn't exist</code></pre>
                    </div>
                    <button onclick="tryCommand('KEYS demo:*')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        List Demo Keys
                    </button>
                    <button onclick="tryCommand('TYPE demo:user')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Check Type
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Finding Keys</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Find keys by pattern (use carefully in production!)
KEYS user:*          # All keys starting with "user:"
KEYS *session*       # Keys containing "session"
KEYS user:???        # user: followed by exactly 3 chars

# SCAN - safe iteration for production
SCAN 0 MATCH user:* COUNT 100
# Returns cursor and keys, continue with returned cursor

# Scan specific data structures
SSCAN myset 0 MATCH pattern* COUNT 100
HSCAN myhash 0 MATCH field* COUNT 100
ZSCAN myzset 0 MATCH member* COUNT 100</code></pre>
                    </div>

                    <div class="bg-yellow-900/30 border border-yellow-500 rounded-lg p-4 mt-4">
                        <h4 class="text-yellow-400 font-semibold mb-2">Warning: KEYS in Production</h4>
                        <p class="text-gray-300 text-sm">
                            Never use <code class="text-red-400">KEYS</code> in production environments! It blocks the server
                            while scanning all keys. Use <code class="text-green-400">SCAN</code> instead for safe iteration.
                        </p>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Key Naming Conventions</h3>
                    <div class="bg-gray-900 rounded-lg p-4">
                        <pre class="text-green-400 text-sm"><code># Use colons as separators
user:1000:profile
user:1000:settings
session:abc123
cache:products:featured

# Common patterns:
object-type:id              # user:1000
object-type:id:field        # user:1000:followers
environment:object:id       # prod:user:1000</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 8: Expiration -->
            <section id="expiration" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">8. Expiration & TTL</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis allows you to set expiration times on keys. Expired keys are automatically deleted.
                        This is essential for caching, sessions, and temporary data.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Setting Expiration</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Set expiration in seconds
EXPIRE mykey 3600          # Expire in 1 hour
EXPIREAT mykey 1705400000  # Expire at Unix timestamp

# Set expiration in milliseconds
PEXPIRE mykey 60000        # Expire in 60 seconds
PEXPIREAT mykey 1705400000000

# Set with creation
SET session:123 "data" EX 3600     # Seconds
SET session:123 "data" PX 3600000  # Milliseconds
SET session:123 "data" EXAT 1705400000  # Unix timestamp

# Set expiration only if key has no TTL
EXPIRE mykey 3600 NX

# Set expiration only if key has TTL
EXPIRE mykey 3600 XX

# Set only if new TTL > current TTL
EXPIRE mykey 7200 GT

# Set only if new TTL < current TTL
EXPIRE mykey 1800 LT</code></pre>
                    </div>
                    <button onclick="tryCommand('SET demo:temp \"temporary\" EX 60')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Set with TTL
                    </button>
                    <button onclick="tryCommand('TTL demo:temp')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Check TTL
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Checking TTL</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Get TTL in seconds
TTL mykey
# Returns:
#  -2 if key doesn't exist
#  -1 if key has no expiration
#  N  seconds remaining

# Get TTL in milliseconds
PTTL mykey

# Remove expiration (make persistent)
PERSIST mykey

# Get expiration as Unix timestamp
EXPIRETIME mykey
PEXPIRETIME mykey  # Milliseconds</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Cache with Refresh</h4>
                        <pre class="text-gray-300 text-sm"><code># Check cache, refresh on access
result = GET cache:data
if result:
    # Extend TTL on access (sliding expiration)
    EXPIRE cache:data 3600
    return result
else:
    # Fetch from database, cache it
    SET cache:data "fresh_data" EX 3600</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 9: Transactions -->
            <section id="transactions" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">9. Transactions</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis transactions allow you to execute multiple commands atomically. All commands in a
                        transaction are serialized and executed sequentially without interruption.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">MULTI/EXEC</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Start transaction
MULTI

# Queue commands
SET user:1:balance 100
DECRBY user:1:balance 50
INCRBY user:2:balance 50

# Execute all commands atomically
EXEC

# Discard transaction
MULTI
SET key1 "value1"
DISCARD  # Cancel transaction</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Optimistic Locking with WATCH</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Watch keys for changes
WATCH user:1:balance

# Get current value
balance = GET user:1:balance

# Start transaction
MULTI

# Queue commands
SET user:1:balance (balance - 50)

# Execute - fails if watched key changed
EXEC
# Returns nil if key was modified by another client

# Cancel watching
UNWATCH</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Transfer Money</h4>
                        <pre class="text-gray-300 text-sm"><code>WATCH account:A account:B
balanceA = GET account:A
balanceB = GET account:B

if balanceA >= amount:
    MULTI
    DECRBY account:A amount
    INCRBY account:B amount
    EXEC  # Atomic transfer
else:
    UNWATCH
    # Insufficient funds</code></pre>
                    </div>

                    <div class="bg-yellow-900/30 border border-yellow-500 rounded-lg p-4 mt-4">
                        <h4 class="text-yellow-400 font-semibold mb-2">Note: No Rollback</h4>
                        <p class="text-gray-300 text-sm">
                            Unlike SQL databases, Redis transactions don't support rollback. If a command fails
                            during EXEC, other commands still execute. Use Lua scripts for true atomicity with
                            conditional logic.
                        </p>
                    </div>
                </div>
            </section>

            <!-- Lesson 10: Pub/Sub -->
            <section id="pubsub" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">10. Pub/Sub Messaging</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis Pub/Sub implements the publish/subscribe messaging paradigm. Publishers send messages
                        to channels without knowing who will receive them, and subscribers receive messages from
                        channels they're interested in.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Basic Pub/Sub</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Subscriber (Client 1)
SUBSCRIBE news sports weather
# Blocks and waits for messages

# Publisher (Client 2)
PUBLISH news "Breaking: Redis 8.0 released!"
# Returns: number of subscribers who received message

# Unsubscribe
UNSUBSCRIBE news
UNSUBSCRIBE  # Unsubscribe from all</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Pattern Subscriptions</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Subscribe to pattern
PSUBSCRIBE news:*
# Matches: news:tech, news:sports, news:local

PSUBSCRIBE user:*:notifications
# Matches: user:123:notifications, user:456:notifications

# Publish to specific channel
PUBLISH news:tech "New iPhone announced"
# Pattern subscribers to news:* receive this

# Unsubscribe from pattern
PUNSUBSCRIBE news:*</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Introspection</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># List active channels
PUBSUB CHANNELS
PUBSUB CHANNELS news:*  # Matching pattern

# Count subscribers per channel
PUBSUB NUMSUB news sports weather

# Count pattern subscriptions
PUBSUB NUMPAT</code></pre>
                    </div>

                    <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4 mt-4">
                        <h4 class="text-blue-400 font-semibold mb-2">Use Case: Real-time Notifications</h4>
                        <pre class="text-gray-300 text-sm"><code># User subscribes to their notification channel
SUBSCRIBE notifications:user:123

# Server publishes when events occur
PUBLISH notifications:user:123 '{"type":"message","from":"john"}'
PUBLISH notifications:user:123 '{"type":"like","post_id":456}'</code></pre>
                    </div>

                    <div class="bg-yellow-900/30 border border-yellow-500 rounded-lg p-4 mt-4">
                        <h4 class="text-yellow-400 font-semibold mb-2">Pub/Sub Limitations</h4>
                        <ul class="text-gray-300 text-sm list-disc list-inside">
                            <li>Messages are fire-and-forget (no persistence)</li>
                            <li>If subscriber disconnects, messages are lost</li>
                            <li>No message history or replay</li>
                            <li>Consider Redis Streams for durable messaging</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Lesson 11: Common Patterns -->
            <section id="patterns" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">11. Common Patterns</h2>

                <div class="prose prose-invert max-w-none">
                    <h3 class="text-xl font-semibold text-red-400 mb-3">Caching Pattern</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Cache-Aside (Lazy Loading)
value = GET cache:user:123
if value is nil:
    value = fetch_from_database(123)
    SET cache:user:123 value EX 3600
return value

# Write-Through
SET cache:user:123 new_data EX 3600
update_database(123, new_data)</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Distributed Lock</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Acquire lock (atomic)
SET lock:resource unique_id NX EX 30
# NX = only if not exists
# EX 30 = auto-expire in 30 seconds

# Check if we got the lock
if result == "OK":
    # We have the lock, do work
    ...
    # Release lock (only if we own it)
    if GET lock:resource == unique_id:
        DEL lock:resource

# Better: Use Lua script for atomic check-and-delete
EVAL "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end" 1 lock:resource unique_id</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Rate Limiting</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Fixed Window
key = "ratelimit:user:123:minute:" + current_minute
count = INCR key
if count == 1:
    EXPIRE key 60
if count > 100:
    return "Rate limited"

# Sliding Window (using sorted sets)
now = current_timestamp
key = "ratelimit:user:123"
ZREMRANGEBYSCORE key 0 (now - 60)  # Remove old
ZADD key now request_id
count = ZCARD key
if count > 100:
    return "Rate limited"</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Leaderboard</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Add/Update score
ZADD leaderboard 1500 "player:123"

# Increment score
ZINCRBY leaderboard 100 "player:123"

# Get top 10
ZREVRANGE leaderboard 0 9 WITHSCORES

# Get player rank
ZREVRANK leaderboard "player:123"

# Get players around a score
ZREVRANGEBYSCORE leaderboard 1600 1400 WITHSCORES LIMIT 0 10</code></pre>
                    </div>
                    <button onclick="tryCommand('ZINCRBY demo:leaderboard 100 \"alice\"')" class="mr-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        Add Points
                    </button>
                    <button onclick="tryCommand('ZREVRANGE demo:leaderboard 0 -1 WITHSCORES')" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-sm">
                        View Leaderboard
                    </button>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Session Storage</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Create session
session_id = generate_uuid()
HSET session:$session_id user_id 123 created_at now role "user"
EXPIRE session:$session_id 86400  # 24 hours

# Validate session
session = HGETALL session:$session_id
if session exists:
    EXPIRE session:$session_id 86400  # Refresh TTL
    return session

# Destroy session
DEL session:$session_id</code></pre>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Job Queue</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Producer: Add jobs
RPUSH jobs '{"type":"email","to":"user@example.com"}'
RPUSH jobs '{"type":"process","file":"data.csv"}'

# Consumer: Process jobs (blocking)
while true:
    job = BLPOP jobs 0  # Wait forever
    process(job)

# Reliable Queue (with processing list)
job = BRPOPLPUSH jobs processing 30
process(job)
LREM processing 0 job  # Remove when done</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 12: Distributed Systems -->
            <section id="distributed" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">12. Redis in Distributed Systems</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Redis plays a crucial role in distributed systems, providing coordination primitives,
                        distributed locks, and shared state management across microservices.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Redis Distributed Locks vs SQL Transactional Locks</h3>

                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-700">
                                    <th class="text-left py-2">Aspect</th>
                                    <th class="text-left py-2">Redis Lock</th>
                                    <th class="text-left py-2">SQL Transaction Lock</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-300">
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-semibold">Scope</td>
                                    <td>Cross-service, distributed</td>
                                    <td>Single database, single transaction</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-semibold">Performance</td>
                                    <td>Sub-millisecond (in-memory)</td>
                                    <td>Slower (disk I/O, ACID overhead)</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-semibold">Auto-release</td>
                                    <td>TTL-based expiration</td>
                                    <td>Connection close / timeout</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-semibold">Deadlock</td>
                                    <td>Prevented via TTL</td>
                                    <td>Possible, requires detection</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-semibold">Durability</td>
                                    <td>Best-effort (can be lost)</td>
                                    <td>ACID guaranteed</td>
                                </tr>
                                <tr>
                                    <td class="py-2 font-semibold">Use Case</td>
                                    <td>Coordination, rate limiting</td>
                                    <td>Data integrity, transactions</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4 class="text-lg font-semibold text-red-300 mb-2">When to Use Redis Lock</h4>
                    <ul class="list-disc list-inside text-gray-300 mb-4 space-y-1">
                        <li>Coordinating tasks across multiple services/instances</li>
                        <li>Preventing duplicate job processing in worker queues</li>
                        <li>Rate limiting at the API gateway level</li>
                        <li>Leader election in distributed systems</li>
                        <li>Preventing cache stampede (thundering herd)</li>
                    </ul>

                    <h4 class="text-lg font-semibold text-red-300 mb-2">When to Use SQL Transaction Lock</h4>
                    <ul class="list-disc list-inside text-gray-300 mb-4 space-y-1">
                        <li>Financial transactions requiring ACID guarantees</li>
                        <li>Row-level locking for concurrent updates</li>
                        <li>Inventory management with strict consistency</li>
                        <li>When lock and data must be atomic</li>
                    </ul>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-6">Redlock Algorithm (Distributed Lock)</h3>
                    <p class="text-gray-300 mb-3">
                        For truly distributed locking across multiple Redis instances, use the Redlock algorithm:
                    </p>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># Redlock: Distributed lock across N Redis nodes
# Requires majority (N/2 + 1) to acquire lock

# 1. Get current time in milliseconds
start_time = current_time_ms()

# 2. Try to acquire lock on all N instances
for each redis_instance:
    SET resource_name unique_value NX PX 30000

# 3. Calculate elapsed time
elapsed = current_time_ms() - start_time

# 4. Lock acquired if:
#    - Majority of instances (N/2 + 1) granted lock
#    - Total elapsed time < lock validity time
if locks_acquired >= (N/2 + 1) AND elapsed < lock_ttl:
    # Lock is valid for: lock_ttl - elapsed
    valid_time = lock_ttl - elapsed

# 5. If lock failed, release all acquired locks
else:
    for each redis_instance:
        DEL resource_name  # or use Lua script</code></pre>
                    </div>

                    <div class="bg-yellow-900/30 border border-yellow-500 rounded-lg p-4 mb-6">
                        <h4 class="text-yellow-400 font-semibold mb-2">Redlock Considerations</h4>
                        <ul class="text-gray-300 text-sm list-disc list-inside space-y-1">
                            <li>Requires N independent Redis instances (not replicas)</li>
                            <li>Clock drift can affect lock validity</li>
                            <li>Network partitions may cause split-brain scenarios</li>
                            <li>Consider using libraries: Redisson (Java), redis-py (Python)</li>
                        </ul>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Redis in Microservices Architecture</h3>

                    <div class="space-y-4 mb-6">
                        <div class="bg-gray-900 rounded-lg p-4">
                            <h4 class="text-red-300 font-semibold mb-2">1. Service Discovery & Configuration</h4>
                            <pre class="text-green-400 text-sm"><code># Store service endpoints
HSET services:user-service host "10.0.1.5" port 8080 health "healthy"
HSET services:order-service host "10.0.1.6" port 8081 health "healthy"

# Service registry with TTL (heartbeat)
SET service:user-service:instance:1 '{"host":"10.0.1.5","port":8080}' EX 30
# Service must renew before TTL expires

# Get all instances of a service
KEYS service:user-service:instance:*</code></pre>
                        </div>

                        <div class="bg-gray-900 rounded-lg p-4">
                            <h4 class="text-red-300 font-semibold mb-2">2. Distributed Session Management</h4>
                            <pre class="text-green-400 text-sm"><code># Shared session across all service instances
HSET session:abc123 user_id 1000 role "admin" permissions "read,write"
EXPIRE session:abc123 3600

# Any service instance can validate/update session
session = HGETALL session:abc123

# Centralized logout (invalidates across all services)
DEL session:abc123</code></pre>
                        </div>

                        <div class="bg-gray-900 rounded-lg p-4">
                            <h4 class="text-red-300 font-semibold mb-2">3. Inter-Service Communication (Event Bus)</h4>
                            <pre class="text-green-400 text-sm"><code># Pub/Sub for real-time events
PUBLISH order:created '{"order_id":123,"user_id":456,"total":99.99}'

# Multiple services subscribe
# Inventory Service: SUBSCRIBE order:created
# Email Service: SUBSCRIBE order:created
# Analytics Service: PSUBSCRIBE order:*

# For durable messaging, use Redis Streams
XADD orders * order_id 123 user_id 456 total 99.99
XREADGROUP GROUP inventory-consumers consumer-1 STREAMS orders ></code></pre>
                        </div>

                        <div class="bg-gray-900 rounded-lg p-4">
                            <h4 class="text-red-300 font-semibold mb-2">4. Distributed Rate Limiting</h4>
                            <pre class="text-green-400 text-sm"><code># API Gateway rate limiting (shared across instances)
# Sliding window algorithm
local key = "ratelimit:" .. user_id
local now = redis.call('TIME')[1]
local window = 60  -- 1 minute

-- Remove old entries
redis.call('ZREMRANGEBYSCORE', key, 0, now - window)

-- Count current requests
local count = redis.call('ZCARD', key)

if count < 100 then  -- 100 requests/minute
    redis.call('ZADD', key, now, now .. ':' .. math.random())
    redis.call('EXPIRE', key, window)
    return {1, 100 - count - 1}  -- allowed, remaining
else
    return {0, 0}  -- denied
end</code></pre>
                        </div>

                        <div class="bg-gray-900 rounded-lg p-4">
                            <h4 class="text-red-300 font-semibold mb-2">5. Circuit Breaker State</h4>
                            <pre class="text-green-400 text-sm"><code># Track service health for circuit breaker
HSET circuit:payment-service state "closed" failures 0 last_failure 0

# On failure
HINCRBY circuit:payment-service failures 1
HSET circuit:payment-service last_failure $(date +%s)

# Check if should open circuit (>5 failures in 60s)
failures = HGET circuit:payment-service failures
if failures > 5:
    HSET circuit:payment-service state "open"
    EXPIRE circuit:payment-service 30  # Auto-reset after 30s</code></pre>
                        </div>

                        <div class="bg-gray-900 rounded-lg p-4">
                            <h4 class="text-red-300 font-semibold mb-2">6. Leader Election</h4>
                            <pre class="text-green-400 text-sm"><code># Only one instance should run scheduled tasks
instance_id = generate_unique_id()

# Try to become leader
result = SET leader:scheduler $instance_id NX EX 30

if result == "OK":
    # I am the leader, run scheduled tasks
    while True:
        run_scheduled_tasks()
        # Renew leadership
        SET leader:scheduler $instance_id XX EX 30
        sleep(10)
else:
    # Another instance is leader, standby
    leader = GET leader:scheduler</code></pre>
                        </div>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Alternatives to Redis for Distributed Coordination</h3>

                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-700">
                                    <th class="text-left py-2">Tool</th>
                                    <th class="text-left py-2">Best For</th>
                                    <th class="text-left py-2">Trade-offs</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-300">
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-red-400">Redis</td>
                                    <td>Speed, caching, simple locks</td>
                                    <td>No strong consistency guarantees</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-blue-400">ZooKeeper</td>
                                    <td>Strong consistency, leader election</td>
                                    <td>Higher latency, complex operations</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2 font-mono text-green-400">etcd</td>
                                    <td>Kubernetes, config management</td>
                                    <td>CP system, not for high throughput</td>
                                </tr>
                                <tr>
                                    <td class="py-2 font-mono text-purple-400">Consul</td>
                                    <td>Service mesh, health checking</td>
                                    <td>More complex setup</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4 class="text-lg font-semibold text-red-300 mb-2">ZooKeeper Deep Dive</h4>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># ZooKeeper: Hierarchical key-value store with strong consistency

# Create ephemeral node (auto-deleted when session ends)
create -e /locks/resource-1 "instance-1"

# Create sequential node (for ordering)
create -e -s /election/candidate- "instance-1"
# Creates: /election/candidate-0000000001

# Watch for changes (get notified)
get -w /config/database  # Watch triggers on change

# Leader Election with ZooKeeper:
# 1. Each instance creates sequential ephemeral node
# 2. Instance with lowest sequence number is leader
# 3. Others watch the node just before them
# 4. When leader dies, next in line becomes leader</code></pre>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="bg-blue-900/30 border border-blue-500 rounded-lg p-4">
                            <h4 class="text-blue-400 font-semibold mb-2">When to Choose ZooKeeper</h4>
                            <ul class="text-gray-300 text-sm list-disc list-inside space-y-1">
                                <li>Need strong consistency (CP in CAP)</li>
                                <li>Complex coordination patterns</li>
                                <li>Already using Kafka/Hadoop ecosystem</li>
                                <li>Need watch/notification features</li>
                                <li>Hierarchical data organization</li>
                            </ul>
                        </div>
                        <div class="bg-red-900/30 border border-red-500 rounded-lg p-4">
                            <h4 class="text-red-400 font-semibold mb-2">When to Choose Redis</h4>
                            <ul class="text-gray-300 text-sm list-disc list-inside space-y-1">
                                <li>Need speed (sub-millisecond)</li>
                                <li>Already using Redis for caching</li>
                                <li>Simple lock requirements</li>
                                <li>High throughput operations</li>
                                <li>Rich data structure needs</li>
                            </ul>
                        </div>
                    </div>

                    <h4 class="text-lg font-semibold text-red-300 mb-2">etcd for Kubernetes-Native Apps</h4>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <pre class="text-green-400 text-sm"><code># etcd: Distributed key-value store (Kubernetes backing store)

# Put a key
etcdctl put /config/db-host "postgres.default.svc"

# Get with prefix (like Redis KEYS)
etcdctl get --prefix /config/

# Watch for changes
etcdctl watch /config/ --prefix

# Distributed lock
etcdctl lock /locks/my-resource
# Lock held until process exits or explicit unlock

# Lease-based TTL
etcdctl lease grant 30  # 30 second lease
etcdctl put --lease=xxx /service/instance-1 "alive"</code></pre>
                    </div>

                    <div class="bg-purple-900/30 border border-purple-500 rounded-lg p-4">
                        <h4 class="text-purple-400 font-semibold mb-2">Real-World Architecture: Microservices with Redis</h4>
                        <pre class="text-gray-300 text-sm"><code>┌─────────────────────────────────────────────────────────────┐
│                      API Gateway                             │
│  • Rate Limiting (Redis Sorted Set)                         │
│  • Session Validation (Redis Hash)                          │
└─────────────────────────┬───────────────────────────────────┘
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
    ▼                     ▼                     ▼
┌─────────┐         ┌─────────┐          ┌─────────┐
│ User    │         │ Order   │          │ Payment │
│ Service │         │ Service │          │ Service │
└────┬────┘         └────┬────┘          └────┬────┘
     │                   │                    │
     └───────────────────┴────────────────────┘
                         │
              ┌──────────┴──────────┐
              │                     │
              ▼                     ▼
         ┌─────────┐          ┌─────────┐
         │  Redis  │          │   DB    │
         │ Cluster │          │(Primary)│
         ├─────────┤          └─────────┘
         │• Cache  │
         │• Sessions│
         │• Locks  │
         │• Pub/Sub│
         │• Queues │
         └─────────┘</code></pre>
                    </div>
                </div>
            </section>

            <!-- Lesson 13: Caching Strategies -->
            <section id="caching-strategies" class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">13. Caching Strategies & Invalidation</h2>

                <div class="prose prose-invert max-w-none">
                    <p class="text-gray-300 mb-4">
                        Effective caching is crucial for application performance. Understanding different caching
                        strategies and when to use them can dramatically improve your system's scalability.
                    </p>

                    <h3 class="text-xl font-semibold text-red-400 mb-3">Caching Strategies</h3>

                    <!-- Strategy 1: Cache-Aside -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">1. Cache-Aside (Lazy Loading)</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Application manages cache. Data loaded on-demand when cache miss occurs.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Read Pattern
def get_user(user_id):
    # 1. Check cache first
    cached = redis.get(f"user:{user_id}")
    if cached:
        return json.loads(cached)

    # 2. Cache miss - fetch from database
    user = database.query("SELECT * FROM users WHERE id = ?", user_id)

    # 3. Store in cache for future requests
    redis.setex(f"user:{user_id}", 3600, json.dumps(user))

    return user

# Write Pattern (application must invalidate)
def update_user(user_id, data):
    database.update("UPDATE users SET ... WHERE id = ?", data, user_id)
    redis.delete(f"user:{user_id}")  # Invalidate cache</code></pre>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="text-green-400">
                                <strong>Pros:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Only caches requested data</li>
                                    <li>Cache failures don't break app</li>
                                    <li>Simple to implement</li>
                                </ul>
                            </div>
                            <div class="text-yellow-400">
                                <strong>Cons:</strong>
                                <ul class="list-disc list-inside">
                                    <li>First request always slow (miss)</li>
                                    <li>Cache stampede risk</li>
                                    <li>Stale data possible</li>
                                </ul>
                            </div>
                        </div>
                        <p class="text-blue-400 text-sm mt-2">
                            <strong>Real-World:</strong> User profiles, product details, blog posts
                        </p>
                    </div>

                    <!-- Strategy 2: Read-Through -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">2. Read-Through Cache</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Cache sits between application and database. Cache automatically loads data on miss.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Cache library handles loading (e.g., Spring Cache, Django cache)
@cache(key="user:{user_id}", ttl=3600)
def get_user(user_id):
    # This only runs on cache miss
    return database.query("SELECT * FROM users WHERE id = ?", user_id)

# Behind the scenes (cache library logic):
def cache_get(key, loader_fn):
    value = redis.get(key)
    if value is None:
        value = loader_fn()  # Call database
        redis.setex(key, ttl, serialize(value))
    return deserialize(value)</code></pre>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="text-green-400">
                                <strong>Pros:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Cleaner application code</li>
                                    <li>Consistent cache logic</li>
                                    <li>Framework support</li>
                                </ul>
                            </div>
                            <div class="text-yellow-400">
                                <strong>Cons:</strong>
                                <ul class="list-disc list-inside">
                                    <li>First request still slow</li>
                                    <li>Less control over caching</li>
                                    <li>Framework dependency</li>
                                </ul>
                            </div>
                        </div>
                        <p class="text-blue-400 text-sm mt-2">
                            <strong>Real-World:</strong> ORM caching, CDN origin fetch, API response caching
                        </p>
                    </div>

                    <!-- Strategy 3: Write-Through -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">3. Write-Through Cache</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Write to cache and database synchronously. Cache always has latest data.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Write updates both cache and database atomically
def update_user(user_id, data):
    # 1. Write to database
    database.update("UPDATE users SET ... WHERE id = ?", data, user_id)

    # 2. Write to cache (same transaction/request)
    user = database.query("SELECT * FROM users WHERE id = ?", user_id)
    redis.setex(f"user:{user_id}", 3600, json.dumps(user))

    return user

# Reads are always fast (cache is pre-populated)
def get_user(user_id):
    cached = redis.get(f"user:{user_id}")
    if cached:
        return json.loads(cached)
    # Fallback to DB only if cache expired/evicted
    return load_from_db_and_cache(user_id)</code></pre>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="text-green-400">
                                <strong>Pros:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Cache always consistent</li>
                                    <li>Reads always fast</li>
                                    <li>No stale data</li>
                                </ul>
                            </div>
                            <div class="text-yellow-400">
                                <strong>Cons:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Writes are slower (2x write)</li>
                                    <li>May cache unused data</li>
                                    <li>Cache failure affects writes</li>
                                </ul>
                            </div>
                        </div>
                        <p class="text-blue-400 text-sm mt-2">
                            <strong>Real-World:</strong> User sessions, shopping carts, real-time inventory
                        </p>
                    </div>

                    <!-- Strategy 4: Write-Behind -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">4. Write-Behind (Write-Back) Cache</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Write to cache immediately, asynchronously persist to database later.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Write to cache, queue for DB write
def update_user(user_id, data):
    # 1. Update cache immediately (fast response)
    redis.hset(f"user:{user_id}", mapping=data)

    # 2. Queue database write (async)
    redis.rpush("db_write_queue", json.dumps({
        "table": "users",
        "id": user_id,
        "data": data,
        "timestamp": time.time()
    }))

    return {"status": "accepted"}

# Background worker processes queue
def db_writer_worker():
    while True:
        item = redis.blpop("db_write_queue", timeout=30)
        if item:
            write_to_database(json.loads(item[1]))</code></pre>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="text-green-400">
                                <strong>Pros:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Fastest write performance</li>
                                    <li>Reduced DB load (batching)</li>
                                    <li>Handles write spikes</li>
                                </ul>
                            </div>
                            <div class="text-yellow-400">
                                <strong>Cons:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Data loss risk if cache fails</li>
                                    <li>Complex implementation</li>
                                    <li>Eventual consistency only</li>
                                </ul>
                            </div>
                        </div>
                        <p class="text-blue-400 text-sm mt-2">
                            <strong>Real-World:</strong> Page view counters, analytics events, logging
                        </p>
                    </div>

                    <!-- Strategy 5: Refresh-Ahead -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">5. Refresh-Ahead Cache</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Proactively refresh cache before expiration to avoid cache misses.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Check if refresh needed (e.g., 80% of TTL elapsed)
def get_user_with_refresh(user_id):
    key = f"user:{user_id}"

    # Get value and TTL
    cached = redis.get(key)
    ttl = redis.ttl(key)
    original_ttl = 3600  # 1 hour

    if cached:
        # Refresh if less than 20% TTL remaining
        if ttl < original_ttl * 0.2:  # < 720 seconds
            # Async refresh (don't block current request)
            background_refresh(user_id)
        return json.loads(cached)

    # Cache miss - load synchronously
    return load_from_db_and_cache(user_id)

# Background refresh (runs async)
async def background_refresh(user_id):
    user = database.query("SELECT * FROM users WHERE id = ?", user_id)
    redis.setex(f"user:{user_id}", 3600, json.dumps(user))</code></pre>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="text-green-400">
                                <strong>Pros:</strong>
                                <ul class="list-disc list-inside">
                                    <li>Eliminates cache miss latency</li>
                                    <li>Consistent response times</li>
                                    <li>Works with hot data</li>
                                </ul>
                            </div>
                            <div class="text-yellow-400">
                                <strong>Cons:</strong>
                                <ul class="list-disc list-inside">
                                    <li>May refresh unused data</li>
                                    <li>More complex logic</li>
                                    <li>Needs background workers</li>
                                </ul>
                            </div>
                        </div>
                        <p class="text-blue-400 text-sm mt-2">
                            <strong>Real-World:</strong> Homepage content, product recommendations, hot API responses
                        </p>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-8">Cache Invalidation Strategies</h3>
                    <p class="text-gray-300 mb-4">
                        "There are only two hard things in Computer Science: cache invalidation and naming things." — Phil Karlton
                    </p>

                    <!-- Invalidation 1: TTL -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">1. Time-To-Live (TTL) Based</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Set expiration time on cached data. Simple but may serve stale data.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Simple TTL
SET user:123 '{"name":"John"}' EX 3600  # Expires in 1 hour

# Different TTLs for different data freshness needs
SET config:app EX 86400            # 24 hours (rarely changes)
SET user:profile:123 EX 3600       # 1 hour (changes occasionally)
SET stock:AAPL EX 60               # 1 minute (changes frequently)
SET realtime:score EX 5            # 5 seconds (near real-time)

# Jitter to prevent thundering herd
import random
base_ttl = 3600
jitter = random.randint(-300, 300)  # ±5 minutes
redis.setex(key, base_ttl + jitter, value)</code></pre>
                        <p class="text-blue-400 text-sm">
                            <strong>Real-World:</strong> Session tokens (expire after inactivity), API rate limits (reset hourly)
                        </p>
                    </div>

                    <!-- Invalidation 2: Event-Based -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">2. Event-Based Invalidation</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Invalidate cache when data changes. Ensures fresh data but requires event infrastructure.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># On data update, publish invalidation event
def update_product(product_id, data):
    database.update_product(product_id, data)

    # Publish invalidation event
    redis.publish("cache:invalidate", json.dumps({
        "type": "product",
        "id": product_id,
        "action": "update"
    }))

# Cache invalidation listener (runs in each app instance)
def cache_invalidation_listener():
    pubsub = redis.pubsub()
    pubsub.subscribe("cache:invalidate")

    for message in pubsub.listen():
        if message["type"] == "message":
            event = json.loads(message["data"])
            if event["type"] == "product":
                redis.delete(f"product:{event['id']}")
                redis.delete(f"product:{event['id']}:details")
                redis.delete("products:featured")  # Related cache</code></pre>
                        <p class="text-blue-400 text-sm">
                            <strong>Real-World:</strong> E-commerce product updates, CMS content changes, user profile updates
                        </p>
                    </div>

                    <!-- Invalidation 3: Version/Tag Based -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">3. Version/Tag-Based Invalidation</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Include version in cache key. Changing version effectively invalidates all related caches.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Store version number
SET product:catalog:version 42

# Cache keys include version
version = GET product:catalog:version
cache_key = f"product:{product_id}:v{version}"

# Read with version
def get_product(product_id):
    version = redis.get("product:catalog:version")
    return redis.get(f"product:{product_id}:v{version}")

# Invalidate ALL products by bumping version
def invalidate_all_products():
    redis.incr("product:catalog:version")
    # Old versioned keys will expire naturally via TTL
    # No need to explicitly delete each one!

# Tag-based: associate caches with tags
SADD cache:tag:user:123 "orders:user:123" "profile:user:123" "cart:user:123"

# Invalidate all caches for a user
def invalidate_user_caches(user_id):
    keys = redis.smembers(f"cache:tag:user:{user_id}")
    if keys:
        redis.delete(*keys)
    redis.delete(f"cache:tag:user:{user_id}")</code></pre>
                        <p class="text-blue-400 text-sm">
                            <strong>Real-World:</strong> Bulk catalog updates, feature flag changes, A/B test variations
                        </p>
                    </div>

                    <!-- Invalidation 4: Write-Through -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">4. Write-Through Invalidation</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Update cache and database together. Cache is always fresh.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Update both in same transaction
def update_user_email(user_id, new_email):
    with database.transaction():
        # Update database
        database.execute(
            "UPDATE users SET email = ? WHERE id = ?",
            new_email, user_id
        )

        # Update cache
        user_data = redis.hgetall(f"user:{user_id}")
        if user_data:
            redis.hset(f"user:{user_id}", "email", new_email)

        # Or: Invalidate and let next read repopulate
        # redis.delete(f"user:{user_id}")</code></pre>
                        <p class="text-blue-400 text-sm">
                            <strong>Real-World:</strong> User profile updates, order status changes, inventory updates
                        </p>
                    </div>

                    <!-- Invalidation 5: Cache-Aside with Background Refresh -->
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <h4 class="text-red-300 font-semibold mb-2">5. Stale-While-Revalidate</h4>
                        <p class="text-gray-400 text-sm mb-3">
                            Serve stale data immediately while refreshing in background. Best user experience.
                        </p>
                        <pre class="text-green-400 text-sm mb-3"><code># Store data with soft and hard TTL
def cache_with_swr(key, value, soft_ttl=300, hard_ttl=3600):
    data = {
        "value": value,
        "soft_expires": time.time() + soft_ttl,  # When to start refresh
        "created": time.time()
    }
    redis.setex(key, hard_ttl, json.dumps(data))

def get_with_swr(key, refresh_fn):
    cached = redis.get(key)
    if cached:
        data = json.loads(cached)

        # Check if soft TTL expired
        if time.time() > data["soft_expires"]:
            # Return stale data immediately
            # Refresh in background
            async_refresh(key, refresh_fn)

        return data["value"]

    # Hard miss - must fetch synchronously
    value = refresh_fn()
    cache_with_swr(key, value)
    return value</code></pre>
                        <p class="text-blue-400 text-sm">
                            <strong>Real-World:</strong> News feeds, dashboard metrics, search results
                        </p>
                    </div>

                    <h3 class="text-xl font-semibold text-red-400 mb-3 mt-8">Cache Invalidation Patterns Summary</h3>
                    <div class="bg-gray-900 rounded-lg p-4 mb-4">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-700">
                                    <th class="text-left py-2">Pattern</th>
                                    <th class="text-left py-2">Consistency</th>
                                    <th class="text-left py-2">Complexity</th>
                                    <th class="text-left py-2">Best For</th>
                                </tr>
                            </thead>
                            <tbody class="text-gray-300">
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">TTL-Based</td>
                                    <td class="text-yellow-400">Eventual</td>
                                    <td class="text-green-400">Low</td>
                                    <td>Config, static content</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Event-Based</td>
                                    <td class="text-green-400">Strong</td>
                                    <td class="text-yellow-400">Medium</td>
                                    <td>User data, inventory</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Version-Based</td>
                                    <td class="text-green-400">Strong</td>
                                    <td class="text-yellow-400">Medium</td>
                                    <td>Bulk updates, catalogs</td>
                                </tr>
                                <tr class="border-b border-gray-700">
                                    <td class="py-2">Write-Through</td>
                                    <td class="text-green-400">Strong</td>
                                    <td class="text-green-400">Low</td>
                                    <td>Critical data</td>
                                </tr>
                                <tr>
                                    <td class="py-2">Stale-While-Revalidate</td>
                                    <td class="text-yellow-400">Eventual</td>
                                    <td class="text-red-400">High</td>
                                    <td>UX-critical, high traffic</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="bg-purple-900/30 border border-purple-500 rounded-lg p-4">
                        <h4 class="text-purple-400 font-semibold mb-2">Real-World Example: E-Commerce Product Page</h4>
                        <pre class="text-gray-300 text-sm"><code>Product Page Caching Strategy:
├── Product Details (Cache-Aside + Event Invalidation)
│   ├── Name, description, images → TTL: 1 hour
│   ├── Invalidate on: admin update
│   └── Key: product:{id}
│
├── Price & Availability (Write-Through)
│   ├── Current price, stock count → TTL: 5 minutes
│   ├── Update cache on every inventory change
│   └── Key: product:{id}:pricing
│
├── Reviews (Stale-While-Revalidate)
│   ├── Average rating, review count → Soft TTL: 5 min, Hard: 1 hour
│   ├── Background refresh, serve stale immediately
│   └── Key: product:{id}:reviews
│
├── Recommendations (Refresh-Ahead)
│   ├── "Customers also bought" → TTL: 6 hours
│   ├── Pre-refresh at 80% TTL
│   └── Key: product:{id}:recommendations:v{version}
│
└── Real-time Stock (No Cache / Write-Behind)
    ├── "Only 3 left!" → Check DB or use Redis counter
    └── Key: stock:{product_id} (Redis counter, write-behind to DB)</code></pre>
                    </div>
                </div>
            </section>

            <!-- Practice Section -->
            <section class="bg-gradient-to-r from-red-900/30 to-red-800/30 border border-red-500 rounded-lg p-6">
                <h2 class="text-2xl font-bold text-white mb-4">Practice in the Dashboard</h2>
                <p class="text-gray-300 mb-4">
                    Ready to practice? Head over to the Redis Dashboard to run commands interactively
                    with our pre-loaded sample data.
                </p>
                <a href="/redis" class="inline-block px-6 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold transition-colors">
                    Open Redis Dashboard
                </a>
            </section>
        </div>
    </div>
</div>

<script>
function tryCommand(command) {
    // Store command in sessionStorage and redirect to dashboard
    sessionStorage.setItem('redis_command', command);
    window.location.href = '/redis';
}
</script>
{{end}}