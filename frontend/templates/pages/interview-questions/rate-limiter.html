<link rel="stylesheet" href="/static/css/interview-questions.css">

<div class="interview-topic-layout">
    <a href="/interview-question" class="back-to-dashboard">‚Üê Back to All Topics</a>

    <h1>‚è±Ô∏è Rate Limiter System Design</h1>
    <p class="topic-description">Design a distributed rate limiting system protecting APIs from abuse with Token Bucket, Sliding Window algorithms</p>

    <div class="quick-nav">
        <h4>Navigation</h4>
        <a href="#mvp">MVP Stage</a>
        <a href="#pan-india">PAN-India</a>
        <a href="#high-traffic">High Traffic</a>
        <a href="#global">Global</a>
    </div>

    <!-- ============================================ -->
    <!-- MVP STAGE -->
    <!-- ============================================ -->
    <div class="stage-section" id="mvp">
        <div class="stage-header">
            <span class="stage-badge mvp">MVP Stage</span>
            <h2 style="margin: 0;">Single Service ‚Ä¢ 10K users ‚Ä¢ 1K req/sec</h2>
        </div>

        <!-- REQUIREMENTS -->
        <h3>üìã Requirements</h3>
        <div class="feature-card">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4 style="color: #22c55e;">Functional</h4>
                    <ul>
                        <li>Limit by IP address</li>
                        <li>Limit by user ID / API key</li>
                        <li>Limit by endpoint (per-route)</li>
                        <li>Different limits per tier (free/pro)</li>
                        <li>Burst allowance (temporary spikes)</li>
                        <li>Return 429 with Retry-After</li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: #3b82f6;">Non-Functional</h4>
                    <ul>
                        <li>Latency overhead: &lt;1ms p99</li>
                        <li>Availability: 99.9%</li>
                        <li>Accuracy: &lt;1% false positives</li>
                        <li>Throughput: 10K checks/sec</li>
                        <li>Memory: ~50B per rate limit key</li>
                        <li>Graceful degradation on failure</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ARCHITECTURE DIAGRAM -->
        <h3>üèóÔ∏è Architecture</h3>
        <div class="diagram-container">
            <h4>MVP Architecture - Middleware Pattern</h4>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
                <!-- Layer 1: Clients -->
                <div style="display: flex; gap: 40px;">
                    <div class="arch-box client">Web Client</div>
                    <div class="arch-box client">Mobile App</div>
                    <div class="arch-box client">API Consumer</div>
                </div>
                <div class="arch-arrow">‚Üì</div>

                <!-- Layer 2: Load Balancer -->
                <div class="arch-box lb">AWS ALB<br><small>Health checks, SSL termination</small></div>
                <div class="arch-arrow">‚Üì</div>

                <!-- Layer 3: API Servers with Rate Limiter -->
                <div style="display: flex; gap: 20px;">
                    <div style="text-align: center;">
                        <div class="arch-box server" style="border: 3px solid #f59e0b;">
                            API Server 1<br>
                            <small style="color: #f59e0b;">Rate Limiter Middleware</small>
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div class="arch-box server" style="border: 3px solid #f59e0b;">
                            API Server 2<br>
                            <small style="color: #f59e0b;">Rate Limiter Middleware</small>
                        </div>
                    </div>
                </div>
                <div class="arch-arrow">‚Üì</div>

                <!-- Layer 4: Redis -->
                <div style="text-align: center;">
                    <div class="arch-box cache">ElastiCache Redis<br><small>Rate Limit State</small></div>
                    <div style="font-size: 12px; color: #64748b; margin-top: 8px;">Centralized counter storage<br>Lua scripts for atomicity</div>
                </div>
            </div>
        </div>

        <!-- DATA FLOW - Check Rate Limit -->
        <h3>üîÑ Data Flow - Rate Limit Check</h3>
        <div class="diagram-container">
            <div style="display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 12px;">
                <div class="flow-step">
                    <div class="flow-step-number">1</div>
                    <div class="arch-box client" style="padding: 10px 16px;">Request</div>
                    <div class="flow-step-label">POST /api/data</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="flow-step">
                    <div class="flow-step-number">2</div>
                    <div class="arch-box server" style="padding: 10px 16px;">Extract Key</div>
                    <div class="flow-step-label">user:123 or ip:1.2.3.4</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="flow-step">
                    <div class="flow-step-number">3</div>
                    <div class="arch-box cache" style="padding: 10px 16px;">Redis Check</div>
                    <div class="flow-step-label">EVALSHA lua_script</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="flow-step">
                    <div class="flow-step-number">4</div>
                    <div class="arch-box db" style="padding: 10px 16px; background: #22c55e;">Allow</div>
                    <div class="flow-step-label">‚Üí Backend</div>
                </div>
            </div>
            <div style="margin-top: 20px; display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 12px;">
                <div style="color: #ef4444; font-weight: 600;">Rate Limited path:</div>
                <div class="arch-arrow">‚Üí</div>
                <div class="arch-box client" style="padding: 10px 16px; background: #ef4444;">429 Denied</div>
                <div class="arch-arrow">‚Üí</div>
                <div style="font-size: 14px;">Retry-After: 30s</div>
            </div>
        </div>

        <!-- ALGORITHM DIAGRAMS -->
        <h3>üìä Rate Limiting Algorithms</h3>

        <!-- Token Bucket -->
        <div class="diagram-container">
            <h4>Token Bucket Algorithm (Most Flexible)</h4>
            <div style="display: flex; gap: 40px; align-items: center; justify-content: center; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div style="background: #1e293b; border: 3px solid #f59e0b; border-radius: 12px; padding: 20px; min-width: 150px;">
                        <div style="font-size: 12px; color: #94a3b8;">Bucket (capacity: 10)</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; margin: 12px 0;">
                            <span style="background: #f59e0b; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                            <span style="background: #f59e0b; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                            <span style="background: #f59e0b; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                            <span style="background: #f59e0b; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                            <span style="background: #f59e0b; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                            <span style="background: #334155; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                            <span style="background: #334155; width: 20px; height: 20px; border-radius: 50%; display: inline-block;"></span>
                        </div>
                        <div style="font-size: 14px; color: #f59e0b;">5 tokens remaining</div>
                    </div>
                    <div style="margin-top: 12px; font-size: 13px; color: #64748b;">
                        Refill: 1 token/sec<br>
                        Burst: up to 10 requests
                    </div>
                </div>
                <div style="text-align: left; max-width: 300px;">
                    <p style="font-size: 14px;"><strong>How it works:</strong></p>
                    <ol style="font-size: 13px; padding-left: 20px;">
                        <li>Bucket holds tokens (max = capacity)</li>
                        <li>Tokens added at fixed rate (refill)</li>
                        <li>Each request consumes 1 token</li>
                        <li>No tokens = request denied</li>
                        <li>Allows burst up to bucket size</li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- Sliding Window Log -->
        <div class="diagram-container">
            <h4>Sliding Window Log (Most Accurate)</h4>
            <div style="display: flex; gap: 40px; align-items: center; justify-content: center; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px; min-width: 300px;">
                        <div style="font-size: 12px; color: #94a3b8; margin-bottom: 12px;">Sorted Set: timestamps of requests</div>
                        <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">10:00:01</span>
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">10:00:15</span>
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">10:00:23</span>
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">10:00:45</span>
                            <span style="background: #22c55e; padding: 4px 8px; border-radius: 4px; font-size: 11px;">10:00:58</span>
                        </div>
                        <div style="margin-top: 12px; font-size: 12px;">
                            <span style="color: #64748b;">Window: 60s | Limit: 10 | Current: </span>
                            <span style="color: #22c55e;">5 requests</span>
                        </div>
                    </div>
                </div>
                <div style="text-align: left; max-width: 280px;">
                    <p style="font-size: 14px;"><strong>Pros:</strong> 100% accurate</p>
                    <p style="font-size: 14px;"><strong>Cons:</strong> High memory (stores all timestamps)</p>
                    <p style="font-size: 13px; color: #64748b;">Memory: O(requests in window)</p>
                </div>
            </div>
        </div>

        <!-- Sliding Window Counter -->
        <div class="diagram-container">
            <h4>Sliding Window Counter (Balanced)</h4>
            <div style="display: flex; gap: 40px; align-items: center; justify-content: center; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px;">
                        <div style="display: flex; gap: 4px; align-items: end;">
                            <div style="text-align: center;">
                                <div style="background: #64748b; width: 80px; height: 60px; border-radius: 4px 4px 0 0; display: flex; align-items: center; justify-content: center;">
                                    <span style="font-size: 18px; font-weight: bold;">45</span>
                                </div>
                                <div style="font-size: 11px; color: #94a3b8; margin-top: 4px;">Prev Window<br>(weight: 0.3)</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #3b82f6; width: 80px; height: 40px; border-radius: 4px 4px 0 0; display: flex; align-items: center; justify-content: center;">
                                    <span style="font-size: 18px; font-weight: bold;">28</span>
                                </div>
                                <div style="font-size: 11px; color: #94a3b8; margin-top: 4px;">Curr Window<br>(weight: 0.7)</div>
                            </div>
                        </div>
                        <div style="margin-top: 16px; padding: 8px; background: #334155; border-radius: 6px; font-size: 13px;">
                            Weighted: 45√ó0.3 + 28√ó0.7 = <strong style="color: #22c55e;">33.1</strong> (limit: 100)
                        </div>
                    </div>
                </div>
                <div style="text-align: left; max-width: 280px;">
                    <p style="font-size: 14px;"><strong>Best balance</strong> of accuracy and memory</p>
                    <p style="font-size: 13px; color: #64748b;">Memory: O(1) - just 2 counters</p>
                    <p style="font-size: 13px; color: #64748b;">Accuracy: ~99.7% (slight approximation)</p>
                </div>
            </div>
        </div>

        <!-- Fixed Window Counter -->
        <div class="diagram-container">
            <h4>Fixed Window Counter (Simplest)</h4>
            <div style="display: flex; gap: 40px; align-items: center; justify-content: center; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px;">
                        <div style="display: flex; gap: 4px; align-items: end;">
                            <div style="background: #64748b; width: 80px; height: 80px; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                                <span style="font-size: 24px; font-weight: bold;">100</span>
                                <span style="font-size: 10px; color: #94a3b8;">10:00-10:01</span>
                            </div>
                            <div style="background: #ef4444; width: 80px; height: 100px; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                                <span style="font-size: 24px; font-weight: bold;">100</span>
                                <span style="font-size: 10px;">10:01-10:02</span>
                            </div>
                        </div>
                        <div style="margin-top: 12px; font-size: 12px; color: #ef4444;">
                            ‚ö†Ô∏è Edge case: 200 requests in 2s at window boundary
                        </div>
                    </div>
                </div>
                <div style="text-align: left; max-width: 280px;">
                    <p style="font-size: 14px;"><strong>Simplest</strong> to implement</p>
                    <p style="font-size: 13px; color: #ef4444;">Problem: Burst at window edges</p>
                    <p style="font-size: 13px; color: #64748b;">Use when: Exact limits not critical</p>
                </div>
            </div>
        </div>

        <!-- Leaky Bucket -->
        <div class="diagram-container">
            <h4>Leaky Bucket (Smoothest Output)</h4>
            <div style="display: flex; gap: 40px; align-items: center; justify-content: center; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px; min-width: 180px;">
                        <div style="font-size: 12px; color: #94a3b8;">Queue (FIFO)</div>
                        <div style="background: #334155; border-radius: 8px; padding: 12px; margin: 12px 0;">
                            <div style="display: flex; flex-direction: column; gap: 4px;">
                                <span style="background: #8b5cf6; padding: 4px 12px; border-radius: 4px; font-size: 12px;">Request 1</span>
                                <span style="background: #8b5cf6; padding: 4px 12px; border-radius: 4px; font-size: 12px;">Request 2</span>
                                <span style="background: #8b5cf6; padding: 4px 12px; border-radius: 4px; font-size: 12px;">Request 3</span>
                            </div>
                        </div>
                        <div class="arch-arrow" style="font-size: 20px;">‚Üì</div>
                        <div style="font-size: 12px; color: #22c55e;">Processed at fixed rate</div>
                        <div style="font-size: 11px; color: #64748b;">(1 req/100ms)</div>
                    </div>
                </div>
                <div style="text-align: left; max-width: 280px;">
                    <p style="font-size: 14px;"><strong>Smoothest</strong> output rate</p>
                    <p style="font-size: 13px; color: #64748b;">Requests queued, not rejected</p>
                    <p style="font-size: 13px; color: #64748b;">Use for: API gateways, traffic shaping</p>
                    <p style="font-size: 13px; color: #ef4444;">Con: Adds latency (queuing)</p>
                </div>
            </div>
        </div>

        <!-- DATABASE/STORE SCHEMA -->
        <h3>üóÑÔ∏è Redis Data Structures</h3>
        <div class="diagram-container">
            <h4>Storage Schema by Algorithm</h4>
            <div class="schema-diagram" style="flex-direction: column; gap: 16px;">
                <div class="schema-table" style="width: 100%;">
                    <div class="schema-table-header">ü™£ Token Bucket - Hash</div>
                    <div class="schema-table-body">
                        <div class="schema-field"><span class="field-name field-pk">Key</span><span class="field-type">ratelimit:token:{user_id}</span></div>
                        <div class="schema-field"><span class="field-name">tokens</span><span class="field-type">FLOAT (remaining tokens)</span></div>
                        <div class="schema-field"><span class="field-name">last_refill</span><span class="field-type">TIMESTAMP (Unix ms)</span></div>
                        <div class="schema-field"><span class="field-name">TTL</span><span class="field-type">EXPIRE 3600s</span></div>
                    </div>
                </div>

                <div class="schema-table" style="width: 100%;">
                    <div class="schema-table-header">üìä Sliding Window Log - Sorted Set</div>
                    <div class="schema-table-body">
                        <div class="schema-field"><span class="field-name field-pk">Key</span><span class="field-type">ratelimit:sliding:{user_id}</span></div>
                        <div class="schema-field"><span class="field-name">Member</span><span class="field-type">UUID (request ID)</span></div>
                        <div class="schema-field"><span class="field-name">Score</span><span class="field-type">TIMESTAMP (Unix ms)</span></div>
                        <div class="schema-field"><span class="field-name">TTL</span><span class="field-type">EXPIRE = window_size</span></div>
                    </div>
                </div>

                <div class="schema-table" style="width: 100%;">
                    <div class="schema-table-header">üî¢ Fixed/Sliding Window Counter - String</div>
                    <div class="schema-table-body">
                        <div class="schema-field"><span class="field-name field-pk">Key</span><span class="field-type">ratelimit:counter:{user_id}:{window_id}</span></div>
                        <div class="schema-field"><span class="field-name">Value</span><span class="field-type">INTEGER (request count)</span></div>
                        <div class="schema-field"><span class="field-name">TTL</span><span class="field-type">EXPIRE = 2 √ó window_size</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- REDIS COMMANDS / LUA SCRIPTS -->
        <h3>üìù Redis Lua Scripts (Atomic Operations)</h3>
        <div class="sql-query">
            <h5>Token Bucket - Atomic Check & Consume</h5>
<pre>-- Token Bucket Lua Script
-- KEYS[1] = rate limit key
-- ARGV[1] = capacity, ARGV[2] = refill_rate, ARGV[3] = now_ms, ARGV[4] = requested

local key = KEYS[1]
local capacity = tonumber(ARGV[1])
local refill_rate = tonumber(ARGV[2])  -- tokens per second
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4]) or 1

-- Get current state
local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
local tokens = tonumber(bucket[1]) or capacity
local last_refill = tonumber(bucket[2]) or now

-- Calculate token refill
local elapsed = (now - last_refill) / 1000  -- convert to seconds
local new_tokens = math.min(capacity, tokens + (elapsed * refill_rate))

-- Try to consume tokens
local allowed = 0
local remaining = new_tokens
if new_tokens >= requested then
    remaining = new_tokens - requested
    allowed = 1
end

-- Update state
redis.call('HMSET', key, 'tokens', remaining, 'last_refill', now)
redis.call('EXPIRE', key, math.ceil(capacity / refill_rate) * 2)

-- Return: allowed (0/1), remaining tokens, reset time
local reset_time = math.ceil((capacity - remaining) / refill_rate)
return {allowed, math.floor(remaining), reset_time}</pre>
        </div>

        <div class="sql-query">
            <h5>Sliding Window Log - Accurate Count</h5>
<pre>-- Sliding Window Log Lua Script
-- KEYS[1] = rate limit key
-- ARGV[1] = window_ms, ARGV[2] = limit, ARGV[3] = now_ms, ARGV[4] = request_id

local key = KEYS[1]
local window = tonumber(ARGV[1])
local limit = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local request_id = ARGV[4]

-- Remove old entries outside window
local window_start = now - window
redis.call('ZREMRANGEBYSCORE', key, '-inf', window_start)

-- Count requests in current window
local current_count = redis.call('ZCARD', key)

if current_count < limit then
    -- Add new request
    redis.call('ZADD', key, now, request_id)
    redis.call('EXPIRE', key, math.ceil(window / 1000) + 1)
    return {1, limit - current_count - 1, 0}  -- allowed, remaining, retry_after
else
    -- Get oldest entry to calculate retry time
    local oldest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
    local retry_after = oldest[2] and (oldest[2] + window - now) / 1000 or 0
    return {0, 0, math.ceil(retry_after)}  -- denied, remaining, retry_after
end</pre>
        </div>

        <div class="sql-query">
            <h5>Sliding Window Counter - Balanced Approach</h5>
<pre>-- Sliding Window Counter Lua Script
-- KEYS[1] = current window key, KEYS[2] = previous window key
-- ARGV[1] = limit, ARGV[2] = window_ms, ARGV[3] = now_ms

local curr_key = KEYS[1]
local prev_key = KEYS[2]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

-- Get counts
local curr_count = tonumber(redis.call('GET', curr_key)) or 0
local prev_count = tonumber(redis.call('GET', prev_key)) or 0

-- Calculate weighted count
local elapsed_in_window = now % window
local weight = elapsed_in_window / window
local weighted_count = (prev_count * (1 - weight)) + curr_count

if weighted_count < limit then
    -- Increment current window
    redis.call('INCR', curr_key)
    redis.call('EXPIRE', curr_key, math.ceil(window / 1000) * 2)
    local remaining = math.floor(limit - weighted_count - 1)
    return {1, remaining, 0}  -- allowed
else
    local retry_after = math.ceil((window - elapsed_in_window) / 1000)
    return {0, 0, retry_after}  -- denied
end</pre>
        </div>

        <!-- API DESIGN -->
        <h3>üîå API Design</h3>
        <div class="api-endpoint">
            <span class="api-method get">ANY</span> <span class="api-path">/api/*</span>
<pre>
Rate Limit Response Headers (Always Included):

X-RateLimit-Limit: 100              // Max requests in window
X-RateLimit-Remaining: 45           // Requests remaining
X-RateLimit-Reset: 1704067200       // Unix timestamp when window resets
X-RateLimit-Policy: "100;w=60"      // Policy: 100 per 60 seconds

Success Response: 200 OK
{
    "data": { ... },
    "meta": {
        "rateLimit": {
            "limit": 100,
            "remaining": 45,
            "reset": 1704067200
        }
    }
}</pre>
        </div>

        <div class="api-endpoint">
            <span class="api-method post" style="background: #ef4444;">429</span> <span class="api-path">Rate Limited Response</span>
<pre>
HTTP/1.1 429 Too Many Requests

Headers:
    Retry-After: 30                 // Seconds until retry allowed
    X-RateLimit-Limit: 100
    X-RateLimit-Remaining: 0
    X-RateLimit-Reset: 1704067200

Response Body:
{
    "error": {
        "code": "RATE_LIMIT_EXCEEDED",
        "message": "Too many requests. Please retry after 30 seconds.",
        "retryAfter": 30,
        "limit": 100,
        "window": "60s"
    }
}</pre>
        </div>

        <div class="api-endpoint">
            <span class="api-method get">GET</span> <span class="api-path">/api/v1/rate-limit/status</span>
<pre>
// Check current rate limit status (for dashboards)

Response: 200 OK
{
    "userId": "user_123",
    "tier": "pro",
    "limits": {
        "requests": {
            "limit": 1000,
            "remaining": 847,
            "reset": 1704067200,
            "window": "60s"
        },
        "daily": {
            "limit": 50000,
            "remaining": 42156,
            "reset": 1704153600,
            "window": "24h"
        }
    }
}</pre>
        </div>

        <!-- STORAGE ALTERNATIVES -->
        <h3>üîÄ Storage Alternatives</h3>
        <div class="alternatives-grid">
            <div class="alternative-card selected">
                <h5>‚úÖ Redis / ElastiCache (Selected)</h5>
                <p>In-memory, atomic Lua scripts, sub-ms latency</p>
                <div class="pros-cons-grid" style="margin: 12px 0;">
                    <div style="background: #f0fdf4; padding: 12px; border-radius: 8px;">
                        <strong style="color: #166534;">Pros:</strong>
                        <ul style="margin: 8px 0 0 0; padding-left: 16px; font-size: 13px;">
                            <li>Lua scripts for atomicity</li>
                            <li>O(1) operations</li>
                            <li>Built-in TTL/expiry</li>
                            <li>Cluster mode for scaling</li>
                        </ul>
                    </div>
                    <div style="background: #fef2f2; padding: 12px; border-radius: 8px;">
                        <strong style="color: #991b1b;">Cons:</strong>
                        <ul style="margin: 8px 0 0 0; padding-left: 16px; font-size: 13px;">
                            <li>Memory cost at scale</li>
                            <li>Single point of failure (mitigate w/ cluster)</li>
                            <li>Network latency added</li>
                        </ul>
                    </div>
                </div>
                <div style="background: #fef3c7; padding: 10px; border-radius: 6px; font-size: 13px;">
                    <strong>‚ö†Ô∏è Care:</strong> Set maxmemory-policy to volatile-lru. Monitor evictions.
                </div>
            </div>

            <div class="alternative-card">
                <h5>Memcached</h5>
                <p>Simpler key-value, multi-threaded</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Better multi-core performance<br>
                    <span style="color: #22c55e;">‚úì</span> Lower memory overhead<br>
                    <span style="color: #22c55e;">‚úì</span> INCR/DECR atomic<br>
                    <span style="color: #ef4444;">‚úó</span> No Lua scripts (race conditions)<br>
                    <span style="color: #ef4444;">‚úó</span> No persistence
                </div>
                <div style="background: #eff6ff; padding: 8px; border-radius: 6px; font-size: 12px; margin-top: 8px;">
                    <strong>When to use:</strong> Simple fixed window counter only. No complex algorithms needed.
                </div>
            </div>

            <div class="alternative-card">
                <h5>Local Memory + Sync</h5>
                <p>In-process rate limiting with periodic sync</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Zero network latency<br>
                    <span style="color: #22c55e;">‚úì</span> Works if Redis down<br>
                    <span style="color: #ef4444;">‚úó</span> Inconsistent across servers<br>
                    <span style="color: #ef4444;">‚úó</span> User can exceed by Nx (N servers)
                </div>
                <div style="background: #eff6ff; padding: 8px; border-radius: 6px; font-size: 12px; margin-top: 8px;">
                    <strong>When to use:</strong> Hybrid approach - local first pass, Redis for accuracy.
                </div>
            </div>
        </div>

        <!-- ALGORITHM ALTERNATIVES -->
        <h3>üîÄ Algorithm Alternatives</h3>
        <div class="alternatives-grid">
            <div class="alternative-card selected">
                <h5>‚úÖ Token Bucket (Selected)</h5>
                <p>Best for APIs with burst tolerance</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Allows controlled bursts<br>
                    <span style="color: #22c55e;">‚úì</span> Memory efficient O(1)<br>
                    <span style="color: #22c55e;">‚úì</span> Intuitive parameters<br>
                    <span style="color: #ef4444;">‚úó</span> Can cause traffic spikes
                </div>
                <div style="background: #eff6ff; padding: 8px; border-radius: 6px; font-size: 12px; margin-top: 8px;">
                    <strong>Best for:</strong> General API rate limiting, user-facing APIs
                </div>
            </div>

            <div class="alternative-card">
                <h5>Sliding Window Counter</h5>
                <p>Balanced accuracy and memory</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> No burst at boundaries<br>
                    <span style="color: #22c55e;">‚úì</span> Memory efficient O(1)<br>
                    <span style="color: #22c55e;">‚úì</span> Smooth rate limiting<br>
                    <span style="color: #ef4444;">‚úó</span> Approximate (~99.7% accurate)
                </div>
                <div style="background: #eff6ff; padding: 8px; border-radius: 6px; font-size: 12px; margin-top: 8px;">
                    <strong>Best for:</strong> Strict rate limits, billing/quota systems
                </div>
            </div>

            <div class="alternative-card">
                <h5>Leaky Bucket</h5>
                <p>Smoothest output, queues requests</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Constant output rate<br>
                    <span style="color: #22c55e;">‚úì</span> Protects downstream<br>
                    <span style="color: #ef4444;">‚úó</span> Adds latency (queuing)<br>
                    <span style="color: #ef4444;">‚úó</span> Complex to implement
                </div>
                <div style="background: #eff6ff; padding: 8px; border-radius: 6px; font-size: 12px; margin-top: 8px;">
                    <strong>Best for:</strong> Traffic shaping, protecting fragile backends
                </div>
            </div>
        </div>

        <!-- DESIGN PATTERNS -->
        <h3>üß© Design Patterns Used</h3>
        <div class="patterns-grid">
            <div class="pattern-card">
                <h5>Decorator Pattern (Middleware)</h5>
                <p>Wrap request handlers with rate limiting. Transparent to business logic. Easy to add/remove.</p>
            </div>
            <div class="pattern-card">
                <h5>Strategy Pattern</h5>
                <p>Switch algorithms at runtime. TokenBucketStrategy, SlidingWindowStrategy, LeakyBucketStrategy. Configure per endpoint.</p>
            </div>
            <div class="pattern-card">
                <h5>Singleton Pattern</h5>
                <p>Single RateLimiter instance per service. Manages connection pool to Redis. Thread-safe operations.</p>
            </div>
            <div class="pattern-card">
                <h5>Chain of Responsibility</h5>
                <p>Multiple rate limit checks: IP ‚Üí User ‚Üí API Key ‚Üí Endpoint. First failure rejects request.</p>
            </div>
        </div>

        <div class="code-example">
            <h5 style="color: #60a5fa; margin-bottom: 12px;">Middleware Implementation (Go)</h5>
<pre>type RateLimiter struct {
    redis    *redis.Client
    script   *redis.Script
    capacity int
    rate     float64
}

func NewRateLimiter(redis *redis.Client, capacity int, rate float64) *RateLimiter {
    return &RateLimiter{
        redis:    redis,
        script:   redis.NewScript(tokenBucketLua),
        capacity: capacity,
        rate:     rate,
    }
}

func (rl *RateLimiter) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        key := rl.extractKey(c)  // IP, user ID, or API key

        result, err := rl.script.Run(c, rl.redis, []string{key},
            rl.capacity, rl.rate, time.Now().UnixMilli(), 1,
        ).Result()

        if err != nil {
            // Fail open on Redis error (graceful degradation)
            c.Next()
            return
        }

        res := result.([]interface{})
        allowed := res[0].(int64)
        remaining := res[1].(int64)
        resetTime := res[2].(int64)

        // Always set rate limit headers
        c.Header("X-RateLimit-Limit", strconv.Itoa(rl.capacity))
        c.Header("X-RateLimit-Remaining", strconv.FormatInt(remaining, 10))
        c.Header("X-RateLimit-Reset", strconv.FormatInt(time.Now().Unix()+resetTime, 10))

        if allowed == 0 {
            c.Header("Retry-After", strconv.FormatInt(resetTime, 10))
            c.JSON(429, gin.H{"error": "Rate limit exceeded"})
            c.Abort()
            return
        }

        c.Next()
    }
}</pre>
        </div>

        <!-- AWS COST ESTIMATION -->
        <h3>üí∞ AWS Cost Estimation (MVP)</h3>
        <div class="feature-card">
            <table class="cost-table">
                <thead>
                    <tr>
                        <th>Service</th>
                        <th>Spec</th>
                        <th>Monthly Cost</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="cost-tag aws">ElastiCache</span> Redis</td>
                        <td>cache.t3.micro, 0.5GB, single node</td>
                        <td>$15</td>
                    </tr>
                    <tr>
                        <td><span class="cost-tag aws">EC2</span> API Servers (2x)</td>
                        <td>t3.small (rate limiter overhead minimal)</td>
                        <td>$30</td>
                    </tr>
                    <tr>
                        <td><span class="cost-tag aws">CloudWatch</span> Monitoring</td>
                        <td>Rate limit metrics, alarms</td>
                        <td>$10</td>
                    </tr>
                    <tr>
                        <td><span class="cost-tag aws">Lambda@Edge</span> (Optional)</td>
                        <td>Edge rate limiting, 1M requests</td>
                        <td>$5</td>
                    </tr>
                    <tr class="total-row">
                        <td colspan="2"><strong>Total MVP Monthly</strong></td>
                        <td><strong>~$60/month</strong></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- K8s DEPLOYMENT -->
        <h3>üöÄ Deployment (K8s)</h3>
        <div class="deployment-diagram">
            <h4>Kubernetes Architecture - Sidecar vs Centralized</h4>
            <div class="k8s-cluster">
                <h5>Option 1: Middleware (Recommended for MVP)</h5>
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px;">
                    <div class="k8s-pod">üî∑ api-pod (rate limiter built-in)</div>
                    <div class="k8s-pod">üî∑ api-pod (rate limiter built-in)</div>
                </div>
                <h5>Option 2: Sidecar (For complex policies)</h5>
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px;">
                    <div class="k8s-pod" style="background: #7c3aed;">üî∑ api-container + envoy-sidecar</div>
                </div>
                <h5>Option 3: Centralized Service</h5>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <div class="k8s-pod" style="background: #0891b2;">üåê rate-limiter-service (replicas: 3)</div>
                    <div class="k8s-pod" style="background: #dc2626;">üîê ConfigMap: rate-limit-rules</div>
                </div>
            </div>
        </div>

        <div class="code-example">
            <h5 style="color: #60a5fa; margin-bottom: 12px;">deployment.yaml</h5>
<pre>apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-with-rate-limiter
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api
  template:
    spec:
      containers:
      - name: api
        image: api:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-creds
              key: url
        - name: RATE_LIMIT_ENABLED
          valueFrom:
            configMapKeyRef:
              name: rate-limit-config
              key: enabled
        - name: RATE_LIMIT_CAPACITY
          value: "100"
        - name: RATE_LIMIT_RATE
          value: "10"  # 10 tokens/sec
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "200m"
            memory: "256Mi"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: rate-limit-config
data:
  enabled: "true"
  rules: |
    default:
      capacity: 100
      rate: 10
    /api/v1/expensive:
      capacity: 10
      rate: 1
    /api/v1/health:
      enabled: false</pre>
        </div>

        <!-- ROLLBACK STRATEGY -->
        <h3>‚è™ Rollback Strategy</h3>
        <div class="feature-card warning">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4>Quick Disable via Config</h4>
                    <div class="code-example" style="margin: 12px 0;">
<pre># Instant disable without deploy
kubectl patch configmap rate-limit-config \
  -p '{"data":{"enabled":"false"}}'

# Or via feature flag service
curl -X POST https://flags.internal/rate-limiter \
  -d '{"enabled": false}'</pre>
                    </div>
                    <p style="font-size: 14px;">Config change propagates in &lt;10s</p>
                </div>
                <div>
                    <h4>Fallback Modes</h4>
                    <ul style="font-size: 14px;">
                        <li><strong>Fail Open:</strong> Allow all if Redis down (default)</li>
                        <li><strong>Fail Closed:</strong> Deny all if Redis down (strict)</li>
                        <li><strong>Local Fallback:</strong> Use in-memory limits (degraded accuracy)</li>
                        <li><strong>Log Only:</strong> Check limits but don't enforce</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- SCALE METRICS -->
        <h3>üìä Scale Metrics (MVP)</h3>
        <div class="metrics-card">
            <div class="metric">
                <div class="value">10K</div>
                <div class="label">Checks/sec</div>
            </div>
            <div class="metric">
                <div class="value">&lt;1ms</div>
                <div class="label">Latency Overhead</div>
            </div>
            <div class="metric">
                <div class="value">&lt;0.1%</div>
                <div class="label">False Positive Rate</div>
            </div>
            <div class="metric">
                <div class="value">99.9%</div>
                <div class="label">Availability</div>
            </div>
        </div>

        <!-- EDGE CASES -->
        <div class="edge-cases">
            <h4>Edge Cases & Error Handling</h4>

            <div class="edge-case-item">
                <div class="case-title">Redis Failure (Fallback Strategy)</div>
                <p>Redis becomes unavailable due to network partition, memory exhaustion, or cluster failover.</p>
                <div class="case-solution"><strong>Fail Open:</strong> Allow all requests (default for most APIs). <strong>Fail Closed:</strong> Deny all (for sensitive endpoints). <strong>Local Fallback:</strong> Use in-memory rate limiting with degraded accuracy. Implement circuit breaker pattern with 30s recovery window.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Clock Skew in Distributed Systems</div>
                <p>Different servers have slightly different system times, causing inconsistent window calculations.</p>
                <div class="case-solution">Use Redis server time (TIME command) instead of local time. Implement NTP sync with &lt;10ms drift tolerance. For sliding window, use Redis ZRANGEBYSCORE with server timestamps. Add 100ms grace period to window boundaries.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">IP Spoofing</div>
                <p>Attackers forge X-Forwarded-For headers to bypass IP-based rate limits.</p>
                <div class="case-solution">Only trust X-Forwarded-For from known proxies (ALB, CloudFront). Use rightmost non-private IP. Implement API key + IP combination for authenticated endpoints. Consider device fingerprinting for additional signal.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Shared IPs (NAT/Corporate)</div>
                <p>Multiple legitimate users share same IP (office networks, mobile carriers, universities).</p>
                <div class="case-solution">Higher limits for known NAT ranges. Prefer user ID over IP for authenticated requests. Implement graduated limits: IP (loose) + User (strict). Use ASN database to identify corporate/ISP ranges.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Burst vs Sustained Traffic</div>
                <p>Legitimate use case needs 100 requests in 1 second, but sustained 100/min is fine.</p>
                <div class="case-solution">Token bucket with burst capacity (e.g., bucket=50, refill=2/sec). Implement dual limits: burst (per-second) + sustained (per-minute). Configure different algorithms per endpoint type.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Legitimate Spike vs Attack</div>
                <p>Marketing campaign causes 10x traffic spike that looks like DDoS.</p>
                <div class="case-solution">Pre-warm rate limits before known events. Implement allowlists for verified partners. Use adaptive limits that scale with authenticated user history. Alert on anomaly but don't auto-block without confirmation.</div>
            </div>
        </div>

        <!-- FUTURE ASPECTS -->
        <div class="future-aspects">
            <h4>Future Enhancements</h4>

            <div class="future-item">
                <div class="future-title">ML-Based Adaptive Limits</div>
                <p>Dynamically adjust rate limits based on user behavior patterns and risk scores.</p>
                <div class="future-approach">Train model on historical usage patterns. Input: request frequency, endpoint mix, time of day, user tenure. Output: personalized limit multiplier (0.5x to 3x). Retrain weekly. Explain decisions for audit.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Behavioral Rate Limiting</div>
                <p>Rate limit based on behavior patterns rather than simple request counts.</p>
                <div class="future-approach">Track request sequences (e.g., search ‚Üí view ‚Üí checkout = normal). Flag anomalous patterns (100 searches, 0 views). Use session-based limits. Implement "reputation score" that affects limits.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Cost-Based Quotas</div>
                <p>Different operations have different costs; heavy queries should count more.</p>
                <div class="future-approach">Assign cost weights: GET=1, POST=5, complex query=20. Track "cost units" instead of requests. Enable users to see cost breakdown in dashboard. Offer prepaid quota packages.</div>
            </div>

            <div class="future-item">
                <div class="future-title">GraphQL Complexity Limiting</div>
                <p>Prevent expensive nested GraphQL queries that could DoS the server.</p>
                <div class="future-approach">Calculate query complexity before execution (depth + breadth). Set max complexity per request (e.g., 1000 points). Rate limit by total complexity per minute. Reject queries exceeding single-request max.</div>
            </div>
        </div>

        <!-- INTERVIEW FOLLOW-UP FEATURES -->
        <div class="followup-features">
            <h4>Interview Follow-Up Questions</h4>

            <div class="followup-item">
                <div class="followup-number">1</div>
                <div class="followup-content">
                    <div class="followup-question">Compare Token Bucket vs Leaky Bucket vs Sliding Window. When would you use each?</div>
                    <div class="followup-hint"><strong>Token Bucket:</strong> Allows bursts, best for user-facing APIs. <strong>Leaky Bucket:</strong> Smoothest output, best for protecting fragile backends. <strong>Sliding Window Counter:</strong> No boundary burst, best for billing/quotas. <strong>Sliding Window Log:</strong> Most accurate, but O(n) memory.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">2</div>
                <div class="followup-content">
                    <div class="followup-question">How do you ensure consistency in distributed rate limiting across multiple servers?</div>
                    <div class="followup-hint">Centralized store (Redis) with atomic Lua scripts. Accept eventual consistency for performance (user may get 10% over limit). Use sticky sessions for strict accuracy. Implement local + global hybrid with periodic sync.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">3</div>
                <div class="followup-content">
                    <div class="followup-question">How would you implement rate limiting for a multi-tenant SaaS platform?</div>
                    <div class="followup-hint">Hierarchical limits: Global ‚Üí Tenant ‚Üí User ‚Üí Endpoint. Store tenant limits in config (Redis hash). Use tenant_id in rate limit key. Implement noisy neighbor isolation (one tenant can't affect others). Offer self-service limit management.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">4</div>
                <div class="followup-content">
                    <div class="followup-question">What happens if your rate limiter becomes the bottleneck?</div>
                    <div class="followup-hint">Local caching of rate limit state (check local first). Batch Redis operations (pipeline). Fail open under extreme load. Use sampling (check 1 in 10 requests). Consider edge rate limiting (CloudFront/Lambda@Edge).</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">5</div>
                <div class="followup-content">
                    <div class="followup-question">How do you handle rate limit bypass for internal services and health checks?</div>
                    <div class="followup-hint">Allowlist internal IP ranges (10.x.x.x). Use service mesh identity (mTLS). Separate rate limit pools for internal vs external. Exempt specific paths (/health, /metrics). Use internal API keys with unlimited quota.</div>
                </div>
            </div>
        </div>

        <!-- SUMMARY FLOW DIAGRAM -->
        <div class="summary-flow">
            <h4>MVP Stage - Complete Request Flow</h4>
            <div class="flow-vertical">
                <!-- Rate Limit Check Flow -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #166534; margin-bottom: 12px;">RATE LIMIT CHECK FLOW</div>
                    <div class="flow-row">
                        <div class="flow-node user">Request<br><small>POST /api/data</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node gateway">Extract Key<br><small>IP / User / API Key</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cache">Redis<br><small>EVALSHA lua_script</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node service">Decision<br><small>Check tokens</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node db" style="background: #22c55e;">200 OK<br><small>‚Üí Backend</small></div>
                    </div>
                </div>

                <!-- Rate Limited Path -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #ef4444; margin-bottom: 12px;">RATE LIMITED PATH</div>
                    <div class="flow-row">
                        <div class="flow-node cache">Redis Check<br><small>tokens = 0</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node user" style="background: #ef4444;">429 Denied<br><small>Retry-After: 30s</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node service">Log Event<br><small>Metrics + Alert</small></div>
                    </div>
                </div>

                <!-- Sliding Window Log Visual -->
                <div style="width: 100%;">
                    <div style="text-align: center; font-weight: 700; color: #3b82f6; margin-bottom: 12px;">SLIDING WINDOW LOG ALGORITHM</div>
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;">
                            <div style="background: #64748b; padding: 8px 12px; border-radius: 6px; font-size: 12px;">
                                <span style="text-decoration: line-through; color: #94a3b8;">09:59:30</span><br>
                                <small>Expired</small>
                            </div>
                            <div style="background: #3b82f6; padding: 8px 12px; border-radius: 6px; font-size: 12px;">
                                10:00:15<br><small>In window</small>
                            </div>
                            <div style="background: #3b82f6; padding: 8px 12px; border-radius: 6px; font-size: 12px;">
                                10:00:23<br><small>In window</small>
                            </div>
                            <div style="background: #3b82f6; padding: 8px 12px; border-radius: 6px; font-size: 12px;">
                                10:00:45<br><small>In window</small>
                            </div>
                            <div style="background: #22c55e; padding: 8px 12px; border-radius: 6px; font-size: 12px;">
                                10:00:58<br><small>New request</small>
                            </div>
                        </div>
                        <div style="font-size: 13px; color: #94a3b8;">
                            Window: 60s | Limit: 100 | Current: <span style="color: #22c55e; font-weight: bold;">4 requests</span> |
                            <span style="color: #22c55e;">ALLOWED</span>
                        </div>
                        <div style="margin-top: 12px; font-size: 12px; color: #64748b;">
                            ZREMRANGEBYSCORE removes entries older than (now - window_size)
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DB EVOLUTION -->
        <div class="db-evolution">
            <h4>Storage Evolution Across Stages</h4>
            <div class="evolution-timeline">
                <div class="evolution-stage">
                    <div class="evolution-icon">üíæ</div>
                    <div class="evolution-label">Local</div>
                    <div class="evolution-db">In-Memory</div>
                    <div class="evolution-detail">sync.Map / LRU cache<br>Single server only</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üî¥</div>
                    <div class="evolution-label">MVP</div>
                    <div class="evolution-db">Single Redis</div>
                    <div class="evolution-detail">ElastiCache<br>Lua scripts for atomicity</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üî∑</div>
                    <div class="evolution-label">Scale</div>
                    <div class="evolution-db">Redis Cluster</div>
                    <div class="evolution-detail">16+ shards<br>Hash slot distribution</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üåê</div>
                    <div class="evolution-label">Global</div>
                    <div class="evolution-db">Cell-Based Architecture</div>
                    <div class="evolution-detail">Regional Redis + sync<br>Quota allocation per cell</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ============================================ -->
    <!-- PAN-INDIA SCALE -->
    <!-- ============================================ -->
    <div class="stage-section" id="pan-india">
        <div class="stage-header">
            <span class="stage-badge pan-india">PAN-India Scale</span>
            <h2 style="margin: 0;">Multi-Region ‚Ä¢ 100K users ‚Ä¢ 10K req/sec</h2>
        </div>

        <!-- REQUIREMENTS -->
        <h3>üìã Requirements</h3>
        <div class="feature-card">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4 style="color: #22c55e;">Functional</h4>
                    <ul>
                        <li>All MVP features</li>
                        <li>Global rate limits (across regions)</li>
                        <li>Regional rate limits (per-region)</li>
                        <li>Tiered limits (free/pro/enterprise)</li>
                        <li>Dynamic limit adjustment via API</li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: #3b82f6;">Non-Functional</h4>
                    <ul>
                        <li>Latency: &lt;2ms p99 (cross-region)</li>
                        <li>Availability: 99.95%</li>
                        <li>Eventual consistency: &lt;1s sync</li>
                        <li>Throughput: 100K checks/sec</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ARCHITECTURE -->
        <h3>üèóÔ∏è Architecture Evolution</h3>
        <div class="diagram-container">
            <h4>Multi-Region Rate Limiting</h4>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
                <div class="arch-box client">Users (All India)</div>
                <div class="arch-arrow">‚Üì</div>
                <div class="arch-box lb">Route 53 (Latency-based)</div>
                <div class="arch-arrow">‚Üì</div>
                <div style="display: flex; gap: 40px; flex-wrap: wrap; justify-content: center;">
                    <div style="text-align: center; padding: 16px; border: 2px dashed #3b82f6; border-radius: 12px;">
                        <strong style="color: #3b82f6;">Mumbai (ap-south-1)</strong>
                        <div style="display: flex; gap: 12px; margin-top: 12px;">
                            <div class="arch-box server" style="padding: 10px;">API (5x)</div>
                            <div class="arch-box cache" style="padding: 10px;">Redis Primary</div>
                        </div>
                    </div>
                    <div style="text-align: center; padding: 16px; border: 2px dashed #22c55e; border-radius: 12px;">
                        <strong style="color: #22c55e;">Hyderabad (ap-south-2)</strong>
                        <div style="display: flex; gap: 12px; margin-top: 12px;">
                            <div class="arch-box server" style="padding: 10px;">API (3x)</div>
                            <div class="arch-box cache" style="padding: 10px;">Redis Replica</div>
                        </div>
                    </div>
                </div>
                <div class="arch-arrow">‚Üì</div>
                <div style="text-align: center;">
                    <div class="arch-box queue" style="background: #8b5cf6;">ElastiCache Global Datastore<br><small>Cross-region replication &lt;1s</small></div>
                </div>
            </div>
        </div>

        <!-- DATA FLOW - DISTRIBUTED -->
        <h3>üîÑ Distributed Rate Limiting</h3>
        <div class="diagram-container">
            <h4>Handling Rate Limits Across Multiple Servers</h4>
            <div style="margin: 20px 0;">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                    <div style="background: #1e293b; padding: 16px; border-radius: 8px; text-align: center;">
                        <h5 style="color: #f59e0b;">Option 1: Centralized Redis</h5>
                        <p style="font-size: 13px; color: #94a3b8;">All servers check single Redis cluster</p>
                        <div style="margin-top: 8px; font-size: 12px;">
                            <span style="color: #22c55e;">‚úì Accurate</span><br>
                            <span style="color: #ef4444;">‚úó Higher latency</span>
                        </div>
                    </div>
                    <div style="background: #1e293b; padding: 16px; border-radius: 8px; text-align: center; border: 2px solid #22c55e;">
                        <h5 style="color: #22c55e;">Option 2: Eventual Consistency ‚úì</h5>
                        <p style="font-size: 13px; color: #94a3b8;">Local Redis + async sync</p>
                        <div style="margin-top: 8px; font-size: 12px;">
                            <span style="color: #22c55e;">‚úì Low latency</span><br>
                            <span style="color: #f59e0b;">~ Slight over-limit OK</span>
                        </div>
                    </div>
                    <div style="background: #1e293b; padding: 16px; border-radius: 8px; text-align: center;">
                        <h5 style="color: #3b82f6;">Option 3: Sticky Sessions</h5>
                        <p style="font-size: 13px; color: #94a3b8;">Route user to same server</p>
                        <div style="margin-top: 8px; font-size: 12px;">
                            <span style="color: #22c55e;">‚úì Simple</span><br>
                            <span style="color: #ef4444;">‚úó Uneven load</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- REDIS DATA STRUCTURES - DISTRIBUTED -->
        <h3>üóÑÔ∏è Distributed Redis Schema</h3>
        <div class="sql-query">
            <h5>Global vs Regional Rate Limits</h5>
<pre>-- Global rate limit (synced across regions)
-- Key format: global:ratelimit:{user_id}
SET global:ratelimit:user123 "45" EX 60

-- Regional rate limit (local to region)
-- Key format: regional:{region}:ratelimit:{user_id}
SET regional:ap-south-1:ratelimit:user123 "23" EX 60

-- Tiered configuration (replicated via config)
HSET ratelimit:config:pro capacity 1000 rate 100 burst 200
HSET ratelimit:config:free capacity 100 rate 10 burst 20

-- Sync counter for eventual consistency
-- Periodically aggregate regional counters to global
INCRBY global:ratelimit:user123 {regional_delta}</pre>
        </div>

        <div class="code-example">
            <h5 style="color: #60a5fa; margin-bottom: 12px;">Cross-Region Sync Logic</h5>
<pre>// Sync regional counts to global every 500ms
func (rl *DistributedRateLimiter) syncToGlobal(ctx context.Context) {
    ticker := time.NewTicker(500 * time.Millisecond)
    for range ticker.C {
        // Get local delta since last sync
        delta := rl.localRedis.GetAndReset("local:delta:" + rl.region)

        // Update global counter
        if delta > 0 {
            rl.globalRedis.IncrBy(ctx, "global:ratelimit:"+key, delta)
        }

        // Fetch global count for accuracy check
        globalCount := rl.globalRedis.Get(ctx, "global:ratelimit:"+key)
        rl.localRedis.Set(ctx, "global:snapshot:"+key, globalCount, time.Second)
    }
}

// Rate limit check with global awareness
func (rl *DistributedRateLimiter) Allow(ctx context.Context, key string) bool {
    // Fast path: check local first
    localAllowed := rl.checkLocal(ctx, key)
    if !localAllowed {
        return false
    }

    // Check against global snapshot (may be slightly stale)
    globalSnapshot := rl.localRedis.Get(ctx, "global:snapshot:"+key)
    return globalSnapshot < rl.globalLimit
}</pre>
        </div>

        <!-- ALGORITHM ALTERNATIVES FOR DISTRIBUTED -->
        <h3>üîÄ Distributed Algorithm Alternatives</h3>
        <div class="alternatives-grid">
            <div class="alternative-card selected">
                <h5>‚úÖ Token Bucket + Sync (Selected)</h5>
                <p>Local bucket with periodic global sync</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Tolerates network partitions<br>
                    <span style="color: #22c55e;">‚úì</span> Allows local bursts<br>
                    <span style="color: #ef4444;">‚úó</span> Slight over-limit during sync delay
                </div>
            </div>

            <div class="alternative-card">
                <h5>Sliding Window + CRDT</h5>
                <p>Conflict-free replicated counters</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Mathematically consistent<br>
                    <span style="color: #22c55e;">‚úì</span> No sync needed<br>
                    <span style="color: #ef4444;">‚úó</span> Complex implementation
                </div>
            </div>

            <div class="alternative-card">
                <h5>Gossip Protocol</h5>
                <p>P2P sync between servers</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> No central point<br>
                    <span style="color: #ef4444;">‚úó</span> Convergence time varies<br>
                    <span style="color: #ef4444;">‚úó</span> Overkill for most cases
                </div>
            </div>
        </div>

        <!-- DESIGN PATTERNS -->
        <h3>üß© Design Patterns Used</h3>
        <div class="patterns-grid">
            <div class="pattern-card">
                <h5>Ambassador Pattern</h5>
                <p>Sidecar handles rate limit checks. Main app unaware of distributed complexity. Envoy proxy integration.</p>
            </div>
            <div class="pattern-card">
                <h5>Circuit Breaker</h5>
                <p>If global Redis unreachable, fall back to local-only limiting. Prevent cascade failures.</p>
            </div>
            <div class="pattern-card">
                <h5>Bulkhead Pattern</h5>
                <p>Separate rate limit pools per tenant/service. Noisy neighbor isolation.</p>
            </div>
            <div class="pattern-card">
                <h5>Event Sourcing</h5>
                <p>Log all rate limit events. Replay to reconstruct state. Audit trail for disputes.</p>
            </div>
        </div>

        <!-- AWS COST -->
        <h3>üí∞ Cost at PAN-India Scale</h3>
        <div class="feature-card">
            <table class="cost-table">
                <tr>
                    <td><span class="cost-tag aws">ElastiCache</span> Global Datastore</td>
                    <td>cache.r6g.large √ó 2 regions</td>
                    <td>$400</td>
                </tr>
                <tr>
                    <td><span class="cost-tag aws">EC2/EKS</span> API Servers</td>
                    <td>8 nodes across regions</td>
                    <td>$500</td>
                </tr>
                <tr>
                    <td><span class="cost-tag aws">Route 53</span></td>
                    <td>Latency routing + health checks</td>
                    <td>$50</td>
                </tr>
                <tr>
                    <td><span class="cost-tag aws">CloudWatch</span></td>
                    <td>Cross-region metrics, dashboards</td>
                    <td>$50</td>
                </tr>
                <tr class="total-row">
                    <td colspan="2"><strong>Total</strong></td>
                    <td><strong>~$1,000/month</strong></td>
                </tr>
            </table>
        </div>

        <!-- SCALE METRICS -->
        <h3>üìä Scale Metrics</h3>
        <div class="metrics-card">
            <div class="metric">
                <div class="value">100K</div>
                <div class="label">Checks/sec</div>
            </div>
            <div class="metric">
                <div class="value">&lt;2ms</div>
                <div class="label">P99 Latency</div>
            </div>
            <div class="metric">
                <div class="value">&lt;1s</div>
                <div class="label">Cross-region Sync</div>
            </div>
            <div class="metric">
                <div class="value">99.95%</div>
                <div class="label">Availability</div>
            </div>
        </div>

        <!-- EDGE CASES -->
        <div class="edge-cases">
            <h4>Edge Cases & Error Handling</h4>

            <div class="edge-case-item">
                <div class="case-title">Cross-Region Redis Replication Lag</div>
                <p>User hits Mumbai then immediately hits Hyderabad before sync completes.</p>
                <div class="case-solution">Accept eventual consistency (1-2% over-limit is OK). Use local-first check with global snapshot. Implement "soft limits" that warn before hard block. For critical APIs, use synchronous global check (adds latency).</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Region Failover During Traffic Spike</div>
                <p>Primary region fails, all traffic redirects to secondary which doesn't have rate limit state.</p>
                <div class="case-solution">Replicate rate limit state via Global Datastore. On failover, use conservative limits initially. Implement "recovery mode" with relaxed limits for 5 minutes. Pre-warm standby region with recent state snapshots.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Clock Drift Across Regions</div>
                <p>Mumbai and Hyderabad servers have 500ms clock difference causing window miscalculations.</p>
                <div class="case-solution">Use Redis TIME for all timestamp operations. Implement vector clocks for cross-region ordering. AWS Time Sync Service ensures &lt;1ms drift. Add tolerance buffer to window boundaries.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Tenant Isolation Breach</div>
                <p>High-traffic tenant exhausts shared Redis resources, affecting other tenants.</p>
                <div class="case-solution">Separate Redis instances per tier (free vs enterprise). Implement resource quotas per tenant in Redis. Use key prefixing with tenant isolation. Monitor per-tenant Redis operations and alert on abuse.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Dynamic Limit Changes During High Load</div>
                <p>Admin updates rate limits but change doesn't propagate consistently across regions.</p>
                <div class="case-solution">Use config versioning with atomic updates. Propagate via dedicated config sync channel. Implement "effective_at" timestamp for scheduled changes. Gradual rollout: 10% ‚Üí 50% ‚Üí 100% of traffic.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Geo-Routing Flip-Flop</div>
                <p>User's requests alternate between regions due to DNS instability, doubling their effective limit.</p>
                <div class="case-solution">Use sticky sessions based on user ID (not IP). Implement global rate limit check for authenticated users. Set DNS TTL appropriately (60s minimum). Track user's "home region" and enforce limits there.</div>
            </div>
        </div>

        <!-- FUTURE ASPECTS -->
        <div class="future-aspects">
            <h4>Future Enhancements</h4>

            <div class="future-item">
                <div class="future-title">Federated Rate Limiting</div>
                <p>Allow partner APIs to share rate limit quota across organizational boundaries.</p>
                <div class="future-approach">OAuth-based quota sharing. Partner A grants Partner B 10% of their quota. Implement quota transfer API. Real-time dashboard showing shared usage. Revocation with immediate effect.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Predictive Auto-Scaling</div>
                <p>Anticipate traffic spikes and pre-scale rate limiter infrastructure.</p>
                <div class="future-approach">ML model trained on historical patterns (time of day, day of week, events). Trigger pre-warming 30 minutes before predicted spike. Integrate with AWS Auto Scaling predictive policies. Alert on anomaly detection.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Rate Limit Marketplace</div>
                <p>Allow users to purchase additional quota on-demand during peak usage.</p>
                <div class="future-approach">Integrate with billing system. Offer burst packages (1000 extra requests for $1). Auto-suggest when user approaches limit. Implement spending caps and alerts.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Compliance-Aware Rate Limiting</div>
                <p>Different rate limits based on data residency and regulatory requirements.</p>
                <div class="future-approach">Geo-fence sensitive data endpoints. Stricter limits for cross-border data access. Audit logging for compliance reporting. GDPR/RBI-compliant rate limit policies.</div>
            </div>
        </div>

        <!-- INTERVIEW FOLLOW-UP FEATURES -->
        <div class="followup-features">
            <h4>Interview Follow-Up Questions</h4>

            <div class="followup-item">
                <div class="followup-number">1</div>
                <div class="followup-content">
                    <div class="followup-question">How do you handle rate limiting when a user's requests are load-balanced across multiple servers?</div>
                    <div class="followup-hint">Centralized Redis for source of truth. Each server checks Redis before allowing request. Use Lua scripts for atomic check-and-update. Accept ~1% over-limit due to network latency between check and update.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">2</div>
                <div class="followup-content">
                    <div class="followup-question">What's the trade-off between accuracy and latency in distributed rate limiting?</div>
                    <div class="followup-hint"><strong>Accuracy:</strong> Synchronous global check, adds 5-20ms latency. <strong>Low latency:</strong> Local check with async sync, may allow 10-20% over-limit. <strong>Hybrid:</strong> Local for fast path, global for borderline cases.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">3</div>
                <div class="followup-content">
                    <div class="followup-question">How would you implement tiered rate limits (free/pro/enterprise) with dynamic upgrades?</div>
                    <div class="followup-hint">Store tier limits in Redis hash (config:tier:pro). Include tier in rate limit key (user:123:pro). On upgrade, update user's tier in auth token. New limits apply immediately on next request. Prorate if mid-billing cycle.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">4</div>
                <div class="followup-content">
                    <div class="followup-question">How do you handle rate limit state during a Redis cluster reshard?</div>
                    <div class="followup-hint">ElastiCache handles resharding transparently. Brief increased latency during slot migration. Use hash tags {user:123} to keep related keys together. Implement retry logic with exponential backoff. Fail open during migration.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">5</div>
                <div class="followup-content">
                    <div class="followup-question">Design a rate limit analytics dashboard for multi-region deployment.</div>
                    <div class="followup-hint">Aggregate metrics via CloudWatch cross-region. Show: requests/region, denial rate, top limited users, limit utilization %. Real-time streaming via Kinesis. Historical trends for capacity planning. Alert on sudden denial rate spikes.</div>
                </div>
            </div>
        </div>

        <!-- SUMMARY FLOW DIAGRAM -->
        <div class="summary-flow">
            <h4>PAN-India Stage - Distributed Request Flow</h4>
            <div class="flow-vertical">
                <!-- Multi-Region Flow -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #166534; margin-bottom: 12px;">MULTI-REGION RATE LIMIT FLOW</div>
                    <div class="flow-row">
                        <div class="flow-node user">Request<br><small>User in Delhi</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node gateway">Route 53<br><small>Latency routing</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node service">Mumbai API<br><small>Nearest region</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cache">Local Redis<br><small>Primary check</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node db" style="background: #22c55e;">200 OK</div>
                    </div>
                </div>

                <!-- Sync Flow -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #3b82f6; margin-bottom: 12px;">CROSS-REGION SYNC (Async, every 500ms)</div>
                    <div class="flow-row">
                        <div class="flow-node cache">Mumbai Redis<br><small>delta: +15</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node queue" style="background: #8b5cf6;">Global Datastore<br><small>Replicate</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cache">Hyderabad Redis<br><small>Receive sync</small></div>
                    </div>
                </div>

                <!-- Eventual Consistency Visual -->
                <div style="width: 100%;">
                    <div style="text-align: center; font-weight: 700; color: #f59e0b; margin-bottom: 12px;">EVENTUAL CONSISTENCY MODEL</div>
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap; margin-bottom: 16px;">
                            <div style="text-align: center;">
                                <div style="background: #3b82f6; padding: 12px 24px; border-radius: 8px; margin-bottom: 8px;">
                                    <strong>Mumbai</strong><br>
                                    <span style="font-size: 24px;">78</span><small>/100</small>
                                </div>
                                <small style="color: #94a3b8;">Local count</small>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #22c55e; padding: 12px 24px; border-radius: 8px; margin-bottom: 8px;">
                                    <strong>Hyderabad</strong><br>
                                    <span style="font-size: 24px;">45</span><small>/100</small>
                                </div>
                                <small style="color: #94a3b8;">Local count</small>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #f59e0b; padding: 12px 24px; border-radius: 8px; margin-bottom: 8px;">
                                    <strong>Global</strong><br>
                                    <span style="font-size: 24px;">123</span><small>/200</small>
                                </div>
                                <small style="color: #94a3b8;">Aggregated (eventually)</small>
                            </div>
                        </div>
                        <div style="font-size: 13px; color: #94a3b8;">
                            Each region enforces local + global limits | Sync delay: &lt;1 second | Accuracy: ~98%
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DB EVOLUTION -->
        <div class="db-evolution">
            <h4>Storage Evolution Across Stages</h4>
            <div class="evolution-timeline">
                <div class="evolution-stage">
                    <div class="evolution-icon">üíæ</div>
                    <div class="evolution-label">Local</div>
                    <div class="evolution-db">In-Memory</div>
                    <div class="evolution-detail">sync.Map / LRU cache<br>Single server only</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üî¥</div>
                    <div class="evolution-label">MVP</div>
                    <div class="evolution-db">Single Redis</div>
                    <div class="evolution-detail">ElastiCache<br>Lua scripts for atomicity</div>
                </div>
                <div class="evolution-stage current">
                    <div class="evolution-icon">üáÆüá≥</div>
                    <div class="evolution-label">PAN-India</div>
                    <div class="evolution-db">Redis Global Datastore</div>
                    <div class="evolution-detail">Cross-region replication<br>Primary + Replica</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üåê</div>
                    <div class="evolution-label">Global</div>
                    <div class="evolution-db">Cell-Based Architecture</div>
                    <div class="evolution-detail">Regional Redis + sync<br>Quota allocation per cell</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ============================================ -->
    <!-- HIGH TRAFFIC -->
    <!-- ============================================ -->
    <div class="stage-section" id="high-traffic">
        <div class="stage-header">
            <span class="stage-badge high-traffic">High Traffic</span>
            <h2 style="margin: 0;">1M users ‚Ä¢ 100K req/sec ‚Ä¢ DDoS Protection</h2>
        </div>

        <!-- REQUIREMENTS -->
        <h3>üìã Requirements</h3>
        <div class="feature-card">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4 style="color: #22c55e;">Functional</h4>
                    <ul>
                        <li>All PAN-India features</li>
                        <li>DDoS-level traffic handling</li>
                        <li>IP reputation scoring</li>
                        <li>Adaptive rate limits (auto-adjust)</li>
                        <li>Per-endpoint granular limits</li>
                        <li>Allowlist/Blocklist management</li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: #3b82f6;">Non-Functional</h4>
                    <ul>
                        <li>Latency: &lt;0.5ms p99 (edge)</li>
                        <li>Availability: 99.99%</li>
                        <li>Handle 10x traffic spikes</li>
                        <li>Zero false positives for VIPs</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- WHAT BREAKS FIRST -->
        <h3>‚ö†Ô∏è What Breaks First</h3>
        <div class="feature-card warning">
            <table style="width: 100%; font-size: 15px;">
                <tr>
                    <td style="width: 25%;"><strong>1. Redis Single Shard</strong></td>
                    <td>Hot keys overwhelm single Redis node</td>
                    <td style="color: #22c55e;"><strong>‚Üí Redis Cluster (16+ shards)</strong></td>
                </tr>
                <tr>
                    <td><strong>2. Network Latency</strong></td>
                    <td>Redis round-trip adds latency at scale</td>
                    <td style="color: #22c55e;"><strong>‚Üí Local cache + edge rate limiting</strong></td>
                </tr>
                <tr>
                    <td><strong>3. Lua Script CPU</strong></td>
                    <td>Complex Lua scripts block Redis</td>
                    <td style="color: #22c55e;"><strong>‚Üí Simplify scripts, batch operations</strong></td>
                </tr>
                <tr>
                    <td><strong>4. Connection Pool</strong></td>
                    <td>Too many connections to Redis</td>
                    <td style="color: #22c55e;"><strong>‚Üí Connection pooling, Twemproxy</strong></td>
                </tr>
            </table>
        </div>

        <!-- ARCHITECTURE -->
        <h3>üèóÔ∏è Architecture at Scale</h3>
        <div class="diagram-container">
            <h4>Multi-Layer Rate Limiting</h4>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
                <div class="arch-box client">Incoming Traffic (100K+ req/sec)</div>
                <div class="arch-arrow">‚Üì</div>

                <div style="background: rgba(239,68,68,0.1); padding: 16px; border-radius: 12px; border: 2px solid #ef4444;">
                    <div style="text-align: center; margin-bottom: 8px; color: #ef4444; font-weight: bold;">Layer 1: Edge (CloudFront/WAF)</div>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <div class="arch-box cdn" style="padding: 10px;">IP Blocklist</div>
                        <div class="arch-box cdn" style="padding: 10px;">Geo Blocking</div>
                        <div class="arch-box cdn" style="padding: 10px;">Basic Rate Limit</div>
                    </div>
                </div>
                <div class="arch-arrow">‚Üì 70% blocked</div>

                <div style="background: rgba(249,115,22,0.1); padding: 16px; border-radius: 12px; border: 2px solid #f97316;">
                    <div style="text-align: center; margin-bottom: 8px; color: #f97316; font-weight: bold;">Layer 2: API Gateway</div>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <div class="arch-box gateway" style="padding: 10px;">Auth Check</div>
                        <div class="arch-box gateway" style="padding: 10px;">User Tier Limits</div>
                        <div class="arch-box gateway" style="padding: 10px;">Burst Control</div>
                    </div>
                </div>
                <div class="arch-arrow">‚Üì 20% to backend</div>

                <div style="background: rgba(34,197,94,0.1); padding: 16px; border-radius: 12px; border: 2px solid #22c55e;">
                    <div style="text-align: center; margin-bottom: 8px; color: #22c55e; font-weight: bold;">Layer 3: Service Level</div>
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <div class="arch-box server" style="padding: 10px;">Per-Endpoint</div>
                        <div class="arch-box server" style="padding: 10px;">Resource Limits</div>
                    </div>
                </div>
                <div class="arch-arrow">‚Üì</div>

                <div style="display: flex; gap: 20px;">
                    <div class="arch-box cache">Redis Cluster<br><small>16 shards</small></div>
                    <div class="arch-box db">Hot Key Cache<br><small>Local LRU</small></div>
                </div>
            </div>
        </div>

        <!-- DATA FLOW - HIGH TRAFFIC -->
        <h3>üîÑ High-Traffic Data Flow</h3>
        <div class="diagram-container">
            <div style="display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 12px;">
                <div class="flow-step">
                    <div class="flow-step-number">1</div>
                    <div class="arch-box cdn" style="padding: 10px 16px;">Edge Check</div>
                    <div class="flow-step-label">IP blocklist (0.1ms)</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="flow-step">
                    <div class="flow-step-number">2</div>
                    <div class="arch-box cache" style="padding: 10px 16px;">Local Cache</div>
                    <div class="flow-step-label">Hot key check (0.01ms)</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="flow-step">
                    <div class="flow-step-number">3</div>
                    <div class="arch-box cache" style="padding: 10px 16px;">Redis Cluster</div>
                    <div class="flow-step-label">Only on cache miss (0.5ms)</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="flow-step">
                    <div class="flow-step-number">4</div>
                    <div class="arch-box server" style="padding: 10px 16px;">Backend</div>
                    <div class="flow-step-label">Allowed requests</div>
                </div>
            </div>
        </div>

        <!-- REDIS CLUSTER SCHEMA -->
        <h3>üóÑÔ∏è Redis Cluster Configuration</h3>
        <div class="sql-query">
            <h5>Cluster Sharding Strategy</h5>
<pre>-- Redis Cluster: 16 shards, hash slots 0-16383
-- Key hashing ensures even distribution

-- Use hash tags for related keys on same shard
-- {user:123} ensures all user:123:* keys on same node
SET {user:123}:tokens 100
SET {user:123}:last_refill 1704067200

-- Hot key mitigation: add random suffix
-- Spread famous user across shards
SET ratelimit:famous_user:{rand(1,100)} 50

-- Pipeline commands for efficiency
MULTI
EVALSHA token_bucket {user:123}:rate 100 10 1704067200 1
EXPIRE {user:123}:rate 3600
EXEC</pre>
        </div>

        <div class="code-example">
            <h5 style="color: #60a5fa; margin-bottom: 12px;">Local Cache + Redis Hybrid</h5>
<pre>type HybridRateLimiter struct {
    localCache  *lru.Cache       // In-memory LRU cache
    redisClient *redis.ClusterClient
    localTTL    time.Duration
}

func (rl *HybridRateLimiter) Allow(ctx context.Context, key string) (bool, error) {
    // Step 1: Check local cache first (0.01ms)
    if cached, ok := rl.localCache.Get(key); ok {
        entry := cached.(*RateLimitEntry)
        if entry.Remaining > 0 && time.Now().Before(entry.ExpiresAt) {
            entry.Remaining--
            return true, nil
        }
        if entry.Remaining <= 0 {
            return false, nil  // Locally known to be rate limited
        }
    }

    // Step 2: Check Redis cluster (0.5ms) - only on cache miss
    result, err := rl.redisClient.EvalSha(ctx, tokenBucketSHA, []string{key},
        capacity, rate, time.Now().UnixMilli(), 1).Result()
    if err != nil {
        // Fail open: allow on Redis error
        return true, err
    }

    // Step 3: Update local cache
    res := result.([]interface{})
    allowed := res[0].(int64) == 1
    remaining := res[1].(int64)

    rl.localCache.Add(key, &RateLimitEntry{
        Remaining: int(remaining),
        ExpiresAt: time.Now().Add(rl.localTTL),
    })

    return allowed, nil
}</pre>
        </div>

        <!-- STORAGE ALTERNATIVES -->
        <h3>üîÄ Storage Alternatives at Scale</h3>
        <div class="alternatives-grid">
            <div class="alternative-card selected">
                <h5>‚úÖ Redis Cluster (Selected)</h5>
                <p>Horizontally scaled, automatic sharding</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> 16+ shards for throughput<br>
                    <span style="color: #22c55e;">‚úì</span> Automatic failover<br>
                    <span style="color: #ef4444;">‚úó</span> Cross-slot transactions limited
                </div>
            </div>

            <div class="alternative-card">
                <h5>AWS DynamoDB + DAX</h5>
                <p>Serverless, auto-scaling</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> Zero ops scaling<br>
                    <span style="color: #22c55e;">‚úì</span> DAX for sub-ms reads<br>
                    <span style="color: #ef4444;">‚úó</span> Cost at high throughput<br>
                    <span style="color: #ef4444;">‚úó</span> No Lua scripts
                </div>
            </div>

            <div class="alternative-card">
                <h5>ScyllaDB</h5>
                <p>C++ Cassandra, extreme throughput</p>
                <div style="font-size: 13px; margin-top: 8px;">
                    <span style="color: #22c55e;">‚úì</span> 1M+ ops/sec per node<br>
                    <span style="color: #22c55e;">‚úì</span> Linear scalability<br>
                    <span style="color: #ef4444;">‚úó</span> Higher latency than Redis<br>
                    <span style="color: #ef4444;">‚úó</span> Operational complexity
                </div>
            </div>
        </div>

        <!-- K8s DEPLOYMENT -->
        <h3>üöÄ K8s Deployment at Scale</h3>
        <div class="code-example">
            <h5 style="color: #60a5fa; margin-bottom: 12px;">Envoy Sidecar Rate Limiting</h5>
<pre>apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-with-envoy-ratelimit
spec:
  replicas: 20
  template:
    spec:
      containers:
      - name: api
        image: api:v2.0.0
        ports:
        - containerPort: 8080

      - name: envoy-proxy
        image: envoyproxy/envoy:v1.28
        ports:
        - containerPort: 8443
        volumeMounts:
        - name: envoy-config
          mountPath: /etc/envoy

      volumes:
      - name: envoy-config
        configMap:
          name: envoy-ratelimit-config
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: envoy-ratelimit-config
data:
  envoy.yaml: |
    static_resources:
      listeners:
      - address:
          socket_address: { address: 0.0.0.0, port_value: 8443 }
        filter_chains:
        - filters:
          - name: envoy.filters.network.http_connection_manager
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
              http_filters:
              - name: envoy.filters.http.ratelimit
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit
                  domain: api_ratelimit
                  rate_limit_service:
                    grpc_service:
                      envoy_grpc:
                        cluster_name: ratelimit_cluster</pre>
        </div>

        <!-- ROLLBACK STRATEGY -->
        <h3>‚è™ Rollback Strategy</h3>
        <div class="feature-card warning">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4>Emergency Bypass</h4>
                    <div class="code-example" style="margin: 12px 0;">
<pre># Kill switch at edge (CloudFront)
aws cloudfront update-distribution \
  --id E123 \
  --default-cache-behavior '{"LambdaFunctionAssociations":[]}'

# Disable Envoy rate limiting
kubectl set env deployment/api \
  ENVOY_RATELIMIT_ENABLED=false</pre>
                    </div>
                </div>
                <div>
                    <h4>Gradual Rollback</h4>
                    <ul style="font-size: 14px;">
                        <li>Increase limits by 10x temporarily</li>
                        <li>Switch to log-only mode</li>
                        <li>Enable bypass for VIP users</li>
                        <li>Canary: rollback 10% of traffic first</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- AWS COST -->
        <h3>üí∞ Cost at High Traffic</h3>
        <div class="feature-card">
            <table class="cost-table">
                <tr><td>ElastiCache Cluster (16 shards, r6g.xlarge)</td><td>$4,000</td></tr>
                <tr><td>EKS (20 nodes, c5.2xlarge)</td><td>$5,000</td></tr>
                <tr><td>CloudFront + WAF</td><td>$3,000</td></tr>
                <tr><td>Lambda@Edge (1B invocations)</td><td>$600</td></tr>
                <tr><td>Data Transfer</td><td>$2,000</td></tr>
                <tr class="total-row"><td><strong>Total</strong></td><td><strong>~$14,600/month</strong></td></tr>
            </table>
        </div>

        <!-- SCALE METRICS -->
        <h3>üìä Scale Metrics</h3>
        <div class="metrics-card">
            <div class="metric">
                <div class="value">1M</div>
                <div class="label">Checks/sec</div>
            </div>
            <div class="metric">
                <div class="value">&lt;0.5ms</div>
                <div class="label">P99 Latency</div>
            </div>
            <div class="metric">
                <div class="value">&lt;0.01%</div>
                <div class="label">False Positive</div>
            </div>
            <div class="metric">
                <div class="value">99.99%</div>
                <div class="label">Availability</div>
            </div>
        </div>

        <!-- EDGE CASES -->
        <div class="edge-cases">
            <h4>Edge Cases & Error Handling</h4>

            <div class="edge-case-item">
                <div class="case-title">Hot Key Problem (Celebrity Effect)</div>
                <p>Single user/IP generates millions of requests, overwhelming one Redis shard.</p>
                <div class="case-solution">Spread hot keys across shards using random suffix (user:123:{rand}). Local cache absorbs hot key reads. Implement early rejection at edge (CloudFront). Use dedicated rate limit shard for known hot keys.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Redis Cluster Slot Migration</div>
                <p>During slot rebalancing, some keys temporarily unavailable or slow.</p>
                <div class="case-solution">Implement retry with exponential backoff (max 3 attempts). Fail open during migration (allow requests). Use hash tags to keep user keys together on same slot. Monitor CLUSTER SLOTS for migration status.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">DDoS Amplification via Rate Limit API</div>
                <p>Attacker queries rate limit status API to probe system capacity and plan attack.</p>
                <div class="case-solution">Rate limit the rate limit status endpoint itself. Require authentication for detailed status. Return approximate values (not exact). Implement honeypot detection for probing patterns.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Lua Script Timeout Under Load</div>
                <p>Complex Lua scripts block Redis single-threaded execution, causing cascading delays.</p>
                <div class="case-solution">Keep Lua scripts simple (&lt;10 operations). Set lua-time-limit (default 5s). Pre-load scripts with SCRIPT LOAD. Use simpler algorithms (fixed window) during extreme load. Monitor slow log.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Multi-Layer Rate Limit Inconsistency</div>
                <p>Edge allows request but application layer denies, causing confusing user experience.</p>
                <div class="case-solution">Consistent limit definitions across layers (edge &gt;= app). Use same rate limit key format. Sync configurations via central config service. Include layer info in 429 response for debugging.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Local Cache Stampede</div>
                <p>Local cache entry expires, all threads simultaneously hit Redis.</p>
                <div class="case-solution">Implement singleflight pattern (one request to Redis, share result). Add jitter to cache TTL (TTL + random(0, 10s)). Use probabilistic early expiration. Background refresh before expiry.</div>
            </div>
        </div>

        <!-- FUTURE ASPECTS -->
        <div class="future-aspects">
            <h4>Future Enhancements</h4>

            <div class="future-item">
                <div class="future-title">AI-Powered Anomaly Detection</div>
                <p>Use machine learning to detect sophisticated attack patterns that evade simple rate limits.</p>
                <div class="future-approach">Train model on normal traffic patterns (request timing, endpoint mix, payload size). Real-time scoring via SageMaker endpoint. Auto-escalate suspicious patterns to stricter limits. Human review queue for borderline cases.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Request Priority Queuing</div>
                <p>Instead of hard rejection, queue low-priority requests during traffic spikes.</p>
                <div class="future-approach">Classify requests: critical (payments) &gt; normal (API) &gt; background (analytics). Queue non-critical with timeout. Process queue as capacity allows. Return 202 Accepted with callback URL.</div>
            </div>

            <div class="future-item">
                <div class="future-title">WebAssembly Edge Rate Limiting</div>
                <p>Run rate limiting logic at CDN edge using WASM for sub-millisecond decisions.</p>
                <div class="future-approach">Compile rate limit logic to WASM. Deploy to Cloudflare Workers / Fastly Compute. Local state in edge KV store. Async sync to origin for global state. Achieves &lt;0.1ms overhead.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Blockchain-Based Quota Trading</div>
                <p>Allow enterprises to trade unused API quotas on a transparent marketplace.</p>
                <div class="future-approach">Mint quota tokens on private blockchain. Smart contracts for instant quota transfer. Real-time verification at API gateway. Audit trail for compliance. Settlement in fiat or crypto.</div>
            </div>
        </div>

        <!-- INTERVIEW FOLLOW-UP FEATURES -->
        <div class="followup-features">
            <h4>Interview Follow-Up Questions</h4>

            <div class="followup-item">
                <div class="followup-number">1</div>
                <div class="followup-content">
                    <div class="followup-question">How would you implement rate limiting at the edge (CDN level) vs application level?</div>
                    <div class="followup-hint"><strong>Edge:</strong> CloudFront + Lambda@Edge or WAF rules. Fast (no origin hit), but limited logic. Good for IP blocking, geo-blocking. <strong>App:</strong> Full context (user ID, API key). Complex rules. Higher latency. <strong>Best:</strong> Layer both - edge for coarse, app for fine-grained.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">2</div>
                <div class="followup-content">
                    <div class="followup-question">How do you handle the "thundering herd" problem when rate limit cache expires?</div>
                    <div class="followup-hint">Singleflight pattern: first request fetches, others wait and share result. Probabilistic early expiration: refresh before TTL with some probability. Background refresh: async update before expiry. Mutex with timeout: only one thread updates.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">3</div>
                <div class="followup-content">
                    <div class="followup-question">Design rate limiting for a system that needs to handle 100x traffic during flash sales.</div>
                    <div class="followup-hint">Pre-scale Redis cluster before event. Implement virtual waiting room (queue users before they hit API). Use aggressive local caching. Simplify algorithm to fixed window (fastest). Pre-warm rate limit state. Have kill switch ready.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">4</div>
                <div class="followup-content">
                    <div class="followup-question">How would you implement per-endpoint rate limits with different algorithms?</div>
                    <div class="followup-hint">Strategy pattern: each endpoint has RateLimitStrategy. Config maps endpoint ‚Üí strategy + params. Factory creates appropriate limiter. Example: /search uses sliding window, /checkout uses token bucket with high burst. Store config in Redis for dynamic updates.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">5</div>
                <div class="followup-content">
                    <div class="followup-question">What metrics would you monitor to ensure rate limiter health at scale?</div>
                    <div class="followup-hint"><strong>Latency:</strong> p50/p99 of rate limit check. <strong>Error rate:</strong> Redis connection failures. <strong>Denial rate:</strong> % of 429s (alert if sudden spike). <strong>Cache hit ratio:</strong> local cache effectiveness. <strong>Redis memory:</strong> eviction rate. <strong>False positive rate:</strong> legitimate users blocked.</div>
                </div>
            </div>
        </div>

        <!-- SUMMARY FLOW DIAGRAM -->
        <div class="summary-flow">
            <h4>High Traffic Stage - Multi-Layer Defense Flow</h4>
            <div class="flow-vertical">
                <!-- Multi-Layer Defense -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #166534; margin-bottom: 12px;">MULTI-LAYER RATE LIMITING</div>
                    <div class="flow-row">
                        <div class="flow-node cdn" style="background: #ef4444;">Layer 1: Edge<br><small>WAF + CloudFront</small></div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div class="flow-arrow">‚Üí</div>
                            <span class="flow-arrow-label">70% blocked</span>
                        </div>
                        <div class="flow-node gateway" style="background: #f97316;">Layer 2: Gateway<br><small>API Gateway</small></div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div class="flow-arrow">‚Üí</div>
                            <span class="flow-arrow-label">20% pass</span>
                        </div>
                        <div class="flow-node service" style="background: #22c55e;">Layer 3: App<br><small>Service mesh</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node db">Backend<br><small>Protected</small></div>
                    </div>
                </div>

                <!-- Local + Redis Hybrid -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #3b82f6; margin-bottom: 12px;">LOCAL CACHE + REDIS HYBRID</div>
                    <div class="flow-row">
                        <div class="flow-node service">Request</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cache" style="background: #22c55e;">Local LRU<br><small>0.01ms</small></div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div class="flow-arrow">‚Üí</div>
                            <span class="flow-arrow-label">cache miss</span>
                        </div>
                        <div class="flow-node cache">Redis Cluster<br><small>0.5ms</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node service">Update Local<br><small>Cache result</small></div>
                    </div>
                </div>

                <!-- Hot Key Mitigation Visual -->
                <div style="width: 100%;">
                    <div style="text-align: center; font-weight: 700; color: #f59e0b; margin-bottom: 12px;">HOT KEY MITIGATION STRATEGY</div>
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-bottom: 16px;">
                            <div style="text-align: center;">
                                <div style="background: #ef4444; padding: 8px 16px; border-radius: 6px; margin-bottom: 4px;">
                                    <strong>Problem</strong>
                                </div>
                                <div style="font-size: 12px; color: #94a3b8;">user:celebrity ‚Üí Shard 7<br>1M req/sec to one shard</div>
                            </div>
                            <div style="font-size: 24px; color: #64748b; align-self: center;">‚Üí</div>
                            <div style="text-align: center;">
                                <div style="background: #22c55e; padding: 8px 16px; border-radius: 6px; margin-bottom: 4px;">
                                    <strong>Solution</strong>
                                </div>
                                <div style="font-size: 12px; color: #94a3b8;">user:celebrity:{1-100}<br>Spread across 100 shards</div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">Shard 1</span>
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">Shard 2</span>
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">Shard 3</span>
                            <span style="color: #64748b;">...</span>
                            <span style="background: #3b82f6; padding: 4px 8px; border-radius: 4px; font-size: 11px;">Shard 16</span>
                        </div>
                        <div style="margin-top: 12px; font-size: 12px; color: #64748b;">
                            Aggregate: SUM(user:celebrity:{1-100}) for total count
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DB EVOLUTION -->
        <div class="db-evolution">
            <h4>Storage Evolution Across Stages</h4>
            <div class="evolution-timeline">
                <div class="evolution-stage">
                    <div class="evolution-icon">üíæ</div>
                    <div class="evolution-label">Local</div>
                    <div class="evolution-db">In-Memory</div>
                    <div class="evolution-detail">sync.Map / LRU cache<br>Single server only</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üî¥</div>
                    <div class="evolution-label">MVP</div>
                    <div class="evolution-db">Single Redis</div>
                    <div class="evolution-detail">ElastiCache<br>Lua scripts for atomicity</div>
                </div>
                <div class="evolution-stage current">
                    <div class="evolution-icon">‚ö°</div>
                    <div class="evolution-label">High Traffic</div>
                    <div class="evolution-db">Redis Cluster + Local</div>
                    <div class="evolution-detail">16+ shards<br>LRU hybrid caching</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üåê</div>
                    <div class="evolution-label">Global</div>
                    <div class="evolution-db">Cell-Based Architecture</div>
                    <div class="evolution-detail">Regional Redis + sync<br>Quota allocation per cell</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ============================================ -->
    <!-- GLOBAL SCALE -->
    <!-- ============================================ -->
    <div class="stage-section" id="global">
        <div class="stage-header">
            <span class="stage-badge global">Global Scale</span>
            <h2 style="margin: 0;">10M users ‚Ä¢ 1M req/sec ‚Ä¢ Multi-Region Active-Active</h2>
        </div>

        <!-- REQUIREMENTS -->
        <h3>üìã Requirements</h3>
        <div class="feature-card">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4 style="color: #22c55e;">Functional</h4>
                    <ul>
                        <li>All High-Traffic features</li>
                        <li>Global rate limits (strict)</li>
                        <li>Regional autonomy (continue if region isolated)</li>
                        <li>Multi-tenant isolation</li>
                        <li>Real-time limit adjustments</li>
                        <li>Compliance (GDPR data locality)</li>
                    </ul>
                </div>
                <div>
                    <h4 style="color: #3b82f6;">Non-Functional</h4>
                    <ul>
                        <li>Latency: &lt;1ms globally</li>
                        <li>Availability: 99.999% (5 nines)</li>
                        <li>Handle 100x traffic spikes</li>
                        <li>Zero downtime deployments</li>
                        <li>Sub-second global sync</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- GLOBAL ARCHITECTURE -->
        <h3>üåç Global Architecture</h3>
        <div class="diagram-container">
            <h4>Multi-Region Active-Active</h4>
            <div style="display: flex; gap: 24px; flex-wrap: wrap; justify-content: center;">
                <div style="text-align: center; padding: 20px; background: rgba(59,130,246,0.1); border-radius: 12px;">
                    <strong>US-East (Virginia)</strong>
                    <div class="arch-box server" style="margin-top: 12px;">EKS + Envoy</div>
                    <div class="arch-box cache" style="margin-top: 8px;">Redis Global</div>
                    <div style="font-size: 12px; color: #64748b; margin-top: 8px;">Primary for Americas</div>
                </div>
                <div style="text-align: center; padding: 20px; background: rgba(34,197,94,0.1); border-radius: 12px;">
                    <strong>EU-West (Ireland)</strong>
                    <div class="arch-box server" style="margin-top: 12px;">EKS + Envoy</div>
                    <div class="arch-box cache" style="margin-top: 8px;">Redis Global</div>
                    <div style="font-size: 12px; color: #64748b; margin-top: 8px;">Primary for EMEA</div>
                </div>
                <div style="text-align: center; padding: 20px; background: rgba(249,115,22,0.1); border-radius: 12px;">
                    <strong>Asia-Pacific (Singapore)</strong>
                    <div class="arch-box server" style="margin-top: 12px;">EKS + Envoy</div>
                    <div class="arch-box cache" style="margin-top: 8px;">Redis Global</div>
                    <div style="font-size: 12px; color: #64748b; margin-top: 8px;">Primary for APAC</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <div class="arch-box queue" style="display: inline-block; background: #8b5cf6;">
                    Kafka / Kinesis<br><small>Global event stream for sync</small>
                </div>
            </div>
        </div>

        <!-- DISTRIBUTED RATE LIMITING DEEP DIVE -->
        <h3>üîÑ Global Rate Limiting Strategies</h3>
        <div class="diagram-container">
            <h4>Consistency vs Availability Trade-offs</h4>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-top: 16px;">
                <div style="background: #1e293b; padding: 16px; border-radius: 8px;">
                    <h5 style="color: #22c55e;">Strategy 1: Quota Allocation</h5>
                    <p style="font-size: 13px; color: #94a3b8;">Pre-allocate quotas to each region</p>
                    <div class="code-example" style="margin-top: 8px;">
<pre>Global limit: 10,000/min
US-East:   4,000 (40%)
EU-West:   3,500 (35%)
APAC:      2,500 (25%)</pre>
                    </div>
                    <div style="font-size: 12px; margin-top: 8px;">
                        <span style="color: #22c55e;">‚úì</span> No cross-region calls needed<br>
                        <span style="color: #ef4444;">‚úó</span> Underutilization if traffic shifts
                    </div>
                </div>

                <div style="background: #1e293b; padding: 16px; border-radius: 8px; border: 2px solid #22c55e;">
                    <h5 style="color: #22c55e;">Strategy 2: Token Bucket + Rebalancing ‚úì</h5>
                    <p style="font-size: 13px; color: #94a3b8;">Dynamic quota based on demand</p>
                    <div class="code-example" style="margin-top: 8px;">
<pre>// Rebalance every 5 seconds
if region.usage > region.quota * 0.9 {
    borrow(from: underutilized_region)
}</pre>
                    </div>
                    <div style="font-size: 12px; margin-top: 8px;">
                        <span style="color: #22c55e;">‚úì</span> Efficient utilization<br>
                        <span style="color: #22c55e;">‚úì</span> Handles traffic shifts
                    </div>
                </div>

                <div style="background: #1e293b; padding: 16px; border-radius: 8px;">
                    <h5 style="color: #3b82f6;">Strategy 3: Probabilistic</h5>
                    <p style="font-size: 13px; color: #94a3b8;">Bloom filters for approximate dedup</p>
                    <div style="font-size: 12px; margin-top: 8px;">
                        <span style="color: #22c55e;">‚úì</span> Very low memory<br>
                        <span style="color: #ef4444;">‚úó</span> False positives possible
                    </div>
                </div>

                <div style="background: #1e293b; padding: 16px; border-radius: 8px;">
                    <h5 style="color: #f59e0b;">Strategy 4: CRDT Counters</h5>
                    <p style="font-size: 13px; color: #94a3b8;">Conflict-free merge across regions</p>
                    <div style="font-size: 12px; margin-top: 8px;">
                        <span style="color: #22c55e;">‚úì</span> Eventually consistent guarantee<br>
                        <span style="color: #ef4444;">‚úó</span> Complex implementation
                    </div>
                </div>
            </div>
        </div>

        <!-- ALGORITHM FOR GLOBAL -->
        <h3>üìù Global Rate Limiter Implementation</h3>
        <div class="code-example">
            <h5 style="color: #60a5fa; margin-bottom: 12px;">Multi-Region Token Bucket with Rebalancing</h5>
<pre>type GlobalRateLimiter struct {
    regions       map[string]*RegionLimiter
    globalLimit   int64
    rebalanceCh   chan RebalanceRequest
    kafkaProducer *kafka.Producer
}

type RegionLimiter struct {
    region       string
    localQuota   int64
    used         int64
    redisCluster *redis.ClusterClient
}

func (gl *GlobalRateLimiter) Allow(ctx context.Context, key string, region string) bool {
    rl := gl.regions[region]

    // Step 1: Check local quota
    if rl.used >= rl.localQuota {
        // Try to borrow from global pool
        if !gl.tryBorrow(ctx, region, 100) {
            return false
        }
    }

    // Step 2: Local rate limit check
    allowed := rl.localCheck(ctx, key)
    if allowed {
        atomic.AddInt64(&rl.used, 1)
    }

    // Step 3: Async publish to global stream (for sync)
    go gl.publishEvent(key, region, allowed)

    return allowed
}

func (gl *GlobalRateLimiter) rebalanceLoop() {
    ticker := time.NewTicker(5 * time.Second)
    for range ticker.C {
        totalUsed := int64(0)
        for _, rl := range gl.regions {
            totalUsed += atomic.LoadInt64(&rl.used)
        }

        // Rebalance quotas based on usage patterns
        for _, rl := range gl.regions {
            usage := float64(rl.used) / float64(rl.localQuota)
            if usage > 0.9 {
                // High usage: try to increase quota
                gl.increaseQuota(rl.region)
            } else if usage < 0.3 {
                // Low usage: donate quota to global pool
                gl.decreaseQuota(rl.region)
            }
        }

        // Reset counters for next window
        for _, rl := range gl.regions {
            atomic.StoreInt64(&rl.used, 0)
        }
    }
}</pre>
        </div>

        <!-- DESIGN PATTERNS -->
        <h3>üß© Design Patterns Used</h3>
        <div class="patterns-grid">
            <div class="pattern-card">
                <h5>CQRS Pattern</h5>
                <p>Separate read (check limit) and write (update counter) paths. Reads from local, writes to event stream.</p>
            </div>
            <div class="pattern-card">
                <h5>Saga Pattern</h5>
                <p>For global limit enforcement with compensation. If over-limit detected, compensate by blocking next N requests.</p>
            </div>
            <div class="pattern-card">
                <h5>Sidecar Pattern</h5>
                <p>Envoy handles rate limiting, app stays simple. Consistent across languages (Go, Java, Python services).</p>
            </div>
            <div class="pattern-card">
                <h5>Leader Election</h5>
                <p>One region is leader for global quota decisions. Leader elected via ZooKeeper/etcd. Failover in &lt;30s.</p>
            </div>
        </div>

        <!-- API DESIGN - ADMIN -->
        <h3>üîå Admin API Design</h3>
        <div class="api-endpoint">
            <span class="api-method post">POST</span> <span class="api-path">/admin/v1/rate-limits</span>
<pre>
// Create or update rate limit rules (propagates globally)

Request:
{
    "scope": "user",           // user | ip | api_key | endpoint
    "identifier": "user_123",  // specific ID or "*" for default
    "limits": {
        "requests_per_minute": 1000,
        "requests_per_day": 100000,
        "burst_size": 200
    },
    "tier": "enterprise",
    "regions": ["us-east-1", "eu-west-1", "ap-southeast-1"],
    "effective_at": "2024-01-15T00:00:00Z",
    "expires_at": null
}

Response: 201 Created
{
    "id": "rl_abc123",
    "status": "propagating",
    "propagation": {
        "us-east-1": "applied",
        "eu-west-1": "pending",
        "ap-southeast-1": "pending"
    }
}</pre>
        </div>

        <div class="api-endpoint">
            <span class="api-method get">GET</span> <span class="api-path">/admin/v1/rate-limits/analytics</span>
<pre>
// Global rate limiting analytics

Response: 200 OK
{
    "period": "last_hour",
    "global": {
        "total_requests": 45678901,
        "allowed": 45123456,
        "denied": 555445,
        "denial_rate": "1.22%"
    },
    "by_region": {
        "us-east-1": { "requests": 18234567, "denied": 198234 },
        "eu-west-1": { "requests": 15678901, "denied": 187654 },
        "ap-southeast-1": { "requests": 11765433, "denied": 169557 }
    },
    "top_limited_users": [
        { "user_id": "user_456", "denied": 12345, "tier": "free" },
        { "user_id": "user_789", "denied": 8901, "tier": "pro" }
    ]
}</pre>
        </div>

        <!-- ROLLBACK STRATEGY -->
        <h3>‚è™ Rollback Strategy</h3>
        <div class="feature-card warning">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                <div>
                    <h4>Global Kill Switch</h4>
                    <div class="code-example" style="margin: 12px 0;">
<pre># Emergency: disable globally via feature flag
curl -X POST https://flags.global/rate-limiter \
  -d '{"enabled": false, "regions": "all"}'

# Per-region disable
curl -X POST https://flags.global/rate-limiter \
  -d '{"enabled": false, "regions": ["us-east-1"]}'</pre>
                    </div>
                </div>
                <div>
                    <h4>Graceful Degradation Levels</h4>
                    <ol style="font-size: 14px;">
                        <li><strong>Level 1:</strong> Increase all limits by 10x</li>
                        <li><strong>Level 2:</strong> Log-only mode (no enforcement)</li>
                        <li><strong>Level 3:</strong> Bypass for authenticated users</li>
                        <li><strong>Level 4:</strong> Complete bypass (DDoS risk!)</li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- AWS COST -->
        <h3>üí∞ Cost at Global Scale</h3>
        <div class="feature-card">
            <table class="cost-table">
                <tr><td>ElastiCache Global Datastore (3 regions)</td><td>$15,000</td></tr>
                <tr><td>EKS (60 nodes total, 3 regions)</td><td>$20,000</td></tr>
                <tr><td>CloudFront Global + WAF</td><td>$10,000</td></tr>
                <tr><td>MSK/Kinesis (event streaming)</td><td>$5,000</td></tr>
                <tr><td>Lambda@Edge (10B invocations)</td><td>$4,000</td></tr>
                <tr><td>Data Transfer (cross-region)</td><td>$8,000</td></tr>
                <tr><td>Monitoring (Datadog/New Relic)</td><td>$5,000</td></tr>
                <tr class="total-row"><td><strong>Total</strong></td><td><strong>~$67,000/month</strong></td></tr>
            </table>
        </div>

        <!-- SCALE METRICS -->
        <h3>üìä Scale Metrics</h3>
        <div class="metrics-card">
            <div class="metric">
                <div class="value">10M+</div>
                <div class="label">Checks/sec Global</div>
            </div>
            <div class="metric">
                <div class="value">&lt;1ms</div>
                <div class="label">P99 Latency</div>
            </div>
            <div class="metric">
                <div class="value">&lt;0.001%</div>
                <div class="label">False Positive</div>
            </div>
            <div class="metric">
                <div class="value">99.999%</div>
                <div class="label">Availability</div>
            </div>
        </div>

        <!-- EDGE CASES -->
        <div class="edge-cases">
            <h4>Edge Cases & Error Handling</h4>

            <div class="edge-case-item">
                <div class="case-title">Global Network Partition (Split Brain)</div>
                <p>US and EU regions can't communicate, both think they're the primary for global limits.</p>
                <div class="case-solution">Use Raft/Paxos for leader election with quorum. During partition, each region enforces local limits only. Reconcile counters when partition heals. Alert ops team immediately. Have manual override for critical users.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Quota Rebalancing During Attack</div>
                <p>One region under DDoS exhausts its quota, tries to borrow from others, spreading the attack.</p>
                <div class="case-solution">Implement circuit breaker on quota borrowing. Limit max borrow to 20% of donor's quota. Detect anomalous borrow patterns (ML-based). Isolate affected region automatically. Notify security team.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Kafka/Kinesis Lag in Global Sync</div>
                <p>Event stream falls behind, rate limit state becomes minutes stale across regions.</p>
                <div class="case-solution">Monitor consumer lag with alerts (threshold: 10s). Implement checkpoint-based catch-up. Fall back to local-only limits if lag exceeds threshold. Use compacted topics to reduce catch-up time.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">GDPR Data Locality Conflict</div>
                <p>EU user's rate limit data must stay in EU, but they're hitting US endpoints.</p>
                <div class="case-solution">Store rate limit state in user's home region. Route rate limit checks to home region (adds latency). Use anonymized/hashed keys for non-EU storage. Implement data residency tags in Redis keys.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Leader Election Flapping</div>
                <p>Unstable network causes frequent leader changes, disrupting global quota decisions.</p>
                <div class="case-solution">Implement leader election with hysteresis (10s minimum term). Use health check smoothing (3 failures before demotion). Have designated backup leader per region. Log all elections for debugging.</div>
            </div>

            <div class="edge-case-item">
                <div class="case-title">Time Zone Confusion in Daily Limits</div>
                <p>User in Tokyo expects daily limit to reset at midnight JST, but system uses UTC.</p>
                <div class="case-solution">Store user's timezone preference. Calculate window boundaries in user's timezone. Display remaining quota with timezone context. Option for fixed UTC for enterprise (predictable billing).</div>
            </div>
        </div>

        <!-- FUTURE ASPECTS -->
        <div class="future-aspects">
            <h4>Future Enhancements</h4>

            <div class="future-item">
                <div class="future-title">Chaos Engineering for Rate Limiters</div>
                <p>Proactively test rate limiter resilience by injecting failures in production.</p>
                <div class="future-approach">Integrate with Chaos Monkey / Gremlin. Test scenarios: Redis failure, network partition, clock skew. Run chaos experiments during low-traffic windows. Automated runbooks for detected failures.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Carbon-Aware Rate Limiting</div>
                <p>Adjust rate limits based on data center carbon intensity to reduce environmental impact.</p>
                <div class="future-approach">Integrate with WattTime API for real-time carbon data. Shift non-critical traffic to greener regions. Offer "green API tier" with sustainability incentives. Report carbon savings in customer dashboard.</div>
            </div>

            <div class="future-item">
                <div class="future-title">Self-Healing Rate Limiters</div>
                <p>Automatically detect and recover from rate limiter failures without human intervention.</p>
                <div class="future-approach">ML model detects anomalies in rate limit behavior. Auto-rollback bad config changes. Self-scaling based on traffic predictions. Automated failover with health verification.</div>
            </div>

            <div class="future-item">
                <div class="future-title">API Credits Economy</div>
                <p>Full-featured internal marketplace for API quota management across teams.</p>
                <div class="future-approach">Teams get monthly API credit budgets. Unused credits roll over or trade. Chargeback model for cross-team API usage. Executive dashboard for API consumption analytics.</div>
            </div>
        </div>

        <!-- INTERVIEW FOLLOW-UP FEATURES -->
        <div class="followup-features">
            <h4>Interview Follow-Up Questions</h4>

            <div class="followup-item">
                <div class="followup-number">1</div>
                <div class="followup-content">
                    <div class="followup-question">How would you implement global rate limits across 5 regions while maintaining sub-millisecond latency?</div>
                    <div class="followup-hint">Pre-allocate regional quotas (40/30/20/5/5%). Local enforcement first, no cross-region calls. Async rebalancing every 5s via Kafka. Accept eventual consistency (~2% over-limit globally). Use CRDT counters for conflict-free merge.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">2</div>
                <div class="followup-content">
                    <div class="followup-question">Design a system that can handle 100x traffic spike during global events like World Cup final.</div>
                    <div class="followup-hint">Pre-scale infrastructure 2 hours before. Virtual waiting room queues users. Aggressive local caching (accept stale). Simplify algorithm to fixed window. Edge rate limiting blocks 90% at CDN. Dedicated "event mode" with relaxed limits for verified users.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">3</div>
                <div class="followup-content">
                    <div class="followup-question">How do you ensure rate limiting doesn't become a single point of failure at global scale?</div>
                    <div class="followup-hint">Multi-layer defense (edge + gateway + app). Each layer can function independently. Fail open with local fallback. No single Redis cluster owns all state. Cell-based architecture isolates failures. Chaos testing validates resilience.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">4</div>
                <div class="followup-content">
                    <div class="followup-question">How would you implement fair rate limiting for a multi-tenant global SaaS?</div>
                    <div class="followup-hint">Hierarchical limits: Platform ‚Üí Tenant ‚Üí User ‚Üí Endpoint. Noisy neighbor isolation (dedicated pools for large tenants). SLA-based guarantees per tier. Real-time usage dashboards. Alerting when approaching limits. Self-service limit increase workflow.</div>
                </div>
            </div>

            <div class="followup-item">
                <div class="followup-number">5</div>
                <div class="followup-content">
                    <div class="followup-question">What's your strategy for migrating from a centralized to distributed rate limiter with zero downtime?</div>
                    <div class="followup-hint">Phase 1: Shadow mode (new system logs, old enforces). Phase 2: Percentage rollout (10% ‚Üí 50% ‚Üí 100%). Phase 3: Reverse shadow (new enforces, old logs for comparison). Automatic rollback on divergence. Feature flags per tenant. Run parallel for 2 weeks before decommission.</div>
                </div>
            </div>
        </div>

        <!-- SUMMARY FLOW DIAGRAM -->
        <div class="summary-flow">
            <h4>Global Stage - Multi-Region Active-Active Flow</h4>
            <div class="flow-vertical">
                <!-- Global Request Flow -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #166534; margin-bottom: 12px;">GLOBAL RATE LIMIT FLOW</div>
                    <div class="flow-row">
                        <div class="flow-node user">Request<br><small>User in Tokyo</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cdn">CloudFront<br><small>Edge POP</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node gateway">APAC Gateway<br><small>Singapore</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cache">Regional Redis<br><small>Local quota</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node db" style="background: #22c55e;">200 OK</div>
                    </div>
                </div>

                <!-- Quota Rebalancing -->
                <div style="width: 100%; margin-bottom: 24px;">
                    <div style="text-align: center; font-weight: 700; color: #8b5cf6; margin-bottom: 12px;">DYNAMIC QUOTA REBALANCING (Every 5 seconds)</div>
                    <div class="flow-row">
                        <div class="flow-node cache">US-East<br><small>Usage: 30%</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node queue" style="background: #8b5cf6;">Kafka<br><small>Quota events</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node service">Leader<br><small>Rebalance calc</small></div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-node cache">APAC<br><small>Usage: 90%</small></div>
                    </div>
                    <div style="text-align: center; margin-top: 8px; font-size: 12px; color: #94a3b8;">
                        APAC high usage ‚Üí Borrow 500 quota from underutilized US-East
                    </div>
                </div>

                <!-- Cell-Based Architecture Visual -->
                <div style="width: 100%;">
                    <div style="text-align: center; font-weight: 700; color: #f59e0b; margin-bottom: 12px;">CELL-BASED ARCHITECTURE</div>
                    <div style="background: #1e293b; border-radius: 12px; padding: 20px; text-align: center;">
                        <div style="display: flex; justify-content: center; gap: 16px; flex-wrap: wrap; margin-bottom: 16px;">
                            <div style="background: rgba(59,130,246,0.2); padding: 16px; border-radius: 8px; border: 2px solid #3b82f6;">
                                <strong style="color: #3b82f6;">Cell: US</strong><br>
                                <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">
                                    Quota: 4,000/min<br>
                                    Redis: us-east-1<br>
                                    Users: 40%
                                </div>
                            </div>
                            <div style="background: rgba(34,197,94,0.2); padding: 16px; border-radius: 8px; border: 2px solid #22c55e;">
                                <strong style="color: #22c55e;">Cell: EU</strong><br>
                                <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">
                                    Quota: 3,500/min<br>
                                    Redis: eu-west-1<br>
                                    Users: 35%
                                </div>
                            </div>
                            <div style="background: rgba(249,115,22,0.2); padding: 16px; border-radius: 8px; border: 2px solid #f97316;">
                                <strong style="color: #f97316;">Cell: APAC</strong><br>
                                <div style="font-size: 12px; color: #94a3b8; margin-top: 8px;">
                                    Quota: 2,500/min<br>
                                    Redis: ap-southeast-1<br>
                                    Users: 25%
                                </div>
                            </div>
                        </div>
                        <div style="font-size: 13px; color: #94a3b8;">
                            Each cell is autonomous | Global limit: 10,000/min | Cells can borrow up to 20% from others
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DB EVOLUTION -->
        <div class="db-evolution">
            <h4>Storage Evolution Across Stages</h4>
            <div class="evolution-timeline">
                <div class="evolution-stage">
                    <div class="evolution-icon">üíæ</div>
                    <div class="evolution-label">Local</div>
                    <div class="evolution-db">In-Memory</div>
                    <div class="evolution-detail">sync.Map / LRU cache<br>Single server only</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">üî¥</div>
                    <div class="evolution-label">MVP</div>
                    <div class="evolution-db">Single Redis</div>
                    <div class="evolution-detail">ElastiCache<br>Lua scripts for atomicity</div>
                </div>
                <div class="evolution-stage">
                    <div class="evolution-icon">‚ö°</div>
                    <div class="evolution-label">High Traffic</div>
                    <div class="evolution-db">Redis Cluster</div>
                    <div class="evolution-detail">16+ shards<br>LRU hybrid caching</div>
                </div>
                <div class="evolution-stage current">
                    <div class="evolution-icon">üåê</div>
                    <div class="evolution-label">Global</div>
                    <div class="evolution-db">Cell-Based Architecture</div>
                    <div class="evolution-detail">Regional Redis clusters<br>Kafka for quota sync</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Tooltip System -->
<div class="tooltip-overlay" id="tooltipOverlay" onclick="closeTooltip()"></div>
<div class="tooltip-popup" id="tooltipPopup">
    <button class="tooltip-close" onclick="closeTooltip()">&times;</button>
    <h4 id="tooltipTitle"></h4>
    <div id="tooltipContent"></div>
</div>

<script>
const termDefinitions = {
    'token-bucket': {
        title: 'Token Bucket Algorithm',
        content: `<p>Rate limiting algorithm that allows controlled bursts.</p>
        <div style="margin-top: 16px;">
            <strong>How it works:</strong>
            <ol style="font-size: 13px; margin-top: 8px;">
                <li>Bucket holds tokens (max = capacity)</li>
                <li>Tokens added at fixed rate (refill rate)</li>
                <li>Each request consumes 1+ tokens</li>
                <li>No tokens available = request denied</li>
            </ol>
        </div>
        <div style="margin-top: 12px;">
            <strong>Redis Implementation:</strong>
            <pre style="background: #1e293b; color: #e2e8f0; padding: 12px; border-radius: 6px; font-size: 13px;">HMSET ratelimit:user123 tokens 10 last_refill 1704067200</pre>
        </div>`
    },
    'sliding-window': {
        title: 'Sliding Window Counter',
        content: `<p>Balanced rate limiting with smooth distribution.</p>
        <div style="margin-top: 16px;">
            <strong>Formula:</strong>
            <pre style="background: #1e293b; color: #e2e8f0; padding: 12px; border-radius: 6px; font-size: 13px;">weighted = prev_count √ó (1 - elapsed/window) + curr_count</pre>
        </div>
        <div style="margin-top: 12px;">
            <strong>Advantages:</strong>
            <ul style="font-size: 13px;">
                <li>No burst at window boundaries</li>
                <li>Memory efficient (2 counters)</li>
                <li>~99.7% accurate</li>
            </ul>
        </div>`
    },
    'redis-cluster': {
        title: 'Redis Cluster',
        content: `<p>Horizontally scaled Redis with automatic sharding.</p>
        <div style="margin-top: 16px;">
            <strong>Architecture:</strong>
            <div style="display: flex; gap: 8px; margin: 8px 0; flex-wrap: wrap;">
                <span style="background: #ef4444; color: white; padding: 4px 8px; border-radius: 4px;">Shard 0</span>
                <span style="background: #f59e0b; color: white; padding: 4px 8px; border-radius: 4px;">Shard 1</span>
                <span style="background: #22c55e; color: white; padding: 4px 8px; border-radius: 4px;">Shard 2</span>
                <span style="background: #3b82f6; color: white; padding: 4px 8px; border-radius: 4px;">...</span>
            </div>
        </div>
        <div style="margin-top: 12px;">
            <strong>Key features:</strong>
            <ul style="font-size: 13px;">
                <li>16384 hash slots distributed across shards</li>
                <li>Automatic failover</li>
                <li>Linear scalability</li>
            </ul>
        </div>`
    }
};

function showTooltip(term) {
    const def = termDefinitions[term];
    if (def) {
        document.getElementById('tooltipTitle').textContent = def.title;
        document.getElementById('tooltipContent').innerHTML = def.content;
        document.getElementById('tooltipOverlay').classList.add('show');
        document.getElementById('tooltipPopup').classList.add('show');
    }
}

function closeTooltip() {
    document.getElementById('tooltipOverlay').classList.remove('show');
    document.getElementById('tooltipPopup').classList.remove('show');
}

document.addEventListener('keydown', e => { if (e.key === 'Escape') closeTooltip(); });

// Scroll spy
window.addEventListener('scroll', function() {
    const sections = document.querySelectorAll('.stage-section');
    const navLinks = document.querySelectorAll('.quick-nav a');
    let current = '';
    sections.forEach(section => {
        if (scrollY >= section.offsetTop - 200) current = section.id;
    });
    navLinks.forEach(link => {
        link.classList.toggle('active', link.getAttribute('href') === '#' + current);
    });
});
</script>
