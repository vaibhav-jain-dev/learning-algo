<div class="practice-page">
    <aside class="sidebar">
        <div class="sidebar-header">
            <h2>Problems</h2>
            <input type="search" id="search" placeholder="Search problems..."
                   onkeyup="filterTree(this.value)">
        </div>
        <div id="problem-tree" hx-get="/htmx/problem-tree" hx-trigger="load" hx-swap="innerHTML">
            <div class="loading">Loading problems...</div>
        </div>
    </aside>

    <div class="content">
        <div class="tabs">
            <button class="tab active" onclick="showTab('description')">Description</button>
            <button class="tab" onclick="showTab('code')">Code</button>
            <button class="tab" onclick="showTab('output')">Output</button>
        </div>

        <div id="description-tab" class="tab-content active">
            <div id="problem-description">
                <div class="placeholder">
                    <h2>Select a Problem</h2>
                    <p>Choose a problem from the sidebar to get started.</p>
                    <p>You can also run custom code using the editor below.</p>
                </div>
            </div>
        </div>

        <div id="code-tab" class="tab-content">
            <div class="editor-header">
                <div class="language-selector">
                    <button class="lang-btn active" data-lang="python" onclick="setLanguage('python')">Python</button>
                    <button class="lang-btn" data-lang="go" onclick="setLanguage('go')">Go</button>
                </div>
                <div class="actions">
                    <button class="btn btn-secondary" onclick="formatCode()" title="Format Code">
                        Format
                    </button>
                    <button class="btn btn-secondary" onclick="resetCode()">Reset</button>
                    <button id="stop-btn" class="btn btn-danger hidden" onclick="stopExecution()">
                        Stop
                    </button>
                    <button id="run-btn" class="btn btn-primary" onclick="runCode()">
                        <span class="run-icon">▶</span> Run
                    </button>
                </div>
            </div>
            <div class="editor-container">
                <div id="code-editor"></div>
            </div>
        </div>

        <div id="output-tab" class="tab-content">
            <div id="output-container">
                <div class="placeholder">
                    <p>Run your code to see output here.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// State management
const STATE_KEY = 'dsalgo_execution_state';
let currentLanguage = 'python';
let originalCode = { python: '', go: '' };
let currentCode = { python: '', go: '' };
let ws = null;
let currentExecutionId = null;
let isRunning = false;
let editor = null;

// Initialize CodeMirror
function initEditor() {
    const editorElement = document.getElementById('code-editor');
    editor = CodeMirror(editorElement, {
        value: getDefaultCode('python'),
        mode: 'python',
        theme: 'material-darker',
        lineNumbers: true,
        indentUnit: 4,
        tabSize: 4,
        indentWithTabs: false,
        matchBrackets: true,
        autoCloseBrackets: true,
        foldGutter: true,
        gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],
        extraKeys: {
            'Tab': function(cm) {
                if (cm.somethingSelected()) {
                    cm.indentSelection('add');
                } else {
                    cm.replaceSelection(cm.getOption('indentWithTabs') ? '\t' :
                        Array(cm.getOption('indentUnit') + 1).join(' '), 'end', '+input');
                }
            },
            'Shift-Tab': function(cm) {
                cm.indentSelection('subtract');
            },
            'Ctrl-Enter': function(cm) {
                runCode();
            },
            'Cmd-Enter': function(cm) {
                runCode();
            },
            'Ctrl-S': function(cm) {
                formatCode();
                return false;
            },
            'Cmd-S': function(cm) {
                formatCode();
                return false;
            }
        }
    });

    // Set editor height
    editor.setSize('100%', '100%');

    // Save code on change
    editor.on('change', function() {
        currentCode[currentLanguage] = editor.getValue();
    });
}

// Format code (basic indentation fix)
function formatCode() {
    if (isRunning || !editor) return;

    const code = editor.getValue();
    let formatted = code;

    if (currentLanguage === 'python') {
        formatted = formatPython(code);
    } else if (currentLanguage === 'go') {
        formatted = formatGo(code);
    }

    editor.setValue(formatted);
}

function formatPython(code) {
    // Basic Python formatting
    const lines = code.split('\n');
    let formatted = [];
    let indentLevel = 0;
    const indentSize = 4;

    for (let line of lines) {
        let trimmed = line.trim();

        // Decrease indent before these keywords
        if (trimmed.startsWith('elif ') || trimmed.startsWith('else:') ||
            trimmed.startsWith('except') || trimmed.startsWith('finally:') ||
            trimmed.startsWith('except:')) {
            indentLevel = Math.max(0, indentLevel - 1);
        }

        // Add the line with proper indentation if not empty
        if (trimmed) {
            formatted.push(' '.repeat(indentLevel * indentSize) + trimmed);
        } else {
            formatted.push('');
        }

        // Increase indent after these patterns
        if (trimmed.endsWith(':') && !trimmed.startsWith('#')) {
            indentLevel++;
        }

        // Decrease indent for certain keywords already handled
        if (trimmed.startsWith('return ') || trimmed === 'return' ||
            trimmed === 'break' || trimmed === 'continue' || trimmed === 'pass') {
            // Next line should be at same or lower level
        }
    }

    return formatted.join('\n');
}

function formatGo(code) {
    // Basic Go formatting
    const lines = code.split('\n');
    let formatted = [];
    let indentLevel = 0;
    const indentChar = '\t';

    for (let line of lines) {
        let trimmed = line.trim();

        // Decrease indent for closing braces
        if (trimmed.startsWith('}') || trimmed.startsWith(')')) {
            indentLevel = Math.max(0, indentLevel - 1);
        }

        // Add the line with proper indentation
        if (trimmed) {
            formatted.push(indentChar.repeat(indentLevel) + trimmed);
        } else {
            formatted.push('');
        }

        // Increase indent after opening braces
        if (trimmed.endsWith('{') || trimmed.endsWith('(')) {
            indentLevel++;
        }
    }

    return formatted.join('\n');
}

// WebSocket connection
function connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${protocol}//${window.location.host}/ws/execute`);

    ws.onopen = () => {
        console.log('WebSocket connected');
        // Check for pending execution on reconnect
        const savedState = loadState();
        if (savedState && savedState.id && savedState.state === 'running') {
            reconnectToExecution(savedState.id);
        }
    };

    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleExecutionUpdate(data);
    };

    ws.onclose = () => {
        console.log('WebSocket disconnected, reconnecting...');
        setTimeout(connectWebSocket, 2000);
    };

    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
    };
}

function handleExecutionUpdate(data) {
    const outputContainer = document.getElementById('output-container');

    switch (data.type) {
        case 'started':
            currentExecutionId = data.id;
            setRunningState(true);
            saveState({ id: data.id, state: 'running' });
            outputContainer.innerHTML = renderLoading(data.id);
            break;

        case 'update':
            if (data.state === 'running') {
                outputContainer.innerHTML = renderLoading(data.id);
            } else {
                setRunningState(false);
                outputContainer.innerHTML = renderOutput(data);
                saveState({ id: data.id, state: data.state });
            }
            break;

        case 'stopped':
            setRunningState(false);
            outputContainer.innerHTML = renderOutput({
                state: 'stopped',
                error: 'Execution stopped by user'
            });
            clearState();
            break;

        case 'error':
            setRunningState(false);
            outputContainer.innerHTML = renderOutput({
                state: 'error',
                error: data.error
            });
            clearState();
            break;
    }
}

function renderLoading(id) {
    return `
        <div class="output-loading">
            <div class="output-header">
                <span class="loading-spinner"></span>
                <span class="status-text">Running...</span>
            </div>
            <div class="loading-info">
                <p>Execution ID: ${id}</p>
                <p>You can close this tab and come back - execution state is preserved.</p>
            </div>
        </div>
    `;
}

function renderOutput(data) {
    const isError = data.state === 'error' || data.state === 'stopped' || data.error;
    const statusIcon = isError ? '✗' : '✓';
    const statusText = isError ? 'Error' : 'Success';
    const statusClass = isError ? 'output-error' : 'output-success';

    let output = data.output || '';
    let error = data.error || '';
    let duration = data.duration || 0;

    return `
        <div class="output-result ${isError ? 'has-error' : ''}">
            <div class="${statusClass}">
                <div class="output-header">
                    <span class="status-icon">${statusIcon}</span>
                    <span class="status-text">${statusText}</span>
                    ${duration ? `<span class="duration">${duration}ms</span>` : ''}
                </div>
                ${error ? `<pre class="error-output">${escapeHtml(error)}</pre>` : ''}
                ${output ? `<pre class="success-output">${escapeHtml(output)}</pre>` : (!error ? '<pre class="success-output">(no output)</pre>' : '')}
            </div>
        </div>
    `;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function setRunningState(running) {
    isRunning = running;
    const runBtn = document.getElementById('run-btn');
    const stopBtn = document.getElementById('stop-btn');

    if (running) {
        runBtn.disabled = true;
        runBtn.classList.add('disabled');
        stopBtn.classList.remove('hidden');
        if (editor) editor.setOption('readOnly', true);
    } else {
        runBtn.disabled = false;
        runBtn.classList.remove('disabled');
        stopBtn.classList.add('hidden');
        if (editor) editor.setOption('readOnly', false);
        currentExecutionId = null;
    }
}

function runCode() {
    if (isRunning || !editor) return;

    const code = editor.getValue();
    currentCode[currentLanguage] = code;

    if (!code.trim()) {
        document.getElementById('output-container').innerHTML = renderOutput({
            state: 'error',
            error: 'No code provided'
        });
        showTab('output');
        return;
    }

    showTab('output');
    document.getElementById('output-container').innerHTML = '<div class="loading">Connecting...</div>';

    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            action: 'execute',
            code: code,
            language: currentLanguage
        }));
    } else {
        // Fallback to HTMX if WebSocket not available
        htmx.ajax('POST', '/htmx/execute', {
            target: '#output-container',
            swap: 'innerHTML',
            values: { code: code, language: currentLanguage }
        });
    }
}

function stopExecution() {
    if (!currentExecutionId) return;

    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            action: 'stop',
            id: currentExecutionId
        }));
    }
}

function reconnectToExecution(id) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        setRunningState(true);
        showTab('output');
        document.getElementById('output-container').innerHTML = renderLoading(id);
        currentExecutionId = id;

        ws.send(JSON.stringify({
            action: 'reconnect',
            id: id
        }));
    }
}

// State persistence
function saveState(state) {
    try {
        localStorage.setItem(STATE_KEY, JSON.stringify(state));
    } catch (e) {}
}

function loadState() {
    try {
        const state = localStorage.getItem(STATE_KEY);
        return state ? JSON.parse(state) : null;
    } catch (e) {
        return null;
    }
}

function clearState() {
    try {
        localStorage.removeItem(STATE_KEY);
    } catch (e) {}
}

// Tab management
function showTab(tabName) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.querySelector(`.tab-content#${tabName}-tab`).classList.add('active');
    document.querySelector(`.tab[onclick="showTab('${tabName}')"]`).classList.add('active');

    // Refresh editor when showing code tab
    if (tabName === 'code' && editor) {
        setTimeout(() => editor.refresh(), 10);
    }
}

function setLanguage(lang) {
    if (isRunning || !editor) return;

    // Save current code
    currentCode[currentLanguage] = editor.getValue();
    currentLanguage = lang;

    // Update language buttons
    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`.lang-btn[data-lang="${lang}"]`).classList.add('active');

    // Set editor mode and content
    const mode = lang === 'go' ? 'text/x-go' : 'python';
    editor.setOption('mode', mode);
    editor.setValue(currentCode[lang] || originalCode[lang] || getDefaultCode(lang));
}

function getDefaultCode(lang) {
    if (lang === 'python') {
        return `def main():
    # Write your code here
    # Allowed: math, collections, heapq, itertools, etc.
    # Blocked: os, subprocess, socket, etc.
    result = [1, 2, 3, 4, 5]
    return result

# main() must be defined and return a value`;
    } else {
        return `package main

import "fmt"

func main() {
    // Write your code here
    // Allowed: fmt, math, sort, strings, etc.
    // Blocked: os/exec, net, syscall, etc.
    result := []int{1, 2, 3, 4, 5}
    fmt.Println(result)
}`;
    }
}

function resetCode() {
    if (isRunning || !editor) return;
    const code = originalCode[currentLanguage] || getDefaultCode(currentLanguage);
    editor.setValue(code);
    currentCode[currentLanguage] = code;
}

function loadProblem(path) {
    htmx.ajax('GET', '/htmx/problem-content/' + path, {
        target: '#problem-description',
        swap: 'innerHTML'
    }).then(() => {
        showTab('description');
    });
}

function loadProblemCode(pythonCode, goCode) {
    if (isRunning) return;
    originalCode.python = pythonCode || getDefaultCode('python');
    originalCode.go = goCode || getDefaultCode('go');
    currentCode.python = originalCode.python;
    currentCode.go = originalCode.go;

    if (editor) {
        editor.setValue(currentCode[currentLanguage]);
    }
    showTab('code');
}

function filterTree(query) {
    const tree = document.getElementById('problem-tree');
    const items = tree.querySelectorAll('.tree-item');
    const folders = tree.querySelectorAll('.tree-folder');
    query = query.toLowerCase();
    items.forEach(item => {
        const text = item.textContent.toLowerCase();
        item.style.display = text.includes(query) ? '' : 'none';
    });
    folders.forEach(folder => {
        const hasVisible = folder.querySelector('.tree-item:not([style*="display: none"])');
        folder.style.display = hasVisible ? '' : 'none';
    });
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    initEditor();
    connectWebSocket();

    // Check for saved state on page load
    const savedState = loadState();
    if (savedState && savedState.state === 'running') {
        showTab('output');
        document.getElementById('output-container').innerHTML = '<div class="loading">Reconnecting...</div>';
    }
});
</script>
