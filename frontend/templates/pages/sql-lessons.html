<div class="sql-lessons-page">
    <aside class="sidebar">
        <div class="sidebar-header">
            <h2>SQL Curriculum</h2>
        </div>
        <div class="lesson-tree">
            <!-- Fundamentals -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('fundamentals')">
                    <span class="icon">&#128218;</span>
                    <span>1. SQL Fundamentals</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="fundamentals" class="category-content expanded">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('basics')">1.1 Basics</div>
                        <div id="basics" class="sub-content expanded">
                            <a class="lesson-link active" onclick="loadLesson('select-basics')">SELECT Basics</a>
                            <a class="lesson-link" onclick="loadLesson('where-clause')">WHERE Clause</a>
                            <a class="lesson-link" onclick="loadLesson('order-by')">ORDER BY</a>
                            <a class="lesson-link" onclick="loadLesson('limit-offset')">LIMIT & OFFSET</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('filtering')">1.2 Filtering</div>
                        <div id="filtering" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('comparison')">Comparison Operators</a>
                            <a class="lesson-link" onclick="loadLesson('logical')">Logical Operators</a>
                            <a class="lesson-link" onclick="loadLesson('like-pattern')">LIKE Pattern Matching</a>
                            <a class="lesson-link" onclick="loadLesson('in-between')">IN & BETWEEN</a>
                            <a class="lesson-link" onclick="loadLesson('null-handling')">NULL Handling</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('data-types')">1.3 Data Types</div>
                        <div id="data-types" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('numeric-types')">Numeric Types</a>
                            <a class="lesson-link" onclick="loadLesson('string-types')">String Types</a>
                            <a class="lesson-link" onclick="loadLesson('date-types')">Date/Time Types</a>
                            <a class="lesson-link" onclick="loadLesson('boolean-json')">Boolean & JSON</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Joins -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('joins')">
                    <span class="icon">&#128279;</span>
                    <span>2. Joins & Relationships</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="joins" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('join-types')">2.1 Join Types</div>
                        <div id="join-types" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('inner-join')">INNER JOIN</a>
                            <a class="lesson-link" onclick="loadLesson('left-join')">LEFT JOIN</a>
                            <a class="lesson-link" onclick="loadLesson('right-join')">RIGHT JOIN</a>
                            <a class="lesson-link" onclick="loadLesson('full-join')">FULL OUTER JOIN</a>
                            <a class="lesson-link" onclick="loadLesson('cross-join')">CROSS JOIN</a>
                            <a class="lesson-link" onclick="loadLesson('self-join')">Self Join</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('multi-join')">2.2 Multi-Table Joins</div>
                        <div id="multi-join" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('chained-joins')">Chaining Joins</a>
                            <a class="lesson-link" onclick="loadLesson('join-conditions')">Complex Conditions</a>
                            <a class="lesson-link" onclick="loadLesson('join-performance')">Join Performance</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Aggregations -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('aggregations')">
                    <span class="icon">&#128202;</span>
                    <span>3. Aggregations & Grouping</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="aggregations" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('agg-functions')">3.1 Aggregate Functions</div>
                        <div id="agg-functions" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('count-sum')">COUNT & SUM</a>
                            <a class="lesson-link" onclick="loadLesson('avg-min-max')">AVG, MIN, MAX</a>
                            <a class="lesson-link" onclick="loadLesson('distinct-agg')">DISTINCT Aggregation</a>
                            <a class="lesson-link" onclick="loadLesson('array-agg')">ARRAY_AGG & STRING_AGG</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('grouping')">3.2 GROUP BY</div>
                        <div id="grouping" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('group-by-basics')">GROUP BY Basics</a>
                            <a class="lesson-link" onclick="loadLesson('having-clause')">HAVING Clause</a>
                            <a class="lesson-link" onclick="loadLesson('grouping-sets')">GROUPING SETS</a>
                            <a class="lesson-link" onclick="loadLesson('rollup-cube')">ROLLUP & CUBE</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Subqueries -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('subqueries')">
                    <span class="icon">&#128203;</span>
                    <span>4. Subqueries</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="subqueries" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('subquery-types')">4.1 Subquery Types</div>
                        <div id="subquery-types" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('scalar-subquery')">Scalar Subqueries</a>
                            <a class="lesson-link" onclick="loadLesson('column-subquery')">Column Subqueries</a>
                            <a class="lesson-link" onclick="loadLesson('table-subquery')">Table Subqueries</a>
                            <a class="lesson-link" onclick="loadLesson('correlated-subquery')">Correlated Subqueries</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('subquery-ops')">4.2 Subquery Operators</div>
                        <div id="subquery-ops" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('exists-not-exists')">EXISTS / NOT EXISTS</a>
                            <a class="lesson-link" onclick="loadLesson('in-not-in')">IN / NOT IN</a>
                            <a class="lesson-link" onclick="loadLesson('any-all')">ANY / ALL</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CTEs -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('ctes')">
                    <span class="icon">&#128221;</span>
                    <span>5. Common Table Expressions</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="ctes" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('cte-basics')">CTE Basics (WITH clause)</a>
                    <a class="lesson-link" onclick="loadLesson('multiple-ctes')">Multiple CTEs</a>
                    <a class="lesson-link" onclick="loadLesson('recursive-cte')">Recursive CTEs</a>
                    <a class="lesson-link" onclick="loadLesson('cte-vs-subquery')">CTE vs Subquery</a>
                </div>
            </div>

            <!-- Window Functions -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('window')">
                    <span class="icon">&#128200;</span>
                    <span>6. Window Functions</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="window" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('window-basics')">6.1 Window Basics</div>
                        <div id="window-basics" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('over-clause')">OVER Clause</a>
                            <a class="lesson-link" onclick="loadLesson('partition-by')">PARTITION BY</a>
                            <a class="lesson-link" onclick="loadLesson('order-by-window')">ORDER BY in Windows</a>
                            <a class="lesson-link" onclick="loadLesson('frame-clause')">Frame Clause</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('ranking')">6.2 Ranking Functions</div>
                        <div id="ranking" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('row-number')">ROW_NUMBER()</a>
                            <a class="lesson-link" onclick="loadLesson('rank-dense-rank')">RANK & DENSE_RANK</a>
                            <a class="lesson-link" onclick="loadLesson('ntile')">NTILE()</a>
                            <a class="lesson-link" onclick="loadLesson('percent-rank')">PERCENT_RANK & CUME_DIST</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('value-functions')">6.3 Value Functions</div>
                        <div id="value-functions" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('lag-lead')">LAG & LEAD</a>
                            <a class="lesson-link" onclick="loadLesson('first-last')">FIRST_VALUE & LAST_VALUE</a>
                            <a class="lesson-link" onclick="loadLesson('nth-value')">NTH_VALUE</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('window-agg')">6.4 Window Aggregates</div>
                        <div id="window-agg" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('running-total')">Running Totals</a>
                            <a class="lesson-link" onclick="loadLesson('moving-average')">Moving Averages</a>
                            <a class="lesson-link" onclick="loadLesson('cumulative')">Cumulative Statistics</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- DML -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('dml')">
                    <span class="icon">&#9999;</span>
                    <span>7. Data Manipulation (DML)</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="dml" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('insert-basics')">INSERT Basics</a>
                    <a class="lesson-link" onclick="loadLesson('insert-select')">INSERT from SELECT</a>
                    <a class="lesson-link" onclick="loadLesson('update-basics')">UPDATE Basics</a>
                    <a class="lesson-link" onclick="loadLesson('update-join')">UPDATE with JOIN</a>
                    <a class="lesson-link" onclick="loadLesson('delete-basics')">DELETE Basics</a>
                    <a class="lesson-link" onclick="loadLesson('upsert')">UPSERT (ON CONFLICT)</a>
                    <a class="lesson-link" onclick="loadLesson('returning')">RETURNING Clause</a>
                </div>
            </div>

            <!-- Indexing -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('indexing')">
                    <span class="icon">&#128269;</span>
                    <span>8. Indexing & Performance</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="indexing" class="category-content">
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('index-basics')">8.1 Index Fundamentals</div>
                        <div id="index-basics" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('what-is-index')">What is an Index?</a>
                            <a class="lesson-link" onclick="loadLesson('btree-index')">B-Tree Index</a>
                            <a class="lesson-link" onclick="loadLesson('hash-index')">Hash Index</a>
                            <a class="lesson-link" onclick="loadLesson('gin-gist')">GIN & GiST Indexes</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('index-types')">8.2 Index Types</div>
                        <div id="index-types" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('single-column')">Single Column Index</a>
                            <a class="lesson-link" onclick="loadLesson('composite-index')">Composite Index</a>
                            <a class="lesson-link" onclick="loadLesson('partial-index')">Partial Index</a>
                            <a class="lesson-link" onclick="loadLesson('expression-index')">Expression Index</a>
                            <a class="lesson-link" onclick="loadLesson('covering-index')">Covering Index</a>
                        </div>
                    </div>
                    <div class="sub-category">
                        <div class="sub-header" onclick="toggleSubCategory('query-planning')">8.3 Query Planning</div>
                        <div id="query-planning" class="sub-content">
                            <a class="lesson-link" onclick="loadLesson('explain-analyze')">EXPLAIN ANALYZE</a>
                            <a class="lesson-link" onclick="loadLesson('scan-types')">Scan Types</a>
                            <a class="lesson-link" onclick="loadLesson('index-selection')">Index Selection</a>
                            <a class="lesson-link" onclick="loadLesson('optimization-tips')">Optimization Tips</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('advanced')">
                    <span class="icon">&#127919;</span>
                    <span>9. Advanced Topics</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="advanced" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('views')">Views</a>
                    <a class="lesson-link" onclick="loadLesson('materialized-views')">Materialized Views</a>
                    <a class="lesson-link" onclick="loadLesson('triggers')">Triggers</a>
                    <a class="lesson-link" onclick="loadLesson('stored-procedures')">Stored Procedures</a>
                    <a class="lesson-link" onclick="loadLesson('transactions')">Transactions</a>
                    <a class="lesson-link" onclick="loadLesson('json-operations')">JSON Operations</a>
                </div>
            </div>

            <!-- Complex Queries -->
            <div class="lesson-category">
                <div class="category-header" onclick="toggleCategory('complex')">
                    <span class="icon">&#129504;</span>
                    <span>10. Complex Query Problems</span>
                    <span class="arrow">&#9662;</span>
                </div>
                <div id="complex" class="category-content">
                    <a class="lesson-link" onclick="loadLesson('problem-revenue')">Revenue Analysis</a>
                    <a class="lesson-link" onclick="loadLesson('problem-retention')">Customer Retention</a>
                    <a class="lesson-link" onclick="loadLesson('problem-ranking')">Top N Per Group</a>
                    <a class="lesson-link" onclick="loadLesson('problem-gaps')">Gap Analysis</a>
                    <a class="lesson-link" onclick="loadLesson('problem-hierarchy')">Hierarchical Data</a>
                    <a class="lesson-link" onclick="loadLesson('problem-comparison')">Query Comparison</a>
                </div>
            </div>
        </div>
    </aside>

    <div class="content">
        <div id="lesson-content">
            <!-- Default: SELECT Basics lesson -->
            <div class="lesson">
                <h1>SELECT Basics</h1>
                <p class="lesson-meta">
                    <span class="category">Category: Fundamentals</span>
                    <span class="difficulty">Difficulty: Beginner</span>
                </p>

                <section class="lesson-section">
                    <h2>What is SELECT?</h2>
                    <p>The <code>SELECT</code> statement is the most fundamental SQL command. It retrieves data from one or more tables in a database.</p>

                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Purpose:</strong> Retrieve data from database tables</li>
                            <li><strong>Read-only:</strong> SELECT doesn't modify data</li>
                            <li><strong>Flexible:</strong> Can select specific columns or all columns</li>
                            <li><strong>Composable:</strong> Can be combined with other clauses</li>
                        </ul>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Basic Syntax</h2>
                    <pre><code class="language-sql">-- Select all columns from a table
SELECT * FROM table_name;

-- Select specific columns
SELECT column1, column2, column3 FROM table_name;

-- Select with alias
SELECT column1 AS alias_name FROM table_name;</code></pre>

                    <div class="info-box">
                        <h4>&#128161; Best Practice</h4>
                        <p>Avoid using <code>SELECT *</code> in production code. Always specify the columns you need:</p>
                        <ul>
                            <li>Reduces network transfer</li>
                            <li>Makes code more readable</li>
                            <li>Prevents issues when table schema changes</li>
                            <li>Allows better query optimization</li>
                        </ul>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Understanding Query Execution Plans</h2>
                    <p>When you run a query, the database creates an <strong>execution plan</strong> to determine the most efficient way to retrieve data.</p>

                    <!-- Query Plan Flow Diagram -->
                    <div class="diagram-container compact">
                        <div class="flow-diagram" style="max-width: 800px;">
                            <h4 style="color: var(--diagram-cyan); margin-bottom: 1rem; font-size: 1rem;">Query Execution Flow: SELECT * FROM requests WHERE status = 'completed'</h4>

                            <!-- Step 1: Parser -->
                            <div class="flow-row" style="justify-content: flex-start;">
                                <div class="flow-box primary" style="min-width: 140px;">
                                    <div class="flow-box-title">1. Parser</div>
                                    <div class="flow-box-subtitle">Syntax Check</div>
                                </div>
                                <div class="data-card" style="flex: 1;">
                                    <div class="data-card-content">
                                        <div class="data-card-description">SQL → Parse Tree → Validates syntax & table/column names exist</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Step 2: Optimizer -->
                            <div class="flow-row" style="justify-content: flex-start;">
                                <div class="flow-box pink" style="min-width: 140px;">
                                    <div class="flow-box-title">2. Optimizer</div>
                                    <div class="flow-box-subtitle">Plan Selection</div>
                                </div>
                                <div class="data-card" style="flex: 1;">
                                    <div class="data-card-content">
                                        <div class="data-card-description">Evaluates multiple plans → Estimates costs → Picks cheapest plan</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Step 3: Executor with Index Decision -->
                            <div class="flow-row" style="justify-content: flex-start; align-items: flex-start;">
                                <div class="flow-box success" style="min-width: 140px;">
                                    <div class="flow-box-title">3. Executor</div>
                                    <div class="flow-box-subtitle">Data Access</div>
                                </div>
                                <div style="flex: 1; display: flex; gap: 0.75rem; flex-wrap: wrap;">
                                    <div class="data-card data-card-accent success" style="flex: 1; min-width: 200px;">
                                        <div class="data-card-content">
                                            <div class="data-card-title" style="color: var(--diagram-success-light);">✓ Index Scan (Fast)</div>
                                            <div class="data-card-description">If index on 'status' exists: O(log n) lookup</div>
                                        </div>
                                    </div>
                                    <div class="data-card data-card-accent error" style="flex: 1; min-width: 200px;">
                                        <div class="data-card-content">
                                            <div class="data-card-title" style="color: var(--diagram-error-light);">✗ Seq Scan (Slow)</div>
                                            <div class="data-card-description">No index: Full table scan O(n)</div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Step 4: Results -->
                            <div class="flow-row" style="justify-content: flex-start;">
                                <div class="flow-box warning" style="min-width: 140px;">
                                    <div class="flow-box-title">4. Results</div>
                                    <div class="flow-box-subtitle">Return Data</div>
                                </div>
                                <div class="data-card" style="flex: 1;">
                                    <div class="data-card-content">
                                        <div class="data-card-description">Rows matching criteria → Format output → Return to client</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Index Utilization Visual -->
                    <div class="diagram-container compact">
                        <div style="width: 100%; max-width: 800px;">
                            <h4 style="color: var(--diagram-pink); margin-bottom: 1rem; font-size: 1rem;">How Indexes Speed Up Queries</h4>
                            <div class="diagram-comparison">
                                <!-- Without Index -->
                                <div class="diagram-comparison-item">
                                    <div>
                                        <div style="color: var(--diagram-error-light); font-weight: 600; margin-bottom: 0.75rem;">❌ Without Index (Sequential Scan)</div>
                                        <div class="data-card">
                                            <div class="data-card-content">
                                                <div style="display: flex; flex-wrap: wrap; gap: 0.25rem; margin-bottom: 0.75rem;">
                                                    <span class="diagram-badge neutral">row1</span>
                                                    <span class="diagram-badge neutral">row2</span>
                                                    <span class="diagram-badge success">✓ row3</span>
                                                    <span class="diagram-badge neutral">row4</span>
                                                    <span class="diagram-badge neutral">row5</span>
                                                    <span class="diagram-badge success">✓ row6</span>
                                                    <span class="diagram-badge neutral">...</span>
                                                    <span class="diagram-badge neutral">row1M</span>
                                                </div>
                                                <div style="color: var(--diagram-error-light); font-size: 0.8rem;">Must check ALL 1M rows → O(n) = slow!</div>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- With Index -->
                                    <div>
                                        <div style="color: var(--diagram-success-light); font-weight: 600; margin-bottom: 0.75rem;">✅ With Index (B-Tree Lookup)</div>
                                        <div class="data-card">
                                            <div class="data-card-content">
                                                <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 0.75rem;">
                                                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                                                        <span style="color: var(--diagram-cyan);">Index:</span>
                                                        <span class="diagram-badge info">'completed' → [3, 6, 42, 99, ...]</span>
                                                    </div>
                                                    <div style="color: var(--diagram-text-muted);">↓ Direct jump to matching rows</div>
                                                    <div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
                                                        <span class="diagram-badge success">row3</span>
                                                        <span class="diagram-badge success">row6</span>
                                                        <span class="diagram-badge success">row42</span>
                                                        <span class="diagram-badge success">row99</span>
                                                    </div>
                                                </div>
                                                <div style="color: var(--diagram-success-light); font-size: 0.8rem;">Jump directly to matches → O(log n) = fast!</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="example-query">
                        <h4>Try: View Query Execution Plan with EXPLAIN</h4>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="3">-- See how the database plans to execute your query
EXPLAIN SELECT * FROM requests WHERE status = 'completed';</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Interactive Example</h2>
                    <p>Try these queries - click "Run Query" to see results inline:</p>

                    <div class="example-query">
                        <h4>Example 1: Select All Columns</h4>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="2">-- Get all columns from requests table
SELECT * FROM requests LIMIT 5;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>

                    <div class="example-query">
                        <h4>Example 2: Select Specific Columns</h4>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="7">-- Get specific columns with meaningful names
SELECT
    request_number AS "Request #",
    status AS "Current Status",
    final_amount AS "Total Amount",
    created_at AS "Date Created"
FROM requests
LIMIT 5;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>

                    <div class="example-query">
                        <h4>Example 3: Expressions in SELECT</h4>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">-- Calculate derived values
SELECT
    request_number,
    total_amount,
    discount_amount,
    total_amount - discount_amount AS calculated_final,
    final_amount AS stored_final,
    ROUND(discount_amount / total_amount * 100, 2) AS discount_percent
FROM requests
WHERE discount_amount > 0
LIMIT 5;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Column Aliases</h2>
                    <p>Aliases give columns temporary names that make results more readable:</p>

                    <div class="comparison-table">
                        <table>
                            <thead>
                                <tr><th>Syntax</th><th>Example</th><th>Notes</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>column AS alias</code></td>
                                    <td><code>name AS customer_name</code></td>
                                    <td>Standard, recommended</td>
                                </tr>
                                <tr>
                                    <td><code>column alias</code></td>
                                    <td><code>name customer_name</code></td>
                                    <td>Without AS (works but less clear)</td>
                                </tr>
                                <tr>
                                    <td><code>column AS "Alias"</code></td>
                                    <td><code>name AS "Customer Name"</code></td>
                                    <td>Quotes for spaces/special chars</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Common Patterns</h2>

                    <h3>1. Concatenation</h3>
                    <pre><code class="language-sql">-- Combine columns (PostgreSQL uses ||)
SELECT
    first_name || ' ' || COALESCE(last_name, '') AS full_name
FROM patients
LIMIT 5;</code></pre>

                    <h3>2. COALESCE for NULL handling</h3>
                    <pre><code class="language-sql">-- Replace NULL with default value
SELECT
    first_name,
    COALESCE(last_name, 'N/A') AS last_name,
    COALESCE(phone, 'No phone') AS phone
FROM patients
LIMIT 5;</code></pre>

                    <h3>3. CASE expressions</h3>
                    <pre><code class="language-sql">-- Conditional logic in SELECT
SELECT
    request_number,
    status,
    CASE
        WHEN status = 'completed' THEN 'Done'
        WHEN status = 'cancelled' THEN 'Cancelled'
        WHEN status IN ('processing', 'in_progress') THEN 'In Progress'
        ELSE 'Pending'
    END AS status_category
FROM requests;</code></pre>
                </section>

                <section class="lesson-section">
                    <h2>Exercises</h2>

                    <div class="exercise">
                        <h4>Exercise 1: Basic Selection</h4>
                        <p>Write a query to select the <code>order_number</code>, <code>status</code>, and <code>subtotal</code> from the <code>orders</code> table.</p>
                        <details>
                            <summary>Show Solution</summary>
                            <pre><code class="language-sql">SELECT order_number, status, subtotal
FROM orders;</code></pre>
                        </details>
                    </div>

                    <div class="exercise">
                        <h4>Exercise 2: Using Aliases</h4>
                        <p>Select patient names (first + last) with a column alias "Full Name" from the patients table.</p>
                        <details>
                            <summary>Show Solution</summary>
                            <pre><code class="language-sql">SELECT
    first_name || ' ' || COALESCE(last_name, '') AS "Full Name"
FROM patients;</code></pre>
                        </details>
                    </div>

                    <div class="exercise">
                        <h4>Exercise 3: Calculated Columns</h4>
                        <p>Select blood tests showing their name, price, and price with 18% tax as "Price with Tax".</p>
                        <details>
                            <summary>Show Solution</summary>
                            <pre><code class="language-sql">SELECT
    name,
    price,
    ROUND(price * 1.18, 2) AS "Price with Tax"
FROM blood_tests;</code></pre>
                        </details>
                    </div>
                </section>

                <section class="lesson-section">
                    <h2>Summary</h2>
                    <div class="summary-box">
                        <ul>
                            <li>&#10003; <code>SELECT</code> retrieves data from tables</li>
                            <li>&#10003; Use specific column names instead of <code>*</code></li>
                            <li>&#10003; Aliases make output more readable</li>
                            <li>&#10003; Expressions can create calculated columns</li>
                            <li>&#10003; <code>COALESCE</code> handles NULL values</li>
                            <li>&#10003; <code>CASE</code> provides conditional logic</li>
                        </ul>
                    </div>
                </section>

                <div class="lesson-nav">
                    <span></span>
                    <a class="btn btn-primary" onclick="loadLesson('where-clause')">Next: WHERE Clause &#8594;</a>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.sql-lessons-page {
    display: flex;
    height: calc(100vh - 60px);
}

.sql-lessons-page .sidebar {
    width: 320px;
    background: var(--bg-secondary, #f5f5f5);
    border-right: 1px solid var(--border-color, #e0e0e0);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.sql-lessons-page .sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color, #e0e0e0);
}

.sql-lessons-page .sidebar-header h2 {
    margin: 0;
    font-size: 1.1rem;
}

.lesson-tree {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
}

.lesson-category {
    margin-bottom: 0.5rem;
}

.category-header {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    background: white;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
}

.category-header:hover {
    background: var(--bg-hover, #f0f0f0);
}

.category-header .icon {
    margin-right: 0.5rem;
}

.category-header .arrow {
    margin-left: auto;
    transition: transform 0.2s;
}

.category-content {
    display: none;
    padding: 0.5rem 0 0.5rem 1rem;
}

.category-content.expanded {
    display: block;
}

.sub-category {
    margin-bottom: 0.25rem;
}

.sub-header {
    padding: 0.5rem;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary, #666);
}

.sub-header:hover {
    color: var(--primary-color, #007bff);
}

.sub-content {
    display: none;
    padding-left: 1rem;
}

.sub-content.expanded {
    display: block;
}

.lesson-link {
    display: block;
    padding: 0.4rem 0.5rem;
    font-size: 0.85rem;
    color: var(--text-primary, #333);
    text-decoration: none;
    border-radius: 4px;
    cursor: pointer;
}

.lesson-link:hover {
    background: var(--bg-hover, #e8e8e8);
    color: var(--primary-color, #007bff);
}

.lesson-link.active {
    background: var(--primary-color, #007bff);
    color: white;
}

.sql-lessons-page .content {
    flex: 1;
    overflow-y: auto;
    padding: 2rem;
    background: white;
}

.lesson {
    max-width: 900px;
    margin: 0 auto;
}

.lesson h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
}

.lesson-meta {
    color: var(--text-secondary, #666);
    font-size: 0.9rem;
    margin-bottom: 2rem;
    display: flex;
    gap: 1rem;
}

.lesson-section {
    margin-bottom: 2.5rem;
}

.lesson-section h2 {
    font-size: 1.4rem;
    margin: 0 0 1rem 0;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--primary-color, #007bff);
}

.lesson-section h3 {
    font-size: 1.1rem;
    margin: 1.5rem 0 0.75rem 0;
}

.lesson-section h4 {
    font-size: 1rem;
    margin: 1rem 0 0.5rem 0;
}

.lesson-section pre {
    background: #f8f9fa;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 4px;
    padding: 1rem;
    overflow-x: auto;
    margin: 0.5rem 0;
}

.lesson-section code {
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9rem;
}

.lesson-section p code {
    background: #f0f0f0;
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
}

.key-points {
    background: #e8f4fd;
    border-left: 4px solid #007bff;
    padding: 1rem;
    margin: 1rem 0;
    border-radius: 0 4px 4px 0;
}

.key-points h3 {
    margin: 0 0 0.5rem 0 !important;
    font-size: 1rem;
}

.key-points ul {
    margin: 0;
    padding-left: 1.5rem;
}

.key-points li {
    margin-bottom: 0.5rem;
}

.info-box {
    background: #fff8e6;
    border-left: 4px solid #ffc107;
    padding: 1rem;
    margin: 1rem 0;
    border-radius: 0 4px 4px 0;
}

.info-box h4 {
    margin: 0 0 0.5rem 0;
}

.info-box ul {
    margin: 0;
    padding-left: 1.5rem;
}

.example-query {
    background: #f8f9fa;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 4px;
    padding: 1rem;
    margin: 1rem 0;
}

.example-query h4 {
    margin: 0 0 0.5rem 0;
}

.example-query pre {
    margin: 0.5rem 0;
}

.example-query button {
    margin-top: 0.5rem;
}

.comparison-table {
    overflow-x: auto;
    margin: 1rem 0;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
}

.comparison-table th,
.comparison-table td {
    padding: 0.75rem;
    border: 1px solid var(--border-color, #ddd);
    text-align: left;
}

.comparison-table th {
    background: var(--bg-secondary, #f5f5f5);
    font-weight: 600;
}

.exercise {
    background: #f0f9f0;
    border: 1px solid #28a745;
    border-radius: 4px;
    padding: 1rem;
    margin: 1rem 0;
}

.exercise h4 {
    margin: 0 0 0.5rem 0;
    color: #28a745;
}

.exercise details {
    margin-top: 1rem;
}

.exercise summary {
    cursor: pointer;
    color: var(--primary-color, #007bff);
    font-weight: 500;
}

.summary-box {
    background: #e8f4fd;
    border: 1px solid #007bff;
    border-radius: 4px;
    padding: 1rem;
}

.summary-box ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.summary-box li {
    padding: 0.5rem 0;
}

.lesson-nav {
    display: flex;
    justify-content: space-between;
    margin-top: 3rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color, #e0e0e0);
}

/* Inline SQL Editor Styles */
.try-it-section {
    background: #f8f9fa;
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
}

.inline-editor-wrapper {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.inline-sql-editor {
    width: 100%;
    font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.9rem;
    padding: 0.75rem;
    border: 1px solid #555;
    border-radius: 4px;
    background: #374151;
    color: #d4d4d4;
    resize: vertical;
    min-height: 80px;
    line-height: 1.6;
}

.inline-sql-editor:focus {
    outline: none;
    border-color: #569cd6;
    box-shadow: 0 0 0 2px rgba(86, 156, 214, 0.2);
}

.btn-run-inline {
    align-self: flex-start;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
}

.inline-results {
    margin-top: 1rem;
    min-height: 20px;
}

.inline-results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    background: #e8f5e9;
    border-radius: 4px 4px 0 0;
    font-size: 0.85rem;
}

.inline-results-header .success {
    color: #28a745;
    font-weight: 500;
}

.inline-results-header .timing {
    color: var(--text-secondary, #666);
}

.inline-table-wrapper {
    max-height: 300px;
    overflow: auto;
    border: 1px solid var(--border-color, #ddd);
    border-top: none;
    border-radius: 0 0 4px 4px;
}

.inline-results-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
}

.inline-results-table th,
.inline-results-table td {
    padding: 0.5rem;
    border: 1px solid var(--border-color, #ddd);
    text-align: left;
    white-space: nowrap;
}

.inline-results-table th {
    background: var(--bg-secondary, #f5f5f5);
    font-weight: 600;
    position: sticky;
    top: 0;
}

.inline-results-table tr:hover {
    background: var(--bg-hover, #f8f8f8);
}

.inline-results-table .null-value {
    color: #999;
    font-style: italic;
}

.inline-error {
    background: #fff5f5;
    border: 1px solid #ffcccc;
    padding: 0.75rem;
    border-radius: 4px;
    color: #dc3545;
    font-family: monospace;
    font-size: 0.85rem;
    white-space: pre-wrap;
}

.loading {
    text-align: center;
    padding: 1rem;
    color: var(--text-secondary, #666);
}

/* Transposed table for single-row results */
.transposed-table {
    max-width: 500px;
}

.transposed-table .column-name {
    background: var(--bg-secondary, #f5f5f5);
    font-weight: 600;
    color: var(--text-primary, #333);
    width: 40%;
    text-transform: capitalize;
}

.transposed-table td:last-child {
    word-break: break-word;
}

/* Ensure results are visible */
.inline-results {
    margin-top: 0.75rem;
}

.inline-results:empty {
    display: none;
}

/* Mobile responsive - hide sidebar */
@media screen and (max-width: 768px) {
    .sql-lessons-page {
        flex-direction: column;
        height: auto;
    }

    .sql-lessons-page .sidebar {
        display: none !important;
        width: 0 !important;
    }

    .sql-lessons-page .content {
        width: 100% !important;
        padding: 1rem;
        max-width: 100%;
        overflow-x: hidden;
    }

    .lesson {
        max-width: 100%;
    }

    .lesson h1 {
        font-size: 1.5rem;
    }

    .lesson-section h2 {
        font-size: 1.2rem;
    }

    /* Code blocks */
    pre, code {
        max-width: 100%;
        overflow-x: auto;
        font-size: 0.8rem;
    }
}
</style>

<script>
(function() {
    // Lesson content database
    const lessonContent = {
        'select-basics': null, // Already loaded as default

        'sql-deep-dive': {
            title: 'How SQL Queries Actually Work',
            category: 'Understanding SQL',
            difficulty: 'Intermediate',
            prev: null,
            next: 'select-basics',
            sections: [
                {
                    title: 'The Journey of a SQL Query',
                    content: `<p>When you write a SQL query, it goes through multiple stages before returning results. Understanding this process helps you write better, faster queries.</p>
                    <pre><code class="language-text">Your Query: SELECT * FROM users WHERE age > 25 ORDER BY name;
                           ↓
┌──────────────────────────────────────────────────────────────┐
│ 1. PARSER                                                    │
│    • Checks syntax (SELECT, FROM, WHERE are valid keywords)  │
│    • Validates table/column names exist                      │
│    • Builds an Abstract Syntax Tree (AST)                    │
└──────────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────────┐
│ 2. QUERY OPTIMIZER                                           │
│    • Considers multiple execution plans                      │
│    • Estimates cost of each plan (I/O, CPU)                  │
│    • Chooses the "cheapest" plan                             │
│    • Decides: use index? scan whole table? join order?       │
└──────────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────────┐
│ 3. EXECUTOR                                                  │
│    • Runs the chosen plan step by step                       │
│    • Reads data from disk (or cache)                         │
│    • Applies filters (WHERE)                                 │
│    • Sorts results (ORDER BY)                                │
│    • Returns rows to client                                  │
└──────────────────────────────────────────────────────────────┘</code></pre>`
                },
                {
                    title: 'SQL Execution Order (Not What You Write!)',
                    content: `<p>SQL executes in a specific order that's DIFFERENT from how you write queries:</p>
                    <div class="comparison-table">
                        <table>
                            <thead><tr><th>Write Order</th><th>Execution Order</th><th>What Happens</th></tr></thead>
                            <tbody>
                                <tr><td>1. SELECT</td><td>6. SELECT</td><td>Pick which columns to return</td></tr>
                                <tr><td>2. FROM</td><td style="background:#e8f4fd;"><strong>1. FROM</strong></td><td>Load tables into memory</td></tr>
                                <tr><td>3. WHERE</td><td style="background:#e8f4fd;"><strong>2. WHERE</strong></td><td>Filter rows</td></tr>
                                <tr><td>4. GROUP BY</td><td style="background:#e8f4fd;"><strong>3. GROUP BY</strong></td><td>Group rows together</td></tr>
                                <tr><td>5. HAVING</td><td style="background:#e8f4fd;"><strong>4. HAVING</strong></td><td>Filter groups</td></tr>
                                <tr><td>6. ORDER BY</td><td>5. SELECT</td><td>Calculate expressions</td></tr>
                                <tr><td>7. LIMIT</td><td>6. ORDER BY</td><td>Sort results</td></tr>
                                <tr><td></td><td>7. LIMIT</td><td>Restrict output count</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="info-box">
                        <h4>Why This Matters</h4>
                        <ul>
                            <li>You can't use a SELECT alias in WHERE (SELECT runs after WHERE)</li>
                            <li>You CAN use a SELECT alias in ORDER BY (ORDER BY runs after SELECT)</li>
                            <li>HAVING filters after GROUP BY, so it can use aggregate functions</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'How Indexes Work (The Secret to Fast Queries)',
                    content: `<p>An <strong>index</strong> is like a book's index - it helps find data without scanning every row.</p>
                    <pre><code class="language-text">WITHOUT INDEX (Full Table Scan):
┌─────────────────────────────────────────┐
│ Table: users (1,000,000 rows)           │
│                                         │
│ Query: WHERE email = 'john@example.com' │
│                                         │
│ → Must check ALL 1,000,000 rows         │
│ → Time: O(n) = 1,000,000 comparisons    │
│ → Slow! (seconds to minutes)            │
└─────────────────────────────────────────┘

WITH INDEX (B-Tree Index on email):
┌─────────────────────────────────────────┐
│ Index: B-Tree                           │
│                                         │
│         [john@...]                      │
│          /    \\                         │
│    [alice]  [mary]                      │
│     /  \\      /  \\                      │
│   ...  ...  ...  ...                    │
│                                         │
│ → Jump directly to matching rows        │
│ → Time: O(log n) = ~20 comparisons      │
│ → Fast! (milliseconds)                  │
└─────────────────────────────────────────┘</code></pre>
                    <div class="key-points">
                        <h3>When to Create Indexes:</h3>
                        <ul>
                            <li><strong>Columns in WHERE clauses</strong> (filtered frequently)</li>
                            <li><strong>Columns in JOIN conditions</strong> (foreign keys)</li>
                            <li><strong>Columns in ORDER BY</strong> (sorted frequently)</li>
                            <li><strong>Primary keys</strong> (auto-indexed in most databases)</li>
                        </ul>
                    </div>
                    <div class="info-box" style="background:#fff3cd; border-color:#ffc107;">
                        <h4>Index Trade-offs</h4>
                        <ul>
                            <li>Faster reads, but slower writes (index must be updated)</li>
                            <li>Uses extra disk space</li>
                            <li>Too many indexes = slow INSERT/UPDATE/DELETE</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'EXPLAIN: See the Query Plan',
                    content: `<p>Use <code>EXPLAIN</code> to see HOW the database will execute your query:</p>
                    <div class="try-it-section">
                        <p>See the execution plan:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">EXPLAIN SELECT *
FROM requests
WHERE status = 'completed'
ORDER BY final_amount DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>
                    <pre><code class="language-text">Common Operations in EXPLAIN:
┌───────────────────┬────────────────────────────────────────┐
│ Operation         │ Meaning                                │
├───────────────────┼────────────────────────────────────────┤
│ Seq Scan          │ Full table scan (BAD for large tables) │
│ Index Scan        │ Using an index (GOOD)                  │
│ Index Only Scan   │ Data from index only (BEST)            │
│ Bitmap Index Scan │ Using multiple indexes                 │
│ Nested Loop       │ Join using loops (slow for large)      │
│ Hash Join         │ Join using hash table (good for large) │
│ Merge Join        │ Join sorted data (good for large)      │
│ Sort              │ Sorting results (ORDER BY)             │
│ Aggregate         │ Computing aggregates (COUNT, SUM, etc) │
└───────────────────┴────────────────────────────────────────┘</code></pre>`
                },
                {
                    title: 'SQL vs NoSQL: When to Use What',
                    content: `<div class="comparison-table">
                        <table>
                            <thead><tr><th>Feature</th><th>SQL (PostgreSQL)</th><th>NoSQL (MongoDB)</th></tr></thead>
                            <tbody>
                                <tr><td>Data Model</td><td>Tables with relationships</td><td>Documents (JSON)</td></tr>
                                <tr><td>Schema</td><td>Fixed schema (strict)</td><td>Flexible schema</td></tr>
                                <tr><td>Joins</td><td>Excellent (built-in)</td><td>Limited ($lookup)</td></tr>
                                <tr><td>Transactions</td><td>Full ACID support</td><td>Limited (document-level)</td></tr>
                                <tr><td>Scaling</td><td>Vertical (bigger server)</td><td>Horizontal (more servers)</td></tr>
                                <tr><td>Complex Queries</td><td>Powerful (SQL)</td><td>Limited</td></tr>
                                <tr><td>Best For</td><td>Complex relationships, reports</td><td>Rapid development, nested data</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="key-points">
                        <h3>Choose SQL When:</h3>
                        <ul>
                            <li>Data has clear relationships (users → orders → products)</li>
                            <li>You need complex queries with JOINs</li>
                            <li>Data integrity is critical (financial, medical)</li>
                            <li>You need ACID transactions</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['SQL queries go through Parser → Optimizer → Executor', 'Execution order differs from write order (FROM runs first)', 'Indexes enable O(log n) lookups instead of O(n) scans', 'Use EXPLAIN to understand query performance', 'SQL is best for relational data with complex queries']
        },

        'where-clause': {
            title: 'WHERE Clause',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'select-basics',
            next: 'order-by',
            sections: [
                {
                    title: 'What is WHERE?',
                    content: `<p>The <code>WHERE</code> clause filters rows based on specified conditions. Only rows that satisfy the condition are included in the result.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Purpose:</strong> Filter rows based on conditions</li>
                            <li><strong>Position:</strong> Comes after FROM clause</li>
                            <li><strong>Evaluation:</strong> Conditions evaluate to TRUE, FALSE, or NULL</li>
                            <li><strong>NULL handling:</strong> NULL comparisons require special operators</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Basic WHERE syntax
SELECT column1, column2
FROM table_name
WHERE condition;

-- Multiple conditions with AND
SELECT * FROM requests
WHERE status = 'completed' AND final_amount > 1000;

-- Multiple conditions with OR
SELECT * FROM requests
WHERE status = 'completed' OR status = 'processing';</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Filter requests by status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">SELECT request_number, status, final_amount
FROM requests
WHERE status = 'completed'
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Common Comparison Operators',
                    content: `<div class="comparison-table">
                        <table>
                            <thead><tr><th>Operator</th><th>Description</th><th>Example</th></tr></thead>
                            <tbody>
                                <tr><td><code>=</code></td><td>Equal to</td><td><code>status = 'completed'</code></td></tr>
                                <tr><td><code><></code> or <code>!=</code></td><td>Not equal to</td><td><code>status <> 'cancelled'</code></td></tr>
                                <tr><td><code><</code></td><td>Less than</td><td><code>final_amount < 1000</code></td></tr>
                                <tr><td><code>></code></td><td>Greater than</td><td><code>final_amount > 500</code></td></tr>
                                <tr><td><code><=</code></td><td>Less than or equal</td><td><code>final_amount <= 1000</code></td></tr>
                                <tr><td><code>>=</code></td><td>Greater than or equal</td><td><code>final_amount >= 500</code></td></tr>
                            </tbody>
                        </table>
                    </div>`
                },
                {
                    title: 'Exercises',
                    content: `<div class="exercise">
                        <h4>Exercise 1: Filter by Amount</h4>
                        <p>Find all requests where final_amount is greater than 2000.</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="3">-- Write your query here
SELECT * FROM requests WHERE </textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                        <details>
                            <summary>Show Solution</summary>
                            <pre><code class="language-sql">SELECT * FROM requests WHERE final_amount > 2000;</code></pre>
                        </details>
                    </div>`
                }
            ],
            summary: ['WHERE filters rows based on conditions', 'Use AND/OR to combine conditions', 'Comparison operators: =, <>, <, >, <=, >=', 'NULL requires IS NULL or IS NOT NULL']
        },

        'order-by': {
            title: 'ORDER BY',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'where-clause',
            next: 'limit-offset',
            sections: [
                {
                    title: 'What is ORDER BY?',
                    content: `<p>The <code>ORDER BY</code> clause sorts the result set by one or more columns. By default, it sorts in ascending order.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>ASC:</strong> Ascending order (default, A-Z, 0-9)</li>
                            <li><strong>DESC:</strong> Descending order (Z-A, 9-0)</li>
                            <li><strong>Multiple columns:</strong> Sort by primary, then secondary, etc.</li>
                            <li><strong>NULL handling:</strong> NULLs sort first or last depending on database</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Sort ascending (default)
SELECT * FROM requests ORDER BY created_at;

-- Sort descending
SELECT * FROM requests ORDER BY final_amount DESC;

-- Multiple columns
SELECT * FROM requests ORDER BY status ASC, final_amount DESC;

-- Sort by column position
SELECT request_number, status, final_amount
FROM requests ORDER BY 3 DESC;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Sort requests by amount (highest first):</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">SELECT request_number, status, final_amount
FROM requests
ORDER BY final_amount DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'NULL Handling',
                    content: `<pre><code class="language-sql">-- PostgreSQL: NULLS FIRST / NULLS LAST
SELECT * FROM patients
ORDER BY last_name ASC NULLS LAST;

-- NULLs at the beginning
SELECT * FROM patients
ORDER BY phone DESC NULLS FIRST;</code></pre>
                    <div class="info-box">
                        <h4>Database Differences</h4>
                        <p>PostgreSQL sorts NULLs last for ASC and first for DESC by default. Use NULLS FIRST/LAST to override.</p>
                    </div>`
                }
            ],
            summary: ['ORDER BY sorts result sets', 'ASC (ascending) is default', 'DESC for descending order', 'Can sort by multiple columns', 'Use NULLS FIRST/LAST for NULL handling']
        },

        'limit-offset': {
            title: 'LIMIT & OFFSET',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'order-by',
            next: 'comparison',
            sections: [
                {
                    title: 'What are LIMIT and OFFSET?',
                    content: `<p><code>LIMIT</code> restricts the number of rows returned. <code>OFFSET</code> skips a specified number of rows before returning results.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>LIMIT:</strong> Maximum rows to return</li>
                            <li><strong>OFFSET:</strong> Number of rows to skip</li>
                            <li><strong>Pagination:</strong> Combine both for paging through results</li>
                            <li><strong>Performance:</strong> Large offsets can be slow</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Limit to 10 rows
SELECT * FROM requests LIMIT 10;

-- Skip first 5 rows, return next 10
SELECT * FROM requests LIMIT 10 OFFSET 5;

-- Pagination example (page 3, 10 items per page)
SELECT * FROM requests
ORDER BY created_at DESC
LIMIT 10 OFFSET 20;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Get the top 5 highest value requests:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">SELECT request_number, status, final_amount
FROM requests
ORDER BY final_amount DESC
LIMIT 5;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Pagination Pattern',
                    content: `<pre><code class="language-sql">-- Common pagination pattern
-- Page 1: OFFSET 0
-- Page 2: OFFSET 10
-- Page N: OFFSET (N-1) * page_size

-- Example: Get page 2 with 10 items per page
SELECT request_number, status, final_amount
FROM requests
ORDER BY created_at DESC
LIMIT 10 OFFSET 10;</code></pre>
                    <div class="info-box">
                        <h4>Performance Tip</h4>
                        <p>For large offsets, consider keyset pagination (WHERE id > last_seen_id) instead of OFFSET for better performance.</p>
                    </div>`
                }
            ],
            summary: ['LIMIT restricts rows returned', 'OFFSET skips rows', 'Combine for pagination', 'Always use ORDER BY with LIMIT', 'Keyset pagination is faster for large offsets']
        },

        'inner-join': {
            title: 'INNER JOIN',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'boolean-json',
            next: 'left-join',
            sections: [
                {
                    title: 'What is INNER JOIN?',
                    content: `<p><code>INNER JOIN</code> returns only the rows that have matching values in both tables. Rows without a match are excluded.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Returns:</strong> Only matching rows from both tables</li>
                            <li><strong>Excludes:</strong> Rows with no match in either table</li>
                            <li><strong>Most common:</strong> Default join type in most queries</li>
                            <li><strong>Symmetrical:</strong> Order of tables doesn't affect results</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Explicit INNER JOIN syntax
SELECT r.request_number, o.order_number, p.first_name
FROM requests r
INNER JOIN orders o ON o.request_id = r.id
INNER JOIN patients p ON o.patient_id = p.id;

-- Implicit join (older syntax, not recommended)
SELECT r.request_number, o.order_number
FROM requests r, orders o
WHERE o.request_id = r.id;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Join requests with their orders:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="6">SELECT
    r.request_number,
    r.status AS request_status,
    o.order_number,
    o.subtotal
FROM requests r
INNER JOIN orders o ON o.request_id = r.id
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Visual Explanation',
                    content: `<div class="info-box">
                        <h4>How INNER JOIN Works</h4>
                        <p>Think of two overlapping circles (Venn diagram). INNER JOIN returns only the overlapping part - rows that exist in BOTH tables.</p>
                        <pre>
    Table A        Table B
      ┌───┐        ┌───┐
      │   │╲      ╱│   │
      │   │ ╲    ╱ │   │
      │   │  ╲  ╱  │   │
      │   │   ╲╱   │   │
      │   │   ╱╲   │   │  ← INNER JOIN returns this intersection
      │   │  ╱  ╲  │   │
      │   │ ╱    ╲ │   │
      │   │╱      ╲│   │
      └───┘        └───┘
                        </pre>
                    </div>`
                }
            ],
            summary: ['INNER JOIN returns matching rows only', 'Non-matching rows are excluded', 'Use explicit JOIN syntax', 'Table order does not matter', 'Most common join type']
        },

        'left-join': {
            title: 'LEFT JOIN',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'inner-join',
            next: 'right-join',
            sections: [
                {
                    title: 'What is LEFT JOIN?',
                    content: `<p><code>LEFT JOIN</code> (or LEFT OUTER JOIN) returns all rows from the left table and matching rows from the right table. Unmatched rows have NULL for right table columns.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>All left rows:</strong> Every row from left table is included</li>
                            <li><strong>Matching right rows:</strong> Right table data where matches exist</li>
                            <li><strong>NULLs:</strong> Right columns are NULL when no match</li>
                            <li><strong>Use case:</strong> Find records with or without related data</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- LEFT JOIN syntax
SELECT r.request_number, cs.slot_date
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id;

-- Find requests WITHOUT collection slots
SELECT r.request_number, r.status
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id
WHERE cs.id IS NULL;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find all requests and their collection slots (if any):</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="7">SELECT
    r.request_number,
    r.status,
    cs.slot_date,
    cs.slot_time
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id
ORDER BY r.created_at DESC
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Finding Missing Records',
                    content: `<div class="try-it-section">
                        <p>Find requests that have NO collection slots:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="6">SELECT r.request_number, r.status, r.final_amount
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id
WHERE cs.id IS NULL
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>
                    <div class="info-box">
                        <h4>Anti-Join Pattern</h4>
                        <p>LEFT JOIN + WHERE right.id IS NULL is called an "anti-join" - it finds records that DON'T have matching records in another table.</p>
                    </div>`
                }
            ],
            summary: ['LEFT JOIN keeps all left table rows', 'Right columns are NULL when no match', 'Great for finding missing relationships', 'Anti-join: LEFT JOIN + WHERE IS NULL', 'Table order matters (left vs right)']
        },

        'count-sum': {
            title: 'COUNT & SUM',
            category: 'Aggregations',
            difficulty: 'Intermediate',
            prev: 'join-performance',
            next: 'avg-min-max',
            sections: [
                {
                    title: 'Aggregate Functions Overview',
                    content: `<p>Aggregate functions perform calculations across multiple rows and return a single result. <code>COUNT</code> counts rows, <code>SUM</code> adds up values.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>COUNT(*):</strong> Counts all rows including NULLs</li>
                            <li><strong>COUNT(column):</strong> Counts non-NULL values</li>
                            <li><strong>COUNT(DISTINCT):</strong> Counts unique non-NULL values</li>
                            <li><strong>SUM:</strong> Adds up numeric values, ignores NULLs</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'COUNT Examples',
                    content: `<pre><code class="language-sql">-- Count all rows
SELECT COUNT(*) AS total_requests FROM requests;

-- Count non-NULL values in a column
SELECT COUNT(phone) AS has_phone FROM patients;

-- Count distinct values
SELECT COUNT(DISTINCT status) AS unique_statuses FROM requests;

-- Count with condition
SELECT COUNT(*) FILTER (WHERE status = 'completed') AS completed
FROM requests;</code></pre>`
                },
                {
                    title: 'Try COUNT',
                    content: `<div class="try-it-section">
                        <p>Count requests by status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">SELECT
    status,
    COUNT(*) AS count
FROM requests
GROUP BY status
ORDER BY count DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'SUM Examples',
                    content: `<pre><code class="language-sql">-- Sum all amounts
SELECT SUM(final_amount) AS total_revenue FROM requests;

-- Sum with condition
SELECT SUM(final_amount) AS completed_revenue
FROM requests
WHERE status = 'completed';

-- Sum with GROUP BY
SELECT status, SUM(final_amount) AS revenue
FROM requests
GROUP BY status;</code></pre>`
                },
                {
                    title: 'Try SUM',
                    content: `<div class="try-it-section">
                        <p>Calculate total revenue by status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">SELECT
    status,
    COUNT(*) AS request_count,
    SUM(final_amount) AS total_revenue,
    ROUND(AVG(final_amount), 2) AS avg_revenue
FROM requests
GROUP BY status
ORDER BY total_revenue DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['COUNT(*) counts all rows', 'COUNT(column) ignores NULLs', 'COUNT(DISTINCT) for unique values', 'SUM adds numeric values', 'Both work with GROUP BY']
        },

        'group-by-basics': {
            title: 'GROUP BY Basics',
            category: 'Aggregations',
            difficulty: 'Intermediate',
            prev: 'array-agg',
            next: 'having-clause',
            sections: [
                {
                    title: 'What is GROUP BY?',
                    content: `<p><code>GROUP BY</code> groups rows that have the same values into summary rows. It's typically used with aggregate functions to calculate values for each group.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Groups data:</strong> Combines rows with matching values</li>
                            <li><strong>With aggregates:</strong> Calculate per-group statistics</li>
                            <li><strong>SELECT rule:</strong> Non-aggregated columns must be in GROUP BY</li>
                            <li><strong>Execution order:</strong> FROM → WHERE → GROUP BY → HAVING → SELECT</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Group by single column
SELECT status, COUNT(*) AS count
FROM requests
GROUP BY status;

-- Group by multiple columns
SELECT status, DATE(created_at) AS date, COUNT(*)
FROM requests
GROUP BY status, DATE(created_at);

-- Using expressions in GROUP BY
SELECT
    EXTRACT(MONTH FROM created_at) AS month,
    COUNT(*) AS requests
FROM requests
GROUP BY EXTRACT(MONTH FROM created_at);</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Group requests by status and see statistics:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="7">SELECT
    status,
    COUNT(*) AS total_requests,
    SUM(final_amount) AS total_revenue,
    ROUND(AVG(final_amount), 2) AS avg_amount,
    MIN(final_amount) AS min_amount,
    MAX(final_amount) AS max_amount
FROM requests
GROUP BY status
ORDER BY total_revenue DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Common Mistake',
                    content: `<div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>Common Error</h4>
                        <pre><code class="language-sql">-- ERROR: request_number is not in GROUP BY
SELECT status, request_number, COUNT(*)
FROM requests
GROUP BY status;

-- CORRECT: Include all non-aggregate columns
SELECT status, COUNT(*)
FROM requests
GROUP BY status;</code></pre>
                        <p>Every column in SELECT must either be in GROUP BY or be an aggregate function.</p>
                    </div>`
                }
            ],
            summary: ['GROUP BY groups rows with same values', 'Must use with aggregate functions', 'All SELECT columns must be aggregated or in GROUP BY', 'Can group by multiple columns', 'Can use expressions in GROUP BY']
        },

        'having-clause': {
            title: 'HAVING Clause',
            category: 'Aggregations',
            difficulty: 'Intermediate',
            prev: 'group-by-basics',
            next: 'grouping-sets',
            sections: [
                {
                    title: 'What is HAVING?',
                    content: `<p><code>HAVING</code> filters groups after GROUP BY aggregation. While WHERE filters rows before grouping, HAVING filters the grouped results.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>WHERE vs HAVING:</strong> WHERE filters rows, HAVING filters groups</li>
                            <li><strong>Timing:</strong> HAVING is evaluated after GROUP BY</li>
                            <li><strong>Aggregate conditions:</strong> Can use aggregate functions in HAVING</li>
                            <li><strong>Combine both:</strong> Use WHERE and HAVING together when needed</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Filter groups with HAVING
SELECT status, COUNT(*) AS count
FROM requests
GROUP BY status
HAVING COUNT(*) > 5;

-- Combine WHERE and HAVING
SELECT status, SUM(final_amount) AS revenue
FROM requests
WHERE created_at > '2024-01-01'  -- Filter rows first
GROUP BY status
HAVING SUM(final_amount) > 10000;  -- Filter groups after</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find statuses with more than 2 requests:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">SELECT
    status,
    COUNT(*) AS request_count,
    SUM(final_amount) AS total_revenue
FROM requests
GROUP BY status
HAVING COUNT(*) >= 2
ORDER BY request_count DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'WHERE vs HAVING',
                    content: `<div class="comparison-table">
                        <table>
                            <thead><tr><th>Aspect</th><th>WHERE</th><th>HAVING</th></tr></thead>
                            <tbody>
                                <tr><td>Filters</td><td>Individual rows</td><td>Groups</td></tr>
                                <tr><td>Timing</td><td>Before GROUP BY</td><td>After GROUP BY</td></tr>
                                <tr><td>Aggregates</td><td>Cannot use</td><td>Can use</td></tr>
                                <tr><td>Example</td><td><code>WHERE status = 'active'</code></td><td><code>HAVING COUNT(*) > 5</code></td></tr>
                            </tbody>
                        </table>
                    </div>`
                }
            ],
            summary: ['HAVING filters groups, WHERE filters rows', 'HAVING comes after GROUP BY', 'Can use aggregate functions in HAVING', 'Use both WHERE and HAVING when needed', 'WHERE is evaluated before GROUP BY']
        },

        'cte-basics': {
            title: 'CTE Basics (WITH Clause)',
            category: 'Common Table Expressions',
            difficulty: 'Intermediate',
            prev: 'any-all',
            next: 'multiple-ctes',
            sections: [
                {
                    title: 'What is a CTE?',
                    content: `<p>A <code>Common Table Expression (CTE)</code> is a temporary named result set that you can reference within a SELECT, INSERT, UPDATE, or DELETE statement. It improves query readability and organization.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Temporary:</strong> Exists only for the duration of the query</li>
                            <li><strong>Readable:</strong> Breaks complex queries into manageable parts</li>
                            <li><strong>Reusable:</strong> Can reference the CTE multiple times</li>
                            <li><strong>Syntax:</strong> Starts with WITH keyword</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Basic CTE syntax
WITH cte_name AS (
    SELECT column1, column2
    FROM table_name
    WHERE condition
)
SELECT * FROM cte_name;

-- CTE with aggregation
WITH request_stats AS (
    SELECT status, COUNT(*) AS cnt, SUM(final_amount) AS total
    FROM requests
    GROUP BY status
)
SELECT * FROM request_stats WHERE total > 5000;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Use a CTE to find high-value requests:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">WITH high_value_requests AS (
    SELECT
        request_number,
        status,
        final_amount,
        created_at
    FROM requests
    WHERE final_amount > 2000
)
SELECT
    status,
    COUNT(*) AS count,
    SUM(final_amount) AS total
FROM high_value_requests
GROUP BY status;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'CTE vs Subquery',
                    content: `<div class="info-box">
                        <h4>When to Use CTEs</h4>
                        <ul>
                            <li>Query is complex and needs to be broken into steps</li>
                            <li>Same subquery is used multiple times</li>
                            <li>You want to improve readability</li>
                            <li>You need recursive queries</li>
                        </ul>
                    </div>
                    <pre><code class="language-sql">-- Subquery version (harder to read)
SELECT * FROM (
    SELECT status, COUNT(*) AS cnt FROM requests GROUP BY status
) sub WHERE cnt > 5;

-- CTE version (clearer)
WITH status_counts AS (
    SELECT status, COUNT(*) AS cnt FROM requests GROUP BY status
)
SELECT * FROM status_counts WHERE cnt > 5;</code></pre>`
                }
            ],
            summary: ['CTEs create temporary named result sets', 'Defined with WITH keyword', 'Improve query readability', 'Can be referenced multiple times', 'Great for breaking down complex queries']
        },

        'row-number': {
            title: 'ROW_NUMBER()',
            category: 'Window Functions',
            difficulty: 'Advanced',
            prev: 'frame-clause',
            next: 'rank-dense-rank',
            sections: [
                {
                    title: 'What is ROW_NUMBER?',
                    content: `<p><code>ROW_NUMBER()</code> assigns a unique sequential integer to each row within a partition. It's one of the most useful window functions for ranking and pagination.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Unique numbers:</strong> No ties, always 1, 2, 3, 4...</li>
                            <li><strong>Per partition:</strong> Resets for each partition group</li>
                            <li><strong>ORDER BY:</strong> Determines the numbering sequence</li>
                            <li><strong>Use cases:</strong> Pagination, deduplication, top N per group</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Simple row numbering
SELECT
    ROW_NUMBER() OVER (ORDER BY created_at) AS row_num,
    request_number,
    status
FROM requests;

-- Row number within each status group
SELECT
    ROW_NUMBER() OVER (PARTITION BY status ORDER BY final_amount DESC) AS rank,
    request_number,
    status,
    final_amount
FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Rank requests by amount within each status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="8">SELECT
    ROW_NUMBER() OVER (
        PARTITION BY status
        ORDER BY final_amount DESC
    ) AS rank_in_status,
    request_number,
    status,
    final_amount
FROM requests
ORDER BY status, rank_in_status;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Top N Per Group Pattern',
                    content: `<div class="try-it-section">
                        <p>Get top 2 highest value requests per status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="11">WITH ranked AS (
    SELECT
        ROW_NUMBER() OVER (
            PARTITION BY status
            ORDER BY final_amount DESC
        ) AS rn,
        request_number,
        status,
        final_amount
    FROM requests
)
SELECT * FROM ranked WHERE rn <= 2
ORDER BY status, rn;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>
                    <div class="info-box">
                        <h4>Top N Per Group</h4>
                        <p>This pattern is extremely useful for getting the top N items within each category - like top 3 products per category, most recent order per customer, etc.</p>
                    </div>`
                }
            ],
            summary: ['ROW_NUMBER() assigns unique sequential numbers', 'PARTITION BY creates groups', 'ORDER BY determines sequence', 'Numbers reset for each partition', 'Great for top N per group queries']
        },

        'lag-lead': {
            title: 'LAG & LEAD',
            category: 'Window Functions',
            difficulty: 'Advanced',
            prev: 'percent-rank',
            next: 'first-last',
            sections: [
                {
                    title: 'What are LAG and LEAD?',
                    content: `<p><code>LAG</code> accesses data from a previous row, and <code>LEAD</code> accesses data from a subsequent row. They're perfect for comparing values across rows.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>LAG:</strong> Look back at previous rows</li>
                            <li><strong>LEAD:</strong> Look ahead at next rows</li>
                            <li><strong>Offset:</strong> Number of rows to look back/ahead (default 1)</li>
                            <li><strong>Default:</strong> Value to return when no row exists</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- LAG: Get previous row's value
SELECT
    request_number,
    final_amount,
    LAG(final_amount) OVER (ORDER BY created_at) AS prev_amount
FROM requests;

-- LEAD: Get next row's value
SELECT
    request_number,
    created_at,
    LEAD(created_at) OVER (ORDER BY created_at) AS next_created
FROM requests;

-- With offset and default value
LAG(column, 2, 0) OVER (...)  -- 2 rows back, default 0</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Compare each request's amount to the previous one:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">SELECT
    request_number,
    created_at,
    final_amount,
    LAG(final_amount, 1, 0) OVER (ORDER BY created_at) AS prev_amount,
    final_amount - LAG(final_amount, 1, 0) OVER (ORDER BY created_at) AS diff
FROM requests
ORDER BY created_at
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Calculating Differences',
                    content: `<div class="try-it-section">
                        <p>Calculate time between requests:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="9">SELECT
    request_number,
    created_at,
    LAG(created_at) OVER (ORDER BY created_at) AS prev_created,
    created_at - LAG(created_at) OVER (ORDER BY created_at) AS time_gap
FROM requests
ORDER BY created_at
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['LAG looks at previous rows', 'LEAD looks at next rows', 'Great for row-to-row comparisons', 'Can specify offset (default 1)', 'Can specify default for missing values']
        },

        'running-total': {
            title: 'Running Totals',
            category: 'Window Functions',
            difficulty: 'Advanced',
            prev: 'nth-value',
            next: 'moving-average',
            sections: [
                {
                    title: 'What is a Running Total?',
                    content: `<p>A running total (cumulative sum) is the summation of a sequence of numbers that is updated each time a new number is added. Window functions make this easy to calculate.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Cumulative:</strong> Each row includes all previous values</li>
                            <li><strong>SUM() OVER:</strong> Aggregate function with window</li>
                            <li><strong>Frame:</strong> Default includes all preceding rows</li>
                            <li><strong>Use cases:</strong> Account balances, inventory, progress tracking</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Running total
SELECT
    request_number,
    final_amount,
    SUM(final_amount) OVER (ORDER BY created_at) AS running_total
FROM requests;

-- Running total per partition
SELECT
    status,
    request_number,
    final_amount,
    SUM(final_amount) OVER (
        PARTITION BY status
        ORDER BY created_at
    ) AS running_total_by_status
FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Calculate running total of request amounts:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="9">SELECT
    request_number,
    created_at,
    final_amount,
    SUM(final_amount) OVER (
        ORDER BY created_at
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM requests
ORDER BY created_at
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Running Total with Percentage',
                    content: `<div class="try-it-section">
                        <p>Show running total as percentage of grand total:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="11">SELECT
    request_number,
    final_amount,
    SUM(final_amount) OVER (ORDER BY created_at) AS running_total,
    SUM(final_amount) OVER () AS grand_total,
    ROUND(
        100.0 * SUM(final_amount) OVER (ORDER BY created_at) /
        SUM(final_amount) OVER (), 2
    ) AS running_pct
FROM requests
ORDER BY created_at
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['Running total = cumulative sum', 'Use SUM() OVER() for running totals', 'ORDER BY determines the sequence', 'PARTITION BY creates separate running totals', 'Useful for progress tracking and balances']
        },

        'explain-analyze': {
            title: 'EXPLAIN ANALYZE',
            category: 'Indexing & Performance',
            difficulty: 'Advanced',
            prev: 'covering-index',
            next: 'scan-types',
            sections: [
                {
                    title: 'What is EXPLAIN ANALYZE?',
                    content: `<p><code>EXPLAIN</code> shows the query execution plan without running the query. <code>EXPLAIN ANALYZE</code> actually runs the query and shows real execution statistics.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>EXPLAIN:</strong> Shows estimated plan only</li>
                            <li><strong>EXPLAIN ANALYZE:</strong> Shows actual execution stats</li>
                            <li><strong>Cost:</strong> Estimated work units (startup..total)</li>
                            <li><strong>Rows:</strong> Estimated vs actual row counts</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Show execution plan only
EXPLAIN SELECT * FROM requests WHERE status = 'completed';

-- Show plan with actual execution stats
EXPLAIN ANALYZE SELECT * FROM requests WHERE status = 'completed';

-- More verbose output
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT * FROM requests WHERE status = 'completed';</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Analyze a simple query:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="3">EXPLAIN ANALYZE
SELECT * FROM requests
WHERE status = 'completed';</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Reading the Output',
                    content: `<div class="info-box">
                        <h4>Key Metrics to Look For</h4>
                        <ul>
                            <li><strong>Seq Scan:</strong> Full table scan (slow for large tables)</li>
                            <li><strong>Index Scan:</strong> Using an index (usually faster)</li>
                            <li><strong>actual time:</strong> Real execution time in milliseconds</li>
                            <li><strong>rows:</strong> Actual rows processed</li>
                            <li><strong>loops:</strong> Number of times the operation was executed</li>
                        </ul>
                    </div>
                    <div class="try-it-section">
                        <p>Compare with a JOIN query:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">EXPLAIN ANALYZE
SELECT r.request_number, o.order_number
FROM requests r
JOIN orders o ON o.request_id = r.id
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['EXPLAIN shows query plan without running', 'EXPLAIN ANALYZE shows real stats', 'Look for Seq Scan vs Index Scan', 'Compare estimated vs actual rows', 'Use to identify slow queries']
        },

        // Add more basic lessons to ensure navigation works
        'comparison': {
            title: 'Comparison Operators',
            category: 'Filtering',
            difficulty: 'Beginner',
            prev: 'limit-offset',
            next: 'logical',
            sections: [
                {
                    title: 'Comparison Operators',
                    content: `<p>SQL comparison operators compare two values and return a boolean result (TRUE, FALSE, or NULL).</p>
                    <div class="comparison-table">
                        <table>
                            <thead><tr><th>Operator</th><th>Meaning</th><th>Example</th></tr></thead>
                            <tbody>
                                <tr><td><code>=</code></td><td>Equal</td><td><code>price = 100</code></td></tr>
                                <tr><td><code><></code></td><td>Not equal</td><td><code>status <> 'deleted'</code></td></tr>
                                <tr><td><code><</code></td><td>Less than</td><td><code>amount < 500</code></td></tr>
                                <tr><td><code>></code></td><td>Greater than</td><td><code>amount > 500</code></td></tr>
                                <tr><td><code><=</code></td><td>Less than or equal</td><td><code>amount <= 500</code></td></tr>
                                <tr><td><code>>=</code></td><td>Greater than or equal</td><td><code>amount >= 500</code></td></tr>
                            </tbody>
                        </table>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find requests with amount greater than 1500:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">SELECT request_number, status, final_amount
FROM requests
WHERE final_amount > 1500
ORDER BY final_amount DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['Use = for equality', 'Use <> or != for not equal', 'Comparison returns TRUE, FALSE, or NULL', 'NULLs require special handling']
        },

        'logical': {
            title: 'Logical Operators',
            category: 'Filtering',
            difficulty: 'Beginner',
            prev: 'comparison',
            next: 'like-pattern',
            sections: [
                {
                    title: 'AND, OR, NOT',
                    content: `<p>Logical operators combine multiple conditions in WHERE clauses.</p>
                    <pre><code class="language-sql">-- AND: Both conditions must be true
SELECT * FROM requests
WHERE status = 'completed' AND final_amount > 1000;

-- OR: Either condition must be true
SELECT * FROM requests
WHERE status = 'completed' OR status = 'processing';

-- NOT: Negates a condition
SELECT * FROM requests
WHERE NOT status = 'cancelled';</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Combine conditions:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">SELECT request_number, status, final_amount
FROM requests
WHERE (status = 'completed' OR status = 'processing')
  AND final_amount > 1000
ORDER BY final_amount DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['AND requires all conditions true', 'OR requires any condition true', 'NOT negates a condition', 'Use parentheses for clarity']
        },

        'like-pattern': {
            title: 'LIKE Pattern Matching',
            category: 'Filtering',
            difficulty: 'Beginner',
            prev: 'logical',
            next: 'in-between',
            sections: [
                {
                    title: 'LIKE Operator',
                    content: `<p><code>LIKE</code> performs pattern matching with wildcards.</p>
                    <div class="key-points">
                        <h3>Wildcards:</h3>
                        <ul>
                            <li><code>%</code> - Matches any sequence of characters</li>
                            <li><code>_</code> - Matches any single character</li>
                        </ul>
                    </div>
                    <pre><code class="language-sql">-- Starts with 'REQ'
SELECT * FROM requests WHERE request_number LIKE 'REQ%';

-- Ends with '001'
SELECT * FROM requests WHERE request_number LIKE '%001';

-- Contains 'test'
SELECT * FROM patients WHERE first_name LIKE '%test%';

-- Case-insensitive (PostgreSQL)
SELECT * FROM patients WHERE first_name ILIKE '%john%';</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find patients whose name starts with a letter:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="4">SELECT first_name, last_name, gender
FROM patients
WHERE first_name ILIKE 'a%'
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['% matches any sequence', '_ matches single character', 'LIKE is case-sensitive', 'ILIKE is case-insensitive (PostgreSQL)']
        },

        'in-between': {
            title: 'IN & BETWEEN',
            category: 'Filtering',
            difficulty: 'Beginner',
            prev: 'like-pattern',
            next: 'null-handling',
            sections: [
                {
                    title: 'IN Operator',
                    content: `<p><code>IN</code> checks if a value matches any value in a list.</p>
                    <pre><code class="language-sql">-- Match any value in list
SELECT * FROM requests
WHERE status IN ('completed', 'processing', 'pending');

-- Equivalent to multiple ORs
SELECT * FROM requests
WHERE status = 'completed'
   OR status = 'processing'
   OR status = 'pending';</code></pre>`
                },
                {
                    title: 'BETWEEN Operator',
                    content: `<p><code>BETWEEN</code> checks if a value is within a range (inclusive).</p>
                    <pre><code class="language-sql">-- Range check
SELECT * FROM requests
WHERE final_amount BETWEEN 1000 AND 2000;

-- Equivalent to
SELECT * FROM requests
WHERE final_amount >= 1000 AND final_amount <= 2000;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find requests with specific statuses and amount range:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">SELECT request_number, status, final_amount
FROM requests
WHERE status IN ('completed', 'processing')
  AND final_amount BETWEEN 500 AND 3000
ORDER BY final_amount;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['IN matches any value in a list', 'BETWEEN is inclusive on both ends', 'Both improve readability over multiple ORs', 'Can use NOT IN and NOT BETWEEN']
        },

        'null-handling': {
            title: 'NULL Handling',
            category: 'Filtering',
            difficulty: 'Beginner',
            prev: 'in-between',
            next: 'numeric-types',
            sections: [
                {
                    title: 'Understanding NULL',
                    content: `<p><code>NULL</code> represents missing or unknown data. It requires special handling because NULL is not equal to anything, not even itself.</p>
                    <div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>Common Mistake</h4>
                        <pre><code class="language-sql">-- WRONG: This will never match NULLs
SELECT * FROM patients WHERE phone = NULL;

-- CORRECT: Use IS NULL
SELECT * FROM patients WHERE phone IS NULL;</code></pre>
                    </div>`
                },
                {
                    title: 'NULL Operators',
                    content: `<pre><code class="language-sql">-- Check for NULL
SELECT * FROM patients WHERE phone IS NULL;

-- Check for NOT NULL
SELECT * FROM patients WHERE phone IS NOT NULL;

-- COALESCE: Return first non-NULL value
SELECT COALESCE(phone, 'No phone') FROM patients;

-- NULLIF: Return NULL if values are equal
SELECT NULLIF(discount_amount, 0) FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find patients with and without phone numbers:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="6">SELECT
    first_name,
    COALESCE(phone, 'Not provided') AS phone,
    CASE WHEN phone IS NULL THEN 'No' ELSE 'Yes' END AS has_phone
FROM patients
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['NULL means unknown/missing', 'Use IS NULL not = NULL', 'COALESCE provides default values', 'NULL propagates in expressions', 'COUNT(column) excludes NULLs']
        },

        // ==================== JOIN LESSONS ====================

        'right-join': {
            title: 'RIGHT JOIN',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'left-join',
            next: 'full-join',
            sections: [
                {
                    title: 'What is RIGHT JOIN?',
                    content: `<p><code>RIGHT JOIN</code> (or RIGHT OUTER JOIN) returns all rows from the right table and matching rows from the left table. Unmatched rows have NULL for left table columns.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>All right rows:</strong> Every row from right table is included</li>
                            <li><strong>Matching left rows:</strong> Left table data where matches exist</li>
                            <li><strong>NULLs:</strong> Left columns are NULL when no match</li>
                            <li><strong>Rare in practice:</strong> Usually rewritten as LEFT JOIN</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <p>Before using RIGHT JOIN, understand: <a onclick="loadLesson('inner-join')">INNER JOIN</a>, <a onclick="loadLesson('left-join')">LEFT JOIN</a>, and table relationship concepts.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- RIGHT JOIN syntax
SELECT orders.order_number, patients.first_name
FROM orders
RIGHT JOIN patients ON orders.patient_id = patients.id;

-- Equivalent LEFT JOIN (preferred)
SELECT orders.order_number, patients.first_name
FROM patients
LEFT JOIN orders ON orders.patient_id = patients.id;</code></pre>
                    <div class="info-box" style="background: #fff3cd; border-color: #ffc107;">
                        <h4>Best Practice</h4>
                        <p>Most developers prefer LEFT JOIN over RIGHT JOIN for readability. You can always swap table order and use LEFT JOIN instead.</p>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find all patients and their orders (if any):</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="7">-- Using RIGHT JOIN
SELECT
    o.order_number,
    p.first_name,
    p.last_name
FROM orders o
RIGHT JOIN patients p ON o.patient_id = p.id
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Alternative: Convert to LEFT JOIN',
                    content: `<pre><code class="language-sql">-- RIGHT JOIN version
SELECT o.order_number, p.first_name
FROM orders o
RIGHT JOIN patients p ON o.patient_id = p.id;

-- Equivalent LEFT JOIN version (more readable)
SELECT o.order_number, p.first_name
FROM patients p
LEFT JOIN orders o ON o.patient_id = p.id;</code></pre>
                    <div class="info-box">
                        <h4>Performance Note</h4>
                        <p>RIGHT JOIN and LEFT JOIN have the same performance. The query planner treats them identically after swapping tables.</p>
                    </div>`
                }
            ],
            summary: ['RIGHT JOIN keeps all right table rows', 'Left columns are NULL when no match', 'Can always be rewritten as LEFT JOIN', 'LEFT JOIN is generally preferred', 'Performance is identical to LEFT JOIN']
        },

        'full-join': {
            title: 'FULL OUTER JOIN',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'right-join',
            next: 'cross-join',
            sections: [
                {
                    title: 'What is FULL OUTER JOIN?',
                    content: `<p><code>FULL OUTER JOIN</code> returns all rows from both tables. Where there is no match, NULL values fill in the missing side.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>All rows:</strong> Every row from both tables is included</li>
                            <li><strong>NULLs both ways:</strong> Unmatched rows get NULLs on opposite side</li>
                            <li><strong>Use case:</strong> Finding orphan records in either table</li>
                            <li><strong>Less common:</strong> Used for reconciliation and data quality checks</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <p>Understand <a onclick="loadLesson('inner-join')">INNER JOIN</a>, <a onclick="loadLesson('left-join')">LEFT JOIN</a>, and NULL handling before using FULL OUTER JOIN.</p>
                    </div>`
                },
                {
                    title: 'Visual Explanation',
                    content: `<div class="info-box">
                        <h4>How FULL OUTER JOIN Works</h4>
                        <pre>
    Table A        Table B
      ┌───┐        ┌───┐
      │ A │╲      ╱│ B │
      │ L │ ╲    ╱ │ O │
      │ L │  ╲  ╱  │ T │
      │   │   ╲╱   │ H │
      │ R │   ╱╲   │   │  ← FULL OUTER JOIN returns EVERYTHING
      │ O │  ╱  ╲  │   │    (A + intersection + B)
      │ W │ ╱    ╲ │   │
      │ S │╱      ╲│   │
      └───┘        └───┘
                        </pre>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- FULL OUTER JOIN syntax
SELECT
    r.request_number,
    cs.slot_date
FROM requests r
FULL OUTER JOIN collection_slots cs ON cs.request_id = r.id;

-- Find orphan records (exist in one table but not the other)
SELECT
    r.request_number,
    cs.slot_date
FROM requests r
FULL OUTER JOIN collection_slots cs ON cs.request_id = r.id
WHERE r.id IS NULL OR cs.id IS NULL;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find all requests and collection slots (matched or unmatched):</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">SELECT
    r.request_number,
    r.status,
    cs.slot_date,
    cs.slot_time,
    CASE
        WHEN r.id IS NULL THEN 'Orphan slot'
        WHEN cs.id IS NULL THEN 'No slot assigned'
        ELSE 'Matched'
    END AS match_status
FROM requests r
FULL OUTER JOIN collection_slots cs ON cs.request_id = r.id
LIMIT 20;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Alternative: UNION of LEFT JOINs',
                    content: `<pre><code class="language-sql">-- If FULL OUTER JOIN is not supported (MySQL < 8)
-- Use UNION of LEFT JOIN and RIGHT JOIN
SELECT r.request_number, cs.slot_date
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id

UNION

SELECT r.request_number, cs.slot_date
FROM requests r
RIGHT JOIN collection_slots cs ON cs.request_id = r.id
WHERE r.id IS NULL;</code></pre>
                    <div class="info-box">
                        <h4>Database Support</h4>
                        <p>FULL OUTER JOIN is supported in PostgreSQL, SQL Server, and Oracle. MySQL added support in version 8.0. For older MySQL, use the UNION alternative.</p>
                    </div>`
                }
            ],
            summary: ['FULL OUTER JOIN returns all rows from both tables', 'NULLs fill unmatched columns on either side', 'Great for finding orphan records', 'Use WHERE IS NULL to find unmatched rows', 'Can be emulated with UNION of LEFT/RIGHT JOINs']
        },

        'cross-join': {
            title: 'CROSS JOIN',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'full-join',
            next: 'self-join',
            sections: [
                {
                    title: 'What is CROSS JOIN?',
                    content: `<p><code>CROSS JOIN</code> produces the Cartesian product of two tables - every row from the first table combined with every row from the second table.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Cartesian product:</strong> All possible combinations</li>
                            <li><strong>No join condition:</strong> Unlike other joins</li>
                            <li><strong>Result size:</strong> Rows in A × Rows in B</li>
                            <li><strong>Use with caution:</strong> Can produce massive result sets</li>
                        </ul>
                    </div>
                    <div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>Warning: Performance Impact</h4>
                        <p>A CROSS JOIN between two tables with 1000 rows each produces 1,000,000 rows! Always limit results or use small tables.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Explicit CROSS JOIN syntax
SELECT p.first_name, s.status
FROM patients p
CROSS JOIN (SELECT DISTINCT status FROM requests) s;

-- Implicit syntax (comma in FROM)
SELECT p.first_name, s.status
FROM patients p, (SELECT DISTINCT status FROM requests) s;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Generate all combinations of patients and statuses:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="8">-- Get statuses as a small set first
WITH statuses AS (
    SELECT DISTINCT status FROM requests
)
SELECT
    p.first_name,
    s.status
FROM (SELECT * FROM patients LIMIT 3) p
CROSS JOIN statuses s;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Practical Use Cases',
                    content: `<pre><code class="language-sql">-- Use case 1: Generate a calendar with all dates
WITH dates AS (
    SELECT generate_series(
        '2024-01-01'::date,
        '2024-01-07'::date,
        '1 day'::interval
    )::date AS date
),
hours AS (
    SELECT generate_series(9, 17) AS hour
)
SELECT date, hour FROM dates CROSS JOIN hours;

-- Use case 2: Create all product-store combinations
-- for inventory tracking
SELECT p.product_name, s.store_name
FROM products p CROSS JOIN stores s;

-- Use case 3: Matrix comparison
SELECT
    a.request_number AS req_a,
    b.request_number AS req_b,
    a.final_amount - b.final_amount AS diff
FROM (SELECT * FROM requests LIMIT 3) a
CROSS JOIN (SELECT * FROM requests LIMIT 3) b
WHERE a.id < b.id;</code></pre>
                    <div class="info-box">
                        <h4>When to Use CROSS JOIN</h4>
                        <ul>
                            <li>Generating test data combinations</li>
                            <li>Creating calendar/scheduling grids</li>
                            <li>Pairing all items for comparison</li>
                            <li>Filling sparse matrices</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['CROSS JOIN produces Cartesian product', 'No join condition required', 'Result = rows in A × rows in B', 'Use for generating combinations', 'Be careful with large tables - limit results']
        },

        'self-join': {
            title: 'Self Join',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'cross-join',
            next: 'chained-joins',
            sections: [
                {
                    title: 'What is a Self Join?',
                    content: `<p>A <strong>self join</strong> joins a table to itself. This is useful for comparing rows within the same table or for hierarchical data.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Same table twice:</strong> Table joins with itself</li>
                            <li><strong>Aliases required:</strong> Must use different aliases</li>
                            <li><strong>Use cases:</strong> Hierarchies, comparisons, sequences</li>
                            <li><strong>Any join type:</strong> Can use INNER, LEFT, etc.</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <p>Understand table aliases and basic JOIN syntax before attempting self joins.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Self join to find employees and their managers
SELECT
    e.name AS employee,
    m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- Self join to compare rows
SELECT
    a.request_number AS request_a,
    b.request_number AS request_b,
    a.final_amount,
    b.final_amount
FROM requests a
JOIN requests b ON a.status = b.status AND a.id < b.id;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find requests with the same status and compare amounts:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">-- Compare requests with same status
SELECT
    a.request_number AS req_1,
    b.request_number AS req_2,
    a.status,
    a.final_amount AS amount_1,
    b.final_amount AS amount_2,
    ABS(a.final_amount - b.final_amount) AS difference
FROM requests a
JOIN requests b ON a.status = b.status AND a.id < b.id
ORDER BY difference DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Use Case: Hierarchical Data',
                    content: `<pre><code class="language-sql">-- Example: Employee hierarchy
-- Assume table: employees(id, name, manager_id)

-- Find direct reports
SELECT
    m.name AS manager,
    e.name AS direct_report
FROM employees e
JOIN employees m ON e.manager_id = m.id;

-- Find all levels (using recursive CTE is better)
SELECT
    e1.name AS employee,
    e2.name AS manager,
    e3.name AS grand_manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id
LEFT JOIN employees e3 ON e2.manager_id = e3.id;</code></pre>
                    <div class="info-box">
                        <h4>Alternative: Recursive CTE</h4>
                        <p>For deep hierarchies with unknown depth, use <a onclick="loadLesson('recursive-cte')">Recursive CTEs</a> instead of chained self joins.</p>
                    </div>`
                },
                {
                    title: 'Use Case: Finding Sequential Records',
                    content: `<div class="try-it-section">
                        <p>Find consecutive requests and calculate time gaps:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">-- Find consecutive requests by created_at
WITH numbered AS (
    SELECT
        *,
        ROW_NUMBER() OVER (ORDER BY created_at) AS rn
    FROM requests
)
SELECT
    a.request_number AS current_req,
    b.request_number AS next_req,
    a.created_at AS current_time,
    b.created_at AS next_time
FROM numbered a
JOIN numbered b ON b.rn = a.rn + 1
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['Self join joins a table to itself', 'Must use different aliases for each instance', 'Useful for hierarchies and comparisons', 'Use a.id < b.id to avoid duplicate pairs', 'Consider LAG/LEAD for sequential comparisons']
        },

        'chained-joins': {
            title: 'Chaining Joins',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'self-join',
            next: 'join-conditions',
            sections: [
                {
                    title: 'What are Chained Joins?',
                    content: `<p>Chained joins connect multiple tables in a single query. Each JOIN adds another table to the result set.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Sequential:</strong> Each JOIN processes left-to-right</li>
                            <li><strong>Mix types:</strong> Can combine INNER, LEFT, etc.</li>
                            <li><strong>Performance:</strong> Join order can affect speed</li>
                            <li><strong>Readability:</strong> Format for clarity</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <p>Master individual join types (<a onclick="loadLesson('inner-join')">INNER</a>, <a onclick="loadLesson('left-join')">LEFT</a>) before chaining multiple joins.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Chaining multiple joins
SELECT
    r.request_number,
    o.order_number,
    p.first_name || ' ' || p.last_name AS patient_name,
    cs.slot_date
FROM requests r
JOIN orders o ON o.request_id = r.id
JOIN patients p ON o.patient_id = p.id
LEFT JOIN collection_slots cs ON cs.request_id = r.id;</code></pre>
                    <div class="info-box">
                        <h4>Formatting Best Practice</h4>
                        <p>Put each JOIN on its own line and indent consistently. This makes complex queries readable.</p>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Join requests, orders, patients, and collection slots:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    r.request_number,
    r.status AS request_status,
    o.order_number,
    p.first_name,
    p.last_name,
    cs.slot_date,
    cs.slot_time
FROM requests r
INNER JOIN orders o ON o.request_id = r.id
INNER JOIN patients p ON o.patient_id = p.id
LEFT JOIN collection_slots cs ON cs.request_id = r.id
ORDER BY r.created_at DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Join Order and Performance',
                    content: `<pre><code class="language-sql">-- The query planner usually optimizes join order, but you can help

-- Good: Start from most filtered table
SELECT r.*, o.order_number, p.first_name
FROM requests r                            -- Filtered by WHERE
JOIN orders o ON o.request_id = r.id       -- Smaller result
JOIN patients p ON o.patient_id = p.id     -- Final join
WHERE r.status = 'completed'
  AND r.created_at > '2024-01-01';

-- Hint: Use EXPLAIN ANALYZE to see actual join order
EXPLAIN ANALYZE
SELECT r.*, o.order_number, p.first_name
FROM requests r
JOIN orders o ON o.request_id = r.id
JOIN patients p ON o.patient_id = p.id
WHERE r.status = 'completed';</code></pre>
                    <div class="info-box">
                        <h4>Performance Tips</h4>
                        <ul>
                            <li>Ensure join columns are indexed</li>
                            <li>Filter early with WHERE clauses</li>
                            <li>Use EXPLAIN ANALYZE to verify the plan</li>
                            <li>Consider join hints only as last resort</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Mixing Join Types',
                    content: `<div class="try-it-section">
                        <p>Mix INNER and LEFT JOINs based on requirements:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="14">-- INNER JOIN where data must exist
-- LEFT JOIN where data is optional
SELECT
    r.request_number,
    r.status,
    o.order_number,
    p.first_name AS patient,
    cs.slot_date,       -- Optional
    cs.slot_time        -- Optional
FROM requests r
INNER JOIN orders o ON o.request_id = r.id        -- Must have order
INNER JOIN patients p ON o.patient_id = p.id      -- Must have patient
LEFT JOIN collection_slots cs ON cs.request_id = r.id  -- Optional
WHERE r.status IN ('completed', 'processing')
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['Chain multiple JOINs for complex queries', 'Each JOIN adds another table', 'Mix INNER and LEFT based on requirements', 'Format queries for readability', 'Use EXPLAIN ANALYZE to check performance']
        },

        'join-conditions': {
            title: 'Complex Join Conditions',
            category: 'Joins & Relationships',
            difficulty: 'Intermediate',
            prev: 'chained-joins',
            next: 'join-performance',
            sections: [
                {
                    title: 'Beyond Simple Equality',
                    content: `<p>Join conditions can be more complex than simple equality. You can use multiple conditions, ranges, and even functions in your ON clauses.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Multiple conditions:</strong> Use AND/OR in ON clause</li>
                            <li><strong>Non-equality:</strong> Use <, >, <=, >=, <></li>
                            <li><strong>Range joins:</strong> BETWEEN in join conditions</li>
                            <li><strong>Function-based:</strong> Join on computed values</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <ul>
                            <li>Understand basic JOINs: <a onclick="loadLesson('inner-join')">INNER</a>, <a onclick="loadLesson('left-join')">LEFT</a></li>
                            <li>Know <a onclick="loadLesson('explain-analyze')">EXPLAIN ANALYZE</a> for checking performance</li>
                            <li>Consider <a onclick="loadLesson('composite-index')">composite indexes</a> for multi-column joins</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Multiple Join Conditions',
                    content: `<pre><code class="language-sql">-- Join on multiple columns
SELECT r.request_number, o.order_number
FROM requests r
JOIN orders o ON o.request_id = r.id
              AND o.status = r.status;  -- Additional condition

-- Using AND in ON vs WHERE
-- These are different for OUTER joins!
SELECT r.request_number, cs.slot_date
FROM requests r
LEFT JOIN collection_slots cs
       ON cs.request_id = r.id
      AND cs.slot_date > '2024-01-01';  -- Filter BEFORE join

-- vs
SELECT r.request_number, cs.slot_date
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id
WHERE cs.slot_date > '2024-01-01';  -- Filter AFTER join (removes NULLs)</code></pre>
                    <div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>Important: ON vs WHERE with OUTER JOINs</h4>
                        <p>For LEFT/RIGHT/FULL joins, conditions in ON filter before joining (keeps NULLs), while WHERE filters after (removes NULLs).</p>
                    </div>`
                },
                {
                    title: 'Try It: ON vs WHERE',
                    content: `<div class="try-it-section">
                        <p>Compare ON condition vs WHERE condition:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">-- Condition in ON (before join) - keeps unmatched requests
SELECT
    r.request_number,
    r.status,
    cs.slot_date,
    CASE WHEN cs.id IS NULL THEN 'No slot' ELSE 'Has slot' END AS slot_status
FROM requests r
LEFT JOIN collection_slots cs
       ON cs.request_id = r.id
      AND cs.slot_date IS NOT NULL  -- Condition in ON
ORDER BY r.created_at DESC
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Non-Equality Joins',
                    content: `<pre><code class="language-sql">-- Range join: Find orders created after request
SELECT r.request_number, o.order_number, r.created_at, o.created_at
FROM requests r
JOIN orders o ON o.request_id = r.id
             AND o.created_at >= r.created_at;

-- Inequality join: Compare amounts
SELECT
    r1.request_number AS smaller,
    r2.request_number AS larger,
    r1.final_amount,
    r2.final_amount
FROM requests r1
JOIN requests r2 ON r1.final_amount < r2.final_amount
                AND r1.status = r2.status
LIMIT 10;

-- BETWEEN in join
SELECT e.event_date, p.name, p.valid_from, p.valid_to
FROM events e
JOIN price_periods p ON e.event_date BETWEEN p.valid_from AND p.valid_to;</code></pre>
                    <div class="info-box" style="background: #fff3cd; border-color: #ffc107;">
                        <h4>Performance Warning</h4>
                        <p>Non-equality joins can be slow! They may not use indexes efficiently. Use <a onclick="loadLesson('explain-analyze')">EXPLAIN ANALYZE</a> to check.</p>
                    </div>`
                },
                {
                    title: 'Try It: Range Joins',
                    content: `<div class="try-it-section">
                        <p>Find requests with collection slots on the same day or later:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">SELECT
    r.request_number,
    r.created_at::date AS request_date,
    cs.slot_date,
    cs.slot_date - r.created_at::date AS days_until_collection
FROM requests r
JOIN collection_slots cs
  ON cs.request_id = r.id
 AND cs.slot_date >= r.created_at::date
ORDER BY days_until_collection
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Function-Based Join Conditions',
                    content: `<pre><code class="language-sql">-- Join on computed values
SELECT r.request_number, p.first_name
FROM requests r
JOIN patients p ON LOWER(p.email) = LOWER(r.contact_email);

-- Date truncation join
SELECT
    r.request_number,
    r.created_at,
    daily_stats.total_requests
FROM requests r
JOIN (
    SELECT DATE_TRUNC('day', created_at) AS day, COUNT(*) AS total_requests
    FROM requests
    GROUP BY 1
) daily_stats ON DATE_TRUNC('day', r.created_at) = daily_stats.day;

-- Pattern matching join (use with caution - slow!)
SELECT o.order_number, p.first_name
FROM orders o
JOIN patients p ON p.phone LIKE '%' || o.contact_phone || '%';</code></pre>
                    <div class="info-box">
                        <h4>Indexing for Function-Based Joins</h4>
                        <p>Consider expression indexes for frequently used function-based joins:</p>
                        <pre><code class="language-sql">CREATE INDEX idx_patients_lower_email
ON patients (LOWER(email));</code></pre>
                    </div>`
                },
                {
                    title: 'Exercises',
                    content: `<div class="exercise">
                        <h4>Exercise 1: Multi-Condition Join</h4>
                        <p>Find orders where the order status matches the request status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">-- Write your query here
SELECT r.request_number, o.order_number, r.status
FROM requests r
JOIN orders o ON </textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                        <details>
                            <summary>Show Solution</summary>
                            <pre><code class="language-sql">SELECT r.request_number, o.order_number, r.status
FROM requests r
JOIN orders o ON o.request_id = r.id
             AND o.status = r.status
LIMIT 10;</code></pre>
                        </details>
                    </div>`
                }
            ],
            summary: ['Join conditions can use AND/OR, not just equality', 'ON vs WHERE behaves differently for OUTER joins', 'Range joins use <, >, BETWEEN in conditions', 'Function-based joins may need expression indexes', 'Always check performance with EXPLAIN ANALYZE']
        },

        'join-performance': {
            title: 'Join Performance',
            category: 'Joins & Relationships',
            difficulty: 'Advanced',
            prev: 'join-conditions',
            next: 'count-sum',
            sections: [
                {
                    title: 'Understanding Join Algorithms',
                    content: `<p>Database engines use different algorithms to execute joins. Understanding them helps you write efficient queries.</p>
                    <div class="key-points">
                        <h3>Common Join Algorithms:</h3>
                        <ul>
                            <li><strong>Nested Loop:</strong> For each row in A, scan B. O(n*m). Good for small tables or indexed lookups.</li>
                            <li><strong>Hash Join:</strong> Build hash table from smaller table, probe with larger. Good for unsorted data.</li>
                            <li><strong>Merge Join:</strong> Sort both tables, merge. Efficient for pre-sorted or indexed data.</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <ul>
                            <li><a onclick="loadLesson('explain-analyze')">EXPLAIN ANALYZE</a> for reading query plans</li>
                            <li><a onclick="loadLesson('what-is-index')">Index fundamentals</a></li>
                            <li><a onclick="loadLesson('scan-types')">Scan types</a> (Seq Scan vs Index Scan)</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Checking Join Performance',
                    content: `<pre><code class="language-sql">-- Use EXPLAIN ANALYZE to see join algorithms
EXPLAIN ANALYZE
SELECT r.request_number, o.order_number
FROM requests r
JOIN orders o ON o.request_id = r.id
WHERE r.status = 'completed';

-- Look for these in the output:
-- - Nested Loop
-- - Hash Join
-- - Merge Join
-- - Index Scan vs Seq Scan</code></pre>
                    <div class="try-it-section">
                        <p>Analyze a join query:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="6">EXPLAIN ANALYZE
SELECT r.request_number, o.order_number, p.first_name
FROM requests r
JOIN orders o ON o.request_id = r.id
JOIN patients p ON o.patient_id = p.id
LIMIT 100;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Indexing for Joins',
                    content: `<pre><code class="language-sql">-- Foreign keys should be indexed
-- These indexes dramatically improve join performance

-- Index on join columns
CREATE INDEX idx_orders_request_id ON orders(request_id);
CREATE INDEX idx_orders_patient_id ON orders(patient_id);
CREATE INDEX idx_collection_slots_request_id ON collection_slots(request_id);

-- Check if index is being used
EXPLAIN ANALYZE
SELECT r.request_number, o.order_number
FROM requests r
JOIN orders o ON o.request_id = r.id  -- Should use idx_orders_request_id
WHERE r.id = 1;</code></pre>
                    <div class="info-box">
                        <h4>Index Rule of Thumb</h4>
                        <p>Always create indexes on:</p>
                        <ul>
                            <li>Foreign key columns</li>
                            <li>Columns frequently used in JOIN conditions</li>
                            <li>Columns frequently used in WHERE clauses</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Common Performance Issues',
                    content: `<pre><code class="language-sql">-- PROBLEM 1: Missing index on join column
-- Causes full table scan
EXPLAIN ANALYZE SELECT * FROM orders o
JOIN requests r ON r.id = o.request_id;  -- Index on request_id?

-- PROBLEM 2: Function on indexed column
-- Index can't be used!
SELECT * FROM patients p
JOIN orders o ON LOWER(p.email) = o.contact_email;  -- No index!
-- SOLUTION: Create expression index or normalize data

-- PROBLEM 3: Implicit type conversion
SELECT * FROM orders o
JOIN requests r ON r.id = o.request_id::text;  -- Type mismatch!
-- SOLUTION: Ensure matching types

-- PROBLEM 4: Joining on non-selective columns
SELECT * FROM requests r1
JOIN requests r2 ON r1.status = r2.status;  -- Low cardinality
-- Many rows match = slow</code></pre>`
                },
                {
                    title: 'Optimization Techniques',
                    content: `<pre><code class="language-sql">-- TECHNIQUE 1: Filter early
-- Good: Filter before join
SELECT r.request_number, o.order_number
FROM requests r
JOIN orders o ON o.request_id = r.id
WHERE r.status = 'completed'  -- Reduces rows before joining
  AND r.created_at > '2024-01-01';

-- TECHNIQUE 2: Select only needed columns
-- Good: Explicit columns
SELECT r.request_number, o.order_number
FROM requests r
JOIN orders o ON o.request_id = r.id;

-- Bad: SELECT * (fetches unnecessary data)
SELECT *
FROM requests r
JOIN orders o ON o.request_id = r.id;

-- TECHNIQUE 3: Use EXISTS instead of JOIN for existence checks
-- Good for "does related row exist?"
SELECT r.request_number
FROM requests r
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.request_id = r.id
);

-- TECHNIQUE 4: Limit early in subqueries
SELECT r.request_number, o.order_number
FROM (SELECT * FROM requests ORDER BY created_at DESC LIMIT 100) r
JOIN orders o ON o.request_id = r.id;</code></pre>`
                },
                {
                    title: 'Try It: Compare Approaches',
                    content: `<div class="try-it-section">
                        <p>Compare JOIN vs EXISTS performance:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">-- Method 1: JOIN (may return duplicates)
EXPLAIN ANALYZE
SELECT DISTINCT r.request_number
FROM requests r
JOIN orders o ON o.request_id = r.id;

-- Method 2: EXISTS (often faster for existence checks)
-- EXPLAIN ANALYZE
-- SELECT r.request_number
-- FROM requests r
-- WHERE EXISTS (SELECT 1 FROM orders o WHERE o.request_id = r.id);</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['Database uses Nested Loop, Hash Join, or Merge Join', 'Index foreign keys and join columns', 'Avoid functions on indexed columns in joins', 'Filter early to reduce join input', 'Use EXISTS for existence checks instead of JOIN + DISTINCT']
        },

        // ==================== SUBQUERY LESSONS ====================

        'scalar-subquery': {
            title: 'Scalar Subqueries',
            category: 'Subqueries',
            difficulty: 'Intermediate',
            prev: 'null-handling',
            next: 'column-subquery',
            sections: [
                {
                    title: 'What is a Scalar Subquery?',
                    content: `<p>A <strong>scalar subquery</strong> returns exactly one value (one row, one column). It can be used anywhere a single value is expected.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Returns:</strong> Exactly one row and one column</li>
                            <li><strong>Use in:</strong> SELECT, WHERE, HAVING clauses</li>
                            <li><strong>Error:</strong> Fails if returns more than one row</li>
                            <li><strong>NULL:</strong> Returns NULL if no rows match</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Scalar subquery in SELECT
SELECT
    request_number,
    final_amount,
    (SELECT AVG(final_amount) FROM requests) AS avg_amount
FROM requests;

-- Scalar subquery in WHERE
SELECT request_number, final_amount
FROM requests
WHERE final_amount > (SELECT AVG(final_amount) FROM requests);

-- Scalar subquery assigning to variable
SELECT
    request_number,
    final_amount,
    final_amount - (SELECT AVG(final_amount) FROM requests) AS diff_from_avg
FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Compare each request to the average:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">SELECT
    request_number,
    status,
    final_amount,
    ROUND((SELECT AVG(final_amount) FROM requests), 2) AS overall_avg,
    ROUND(final_amount - (SELECT AVG(final_amount) FROM requests), 2) AS diff_from_avg,
    CASE
        WHEN final_amount > (SELECT AVG(final_amount) FROM requests) THEN 'Above Average'
        ELSE 'Below Average'
    END AS comparison
FROM requests
ORDER BY final_amount DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Alternative: Window Functions',
                    content: `<pre><code class="language-sql">-- Scalar subquery (runs once)
SELECT
    request_number,
    final_amount,
    (SELECT AVG(final_amount) FROM requests) AS avg_amount
FROM requests;

-- Equivalent with window function (often more efficient)
SELECT
    request_number,
    final_amount,
    AVG(final_amount) OVER () AS avg_amount
FROM requests;</code></pre>
                    <div class="info-box">
                        <h4>When to Use Each</h4>
                        <ul>
                            <li><strong>Scalar subquery:</strong> Simple one-time calculations</li>
                            <li><strong>Window function:</strong> When you need the calculation for every row</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['Scalar subquery returns one value', 'Can use in SELECT, WHERE, HAVING', 'Fails if multiple rows returned', 'Consider window functions as alternative', 'Returns NULL if no rows match']
        },

        'correlated-subquery': {
            title: 'Correlated Subqueries',
            category: 'Subqueries',
            difficulty: 'Advanced',
            prev: 'table-subquery',
            next: 'exists-not-exists',
            sections: [
                {
                    title: 'What is a Correlated Subquery?',
                    content: `<p>A <strong>correlated subquery</strong> references columns from the outer query. It executes once for each row in the outer query.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>References outer query:</strong> Uses outer table's columns</li>
                            <li><strong>Executes per row:</strong> Runs once for each outer row</li>
                            <li><strong>Performance:</strong> Can be slow for large datasets</li>
                            <li><strong>Use cases:</strong> Row-level comparisons, existence checks</li>
                        </ul>
                    </div>
                    <div class="info-box" style="background: #fff3cd; border-color: #ffc107;">
                        <h4>Performance Consideration</h4>
                        <p>Correlated subqueries run once per outer row. For large tables, consider JOINs or window functions instead.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Correlated subquery: Find requests above their status average
SELECT r.request_number, r.status, r.final_amount
FROM requests r
WHERE r.final_amount > (
    SELECT AVG(r2.final_amount)
    FROM requests r2
    WHERE r2.status = r.status  -- References outer query!
);

-- Compare to non-correlated (runs once)
SELECT r.request_number, r.final_amount
FROM requests r
WHERE r.final_amount > (
    SELECT AVG(final_amount) FROM requests  -- No reference to outer
);</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find requests with amount above their status average:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    r.request_number,
    r.status,
    r.final_amount,
    (SELECT ROUND(AVG(r2.final_amount), 2)
     FROM requests r2
     WHERE r2.status = r.status) AS status_avg
FROM requests r
WHERE r.final_amount > (
    SELECT AVG(r2.final_amount)
    FROM requests r2
    WHERE r2.status = r.status
)
ORDER BY r.status, r.final_amount DESC
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Alternative: Window Functions',
                    content: `<pre><code class="language-sql">-- Correlated subquery (slower)
SELECT r.request_number, r.status, r.final_amount
FROM requests r
WHERE r.final_amount > (
    SELECT AVG(r2.final_amount)
    FROM requests r2
    WHERE r2.status = r.status
);

-- Window function alternative (faster)
SELECT request_number, status, final_amount
FROM (
    SELECT
        request_number,
        status,
        final_amount,
        AVG(final_amount) OVER (PARTITION BY status) AS status_avg
    FROM requests
) sub
WHERE final_amount > status_avg;</code></pre>
                    <div class="try-it-section">
                        <p>Try the window function approach:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">-- More efficient with window function
SELECT request_number, status, final_amount, ROUND(status_avg, 2) AS status_avg
FROM (
    SELECT
        request_number,
        status,
        final_amount,
        AVG(final_amount) OVER (PARTITION BY status) AS status_avg
    FROM requests
) sub
WHERE final_amount > status_avg
ORDER BY status, final_amount DESC
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['Correlated subquery references outer query columns', 'Executes once per outer row (can be slow)', 'Great for row-level comparisons', 'Consider window functions for better performance', 'Often used with EXISTS for existence checks']
        },

        'exists-not-exists': {
            title: 'EXISTS / NOT EXISTS',
            category: 'Subqueries',
            difficulty: 'Intermediate',
            prev: 'correlated-subquery',
            next: 'in-not-in',
            sections: [
                {
                    title: 'What is EXISTS?',
                    content: `<p><code>EXISTS</code> returns TRUE if the subquery returns any rows. It's optimized to stop at the first match.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Boolean result:</strong> Returns TRUE or FALSE</li>
                            <li><strong>Short-circuits:</strong> Stops at first match (efficient)</li>
                            <li><strong>NULL-safe:</strong> Works correctly with NULLs</li>
                            <li><strong>Correlated:</strong> Usually used with correlated subquery</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Find requests that have at least one order
SELECT r.request_number, r.status
FROM requests r
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.request_id = r.id
);

-- Find requests that have NO orders
SELECT r.request_number, r.status
FROM requests r
WHERE NOT EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.request_id = r.id
);</code></pre>
                    <div class="info-box">
                        <h4>SELECT 1 vs SELECT *</h4>
                        <p>The subquery's SELECT list doesn't matter for EXISTS. <code>SELECT 1</code> is convention, but <code>SELECT *</code> works identically.</p>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find requests with orders vs without orders:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">-- Requests WITH orders
SELECT r.request_number, r.status, r.final_amount
FROM requests r
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.request_id = r.id
)
ORDER BY r.created_at DESC
LIMIT 10;

-- Try changing EXISTS to NOT EXISTS to find requests without orders</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'EXISTS vs IN vs JOIN',
                    content: `<pre><code class="language-sql">-- Method 1: EXISTS (often fastest)
SELECT r.request_number
FROM requests r
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.request_id = r.id);

-- Method 2: IN (can be slow with large subquery results)
SELECT r.request_number
FROM requests r
WHERE r.id IN (SELECT request_id FROM orders);

-- Method 3: JOIN (returns duplicates if multiple matches)
SELECT DISTINCT r.request_number
FROM requests r
JOIN orders o ON o.request_id = r.id;</code></pre>
                    <div class="info-box">
                        <h4>When to Use Each</h4>
                        <table>
                            <tr><td><strong>EXISTS</strong></td><td>Best for checking existence, handles NULLs well</td></tr>
                            <tr><td><strong>IN</strong></td><td>Simple syntax, good for small value lists</td></tr>
                            <tr><td><strong>JOIN</strong></td><td>When you need data from both tables</td></tr>
                        </table>
                    </div>`
                },
                {
                    title: 'NOT EXISTS for Anti-Joins',
                    content: `<div class="try-it-section">
                        <p>Find requests without collection slots (anti-join):</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">-- NOT EXISTS anti-join
SELECT r.request_number, r.status, r.final_amount
FROM requests r
WHERE NOT EXISTS (
    SELECT 1
    FROM collection_slots cs
    WHERE cs.request_id = r.id
)
ORDER BY r.created_at DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>
                    <div class="info-box">
                        <h4>Alternative: LEFT JOIN + IS NULL</h4>
                        <pre><code class="language-sql">-- Equivalent anti-join with LEFT JOIN
SELECT r.request_number, r.status
FROM requests r
LEFT JOIN collection_slots cs ON cs.request_id = r.id
WHERE cs.id IS NULL;</code></pre>
                    </div>`
                }
            ],
            summary: ['EXISTS returns TRUE if subquery has any rows', 'NOT EXISTS finds rows without matches (anti-join)', 'EXISTS short-circuits at first match (efficient)', 'Handles NULLs better than IN', 'SELECT list in EXISTS subquery is ignored']
        },

        'in-not-in': {
            title: 'IN / NOT IN',
            category: 'Subqueries',
            difficulty: 'Intermediate',
            prev: 'exists-not-exists',
            next: 'any-all',
            sections: [
                {
                    title: 'What is IN with Subqueries?',
                    content: `<p><code>IN</code> checks if a value matches any value returned by a subquery. <code>NOT IN</code> checks for non-membership.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>IN:</strong> TRUE if value matches any in the list</li>
                            <li><strong>NOT IN:</strong> TRUE if value matches none</li>
                            <li><strong>NULL trap:</strong> NOT IN returns NULL if list contains NULL</li>
                            <li><strong>Performance:</strong> Can be slow with large subquery results</li>
                        </ul>
                    </div>
                    <div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>Warning: NULL Behavior</h4>
                        <p><code>NOT IN</code> with NULLs can return unexpected results! If the subquery returns any NULL, <code>NOT IN</code> returns NULL (unknown), not TRUE.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- IN with subquery
SELECT r.request_number, r.status
FROM requests r
WHERE r.id IN (
    SELECT DISTINCT request_id
    FROM orders
);

-- NOT IN with subquery
SELECT r.request_number, r.status
FROM requests r
WHERE r.id NOT IN (
    SELECT DISTINCT request_id
    FROM orders
    WHERE request_id IS NOT NULL  -- Filter NULLs!
);</code></pre>`
                },
                {
                    title: 'The NULL Trap',
                    content: `<pre><code class="language-sql">-- PROBLEM: NOT IN with NULLs
SELECT 1 WHERE 'a' NOT IN ('b', 'c', NULL);
-- Returns: (empty) - because NULL makes result unknown!

-- SOLUTION 1: Filter NULLs in subquery
SELECT r.request_number
FROM requests r
WHERE r.id NOT IN (
    SELECT request_id FROM orders WHERE request_id IS NOT NULL
);

-- SOLUTION 2: Use NOT EXISTS instead (recommended)
SELECT r.request_number
FROM requests r
WHERE NOT EXISTS (
    SELECT 1 FROM orders o WHERE o.request_id = r.id
);</code></pre>
                    <div class="try-it-section">
                        <p>Demonstrate the NULL issue:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="8">-- This works correctly (no NULLs)
SELECT 'found' AS result
WHERE 'apple' NOT IN ('banana', 'cherry');

-- Uncomment below to see NULL behavior
-- SELECT 'found' AS result
-- WHERE 'apple' NOT IN ('banana', 'cherry', NULL);</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find requests with/without orders using IN:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">-- Requests that have orders (using IN)
SELECT r.request_number, r.status, r.final_amount
FROM requests r
WHERE r.id IN (
    SELECT DISTINCT request_id
    FROM orders
)
ORDER BY r.final_amount DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'IN vs EXISTS Performance',
                    content: `<pre><code class="language-sql">-- IN: Builds complete list, then checks membership
SELECT r.request_number
FROM requests r
WHERE r.id IN (SELECT request_id FROM orders);

-- EXISTS: Stops at first match (can be faster)
SELECT r.request_number
FROM requests r
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.request_id = r.id);</code></pre>
                    <div class="info-box">
                        <h4>Performance Guidelines</h4>
                        <ul>
                            <li><strong>Small subquery result:</strong> IN is fine</li>
                            <li><strong>Large subquery result:</strong> EXISTS may be faster</li>
                            <li><strong>NOT IN:</strong> Prefer NOT EXISTS (avoids NULL issues)</li>
                            <li><strong>Always check:</strong> Use EXPLAIN ANALYZE</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['IN checks if value is in subquery result', 'NOT IN has dangerous NULL behavior', 'Filter NULLs or use NOT EXISTS instead', 'EXISTS often performs better than IN', 'Always test with EXPLAIN ANALYZE']
        },

        // ==================== CTE LESSONS ====================

        'cte-basics': {
            title: 'CTE Basics (WITH Clause)',
            category: 'Common Table Expressions',
            difficulty: 'Intermediate',
            prev: 'any-all',
            next: 'multiple-ctes',
            sections: [
                {
                    title: 'What is a CTE?',
                    content: `<p>A <strong>Common Table Expression (CTE)</strong> is a named temporary result set defined with the <code>WITH</code> clause. It makes complex queries more readable.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Named:</strong> Give meaningful names to subqueries</li>
                            <li><strong>Readable:</strong> Break complex queries into steps</li>
                            <li><strong>Reusable:</strong> Reference multiple times in main query</li>
                            <li><strong>Scope:</strong> Only exists for the query it's defined in</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Basic CTE syntax
WITH cte_name AS (
    SELECT column1, column2
    FROM table_name
    WHERE condition
)
SELECT * FROM cte_name;

-- Example: High-value requests
WITH high_value_requests AS (
    SELECT request_number, status, final_amount
    FROM requests
    WHERE final_amount > 1000
)
SELECT * FROM high_value_requests
ORDER BY final_amount DESC;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Use a CTE to find above-average requests:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">WITH avg_amount AS (
    SELECT AVG(final_amount) AS avg_value
    FROM requests
),
above_average AS (
    SELECT
        r.request_number,
        r.status,
        r.final_amount,
        a.avg_value
    FROM requests r
    CROSS JOIN avg_amount a
    WHERE r.final_amount > a.avg_value
)
SELECT * FROM above_average
ORDER BY final_amount DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'CTE vs Subquery',
                    content: `<pre><code class="language-sql">-- Without CTE (harder to read)
SELECT r.request_number, r.final_amount
FROM requests r
WHERE r.final_amount > (
    SELECT AVG(final_amount) FROM requests
)
AND r.status = (
    SELECT status FROM requests
    GROUP BY status
    ORDER BY COUNT(*) DESC
    LIMIT 1
);

-- With CTEs (clearer intent)
WITH avg_amount AS (
    SELECT AVG(final_amount) AS value FROM requests
),
most_common_status AS (
    SELECT status
    FROM requests
    GROUP BY status
    ORDER BY COUNT(*) DESC
    LIMIT 1
)
SELECT r.request_number, r.final_amount
FROM requests r
CROSS JOIN avg_amount a
CROSS JOIN most_common_status s
WHERE r.final_amount > a.value
  AND r.status = s.status;</code></pre>
                    <div class="info-box">
                        <h4>When to Use CTEs</h4>
                        <ul>
                            <li>Complex queries with multiple subqueries</li>
                            <li>When you need to reference the same subquery multiple times</li>
                            <li>To improve query readability</li>
                            <li>Recursive queries (hierarchical data)</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['CTE = named temporary result set with WITH clause', 'Improves readability of complex queries', 'Can be referenced multiple times', 'Scope is limited to the query', 'Great for breaking down complex logic']
        },

        'multiple-ctes': {
            title: 'Multiple CTEs',
            category: 'Common Table Expressions',
            difficulty: 'Intermediate',
            prev: 'cte-basics',
            next: 'recursive-cte',
            sections: [
                {
                    title: 'Chaining Multiple CTEs',
                    content: `<p>You can define multiple CTEs in a single WITH clause, separated by commas. Later CTEs can reference earlier ones.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Comma-separated:</strong> Multiple CTEs in one WITH</li>
                            <li><strong>Order matters:</strong> Later CTEs can use earlier ones</li>
                            <li><strong>Pipeline:</strong> Build complex logic step by step</li>
                            <li><strong>Readability:</strong> Each step has a meaningful name</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">WITH
    -- First CTE
    first_cte AS (
        SELECT ...
    ),
    -- Second CTE (can reference first_cte)
    second_cte AS (
        SELECT ...
        FROM first_cte
        WHERE ...
    ),
    -- Third CTE (can reference first and second)
    third_cte AS (
        SELECT ...
        FROM second_cte
        JOIN first_cte ON ...
    )
-- Main query uses any/all CTEs
SELECT * FROM third_cte;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Build a multi-step analysis with chained CTEs:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="20">WITH
    -- Step 1: Calculate overall stats
    overall_stats AS (
        SELECT
            COUNT(*) AS total_requests,
            AVG(final_amount) AS avg_amount,
            SUM(final_amount) AS total_revenue
        FROM requests
    ),
    -- Step 2: Calculate per-status stats
    status_stats AS (
        SELECT
            status,
            COUNT(*) AS count,
            AVG(final_amount) AS avg_amount,
            SUM(final_amount) AS revenue
        FROM requests
        GROUP BY status
    ),
    -- Step 3: Combine with overall for comparison
    status_comparison AS (
        SELECT
            ss.*,
            os.total_requests,
            ROUND(100.0 * ss.count / os.total_requests, 2) AS pct_of_total,
            ROUND(100.0 * ss.revenue / os.total_revenue, 2) AS pct_of_revenue
        FROM status_stats ss
        CROSS JOIN overall_stats os
    )
SELECT * FROM status_comparison
ORDER BY revenue DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Practical Example: Funnel Analysis',
                    content: `<pre><code class="language-sql">WITH
    -- Stage 1: All requests
    all_requests AS (
        SELECT COUNT(*) AS count FROM requests
    ),
    -- Stage 2: Requests with orders
    with_orders AS (
        SELECT COUNT(DISTINCT r.id) AS count
        FROM requests r
        JOIN orders o ON o.request_id = r.id
    ),
    -- Stage 3: Completed requests
    completed AS (
        SELECT COUNT(*) AS count
        FROM requests
        WHERE status = 'completed'
    )
SELECT
    'All Requests' AS stage,
    all_requests.count,
    100.0 AS pct
FROM all_requests
UNION ALL
SELECT
    'With Orders',
    with_orders.count,
    ROUND(100.0 * with_orders.count / all_requests.count, 2)
FROM with_orders, all_requests
UNION ALL
SELECT
    'Completed',
    completed.count,
    ROUND(100.0 * completed.count / all_requests.count, 2)
FROM completed, all_requests;</code></pre>`
                }
            ],
            summary: ['Multiple CTEs separated by commas', 'Later CTEs can reference earlier ones', 'Build complex logic step by step', 'Each CTE has a meaningful name', 'Great for data pipelines and analysis']
        },

        'recursive-cte': {
            title: 'Recursive CTEs',
            category: 'Common Table Expressions',
            difficulty: 'Advanced',
            prev: 'multiple-ctes',
            next: 'cte-vs-subquery',
            sections: [
                {
                    title: 'What is a Recursive CTE?',
                    content: `<p>A <strong>recursive CTE</strong> references itself to process hierarchical or tree-structured data. It has two parts: anchor member (starting point) and recursive member (iteration).</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>RECURSIVE keyword:</strong> Required for self-referencing CTEs</li>
                            <li><strong>Anchor member:</strong> Starting rows (base case)</li>
                            <li><strong>Recursive member:</strong> Joined to CTE itself (iteration)</li>
                            <li><strong>UNION ALL:</strong> Combines anchor and recursive results</li>
                            <li><strong>Use cases:</strong> Hierarchies, trees, graphs, sequences</li>
                        </ul>
                    </div>
                    <div class="info-box" style="background: #fff3cd; border-color: #ffc107;">
                        <h4>Warning: Infinite Loops</h4>
                        <p>Recursive CTEs can run forever if not properly terminated. Always ensure the recursive member eventually returns no rows.</p>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">WITH RECURSIVE cte_name AS (
    -- Anchor member (base case)
    SELECT initial_columns
    FROM table
    WHERE starting_condition

    UNION ALL

    -- Recursive member (references cte_name)
    SELECT next_columns
    FROM table
    JOIN cte_name ON recursive_condition
)
SELECT * FROM cte_name;</code></pre>`
                },
                {
                    title: 'Example: Generate Number Sequence',
                    content: `<div class="try-it-section">
                        <p>Generate numbers 1 to 10:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">WITH RECURSIVE numbers AS (
    -- Anchor: start with 1
    SELECT 1 AS n

    UNION ALL

    -- Recursive: add 1 until we reach 10
    SELECT n + 1
    FROM numbers
    WHERE n < 10  -- Stop condition!
)
SELECT n FROM numbers;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Example: Date Range',
                    content: `<div class="try-it-section">
                        <p>Generate a date range:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">WITH RECURSIVE date_range AS (
    -- Anchor: start date
    SELECT DATE '2024-01-01' AS date

    UNION ALL

    -- Recursive: add one day
    SELECT date + INTERVAL '1 day'
    FROM date_range
    WHERE date < DATE '2024-01-07'
)
SELECT
    date,
    TO_CHAR(date, 'Day') AS day_name
FROM date_range;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Example: Employee Hierarchy',
                    content: `<pre><code class="language-sql">-- Assume: employees(id, name, manager_id)
WITH RECURSIVE org_chart AS (
    -- Anchor: Top-level managers (no manager)
    SELECT
        id,
        name,
        manager_id,
        1 AS level,
        name AS path
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive: Find direct reports
    SELECT
        e.id,
        e.name,
        e.manager_id,
        oc.level + 1,
        oc.path || ' > ' || e.name
    FROM employees e
    JOIN org_chart oc ON e.manager_id = oc.id
)
SELECT * FROM org_chart
ORDER BY path;</code></pre>
                    <div class="info-box">
                        <h4>Common Hierarchy Patterns</h4>
                        <ul>
                            <li>Organization charts (employee → manager)</li>
                            <li>Category trees (subcategory → parent)</li>
                            <li>Comment threads (reply → parent comment)</li>
                            <li>Bill of materials (component → assembly)</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['Use WITH RECURSIVE for self-referencing CTEs', 'Anchor member provides starting rows', 'Recursive member iterates until no new rows', 'Always include a termination condition', 'Perfect for hierarchical/tree data']
        },

        // ==================== INDEXING LESSONS ====================

        'what-is-index': {
            title: 'What is an Index?',
            category: 'Indexing & Performance',
            difficulty: 'Intermediate',
            prev: 'json-operations',
            next: 'btree-index',
            sections: [
                {
                    title: 'Understanding Database Indexes',
                    content: `<p>An <strong>index</strong> is a data structure that improves the speed of data retrieval operations. Think of it like a book's index - instead of reading every page, you can jump directly to the relevant page.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Speeds up reads:</strong> Find data without scanning entire table</li>
                            <li><strong>Slows down writes:</strong> Index must be updated on INSERT/UPDATE</li>
                            <li><strong>Uses storage:</strong> Indexes take disk space</li>
                            <li><strong>Trade-off:</strong> Read speed vs write speed vs storage</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Without Index vs With Index',
                    content: `<div class="info-box">
                        <h4>Without Index: Sequential Scan</h4>
                        <pre>
Table: 1,000,000 rows
Query: WHERE email = 'john@example.com'

Database must check EVERY row: O(n)
Time: ~1000ms for large tables
                        </pre>
                    </div>
                    <div class="info-box" style="background: #d4edda; border-color: #28a745;">
                        <h4>With Index: Index Scan</h4>
                        <pre>
Table: 1,000,000 rows + email index
Query: WHERE email = 'john@example.com'

Database uses index to find row: O(log n)
Time: ~1ms even for large tables
                        </pre>
                    </div>`
                },
                {
                    title: 'Try It: See the Difference',
                    content: `<div class="try-it-section">
                        <p>Compare query plans with EXPLAIN:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="6">-- Check if query uses an index
EXPLAIN ANALYZE
SELECT * FROM requests
WHERE id = 1;
-- Look for "Index Scan" vs "Seq Scan"</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'When to Create Indexes',
                    content: `<pre><code class="language-sql">-- CREATE INDEX: Primary keys are indexed automatically
-- Foreign keys should ALWAYS be indexed

-- Good candidates for indexing:
-- 1. Foreign key columns
CREATE INDEX idx_orders_request_id ON orders(request_id);

-- 2. Columns in WHERE clauses
CREATE INDEX idx_requests_status ON requests(status);

-- 3. Columns in JOIN conditions
CREATE INDEX idx_orders_patient_id ON orders(patient_id);

-- 4. Columns in ORDER BY (for sorted queries)
CREATE INDEX idx_requests_created_at ON requests(created_at DESC);</code></pre>
                    <div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>When NOT to Create Indexes</h4>
                        <ul>
                            <li>Small tables (< 1000 rows) - full scan is fast</li>
                            <li>Columns with low cardinality (few unique values)</li>
                            <li>Tables with heavy write loads</li>
                            <li>Columns rarely used in queries</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Index Types Overview',
                    content: `<div class="comparison-table">
                        <table>
                            <thead><tr><th>Type</th><th>Best For</th><th>Example</th></tr></thead>
                            <tbody>
                                <tr><td><strong>B-Tree</strong></td><td>Most queries, ranges, sorting</td><td>=, <, >, BETWEEN, ORDER BY</td></tr>
                                <tr><td><strong>Hash</strong></td><td>Equality only</td><td>= comparisons</td></tr>
                                <tr><td><strong>GIN</strong></td><td>Arrays, full-text, JSONB</td><td>@>, &&, to_tsvector</td></tr>
                                <tr><td><strong>GiST</strong></td><td>Geometric, range types</td><td>Spatial queries, range overlap</td></tr>
                            </tbody>
                        </table>
                    </div>`
                }
            ],
            summary: ['Indexes speed up data retrieval (reads)', 'Trade-off: faster reads, slower writes', 'Always index foreign keys', 'Index columns used in WHERE, JOIN, ORDER BY', 'Use EXPLAIN ANALYZE to verify index usage']
        },

        'btree-index': {
            title: 'B-Tree Index',
            category: 'Indexing & Performance',
            difficulty: 'Intermediate',
            prev: 'what-is-index',
            next: 'hash-index',
            sections: [
                {
                    title: 'What is a B-Tree Index?',
                    content: `<p><strong>B-Tree</strong> (Balanced Tree) is the default and most common index type. It keeps data sorted and allows efficient searches, range queries, and ordering.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Default type:</strong> Used when you don't specify a type</li>
                            <li><strong>Sorted:</strong> Maintains order of indexed values</li>
                            <li><strong>Versatile:</strong> Supports =, <, >, <=, >=, BETWEEN</li>
                            <li><strong>O(log n):</strong> Efficient for large tables</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'B-Tree Structure',
                    content: `<div class="info-box">
                        <h4>How B-Tree Works</h4>
                        <pre>
              [50]                    ← Root node
             /    \\
       [25]        [75]              ← Branch nodes
       /  \\        /  \\
   [10,20] [30,40] [60,70] [80,90]   ← Leaf nodes (point to data)

Finding value 70:
1. Start at root [50] → 70 > 50 → go right
2. At [75] → 70 < 75 → go left
3. At [60,70] → found!
Total: 3 comparisons (not 90 as in full scan)
                        </pre>
                    </div>`
                },
                {
                    title: 'Creating B-Tree Indexes',
                    content: `<pre><code class="language-sql">-- Default: B-Tree (no need to specify)
CREATE INDEX idx_requests_status ON requests(status);

-- Explicit B-Tree
CREATE INDEX idx_requests_amount ON requests USING BTREE(final_amount);

-- Descending order (for ORDER BY DESC)
CREATE INDEX idx_requests_created_desc ON requests(created_at DESC);

-- Multiple columns (composite index)
CREATE INDEX idx_requests_status_amount ON requests(status, final_amount);</code></pre>`
                },
                {
                    title: 'B-Tree Supported Operations',
                    content: `<pre><code class="language-sql">-- All these queries can use a B-Tree index on final_amount:

-- Equality
SELECT * FROM requests WHERE final_amount = 1000;

-- Less than / Greater than
SELECT * FROM requests WHERE final_amount < 1000;
SELECT * FROM requests WHERE final_amount > 1000;

-- Range (BETWEEN)
SELECT * FROM requests WHERE final_amount BETWEEN 500 AND 1500;

-- Sorting (ORDER BY)
SELECT * FROM requests ORDER BY final_amount;

-- Pattern matching (prefix only!)
SELECT * FROM requests WHERE request_number LIKE 'REQ%';
-- Note: 'REQ%' uses index, but '%REQ' does NOT</code></pre>
                    <div class="try-it-section">
                        <p>Test B-Tree index usage:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="5">EXPLAIN ANALYZE
SELECT * FROM requests
WHERE final_amount BETWEEN 1000 AND 2000
ORDER BY final_amount;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['B-Tree is the default index type', 'Supports =, <, >, <=, >=, BETWEEN, ORDER BY', 'Maintains sorted order', 'O(log n) lookups', 'Best general-purpose index']
        },

        'composite-index': {
            title: 'Composite Index',
            category: 'Indexing & Performance',
            difficulty: 'Intermediate',
            prev: 'single-column',
            next: 'partial-index',
            sections: [
                {
                    title: 'What is a Composite Index?',
                    content: `<p>A <strong>composite index</strong> (multi-column index) indexes multiple columns together. Column order matters for query optimization.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Multiple columns:</strong> Index on 2+ columns</li>
                            <li><strong>Order matters:</strong> Leftmost columns used first</li>
                            <li><strong>Prefix rule:</strong> Can use left prefix of index</li>
                            <li><strong>Selective first:</strong> Put most selective column first</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'The Leftmost Prefix Rule',
                    content: `<pre><code class="language-sql">-- Create composite index
CREATE INDEX idx_requests_status_date_amount
ON requests(status, created_at, final_amount);

-- This index can be used for:
-- ✓ WHERE status = 'completed'
-- ✓ WHERE status = 'completed' AND created_at > '2024-01-01'
-- ✓ WHERE status = 'completed' AND created_at > '2024-01-01' AND final_amount > 1000

-- This index CANNOT be efficiently used for:
-- ✗ WHERE created_at > '2024-01-01' (skips status)
-- ✗ WHERE final_amount > 1000 (skips status and created_at)
-- ✗ WHERE status = 'completed' AND final_amount > 1000 (skips created_at)</code></pre>
                    <div class="info-box">
                        <h4>Think of it Like a Phone Book</h4>
                        <p>A phone book is indexed by (LastName, FirstName). You can efficiently find all "Smith" or "Smith, John" but NOT all people named "John".</p>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Test composite index usage:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="8">-- Test which queries use the index
EXPLAIN ANALYZE
SELECT * FROM requests
WHERE status = 'completed'
  AND created_at > '2024-01-01'
ORDER BY created_at
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Choosing Column Order',
                    content: `<pre><code class="language-sql">-- Bad: Low selectivity first
CREATE INDEX idx_bad ON requests(status, id);
-- status has few distinct values (low selectivity)
-- Many rows match status = 'completed'

-- Good: High selectivity first (for equality)
CREATE INDEX idx_good ON requests(id, status);
-- id is unique (high selectivity)
-- Few rows match id = 123

-- For range queries: equality columns first, then range
CREATE INDEX idx_range ON requests(status, created_at);
-- WHERE status = 'x' AND created_at > '2024-01-01'
-- Equality (status) before range (created_at)</code></pre>
                    <div class="info-box">
                        <h4>Column Order Guidelines</h4>
                        <ol>
                            <li>Columns used with = before columns with ranges (<, >, BETWEEN)</li>
                            <li>More selective columns before less selective (for equality)</li>
                            <li>Columns in ORDER BY should match index order</li>
                        </ol>
                    </div>`
                }
            ],
            summary: ['Composite index covers multiple columns', 'Leftmost prefix rule determines usability', 'Column order is critical', 'Equality columns before range columns', 'Consider your most common query patterns']
        },

        'scan-types': {
            title: 'Scan Types',
            category: 'Indexing & Performance',
            difficulty: 'Advanced',
            prev: 'explain-analyze',
            next: 'index-selection',
            sections: [
                {
                    title: 'Understanding Scan Types',
                    content: `<p>When executing a query, PostgreSQL chooses how to access table data. Understanding scan types helps you optimize queries.</p>
                    <div class="key-points">
                        <h3>Common Scan Types:</h3>
                        <ul>
                            <li><strong>Seq Scan:</strong> Full table scan, reads every row</li>
                            <li><strong>Index Scan:</strong> Uses index, then fetches rows from table</li>
                            <li><strong>Index Only Scan:</strong> Uses index only, no table access</li>
                            <li><strong>Bitmap Scan:</strong> Combines multiple index results</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Sequential Scan (Seq Scan)',
                    content: `<pre><code class="language-sql">-- Seq Scan: Reads entire table
-- Used when:
-- - No suitable index exists
-- - Query returns large portion of table
-- - Table is very small

EXPLAIN ANALYZE
SELECT * FROM requests;  -- Always Seq Scan (selecting all)

EXPLAIN ANALYZE
SELECT * FROM requests WHERE status = 'completed';
-- May use Seq Scan if 'completed' is very common</code></pre>
                    <div class="info-box">
                        <h4>Seq Scan is Not Always Bad</h4>
                        <p>For queries returning >10-20% of the table, Seq Scan is often faster than Index Scan because of sequential disk reads.</p>
                    </div>`
                },
                {
                    title: 'Try It: Compare Scan Types',
                    content: `<div class="try-it-section">
                        <p>Compare different scan types:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="8">-- This will likely use Index Scan (specific row)
EXPLAIN ANALYZE
SELECT * FROM requests WHERE id = 1;

-- Uncomment to compare with broader query
-- EXPLAIN ANALYZE
-- SELECT * FROM requests WHERE status = 'completed';</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Index Scan vs Index Only Scan',
                    content: `<pre><code class="language-sql">-- Index Scan: Uses index, then visits table for other columns
EXPLAIN ANALYZE
SELECT * FROM requests WHERE id = 1;

-- Index Only Scan: All needed columns are in the index
-- Much faster - no table visit needed!
EXPLAIN ANALYZE
SELECT id FROM requests WHERE id = 1;

-- Covering index for Index Only Scan
CREATE INDEX idx_covering ON requests(status) INCLUDE (request_number, final_amount);

EXPLAIN ANALYZE
SELECT status, request_number, final_amount
FROM requests
WHERE status = 'completed';</code></pre>
                    <div class="info-box" style="background: #d4edda; border-color: #28a745;">
                        <h4>Index Only Scan</h4>
                        <p>Fastest scan type! Create covering indexes that include all columns needed by frequent queries.</p>
                    </div>`
                },
                {
                    title: 'Scan Type Summary',
                    content: `<div class="comparison-table">
                        <table>
                            <thead><tr><th>Scan Type</th><th>Speed</th><th>When Used</th></tr></thead>
                            <tbody>
                                <tr><td><strong>Index Only Scan</strong></td><td>Fastest</td><td>All columns in index (covering index)</td></tr>
                                <tr><td><strong>Index Scan</strong></td><td>Fast</td><td>Small result set, index exists</td></tr>
                                <tr><td><strong>Bitmap Index Scan</strong></td><td>Medium</td><td>Multiple conditions, medium result set</td></tr>
                                <tr><td><strong>Seq Scan</strong></td><td>Slowest*</td><td>No index, large result set</td></tr>
                            </tbody>
                        </table>
                        <p><small>*For small tables or large result sets, Seq Scan can be faster</small></p>
                    </div>`
                }
            ],
            summary: ['Seq Scan reads entire table', 'Index Scan uses index + table visit', 'Index Only Scan is fastest (no table visit)', 'Bitmap Scan combines multiple indexes', 'Use EXPLAIN ANALYZE to see actual scan type']
        },

        'optimization-tips': {
            title: 'Optimization Tips',
            category: 'Indexing & Performance',
            difficulty: 'Advanced',
            prev: 'index-selection',
            next: 'views',
            sections: [
                {
                    title: 'Query Optimization Checklist',
                    content: `<div class="key-points">
                        <h3>Before You Write the Query:</h3>
                        <ul>
                            <li>Select only columns you need (not SELECT *)</li>
                            <li>Know your data volumes and patterns</li>
                            <li>Understand available indexes</li>
                        </ul>
                        <h3>While Writing:</h3>
                        <ul>
                            <li>Filter as early as possible (WHERE before JOIN)</li>
                            <li>Avoid functions on indexed columns</li>
                            <li>Use appropriate join types</li>
                        </ul>
                        <h3>After Writing:</h3>
                        <ul>
                            <li>Run EXPLAIN ANALYZE</li>
                            <li>Check for Seq Scans on large tables</li>
                            <li>Verify estimated vs actual rows</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Avoid Functions on Indexed Columns',
                    content: `<pre><code class="language-sql">-- BAD: Function prevents index usage
SELECT * FROM requests
WHERE LOWER(request_number) = 'req001';

-- GOOD: Index can be used
SELECT * FROM requests
WHERE request_number = 'REQ001';

-- Alternative: Create expression index
CREATE INDEX idx_lower_request ON requests(LOWER(request_number));

-- BAD: Date function prevents index
SELECT * FROM requests
WHERE DATE(created_at) = '2024-01-15';

-- GOOD: Range preserves index usage
SELECT * FROM requests
WHERE created_at >= '2024-01-15'
  AND created_at < '2024-01-16';</code></pre>`
                },
                {
                    title: 'Filter Early',
                    content: `<pre><code class="language-sql">-- BAD: Filtering after join
SELECT r.*, o.*
FROM requests r
JOIN orders o ON o.request_id = r.id
WHERE r.status = 'completed';  -- Filter after joining all rows

-- GOOD: Filter in subquery/CTE
WITH completed_requests AS (
    SELECT * FROM requests
    WHERE status = 'completed'  -- Filter first, fewer rows to join
)
SELECT cr.*, o.*
FROM completed_requests cr
JOIN orders o ON o.request_id = cr.id;

-- GOOD: Let optimizer handle it (same plan usually)
SELECT r.*, o.*
FROM requests r
JOIN orders o ON o.request_id = r.id
WHERE r.status = 'completed';
-- Most modern optimizers will filter before joining</code></pre>`
                },
                {
                    title: 'Try It: Optimization in Action',
                    content: `<div class="try-it-section">
                        <p>Compare query approaches:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">-- Check the execution plan
EXPLAIN ANALYZE
SELECT
    r.request_number,
    r.status,
    r.final_amount,
    COUNT(o.id) AS order_count
FROM requests r
LEFT JOIN orders o ON o.request_id = r.id
WHERE r.status = 'completed'
  AND r.final_amount > 1000
GROUP BY r.id
ORDER BY r.final_amount DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Common Anti-Patterns',
                    content: `<pre><code class="language-sql">-- ANTI-PATTERN 1: SELECT * (fetches unnecessary data)
SELECT * FROM requests;  -- BAD
SELECT id, status, final_amount FROM requests;  -- GOOD

-- ANTI-PATTERN 2: OR on different columns
SELECT * FROM requests
WHERE status = 'completed' OR final_amount > 1000;  -- Hard to optimize
-- Consider: UNION of two indexed queries

-- ANTI-PATTERN 3: NOT IN with NULLs
SELECT * FROM requests
WHERE id NOT IN (SELECT request_id FROM orders);  -- NULL trap!
-- Use: NOT EXISTS instead

-- ANTI-PATTERN 4: DISTINCT without need
SELECT DISTINCT status FROM requests;  -- OK
SELECT DISTINCT r.* FROM requests r
JOIN orders o ON ...;  -- Often indicates wrong join

-- ANTI-PATTERN 5: COUNT(*) for existence check
IF (SELECT COUNT(*) FROM orders WHERE ...) > 0  -- Counts all
IF EXISTS (SELECT 1 FROM orders WHERE ...)  -- Stops at first</code></pre>`
                },
                {
                    title: 'Monitoring Query Performance',
                    content: `<pre><code class="language-sql">-- Find slow queries in PostgreSQL
SELECT
    query,
    calls,
    mean_exec_time,
    total_exec_time
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;

-- Check table statistics
SELECT
    relname,
    seq_scan,
    idx_scan,
    n_live_tup
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;

-- Find missing indexes (high seq_scan, no idx_scan)
SELECT
    schemaname || '.' || relname AS table,
    seq_scan,
    idx_scan,
    CASE WHEN idx_scan = 0 THEN 'NEEDS INDEX?' ELSE 'OK' END AS status
FROM pg_stat_user_tables
WHERE seq_scan > 1000 AND idx_scan = 0;</code></pre>`
                }
            ],
            summary: ['Select only needed columns', 'Avoid functions on indexed columns', 'Filter early in the query', 'Use EXPLAIN ANALYZE to verify plans', 'Monitor slow queries with pg_stat_statements']
        },

        // ==================== WINDOW FUNCTION LESSONS ====================

        'over-clause': {
            title: 'OVER Clause',
            category: 'Window Functions',
            difficulty: 'Intermediate',
            prev: 'having-clause',
            next: 'partition-by',
            sections: [
                {
                    title: 'What is the OVER Clause?',
                    content: `<p>The <code>OVER</code> clause defines a window (set of rows) for window functions to operate on. Unlike GROUP BY, it doesn't collapse rows - each row keeps its identity.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Window:</strong> A set of rows related to the current row</li>
                            <li><strong>No collapse:</strong> Unlike GROUP BY, keeps all rows</li>
                            <li><strong>Access:</strong> Calculate based on other rows while keeping current row</li>
                            <li><strong>Components:</strong> PARTITION BY, ORDER BY, frame clause</li>
                        </ul>
                    </div>
                    <div class="info-box">
                        <h4>Prerequisites</h4>
                        <p>Understand <a onclick="loadLesson('group-by-basics')">GROUP BY</a> and aggregate functions (<a onclick="loadLesson('count-sum')">COUNT, SUM</a>) before learning window functions.</p>
                    </div>`
                },
                {
                    title: 'GROUP BY vs OVER',
                    content: `<pre><code class="language-sql">-- GROUP BY: Collapses rows into groups
SELECT status, COUNT(*), SUM(final_amount)
FROM requests
GROUP BY status;
-- Returns: One row per status

-- OVER: Calculates across rows WITHOUT collapsing
SELECT
    request_number,
    status,
    final_amount,
    COUNT(*) OVER () AS total_count,
    SUM(final_amount) OVER () AS total_amount
FROM requests;
-- Returns: All rows, each with the totals</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Compare each request to overall totals:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    request_number,
    status,
    final_amount,
    -- Window functions with OVER
    COUNT(*) OVER () AS total_requests,
    SUM(final_amount) OVER () AS total_revenue,
    ROUND(AVG(final_amount) OVER (), 2) AS avg_amount,
    -- Percentage of total
    ROUND(100.0 * final_amount / SUM(final_amount) OVER (), 2) AS pct_of_total
FROM requests
ORDER BY final_amount DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Basic OVER Syntax',
                    content: `<pre><code class="language-sql">-- Empty OVER(): Entire result set is the window
SELECT
    request_number,
    final_amount,
    SUM(final_amount) OVER () AS grand_total
FROM requests;

-- OVER with PARTITION BY: Window per group
SELECT
    request_number,
    status,
    final_amount,
    SUM(final_amount) OVER (PARTITION BY status) AS status_total
FROM requests;

-- OVER with ORDER BY: Running calculations
SELECT
    request_number,
    final_amount,
    SUM(final_amount) OVER (ORDER BY created_at) AS running_total
FROM requests;</code></pre>`
                }
            ],
            summary: ['OVER defines a window of rows for calculation', 'Unlike GROUP BY, does not collapse rows', 'Empty OVER() = entire result set', 'PARTITION BY = window per group', 'ORDER BY = running calculations within window']
        },

        'partition-by': {
            title: 'PARTITION BY',
            category: 'Window Functions',
            difficulty: 'Intermediate',
            prev: 'over-clause',
            next: 'order-by-window',
            sections: [
                {
                    title: 'What is PARTITION BY?',
                    content: `<p><code>PARTITION BY</code> divides the result set into partitions (groups). Window functions are applied separately to each partition.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Groups rows:</strong> Like GROUP BY but keeps all rows</li>
                            <li><strong>Separate windows:</strong> Each partition is an independent window</li>
                            <li><strong>Resets:</strong> Calculations restart for each partition</li>
                            <li><strong>Multiple columns:</strong> Can partition by multiple columns</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'PARTITION BY Examples',
                    content: `<pre><code class="language-sql">-- Calculate totals per status
SELECT
    request_number,
    status,
    final_amount,
    SUM(final_amount) OVER (PARTITION BY status) AS status_total,
    COUNT(*) OVER (PARTITION BY status) AS status_count
FROM requests;

-- Compare to status average
SELECT
    request_number,
    status,
    final_amount,
    AVG(final_amount) OVER (PARTITION BY status) AS status_avg,
    final_amount - AVG(final_amount) OVER (PARTITION BY status) AS diff_from_avg
FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Calculate stats within each status group:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="14">SELECT
    request_number,
    status,
    final_amount,
    -- Per-status calculations
    COUNT(*) OVER (PARTITION BY status) AS count_in_status,
    SUM(final_amount) OVER (PARTITION BY status) AS status_total,
    ROUND(AVG(final_amount) OVER (PARTITION BY status), 2) AS status_avg,
    MIN(final_amount) OVER (PARTITION BY status) AS status_min,
    MAX(final_amount) OVER (PARTITION BY status) AS status_max,
    -- Percentage within status
    ROUND(100.0 * final_amount / SUM(final_amount) OVER (PARTITION BY status), 2) AS pct_of_status
FROM requests
ORDER BY status, final_amount DESC
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Multiple Partition Columns',
                    content: `<pre><code class="language-sql">-- Partition by multiple columns
SELECT
    DATE_TRUNC('month', created_at) AS month,
    status,
    request_number,
    final_amount,
    SUM(final_amount) OVER (
        PARTITION BY DATE_TRUNC('month', created_at), status
    ) AS monthly_status_total
FROM requests
ORDER BY month, status;</code></pre>
                    <div class="info-box">
                        <h4>When to Use PARTITION BY</h4>
                        <ul>
                            <li>Calculate metrics within groups (per category, per date, etc.)</li>
                            <li>Rank items within groups</li>
                            <li>Compare rows to their group's aggregate</li>
                            <li>Running totals that reset per group</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['PARTITION BY divides rows into groups', 'Window functions calculated per partition', 'Like GROUP BY but keeps all rows', 'Calculations reset for each partition', 'Can partition by multiple columns']
        },

        'order-by-window': {
            title: 'ORDER BY in Windows',
            category: 'Window Functions',
            difficulty: 'Intermediate',
            prev: 'partition-by',
            next: 'frame-clause',
            sections: [
                {
                    title: 'ORDER BY in OVER Clause',
                    content: `<p><code>ORDER BY</code> inside <code>OVER</code> determines the order of rows within the window, enabling running/cumulative calculations.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>Row order:</strong> Determines processing order within window</li>
                            <li><strong>Running calculations:</strong> Enables cumulative sums, counts, etc.</li>
                            <li><strong>Ranking:</strong> Required for ROW_NUMBER, RANK, etc.</li>
                            <li><strong>Default frame:</strong> Changes default from all rows to "up to current"</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Running Calculations',
                    content: `<pre><code class="language-sql">-- Without ORDER BY: Same value for all rows
SELECT
    request_number,
    final_amount,
    SUM(final_amount) OVER () AS total  -- Same for all rows
FROM requests;

-- With ORDER BY: Running total
SELECT
    request_number,
    created_at,
    final_amount,
    SUM(final_amount) OVER (ORDER BY created_at) AS running_total
FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Calculate running totals:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    request_number,
    created_at,
    final_amount,
    -- Running calculations
    SUM(final_amount) OVER (ORDER BY created_at) AS running_total,
    COUNT(*) OVER (ORDER BY created_at) AS running_count,
    ROUND(AVG(final_amount) OVER (ORDER BY created_at), 2) AS running_avg
FROM requests
ORDER BY created_at
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Combined: PARTITION BY + ORDER BY',
                    content: `<div class="try-it-section">
                        <p>Running totals per status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    request_number,
    status,
    created_at,
    final_amount,
    -- Running total resets for each status
    SUM(final_amount) OVER (
        PARTITION BY status
        ORDER BY created_at
    ) AS running_status_total,
    ROW_NUMBER() OVER (
        PARTITION BY status
        ORDER BY created_at
    ) AS row_in_status
FROM requests
ORDER BY status, created_at
LIMIT 20;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                }
            ],
            summary: ['ORDER BY in OVER determines row processing order', 'Enables running/cumulative calculations', 'Required for ranking functions', 'Combined with PARTITION BY for grouped running totals', 'Changes default frame to rows up to current']
        },

        'frame-clause': {
            title: 'Frame Clause',
            category: 'Window Functions',
            difficulty: 'Advanced',
            prev: 'order-by-window',
            next: 'row-number',
            sections: [
                {
                    title: 'What is a Frame Clause?',
                    content: `<p>The <strong>frame clause</strong> defines exactly which rows relative to the current row are included in the window calculation.</p>
                    <div class="key-points">
                        <h3>Frame Syntax:</h3>
                        <ul>
                            <li><code>ROWS BETWEEN start AND end</code> - Count by row position</li>
                            <li><code>RANGE BETWEEN start AND end</code> - Count by value range</li>
                        </ul>
                        <h3>Frame Boundaries:</h3>
                        <ul>
                            <li><code>UNBOUNDED PRECEDING</code> - First row of partition</li>
                            <li><code>n PRECEDING</code> - n rows before current</li>
                            <li><code>CURRENT ROW</code> - Current row</li>
                            <li><code>n FOLLOWING</code> - n rows after current</li>
                            <li><code>UNBOUNDED FOLLOWING</code> - Last row of partition</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Common Frame Patterns',
                    content: `<pre><code class="language-sql">-- Running total (default with ORDER BY)
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- Moving average (3 rows)
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING

-- All rows in partition
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING

-- Previous row only
ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING

-- Current and all following
ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code></pre>`
                },
                {
                    title: 'Try It: Moving Average',
                    content: `<div class="try-it-section">
                        <p>Calculate 3-row moving average:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="14">SELECT
    request_number,
    created_at,
    final_amount,
    -- 3-row moving average (prev, current, next)
    ROUND(AVG(final_amount) OVER (
        ORDER BY created_at
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ), 2) AS moving_avg_3,
    -- 5-row moving average
    ROUND(AVG(final_amount) OVER (
        ORDER BY created_at
        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
    ), 2) AS moving_avg_5
FROM requests
ORDER BY created_at
LIMIT 15;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'ROWS vs RANGE',
                    content: `<pre><code class="language-sql">-- ROWS: Counts physical rows
-- If you have: 100, 100, 100, 200
-- ROWS 1 PRECEDING counts exactly 1 row

-- RANGE: Groups by value
-- If you have: 100, 100, 100, 200
-- RANGE 0 PRECEDING includes all rows with same value

-- Example difference:
SELECT
    created_at::date AS date,
    final_amount,
    -- ROWS: exactly 2 preceding rows
    SUM(final_amount) OVER (
        ORDER BY created_at::date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS sum_rows,
    -- RANGE: all rows with date in range
    SUM(final_amount) OVER (
        ORDER BY created_at::date
        RANGE BETWEEN INTERVAL '2 days' PRECEDING AND CURRENT ROW
    ) AS sum_range
FROM requests;</code></pre>
                    <div class="info-box">
                        <h4>When to Use Each</h4>
                        <ul>
                            <li><strong>ROWS:</strong> Fixed number of rows (3-day moving average by row count)</li>
                            <li><strong>RANGE:</strong> Value-based window (all orders within $100 of current)</li>
                        </ul>
                    </div>`
                }
            ],
            summary: ['Frame clause defines which rows are in the window', 'ROWS counts physical rows', 'RANGE groups by value', 'Use PRECEDING/FOLLOWING for relative positions', 'UNBOUNDED means start/end of partition']
        },

        'rank-dense-rank': {
            title: 'RANK & DENSE_RANK',
            category: 'Window Functions',
            difficulty: 'Advanced',
            prev: 'row-number',
            next: 'ntile',
            sections: [
                {
                    title: 'RANK vs DENSE_RANK vs ROW_NUMBER',
                    content: `<p>These ranking functions assign numbers to rows but handle ties differently.</p>
                    <div class="key-points">
                        <h3>Key Differences:</h3>
                        <ul>
                            <li><strong>ROW_NUMBER:</strong> Unique numbers, no gaps (1,2,3,4,5)</li>
                            <li><strong>RANK:</strong> Same rank for ties, then gaps (1,1,3,4,4,6)</li>
                            <li><strong>DENSE_RANK:</strong> Same rank for ties, no gaps (1,1,2,3,3,4)</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Visual Comparison',
                    content: `<div class="info-box">
                        <h4>Ranking 5 Students by Score</h4>
                        <pre>
Score   ROW_NUMBER   RANK   DENSE_RANK
-----   ----------   ----   ----------
100     1            1      1
100     2            1      1    ← Tie: same score
95      3            3      2    ← RANK skips, DENSE_RANK doesn't
90      4            4      3
90      5            4      3    ← Another tie
                        </pre>
                    </div>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Compare all three ranking functions:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="14">SELECT
    request_number,
    status,
    final_amount,
    ROW_NUMBER() OVER (ORDER BY final_amount DESC) AS row_num,
    RANK() OVER (ORDER BY final_amount DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY final_amount DESC) AS dense_rank
FROM requests
ORDER BY final_amount DESC
LIMIT 15;

-- Notice how ties are handled differently!</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Ranking Within Groups',
                    content: `<div class="try-it-section">
                        <p>Rank requests within each status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    request_number,
    status,
    final_amount,
    DENSE_RANK() OVER (
        PARTITION BY status
        ORDER BY final_amount DESC
    ) AS rank_in_status
FROM requests
ORDER BY status, rank_in_status
LIMIT 20;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'When to Use Each',
                    content: `<div class="info-box">
                        <h4>Choosing the Right Function</h4>
                        <table>
                            <thead><tr><th>Function</th><th>Use When</th><th>Example</th></tr></thead>
                            <tbody>
                                <tr><td>ROW_NUMBER</td><td>Need unique IDs, pagination</td><td>Top 10 products (exactly 10)</td></tr>
                                <tr><td>RANK</td><td>Competition ranking</td><td>Race results (1st, 1st, 3rd...)</td></tr>
                                <tr><td>DENSE_RANK</td><td>Need sequential ranks despite ties</td><td>Salary bands, percentiles</td></tr>
                            </tbody>
                        </table>
                    </div>`
                }
            ],
            summary: ['ROW_NUMBER: unique sequential numbers', 'RANK: ties get same rank, gaps after', 'DENSE_RANK: ties get same rank, no gaps', 'All require ORDER BY in OVER', 'Use PARTITION BY for ranking within groups']
        },

        // ==================== DATA TYPE LESSONS ====================

        'numeric-types': {
            title: 'Numeric Types',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'null-handling',
            next: 'string-types',
            sections: [
                {
                    title: 'PostgreSQL Numeric Types',
                    content: `<p>PostgreSQL offers several numeric types for different use cases. Choosing the right type affects storage, precision, and performance.</p>
                    <div class="comparison-table">
                        <table>
                            <thead><tr><th>Type</th><th>Storage</th><th>Range</th><th>Use For</th></tr></thead>
                            <tbody>
                                <tr><td><code>smallint</code></td><td>2 bytes</td><td>-32,768 to 32,767</td><td>Small counts</td></tr>
                                <tr><td><code>integer</code></td><td>4 bytes</td><td>-2B to 2B</td><td>Most integers</td></tr>
                                <tr><td><code>bigint</code></td><td>8 bytes</td><td>-9×10^18 to 9×10^18</td><td>Large counts</td></tr>
                                <tr><td><code>decimal/numeric</code></td><td>variable</td><td>Up to 131072 digits</td><td>Money, exact</td></tr>
                                <tr><td><code>real</code></td><td>4 bytes</td><td>6 decimal digits</td><td>Scientific</td></tr>
                                <tr><td><code>double precision</code></td><td>8 bytes</td><td>15 decimal digits</td><td>Scientific</td></tr>
                            </tbody>
                        </table>
                    </div>`
                },
                {
                    title: 'Integer Types',
                    content: `<pre><code class="language-sql">-- Integer types for whole numbers
CREATE TABLE example (
    small_val smallint,      -- -32768 to 32767
    int_val integer,         -- ~-2 billion to ~2 billion
    big_val bigint           -- Very large numbers
);

-- Serial types (auto-incrementing)
CREATE TABLE users (
    id serial PRIMARY KEY,      -- 1 to 2147483647
    big_id bigserial            -- For billions of rows
);

-- Integer operations
SELECT
    10 / 3 AS int_division,        -- Result: 3 (integer division)
    10.0 / 3 AS float_division,    -- Result: 3.333...
    10 % 3 AS modulo;              -- Result: 1</code></pre>`
                },
                {
                    title: 'Try It: Numeric Operations',
                    content: `<div class="try-it-section">
                        <p>Explore numeric operations:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="10">SELECT
    -- Integer division vs decimal
    10 / 3 AS int_div,
    10.0 / 3 AS decimal_div,
    -- Rounding
    ROUND(10.0 / 3, 2) AS rounded,
    CEIL(10.0 / 3) AS ceiling,
    FLOOR(10.0 / 3) AS floor,
    -- Absolute value
    ABS(-42) AS absolute,
    -- Power and square root
    POWER(2, 10) AS two_to_ten,
    SQRT(144) AS square_root;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Decimal/Numeric for Money',
                    content: `<pre><code class="language-sql">-- NEVER use float for money! Precision issues.
-- Use numeric(precision, scale) instead

CREATE TABLE transactions (
    amount numeric(10, 2)  -- 10 digits total, 2 after decimal
);

-- Why not float?
SELECT 0.1 + 0.2;                    -- Might show 0.30000000000000004
SELECT 0.1::numeric + 0.2::numeric;  -- Exactly 0.3

-- Money calculations
SELECT
    final_amount,
    final_amount * 0.08 AS tax,
    ROUND(final_amount * 0.08, 2) AS tax_rounded,
    final_amount + ROUND(final_amount * 0.08, 2) AS total
FROM requests
LIMIT 5;</code></pre>
                    <div class="info-box" style="background: #fff5f5; border-color: #dc3545;">
                        <h4>Warning: Float Precision</h4>
                        <p>Never use <code>real</code> or <code>double precision</code> for money. Use <code>numeric</code> for exact decimal calculations.</p>
                    </div>`
                }
            ],
            summary: ['Use integer types for whole numbers', 'Use numeric/decimal for money (never float)', 'smallint/integer/bigint for different ranges', 'serial/bigserial for auto-incrementing IDs', 'Be aware of integer division vs decimal division']
        },

        'string-types': {
            title: 'String Types',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'numeric-types',
            next: 'date-types',
            sections: [
                {
                    title: 'PostgreSQL String Types',
                    content: `<p>PostgreSQL provides several string types and powerful text manipulation functions.</p>
                    <div class="comparison-table">
                        <table>
                            <thead><tr><th>Type</th><th>Description</th><th>Max Length</th></tr></thead>
                            <tbody>
                                <tr><td><code>char(n)</code></td><td>Fixed length, padded with spaces</td><td>n characters</td></tr>
                                <tr><td><code>varchar(n)</code></td><td>Variable length with limit</td><td>n characters</td></tr>
                                <tr><td><code>text</code></td><td>Variable unlimited length</td><td>~1 GB</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="info-box">
                        <h4>Best Practice</h4>
                        <p>In PostgreSQL, <code>text</code> is generally preferred. There's no performance difference between <code>varchar(n)</code> and <code>text</code>.</p>
                    </div>`
                },
                {
                    title: 'String Functions',
                    content: `<pre><code class="language-sql">-- Concatenation
SELECT 'Hello' || ' ' || 'World';           -- Hello World
SELECT CONCAT('Hello', ' ', 'World');       -- Hello World
SELECT CONCAT_WS(', ', 'a', 'b', 'c');      -- a, b, c

-- Case conversion
SELECT UPPER('hello'), LOWER('HELLO'), INITCAP('hello world');

-- Trimming
SELECT TRIM('  hello  ');                   -- 'hello'
SELECT LTRIM('  hello'), RTRIM('hello  ');

-- Length and position
SELECT LENGTH('hello');                     -- 5
SELECT POSITION('l' IN 'hello');           -- 3
SELECT STRPOS('hello', 'l');               -- 3

-- Substring
SELECT SUBSTRING('hello' FROM 2 FOR 3);    -- 'ell'
SELECT LEFT('hello', 2), RIGHT('hello', 2); -- 'he', 'lo'</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Practice string manipulations:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    first_name,
    last_name,
    -- Concatenate names
    first_name || ' ' || last_name AS full_name,
    -- Uppercase and length
    UPPER(last_name) AS upper_last,
    LENGTH(first_name) AS name_length,
    -- Extract first letter
    LEFT(first_name, 1) || '.' AS initial,
    -- Reverse name
    REVERSE(first_name) AS reversed
FROM patients
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Pattern Matching',
                    content: `<pre><code class="language-sql">-- LIKE patterns
SELECT * FROM patients WHERE first_name LIKE 'J%';      -- Starts with J
SELECT * FROM patients WHERE first_name LIKE '%son';    -- Ends with son
SELECT * FROM patients WHERE first_name LIKE '_ohn';    -- 4-char, ends ohn

-- ILIKE: Case-insensitive (PostgreSQL)
SELECT * FROM patients WHERE first_name ILIKE 'john';

-- SIMILAR TO: SQL regex
SELECT * FROM patients WHERE first_name SIMILAR TO '(John|Jane)%';

-- ~ : POSIX regex
SELECT * FROM patients WHERE first_name ~ '^J[aeiou]';  -- J + vowel
SELECT * FROM patients WHERE first_name ~* '^j';        -- Case-insensitive</code></pre>`
                },
                {
                    title: 'Replace and Split',
                    content: `<pre><code class="language-sql">-- Replace
SELECT REPLACE('hello world', 'world', 'SQL');  -- 'hello SQL'
SELECT TRANSLATE('hello', 'el', 'ip');          -- 'hippo'

-- Split and array
SELECT STRING_TO_ARRAY('a,b,c', ',');           -- {a,b,c}
SELECT UNNEST(STRING_TO_ARRAY('a,b,c', ','));   -- 3 rows

-- Regular expression replace
SELECT REGEXP_REPLACE('abc123def', '[0-9]+', 'X');  -- 'abcXdef'</code></pre>`
                }
            ],
            summary: ['Use text for most string columns', 'CONCAT or || for string concatenation', 'LIKE for simple patterns, ~ for regex', 'ILIKE for case-insensitive matching', 'STRING_TO_ARRAY to split strings']
        },

        'date-types': {
            title: 'Date/Time Types',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'string-types',
            next: 'boolean-json',
            sections: [
                {
                    title: 'PostgreSQL Date/Time Types',
                    content: `<div class="comparison-table">
                        <table>
                            <thead><tr><th>Type</th><th>Storage</th><th>Description</th><th>Example</th></tr></thead>
                            <tbody>
                                <tr><td><code>date</code></td><td>4 bytes</td><td>Date only</td><td>2024-01-15</td></tr>
                                <tr><td><code>time</code></td><td>8 bytes</td><td>Time only</td><td>14:30:00</td></tr>
                                <tr><td><code>timestamp</code></td><td>8 bytes</td><td>Date and time</td><td>2024-01-15 14:30:00</td></tr>
                                <tr><td><code>timestamptz</code></td><td>8 bytes</td><td>With timezone</td><td>2024-01-15 14:30:00+00</td></tr>
                                <tr><td><code>interval</code></td><td>16 bytes</td><td>Time span</td><td>2 days 3 hours</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="info-box">
                        <h4>Best Practice</h4>
                        <p>Use <code>timestamptz</code> (timestamp with time zone) for most cases. It stores UTC and converts to local timezone on display.</p>
                    </div>`
                },
                {
                    title: 'Date/Time Functions',
                    content: `<pre><code class="language-sql">-- Current date/time
SELECT
    CURRENT_DATE,           -- Today's date
    CURRENT_TIME,           -- Current time
    CURRENT_TIMESTAMP,      -- Current timestamp
    NOW();                  -- Same as CURRENT_TIMESTAMP

-- Extract components
SELECT
    EXTRACT(YEAR FROM NOW()) AS year,
    EXTRACT(MONTH FROM NOW()) AS month,
    EXTRACT(DAY FROM NOW()) AS day,
    EXTRACT(DOW FROM NOW()) AS day_of_week,  -- 0=Sunday
    EXTRACT(HOUR FROM NOW()) AS hour;

-- Date truncation
SELECT
    DATE_TRUNC('month', NOW()) AS start_of_month,
    DATE_TRUNC('year', NOW()) AS start_of_year;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Analyze request dates:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="14">SELECT
    request_number,
    created_at,
    -- Extract components
    EXTRACT(YEAR FROM created_at) AS year,
    EXTRACT(MONTH FROM created_at) AS month,
    TO_CHAR(created_at, 'Day') AS day_name,
    TO_CHAR(created_at, 'Mon DD, YYYY') AS formatted,
    -- Age/difference
    AGE(NOW(), created_at) AS age,
    NOW() - created_at AS time_since,
    -- Truncate to month
    DATE_TRUNC('month', created_at) AS month_start
FROM requests
ORDER BY created_at DESC
LIMIT 10;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Date Arithmetic',
                    content: `<pre><code class="language-sql">-- Add/subtract intervals
SELECT
    NOW() + INTERVAL '1 day' AS tomorrow,
    NOW() - INTERVAL '1 week' AS last_week,
    NOW() + INTERVAL '3 months' AS three_months_later;

-- Difference between dates
SELECT
    created_at,
    NOW() - created_at AS time_since,
    EXTRACT(DAY FROM NOW() - created_at) AS days_ago
FROM requests;

-- Date ranges
SELECT * FROM requests
WHERE created_at >= NOW() - INTERVAL '30 days';

-- Business day calculations (approximate)
SELECT
    created_at,
    created_at + INTERVAL '5 days' AS plus_5_days
FROM requests;</code></pre>`
                },
                {
                    title: 'Formatting Dates',
                    content: `<pre><code class="language-sql">-- TO_CHAR for formatting
SELECT
    TO_CHAR(NOW(), 'YYYY-MM-DD') AS iso_date,
    TO_CHAR(NOW(), 'DD/MM/YYYY') AS european,
    TO_CHAR(NOW(), 'Month DD, YYYY') AS long_date,
    TO_CHAR(NOW(), 'Day') AS day_name,
    TO_CHAR(NOW(), 'HH24:MI:SS') AS time_24h,
    TO_CHAR(NOW(), 'HH:MI AM') AS time_12h;

-- TO_DATE/TO_TIMESTAMP for parsing
SELECT
    TO_DATE('2024-01-15', 'YYYY-MM-DD'),
    TO_TIMESTAMP('2024-01-15 14:30', 'YYYY-MM-DD HH24:MI');</code></pre>`
                }
            ],
            summary: ['Use timestamptz for most timestamps', 'EXTRACT to get date/time components', 'DATE_TRUNC to round to period start', 'INTERVAL for date arithmetic', 'TO_CHAR/TO_DATE for formatting/parsing']
        },

        'boolean-json': {
            title: 'Boolean & JSON',
            category: 'Fundamentals',
            difficulty: 'Beginner',
            prev: 'date-types',
            next: 'inner-join',
            sections: [
                {
                    title: 'Boolean Type',
                    content: `<p>PostgreSQL has a native <code>boolean</code> type with three possible values: TRUE, FALSE, and NULL.</p>
                    <pre><code class="language-sql">-- Boolean values
SELECT
    TRUE,
    FALSE,
    NULL::boolean;

-- Boolean expressions
SELECT
    1 = 1 AS is_true,           -- TRUE
    1 = 2 AS is_false,          -- FALSE
    NULL = NULL AS is_null;     -- NULL (not TRUE!)

-- Boolean in WHERE
SELECT * FROM requests WHERE is_active = TRUE;
SELECT * FROM requests WHERE is_active;       -- Same as above
SELECT * FROM requests WHERE NOT is_active;   -- FALSE values

-- Coalesce NULL booleans
SELECT COALESCE(is_active, FALSE) FROM requests;</code></pre>`
                },
                {
                    title: 'JSON and JSONB Types',
                    content: `<p>PostgreSQL supports JSON data with two types: <code>json</code> (text storage) and <code>jsonb</code> (binary, faster, indexable).</p>
                    <div class="info-box">
                        <h4>json vs jsonb</h4>
                        <ul>
                            <li><strong>json:</strong> Stores exact text, preserves formatting and key order</li>
                            <li><strong>jsonb:</strong> Binary format, faster queries, supports indexing - use this!</li>
                        </ul>
                    </div>
                    <pre><code class="language-sql">-- Creating JSON
SELECT '{"name": "John", "age": 30}'::jsonb;
SELECT jsonb_build_object('name', 'John', 'age', 30);

-- JSON operators
SELECT
    '{"name": "John", "age": 30}'::jsonb -> 'name',     -- "John" (jsonb)
    '{"name": "John", "age": 30}'::jsonb ->> 'name',    -- John (text)
    '{"a": {"b": 1}}'::jsonb -> 'a' -> 'b';             -- 1</code></pre>`
                },
                {
                    title: 'Try It: JSON Queries',
                    content: `<div class="try-it-section">
                        <p>Work with JSON data:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="14">-- Build and query JSON
SELECT
    jsonb_build_object(
        'request', request_number,
        'status', status,
        'amount', final_amount
    ) AS request_json,
    -- Extract from the built JSON
    jsonb_build_object(
        'request', request_number,
        'status', status
    ) ->> 'status' AS extracted_status
FROM requests
LIMIT 5;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Common JSON Operations',
                    content: `<pre><code class="language-sql">-- Check if key exists
SELECT '{"a": 1}'::jsonb ? 'a';                    -- TRUE
SELECT '{"a": 1, "b": 2}'::jsonb ?& array['a','b']; -- Has all keys

-- Contains
SELECT '{"a": 1, "b": 2}'::jsonb @> '{"a": 1}';   -- TRUE

-- Array access
SELECT '[1, 2, 3]'::jsonb -> 0;                   -- 1

-- Modify JSON
SELECT '{"a": 1}'::jsonb || '{"b": 2}'::jsonb;    -- {"a": 1, "b": 2}
SELECT '{"a": 1, "b": 2}'::jsonb - 'a';           -- {"b": 2}

-- Aggregate to JSON
SELECT jsonb_agg(request_number) FROM requests LIMIT 5;
SELECT jsonb_object_agg(request_number, status) FROM requests LIMIT 5;</code></pre>`
                }
            ],
            summary: ['Boolean: TRUE, FALSE, or NULL', 'Use COALESCE for NULL booleans', 'Prefer jsonb over json for queries', '-> returns jsonb, ->> returns text', 'JSONB supports indexing with GIN']
        },

        // ==================== AGGREGATION LESSONS ====================

        'avg-min-max': {
            title: 'AVG, MIN, MAX',
            category: 'Aggregations',
            difficulty: 'Intermediate',
            prev: 'count-sum',
            next: 'distinct-agg',
            sections: [
                {
                    title: 'AVG, MIN, MAX Functions',
                    content: `<p>These aggregate functions calculate average, minimum, and maximum values across rows.</p>
                    <div class="key-points">
                        <h3>Key Points:</h3>
                        <ul>
                            <li><strong>AVG:</strong> Average (mean) of numeric values</li>
                            <li><strong>MIN:</strong> Smallest value (works with numbers, strings, dates)</li>
                            <li><strong>MAX:</strong> Largest value</li>
                            <li><strong>NULL handling:</strong> All three ignore NULL values</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Usage',
                    content: `<pre><code class="language-sql">-- Simple aggregates
SELECT
    AVG(final_amount) AS average,
    MIN(final_amount) AS minimum,
    MAX(final_amount) AS maximum
FROM requests;

-- With GROUP BY
SELECT
    status,
    ROUND(AVG(final_amount), 2) AS avg_amount,
    MIN(final_amount) AS min_amount,
    MAX(final_amount) AS max_amount
FROM requests
GROUP BY status;

-- With dates
SELECT
    MIN(created_at) AS earliest,
    MAX(created_at) AS latest,
    MAX(created_at) - MIN(created_at) AS date_range
FROM requests;</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Calculate statistics by status:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    status,
    COUNT(*) AS count,
    ROUND(AVG(final_amount), 2) AS avg_amount,
    MIN(final_amount) AS min_amount,
    MAX(final_amount) AS max_amount,
    MAX(final_amount) - MIN(final_amount) AS range,
    ROUND(MAX(final_amount) / NULLIF(MIN(final_amount), 0), 2) AS max_min_ratio
FROM requests
GROUP BY status
ORDER BY avg_amount DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Advanced: Conditional Aggregates',
                    content: `<pre><code class="language-sql">-- FILTER clause (PostgreSQL)
SELECT
    AVG(final_amount) AS overall_avg,
    AVG(final_amount) FILTER (WHERE status = 'completed') AS completed_avg,
    AVG(final_amount) FILTER (WHERE status = 'pending') AS pending_avg
FROM requests;

-- Same with CASE (more portable)
SELECT
    AVG(final_amount) AS overall_avg,
    AVG(CASE WHEN status = 'completed' THEN final_amount END) AS completed_avg,
    AVG(CASE WHEN status = 'pending' THEN final_amount END) AS pending_avg
FROM requests;</code></pre>`
                }
            ],
            summary: ['AVG calculates the mean', 'MIN/MAX work on numbers, strings, and dates', 'All three ignore NULL values', 'Use ROUND() with AVG for clean output', 'Use FILTER or CASE for conditional aggregates']
        },

        'having-clause': {
            title: 'HAVING Clause',
            category: 'Aggregations',
            difficulty: 'Intermediate',
            prev: 'group-by-basics',
            next: 'grouping-sets',
            sections: [
                {
                    title: 'What is HAVING?',
                    content: `<p><code>HAVING</code> filters groups after aggregation, while <code>WHERE</code> filters rows before aggregation.</p>
                    <div class="key-points">
                        <h3>WHERE vs HAVING:</h3>
                        <ul>
                            <li><strong>WHERE:</strong> Filters individual rows BEFORE grouping</li>
                            <li><strong>HAVING:</strong> Filters groups AFTER aggregation</li>
                            <li><strong>Rule:</strong> Use HAVING only with aggregate functions</li>
                        </ul>
                    </div>`
                },
                {
                    title: 'Basic Syntax',
                    content: `<pre><code class="language-sql">-- Find statuses with more than 10 requests
SELECT status, COUNT(*) AS count
FROM requests
GROUP BY status
HAVING COUNT(*) > 10;

-- Find statuses with average amount > 1000
SELECT status, ROUND(AVG(final_amount), 2) AS avg_amount
FROM requests
GROUP BY status
HAVING AVG(final_amount) > 1000;

-- Combining WHERE and HAVING
SELECT status, COUNT(*), AVG(final_amount)
FROM requests
WHERE created_at > '2024-01-01'    -- Filter rows first
GROUP BY status
HAVING COUNT(*) > 5;               -- Then filter groups</code></pre>`
                },
                {
                    title: 'Try It Yourself',
                    content: `<div class="try-it-section">
                        <p>Find statuses with significant volume:</p>
                        <div class="inline-editor-wrapper">
                            <textarea class="inline-sql-editor" rows="12">SELECT
    status,
    COUNT(*) AS request_count,
    SUM(final_amount) AS total_revenue,
    ROUND(AVG(final_amount), 2) AS avg_amount
FROM requests
GROUP BY status
HAVING
    COUNT(*) >= 5                    -- At least 5 requests
    AND SUM(final_amount) > 5000     -- At least 5000 in revenue
ORDER BY total_revenue DESC;</textarea>
                            <button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>
                        </div>
                        <div class="inline-results"></div>
                    </div>`
                },
                {
                    title: 'Query Execution Order',
                    content: `<div class="info-box">
                        <h4>SQL Execution Order</h4>
                        <pre>
1. FROM       - Get the tables
2. WHERE      - Filter rows
3. GROUP BY   - Create groups
4. HAVING     - Filter groups
5. SELECT     - Choose columns
6. ORDER BY   - Sort results
7. LIMIT      - Limit rows
                        </pre>
                        <p>This is why you can't use column aliases in WHERE or HAVING - SELECT happens later!</p>
                    </div>`
                }
            ],
            summary: ['HAVING filters groups after aggregation', 'WHERE filters rows before grouping', 'HAVING must use aggregate functions', 'Can combine WHERE and HAVING', 'HAVING comes after GROUP BY in query']
        }
    };

    // Generate default lesson content HTML
    function generateLessonHTML(lesson) {
        let html = '<div class="lesson">';
        html += '<h1>' + lesson.title + '</h1>';
        html += '<p class="lesson-meta">';
        html += '<span class="category">Category: ' + lesson.category + '</span>';
        html += '<span class="difficulty">Difficulty: ' + lesson.difficulty + '</span>';
        html += '</p>';

        lesson.sections.forEach(function(section) {
            html += '<section class="lesson-section">';
            html += '<h2>' + section.title + '</h2>';
            html += section.content;
            html += '</section>';
        });

        if (lesson.summary) {
            html += '<section class="lesson-section">';
            html += '<h2>Summary</h2>';
            html += '<div class="summary-box"><ul>';
            lesson.summary.forEach(function(point) {
                html += '<li>&#10003; ' + point + '</li>';
            });
            html += '</ul></div></section>';
        }

        html += '<div class="lesson-nav">';
        if (lesson.prev) {
            html += '<a class="btn btn-secondary" onclick="loadLesson(\'' + lesson.prev + '\')">&#8592; Previous</a>';
        } else {
            html += '<span></span>';
        }
        if (lesson.next) {
            html += '<a class="btn btn-primary" onclick="loadLesson(\'' + lesson.next + '\')">Next &#8594;</a>';
        } else {
            html += '<span></span>';
        }
        html += '</div>';
        html += '</div>';

        return html;
    }

    window.toggleCategory = function(id) {
        const content = document.getElementById(id);
        if (content) {
            content.classList.toggle('expanded');
        }
    };

    window.toggleSubCategory = function(id) {
        const content = document.getElementById(id);
        if (content) {
            content.classList.toggle('expanded');
        }
    };

    window.loadLesson = function(lessonId) {
        // Update active state
        document.querySelectorAll('.lesson-link').forEach(function(link) {
            link.classList.remove('active');
        });
        if (event && event.target) {
            event.target.classList.add('active');
        }

        // Check if lesson content exists
        const content = document.getElementById('lesson-content');

        if (lessonId === 'select-basics') {
            // Reload page to show default content
            window.location.reload();
            return;
        }

        if (lessonContent[lessonId]) {
            content.innerHTML = generateLessonHTML(lessonContent[lessonId]);
            // Scroll to top
            content.scrollTop = 0;
            // Highlight code blocks
            if (typeof hljs !== 'undefined') {
                content.querySelectorAll('pre code').forEach(function(block) {
                    hljs.highlightElement(block);
                });
            }
        } else {
            // Show coming soon message with better formatting
            content.innerHTML = '<div class="lesson">' +
                '<h1>' + lessonId.replace(/-/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }) + '</h1>' +
                '<div class="info-box">' +
                '<h4>Lesson Coming Soon</h4>' +
                '<p>This lesson is being developed. In the meantime, you can practice SQL in the editor below or visit the <a href="/sql">SQL Dashboard</a> for a full-featured query experience.</p>' +
                '</div>' +
                '<section class="lesson-section">' +
                '<h2>Practice Area</h2>' +
                '<div class="try-it-section">' +
                '<p>Write and run your own queries:</p>' +
                '<div class="inline-editor-wrapper">' +
                '<textarea class="inline-sql-editor" rows="6">-- Try your own SQL query here\nSELECT * FROM requests LIMIT 5;</textarea>' +
                '<button class="btn btn-primary btn-run-inline" onclick="runInlineQuery(this)">Run Query</button>' +
                '</div>' +
                '<div class="inline-results"></div>' +
                '</div>' +
                '</section>' +
                '</div>';
        }
    };

    window.runExample = function(button) {
        const queryBlock = button.parentElement.querySelector('code');
        const query = queryBlock.textContent;

        // Open SQL dashboard with query
        const encoded = encodeURIComponent(query);
        window.location.href = '/sql?query=' + encoded;
    };

    // Run inline query within the lesson
    window.runInlineQuery = function(button) {
        // Find the editor wrapper and results container
        const wrapper = button.closest('.inline-editor-wrapper') || button.parentElement;
        const textarea = wrapper.querySelector('.inline-sql-editor');

        // More robust results div lookup - check multiple locations
        let resultsDiv = wrapper.parentElement.querySelector('.inline-results');
        if (!resultsDiv) {
            resultsDiv = wrapper.nextElementSibling;
        }
        if (!resultsDiv || !resultsDiv.classList.contains('inline-results')) {
            // Create results div if it doesn't exist
            resultsDiv = document.createElement('div');
            resultsDiv.className = 'inline-results';
            wrapper.parentElement.appendChild(resultsDiv);
        }

        if (!textarea) {
            console.error('Could not find textarea');
            return;
        }

        // Get value from CodeMirror if available, otherwise from textarea
        let query;
        if (textarea.cmEditor) {
            query = textarea.cmEditor.getValue().trim();
        } else {
            query = textarea.value.trim();
        }
        if (!query) return;

        // Show loading state
        resultsDiv.innerHTML = '<div class="loading">Executing query...</div>';
        resultsDiv.style.display = 'block';

        fetch('/api/sql/execute', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: query, preview: false })
        })
        .then(function(res) { return res.json(); })
        .then(function(data) {
            if (!data.success || data.error) {
                resultsDiv.innerHTML = '<div class="inline-error">' + escapeHtml(data.error || 'Query execution failed') + '</div>';
                return;
            }

            const isSelectQuery = ['SELECT', 'WITH', 'EXPLAIN'].includes(data.query_type);

            let html = '<div class="inline-results-header">' +
                '<span class="success">&#10003; ';

            if (isSelectQuery) {
                html += data.rows.length + ' rows returned';
            } else {
                html += data.rows_affected + ' rows affected';
            }

            html += '</span>' +
                '<span class="timing">' + data.duration_ms + 'ms</span>' +
                '</div>';

            if (isSelectQuery && data.columns && data.columns.length > 0 && data.rows && data.rows.length > 0) {
                // Check if single row - display as transposed (vertical) layout
                if (data.rows.length === 1) {
                    html += '<div class="inline-table-wrapper"><table class="inline-results-table transposed-table">';
                    html += '<thead><tr><th>Column</th><th>Value</th></tr></thead><tbody>';

                    data.columns.forEach(function(col, index) {
                        const cell = data.rows[0][index];
                        const val = cell === null ? '<em class="null-value">NULL</em>' : escapeHtml(String(cell));
                        html += '<tr><td class="column-name">' + escapeHtml(col) + '</td><td>' + val + '</td></tr>';
                    });

                    html += '</tbody></table></div>';
                } else {
                    // Multiple rows - display as normal table
                    html += '<div class="inline-table-wrapper"><table class="inline-results-table">';
                    html += '<thead><tr>';
                    data.columns.forEach(function(col) {
                        html += '<th>' + escapeHtml(col) + '</th>';
                    });
                    html += '</tr></thead><tbody>';

                    data.rows.forEach(function(row) {
                        html += '<tr>';
                        row.forEach(function(cell) {
                            const val = cell === null ? '<em class="null-value">NULL</em>' : escapeHtml(String(cell));
                            html += '<td>' + val + '</td>';
                        });
                        html += '</tr>';
                    });

                    html += '</tbody></table></div>';
                }
            } else if (isSelectQuery && data.rows.length === 0) {
                html += '<p>Query executed successfully. No rows returned.</p>';
            } else if (!isSelectQuery) {
                html += '<p>Query executed successfully. ' + data.rows_affected + ' rows affected.</p>';
            }

            resultsDiv.innerHTML = html;
        })
        .catch(function(err) {
            resultsDiv.innerHTML = '<div class="inline-error">Error: ' + escapeHtml(err.message || 'Connection error') + '</div>';
        });
    };

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Highlight code blocks on page load
    if (typeof hljs !== 'undefined') {
        document.querySelectorAll('pre code').forEach(function(block) {
            hljs.highlightElement(block);
        });
    }

    // Initialize CodeMirror for inline SQL editors
    function initInlineEditors() {
        document.querySelectorAll('.inline-sql-editor').forEach(function(textarea) {
            if (textarea.cmEditor) return; // Already initialized

            const editor = CodeMirror.fromTextArea(textarea, {
                mode: 'text/x-sql',
                theme: 'default',
                lineNumbers: true,
                matchBrackets: true,
                autoCloseBrackets: true,
                indentWithTabs: false,
                indentUnit: 4,
                tabSize: 4,
                lineWrapping: true,
                viewportMargin: Infinity
            });

            // Store reference to CodeMirror on the textarea for easy access
            textarea.cmEditor = editor;

            // Set height based on content
            const lines = textarea.value.split('\n').length;
            editor.setSize(null, Math.max(100, Math.min(300, lines * 22 + 20)));
        });
    }

    // Initialize editors on page load
    initInlineEditors();

    // Re-initialize when lessons are loaded dynamically
    const originalLoadLesson = window.loadLesson;
    window.loadLesson = function(lessonId) {
        if (originalLoadLesson) {
            originalLoadLesson(lessonId);
        }
        // Re-initialize editors after content loads
        setTimeout(initInlineEditors, 100);
    };
})();
</script>

<!-- CodeMirror light grey theme for SQL editors -->
<style>
.CodeMirror {
    font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.9rem;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: #f8f9fa !important;
    color: #333;
}
.CodeMirror-gutters { background: #eef0f2 !important; border-right: 1px solid #ddd; }
.CodeMirror-linenumber { color: #888; }
.CodeMirror-cursor { border-left: 2px solid #333; }
.CodeMirror-selected { background: #d0e8ff !important; }
.CodeMirror-focused .CodeMirror-selected { background: #b3d7ff !important; }
.cm-comment { color: #6a737d; font-style: italic; }
.cm-keyword { color: #0033b3; font-weight: bold; }
.cm-string { color: #067d17; }
.cm-string-2 { color: #067d17; }
.cm-number { color: #1750eb; }
.cm-variable { color: #333; }
.cm-variable-2 { color: #9e4607; }
.cm-def { color: #6f42c1; }
.cm-operator { color: #333; }
.cm-builtin { color: #0033b3; }
.cm-atom { color: #1750eb; }
.cm-property { color: #9e4607; }
</style>
