<div class="guide-page">
    <nav class="breadcrumb">
        <a href="/">Home</a> <span class="breadcrumb-sep">/</span> <span>Go Development</span>
    </nav>

    <div class="guide-header">
        <div class="guide-header-content">
            <span class="guide-badge go-badge">Go 1.21+</span>
            <h1>Go API Development Guide</h1>
            <p class="guide-description">Master Go for building high-performance APIs - from language basics to advanced concurrency patterns</p>
            <div class="guide-stats">
                <div class="stat-item">
                    <span class="stat-icon">&#128218;</span>
                    <span class="stat-text">4 Sections</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">&#9889;</span>
                    <span class="stat-text">Interactive Code</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">&#128200;</span>
                    <span class="stat-text">Beginner to Advanced</span>
                </div>
            </div>
        </div>
    </div>

    <div class="guide-nav">
        <a href="#go-basics" class="guide-nav-link active" data-section="go-basics">
            <span class="nav-icon">&#128029;</span> Go Basics
        </a>
        <a href="#basic" class="guide-nav-link" data-section="basic">
            <span class="nav-icon">&#9881;</span> Foundations
        </a>
        <a href="#intermediate" class="guide-nav-link" data-section="intermediate">
            <span class="nav-icon">&#128295;</span> Intermediate
        </a>
        <a href="#advanced" class="guide-nav-link" data-section="advanced">
            <span class="nav-icon">&#128640;</span> Advanced
        </a>
    </div>

    <!-- GO BASICS SECTION -->
    <section id="go-basics" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#128029;</span> Go Language Fundamentals</h2>
            <p class="section-description">Essential Go concepts to get you started quickly</p>
        </div>

        <div class="topic-block highlight-block">
            <div class="block-header">
                <span class="block-icon">&#128161;</span>
                <h3>Why Go for APIs?</h3>
            </div>
            <p>Go was designed at Google to handle large-scale systems. It combines the simplicity of Python with the performance of C, making it ideal for building APIs, microservices, and concurrent applications.</p>

            <div class="concept-grid">
                <div class="concept-card">
                    <span class="concept-icon">&#9889;</span>
                    <h4>Fast Compilation</h4>
                    <p>Compile in seconds, not minutes</p>
                </div>
                <div class="concept-card">
                    <span class="concept-icon">&#128640;</span>
                    <h4>High Performance</h4>
                    <p>Near C-level speed with GC</p>
                </div>
                <div class="concept-card">
                    <span class="concept-icon">&#128101;</span>
                    <h4>Built-in Concurrency</h4>
                    <p>Goroutines and channels</p>
                </div>
                <div class="concept-card">
                    <span class="concept-icon">&#128230;</span>
                    <h4>Simple Deployment</h4>
                    <p>Single static binary</p>
                </div>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#127968;</span>
                <h3>Hello World and Program Structure</h3>
            </div>
            <p>Every Go program starts with a <code>package</code> declaration. The <code>main</code> package is special - it defines an executable program.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

// main is the entry point of the program
func main() {
    // Print to console
    fmt.Println("Hello, Go!")

    // Variables
    name := "Gopher"  // Short declaration (type inferred)
    var age int = 10  // Explicit type

    fmt.Printf("Name: %s, Age: %d\n", name, age)

    // Current time
    fmt.Println("Current time:", time.Now().Format("2006-01-02 15:04:05"))
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128221;</span>
                <h3>Variables and Data Types</h3>
            </div>
            <p>Go is statically typed but has type inference. Understanding types is essential for building robust APIs.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import "fmt"

func main() {
    // Basic types
    var name string = "Alice"
    var age int = 30
    var price float64 = 19.99
    var isActive bool = true

    // Short declaration (most common)
    email := "alice@example.com"
    count := 42

    fmt.Println("=== Basic Types ===")
    fmt.Printf("name: %s (type: %T)\n", name, name)
    fmt.Printf("age: %d (type: %T)\n", age, age)
    fmt.Printf("price: %.2f (type: %T)\n", price, price)
    fmt.Printf("isActive: %v (type: %T)\n", isActive, isActive)
    fmt.Printf("email: %s\n", email)

    // Zero values (default values)
    var defaultInt int
    var defaultString string
    var defaultBool bool
    var defaultFloat float64

    fmt.Println("\n=== Zero Values ===")
    fmt.Printf("int: %d, string: %q, bool: %v, float: %f\n",
        defaultInt, defaultString, defaultBool, defaultFloat)

    // Constants
    const MaxUsers = 1000
    const ApiVersion = "v1"

    fmt.Println("\n=== Constants ===")
    fmt.Printf("MaxUsers: %d, API: %s\n", MaxUsers, ApiVersion)

    // Multiple assignment
    x, y := 10, 20
    x, y = y, x  // Swap values
    fmt.Printf("\n=== After swap: x=%d, y=%d ===\n", x, y)

    // Type conversion (explicit)
    var numInt int = 42
    var numFloat float64 = float64(numInt)
    var numStr string = fmt.Sprintf("%d", numInt)

    fmt.Printf("\nConverted: int=%d, float=%.1f, string=%q\n",
        numInt, numFloat, numStr)
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128260;</span>
                <h3>Control Structures</h3>
            </div>
            <p>Go has simplified control structures - no parentheses needed, and braces are always required.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import "fmt"

func main() {
    // If-else (no parentheses needed)
    score := 85

    fmt.Println("=== If-Else ===")
    if score >= 90 {
        fmt.Println("Grade: A")
    } else if score >= 80 {
        fmt.Println("Grade: B")
    } else {
        fmt.Println("Grade: C")
    }

    // If with initialization statement
    if length := len("hello"); length > 3 {
        fmt.Printf("String length %d is greater than 3\n", length)
    }

    // Switch (no break needed - implicit)
    fmt.Println("\n=== Switch ===")
    day := "Monday"
    switch day {
    case "Monday", "Tuesday", "Wednesday", "Thursday", "Friday":
        fmt.Println("Weekday")
    case "Saturday", "Sunday":
        fmt.Println("Weekend")
    default:
        fmt.Println("Unknown day")
    }

    // Switch without expression (like if-else chain)
    hour := 14
    switch {
    case hour < 12:
        fmt.Println("Good morning!")
    case hour < 17:
        fmt.Println("Good afternoon!")
    default:
        fmt.Println("Good evening!")
    }

    // For loop (Go's only loop construct)
    fmt.Println("\n=== For Loop ===")

    // Traditional for
    for i := 0; i < 3; i++ {
        fmt.Printf("i = %d\n", i)
    }

    // While-style
    count := 0
    for count < 3 {
        fmt.Printf("count = %d\n", count)
        count++
    }

    // Range over slice
    fmt.Println("\n=== Range ===")
    colors := []string{"red", "green", "blue"}
    for index, color := range colors {
        fmt.Printf("Index %d: %s\n", index, color)
    }

    // Range over map
    ages := map[string]int{"Alice": 30, "Bob": 25}
    for name, age := range ages {
        fmt.Printf("%s is %d years old\n", name, age)
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#9881;</span>
                <h3>Functions</h3>
            </div>
            <p>Functions in Go can return multiple values - commonly used for returning results and errors.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "errors"
    "fmt"
)

// Basic function
func greet(name string) string {
    return "Hello, " + name + "!"
}

// Multiple return values (common pattern: result + error)
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}

// Named return values
func calculate(x, y int) (sum, product int) {
    sum = x + y
    product = x * y
    return  // "naked" return - returns named values
}

// Variadic function (variable number of arguments)
func sumAll(numbers ...int) int {
    total := 0
    for _, n := range numbers {
        total += n
    }
    return total
}

// Function as parameter (higher-order function)
func apply(nums []int, fn func(int) int) []int {
    result := make([]int, len(nums))
    for i, n := range nums {
        result[i] = fn(n)
    }
    return result
}

func main() {
    // Basic function call
    fmt.Println("=== Basic Function ===")
    fmt.Println(greet("Gopher"))

    // Multiple return values
    fmt.Println("\n=== Multiple Returns ===")
    result, err := divide(10, 3)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Printf("10 / 3 = %.2f\n", result)
    }

    // Error case
    _, err = divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
    }

    // Named returns
    fmt.Println("\n=== Named Returns ===")
    s, p := calculate(5, 3)
    fmt.Printf("Sum: %d, Product: %d\n", s, p)

    // Variadic function
    fmt.Println("\n=== Variadic Function ===")
    fmt.Println("Sum of 1,2,3:", sumAll(1, 2, 3))
    fmt.Println("Sum of 1-5:", sumAll(1, 2, 3, 4, 5))

    // Slice expansion
    nums := []int{10, 20, 30}
    fmt.Println("Sum of slice:", sumAll(nums...))

    // Function as value
    fmt.Println("\n=== Higher-Order Function ===")
    double := func(x int) int { return x * 2 }
    numbers := []int{1, 2, 3, 4}
    doubled := apply(numbers, double)
    fmt.Println("Original:", numbers)
    fmt.Println("Doubled:", doubled)

    // Closure (function that captures variables)
    fmt.Println("\n=== Closure ===")
    counter := func() func() int {
        count := 0
        return func() int {
            count++
            return count
        }
    }()

    fmt.Println("Count:", counter())
    fmt.Println("Count:", counter())
    fmt.Println("Count:", counter())
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Collections: Slices and Maps</h3>
            </div>
            <p>Slices and maps are Go's primary collection types. Understanding them is essential for API development.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import "fmt"

func main() {
    // === SLICES ===
    fmt.Println("=== Slices ===")

    // Creating slices
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println("Numbers:", numbers)

    // Make with length and capacity
    scores := make([]int, 3, 10)  // len=3, cap=10
    scores[0], scores[1], scores[2] = 100, 95, 87
    fmt.Printf("Scores: %v (len=%d, cap=%d)\n", scores, len(scores), cap(scores))

    // Append
    scores = append(scores, 92, 88)
    fmt.Println("After append:", scores)

    // Slicing (creates a view, not a copy!)
    firstThree := numbers[:3]
    lastThree := numbers[2:]
    fmt.Println("First 3:", firstThree)
    fmt.Println("Last 3:", lastThree)

    // Copy (to avoid shared backing array)
    copied := make([]int, len(numbers))
    copy(copied, numbers)
    fmt.Println("Copied:", copied)

    // === MAPS ===
    fmt.Println("\n=== Maps ===")

    // Creating maps
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
        "Carol": 35,
    }
    fmt.Println("Ages:", ages)

    // Make empty map
    users := make(map[string]string)
    users["admin"] = "admin@example.com"
    users["user1"] = "user1@example.com"
    fmt.Println("Users:", users)

    // Access and check existence
    age, exists := ages["Alice"]
    if exists {
        fmt.Printf("Alice is %d years old\n", age)
    }

    _, exists = ages["Dave"]
    fmt.Printf("Dave exists: %v\n", exists)

    // Delete
    delete(ages, "Bob")
    fmt.Println("After delete:", ages)

    // Iterate
    fmt.Println("\nIterating:")
    for name, age := range ages {
        fmt.Printf("  %s: %d\n", name, age)
    }

    // === STRUCTS AS MAP VALUES ===
    fmt.Println("\n=== Struct in Map ===")

    type User struct {
        Name  string
        Email string
        Age   int
    }

    userDB := map[int]User{
        1: {Name: "Alice", Email: "alice@example.com", Age: 30},
        2: {Name: "Bob", Email: "bob@example.com", Age: 25},
    }

    for id, user := range userDB {
        fmt.Printf("  ID %d: %s (%s)\n", id, user.Name, user.Email)
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>
    </section>

    <!-- BASIC SECTION -->
    <section id="basic" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#9881;</span> Foundations for Go API Development</h2>
            <p class="section-description">Core concepts for building robust APIs</p>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128204;</span>
                <h3>Understanding Pointers in Go</h3>
            </div>
            <p>Pointers are fundamental in Go. A pointer holds the memory address of a value. Understanding pointers is crucial for API development because they affect how data is passed, modified, and shared.</p>

            <div class="diagram-container">
                <div class="diagram-title">Pointer vs Value in Memory</div>
                <div class="mermaid">
flowchart LR
    subgraph "Pass by Value"
        A[x = 42] -->|copy| B[func receives copy]
        B -->|modify| C[copy = 100]
        A -->|unchanged| D[x still 42]
    end

    subgraph "Pass by Pointer"
        E[x = 42] -->|address| F["func receives &x"]
        F -->|modify *ptr| G[x = 100]
    end
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import "fmt"

func main() {
    // Regular variable
    x := 42

    // Pointer to x (stores the memory address of x)
    ptr := &x

    fmt.Println("Value of x:", x)           // 42
    fmt.Println("Address of x:", &x)        // 0x... (memory address)
    fmt.Println("Pointer ptr holds:", ptr)  // Same address as &x
    fmt.Println("Value at ptr:", *ptr)      // 42 (dereferencing)

    // Modifying through pointer changes original
    *ptr = 100
    fmt.Println("x after modification:", x) // 100
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>

            <h4>Why Use Pointers in APIs?</h4>
            <div class="feature-list">
                <div class="feature-item">
                    <span class="feature-icon">&#128640;</span>
                    <div>
                        <strong>Efficiency</strong>
                        <p>Pass large structs by reference instead of copying</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">&#9999;</span>
                    <div>
                        <strong>Mutability</strong>
                        <p>Allow functions to modify caller's data</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">&#10067;</span>
                    <div>
                        <strong>Optional Values</strong>
                        <p>nil pointers represent "no value"</p>
                    </div>
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import "fmt"

// User represents an API resource
type User struct {
    ID    int
    Name  string
    Email string
}

// Pass by value - cannot modify original
func updateNameByValue(u User, name string) {
    u.Name = name // Only modifies the copy
}

// Pass by pointer - can modify original
func updateNameByPointer(u *User, name string) {
    u.Name = name // Modifies the original
}

// Using pointer for optional fields (nil = not provided)
type UpdateRequest struct {
    Name  *string // nil means "don't update"
    Email *string
}

func main() {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}

    // By value - no change
    updateNameByValue(user, "Bob")
    fmt.Println("After value update:", user.Name) // Still "Alice"

    // By pointer - changes original
    updateNameByPointer(&user, "Bob")
    fmt.Println("After pointer update:", user.Name) // Now "Bob"

    // Optional field example
    newName := "Charlie"
    req := UpdateRequest{Name: &newName, Email: nil}

    if req.Name != nil {
        fmt.Println("Update name to:", *req.Name)
    }
    if req.Email == nil {
        fmt.Println("Email not provided, keep existing")
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Structs and Methods</h3>
            </div>
            <p>Structs are Go's way to define custom types. Methods allow you to attach behavior to structs - essential for building clean API handlers and services.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

// Value receiver - cannot modify the struct
func (u User) FullInfo() string {
    return fmt.Sprintf("User %d: %s (%s)", u.ID, u.Name, u.Email)
}

// Pointer receiver - can modify the struct
func (u *User) SetEmail(email string) {
    u.Email = email
}

// Pointer receiver - for large structs or consistency
func (u *User) ToJSON() ([]byte, error) {
    return json.Marshal(u)
}

// Validation method
func (u *User) Validate() error {
    if u.Name == "" {
        return fmt.Errorf("name is required")
    }
    if u.Email == "" {
        return fmt.Errorf("email is required")
    }
    if u.Age < 0 {
        return fmt.Errorf("age cannot be negative")
    }
    return nil
}

func main() {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com", Age: 25}

    // Value receiver method
    fmt.Println(user.FullInfo())

    // Pointer receiver method - modifies the struct
    user.SetEmail("newalice@example.com")
    fmt.Println("After SetEmail:", user.Email)

    // ToJSON
    jsonData, _ := user.ToJSON()
    fmt.Println("JSON:", string(jsonData))

    // Validation
    if err := user.Validate(); err != nil {
        fmt.Println("Validation error:", err)
    } else {
        fmt.Println("User is valid")
    }

    // Invalid user
    invalidUser := User{ID: 2, Age: -5}
    if err := invalidUser.Validate(); err != nil {
        fmt.Println("Validation error:", err)
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128268;</span>
                <h3>Interfaces for API Design</h3>
            </div>
            <p>Interfaces define behavior contracts. They enable loose coupling and are essential for testable API code.</p>

            <div class="info-box">
                <div class="info-header">
                    <span class="info-icon">&#128161;</span>
                    <span>Key Insight</span>
                </div>
                <p><strong>Go interfaces are implicit!</strong> A type implements an interface simply by implementing its methods - no explicit declaration needed. This makes Go's interfaces very flexible.</p>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import "fmt"

// Interface defines the contract
type Repository interface {
    FindByID(id int) (interface{}, error)
    Save(entity interface{}) error
}

// Mock implementation for testing
type MockUserRepository struct {
    users map[int]string
}

func NewMockUserRepository() *MockUserRepository {
    return &MockUserRepository{
        users: map[int]string{
            1: "Alice",
            2: "Bob",
        },
    }
}

func (r *MockUserRepository) FindByID(id int) (interface{}, error) {
    if name, ok := r.users[id]; ok {
        return name, nil
    }
    return nil, fmt.Errorf("user not found")
}

func (r *MockUserRepository) Save(entity interface{}) error {
    fmt.Printf("Saved: %v\n", entity)
    return nil
}

// Service depends on interface, not concrete type
type UserService struct {
    repo Repository
}

func NewUserService(repo Repository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) GetUser(id int) (interface{}, error) {
    return s.repo.FindByID(id)
}

func main() {
    // Inject mock repository
    repo := NewMockUserRepository()
    service := NewUserService(repo)

    user, err := service.GetUser(1)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Found user:", user)

    _, err = service.GetUser(99)
    if err != nil {
        fmt.Println("Error:", err)
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#9888;</span>
                <h3>Error Handling in Go</h3>
            </div>
            <p>Go uses explicit error handling. Functions return errors as values - no exceptions.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "errors"
    "fmt"
)

// Custom error types
var (
    ErrNotFound     = errors.New("resource not found")
    ErrUnauthorized = errors.New("unauthorized access")
    ErrValidation   = errors.New("validation failed")
)

// Wrapping errors with context
type User struct {
    ID    int
    Name  string
    Email string
}

func findUser(id int) (*User, error) {
    // Simulate database lookup
    if id <= 0 {
        return nil, fmt.Errorf("findUser: invalid id %d: %w", id, ErrValidation)
    }
    if id == 99 {
        return nil, fmt.Errorf("findUser id=%d: %w", id, ErrNotFound)
    }
    return &User{ID: id, Name: "Alice", Email: "alice@example.com"}, nil
}

func main() {
    // Success case
    user, err := findUser(1)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Printf("Found: %+v\n", user)
    }

    // Error case - check specific error type
    _, err = findUser(99)
    if err != nil {
        // Using errors.Is to check wrapped errors
        if errors.Is(err, ErrNotFound) {
            fmt.Println("User not found - return 404")
        } else if errors.Is(err, ErrValidation) {
            fmt.Println("Validation error - return 400")
        } else {
            fmt.Println("Unknown error:", err)
        }
    }

    // Validation error
    _, err = findUser(-1)
    if errors.Is(err, ErrValidation) {
        fmt.Println("Bad request:", err)
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>
    </section>

    <!-- INTERMEDIATE SECTION -->
    <section id="intermediate" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#128295;</span> Intermediate - Concurrency and Patterns</h2>
            <p class="section-description">Master Go's powerful concurrency model</p>
        </div>

        <div class="topic-block highlight-block">
            <div class="block-header">
                <span class="block-icon">&#128101;</span>
                <h3>Goroutines - Concurrent Execution</h3>
            </div>
            <p>Goroutines are lightweight, user-space threads managed by the Go runtime scheduler. They are Go's fundamental concurrency primitive.</p>

            <div class="diagram-container">
                <div class="diagram-title">Go's M:N Scheduling Model</div>
                <div class="mermaid">
flowchart TB
    subgraph "Goroutines (G)"
        G1[G1]
        G2[G2]
        G3[G3]
        G4[G4]
        G5[G5]
    end

    subgraph "Processors (P)"
        P1[P1 Local Queue]
        P2[P2 Local Queue]
    end

    subgraph "OS Threads (M)"
        M1[Thread 1]
        M2[Thread 2]
    end

    G1 --> P1
    G2 --> P1
    G3 --> P2
    G4 --> P2
    G5 --> P1

    P1 --> M1
    P2 --> M2

    M1 --> CPU1[CPU Core]
    M2 --> CPU2[CPU Core]
                </div>
            </div>

            <div class="comparison-table">
                <div class="comparison-header">
                    <div class="comparison-title">Goroutines vs OS Threads</div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>OS Threads</th>
                            <th>Goroutines</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Stack Size</td>
                            <td>~1-8MB fixed</td>
                            <td>~2KB (grows dynamically)</td>
                        </tr>
                        <tr>
                            <td>Creation Time</td>
                            <td>~10,000 CPU cycles</td>
                            <td>~300 CPU cycles</td>
                        </tr>
                        <tr>
                            <td>Context Switch</td>
                            <td>Kernel mode (slow)</td>
                            <td>User mode (fast)</td>
                        </tr>
                        <tr>
                            <td>Scalability</td>
                            <td>Thousands</td>
                            <td>Millions</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func fetchUser(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Signal completion when function returns

    // Simulate API call
    time.Sleep(10 * time.Millisecond)
    fmt.Printf("Fetched user %d\n", id)
}

func main() {
    var wg sync.WaitGroup

    userIDs := []int{1, 2, 3, 4, 5}

    start := time.Now()

    // Launch goroutines for concurrent fetching
    for _, id := range userIDs {
        wg.Add(1)
        go fetchUser(id, &wg)
    }

    // Wait for all goroutines to complete
    wg.Wait()

    fmt.Printf("Fetched %d users in %v\n", len(userIDs), time.Since(start))
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128232;</span>
                <h3>Channels - Goroutine Communication</h3>
            </div>
            <p>Channels are Go's way to communicate between goroutines safely. "Don't communicate by sharing memory; share memory by communicating."</p>

            <div class="diagram-container">
                <div class="diagram-title">Channel Communication</div>
                <div class="mermaid">
sequenceDiagram
    participant G1 as Goroutine 1
    participant CH as Channel
    participant G2 as Goroutine 2

    G1->>CH: Send data
    Note over CH: Buffered or<br/>blocks until received
    CH->>G2: Receive data
    G2->>G2: Process data
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

type Result struct {
    UserID int
    Data   string
    Error  error
}

func fetchUserData(id int, results chan<- Result) {
    // Simulate API call
    time.Sleep(5 * time.Millisecond)

    // Send result through channel
    results <- Result{
        UserID: id,
        Data:   fmt.Sprintf("User %d data", id),
        Error:  nil,
    }
}

func main() {
    userIDs := []int{1, 2, 3, 4, 5}

    // Buffered channel - won't block until buffer is full
    results := make(chan Result, len(userIDs))

    // Launch goroutines
    for _, id := range userIDs {
        go fetchUserData(id, results)
    }

    // Collect results
    for i := 0; i < len(userIDs); i++ {
        result := <-results // Receive from channel
        if result.Error != nil {
            fmt.Printf("Error for user %d: %v\n", result.UserID, result.Error)
        } else {
            fmt.Printf("Got: %s\n", result.Data)
        }
    }

    close(results) // Close channel when done
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128260;</span>
                <h3>Select Statement - Handling Multiple Channels</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(10 * time.Millisecond)
        ch1 <- "Result from service 1"
    }()

    go func() {
        time.Sleep(5 * time.Millisecond)
        ch2 <- "Result from service 2"
    }()

    // Receive from whichever channel is ready first
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("Received:", msg1)
        case msg2 := <-ch2:
            fmt.Println("Received:", msg2)
        }
    }

    // Select with timeout
    timeout := make(chan string)
    go func() {
        time.Sleep(20 * time.Millisecond)
        timeout <- "slow result"
    }()

    select {
    case result := <-timeout:
        fmt.Println("Got:", result)
    case <-time.After(10 * time.Millisecond):
        fmt.Println("Timeout! Service too slow")
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header warning-header">
                <span class="block-icon">&#9888;</span>
                <h3>Common Concurrency Mistakes</h3>
            </div>

            <h4>Mistake 1: Goroutine Leak</h4>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

// GOOD: Use context for cancellation
func safeGoroutine(ctx context.Context) chan int {
    ch := make(chan int, 1) // Buffered - won't block

    go func() {
        select {
        case ch <- 42:
            fmt.Println("Sent successfully")
        case <-ctx.Done():
            fmt.Println("Context cancelled, cleaning up")
            return
        }
    }()

    return ch
}

func main() {
    // Using context with timeout to prevent leaks
    ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
    defer cancel()

    ch := safeGoroutine(ctx)

    select {
    case result := <-ch:
        fmt.Println("Got result:", result)
    case <-ctx.Done():
        fmt.Println("Timed out")
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>

            <h4>Mistake 2: Race Conditions</h4>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func main() {
    var wg sync.WaitGroup

    // GOOD: Using atomic operations
    var atomicCounter int64
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&atomicCounter, 1)
        }()
    }
    wg.Wait()
    fmt.Println("Atomic counter:", atomicCounter)

    // GOOD: Using mutex
    var mutexCounter int
    var mu sync.Mutex
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            mutexCounter++
            mu.Unlock()
        }()
    }
    wg.Wait()
    fmt.Println("Mutex counter:", mutexCounter)
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>

            <h4>Mistake 3: Loop Variable Capture</h4>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup

    fmt.Println("GOOD - Pass as parameter:")
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go func(n int) {
            defer wg.Done()
            // n is a copy - prints 1,2,3 (order may vary)
            fmt.Printf("  Got: %d\n", n)
        }(i)
    }
    wg.Wait()
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128268;</span>
                <h3>Context for Request Handling</h3>
            </div>
            <p>Context carries deadlines, cancellation signals, and request-scoped values across API boundaries.</p>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

func fetchFromDB(ctx context.Context, query string) (string, error) {
    // Create a channel for the result
    resultCh := make(chan string, 1)

    go func() {
        // Simulate slow database query
        time.Sleep(20 * time.Millisecond)
        resultCh <- "DB Result: " + query
    }()

    // Wait for result or context cancellation
    select {
    case result := <-resultCh:
        return result, nil
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

func handleRequest(ctx context.Context) {
    // Add timeout to context
    ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
    defer cancel()

    result, err := fetchFromDB(ctx, "SELECT * FROM users")
    if err != nil {
        if err == context.DeadlineExceeded {
            fmt.Println("Request timed out")
        } else if err == context.Canceled {
            fmt.Println("Request was cancelled")
        } else {
            fmt.Println("Error:", err)
        }
        return
    }

    fmt.Println("Got:", result)
}

func main() {
    ctx := context.Background()

    fmt.Println("Request with 100ms timeout (DB takes 20ms - will succeed):")
    handleRequest(ctx)
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>JSON Handling for APIs</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID        int    `json:"id"`
    Name      string `json:"name"`
    Email     string `json:"email,omitempty"`    // Omit if empty
    Password  string `json:"-"`                   // Never include in JSON
    IsAdmin   bool   `json:"is_admin"`
}

type APIResponse struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}

func main() {
    // Struct to JSON
    user := User{
        ID:       1,
        Name:     "Alice",
        Email:    "alice@example.com",
        Password: "secret123", // Won't appear in JSON
        IsAdmin:  false,
    }

    jsonData, _ := json.MarshalIndent(user, "", "  ")
    fmt.Println("User JSON:")
    fmt.Println(string(jsonData))

    // API Response
    response := APIResponse{
        Success: true,
        Data:    user,
    }

    jsonResp, _ := json.MarshalIndent(response, "", "  ")
    fmt.Println("\nAPI Response:")
    fmt.Println(string(jsonResp))

    // JSON to Struct
    input := []byte(`{"id": 2, "name": "Bob", "is_admin": true}`)
    var newUser User
    json.Unmarshal(input, &newUser)
    fmt.Printf("\nParsed User: %+v\n", newUser)
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>
    </section>

    <!-- ADVANCED SECTION -->
    <section id="advanced" class="guide-section">
        <div class="section-header">
            <h2><span class="section-icon">&#128640;</span> Advanced - Production Patterns</h2>
            <p class="section-description">Battle-tested patterns for high-performance APIs</p>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128101;</span>
                <h3>Worker Pool Pattern</h3>
            </div>
            <p>Process multiple tasks concurrently with a fixed number of workers - essential for rate limiting and resource management.</p>

            <div class="diagram-container">
                <div class="diagram-title">Worker Pool Architecture</div>
                <div class="mermaid">
flowchart LR
    J[Jobs Channel] --> W1[Worker 1]
    J --> W2[Worker 2]
    J --> W3[Worker 3]
    W1 --> R[Results Channel]
    W2 --> R
    W3 --> R
    R --> C[Collector]
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type Job struct {
    ID      int
    Payload string
}

type Result struct {
    JobID   int
    Output  string
    Error   error
}

func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()

    for job := range jobs {
        // Simulate processing
        time.Sleep(5 * time.Millisecond)

        results <- Result{
            JobID:  job.ID,
            Output: fmt.Sprintf("Worker %d processed job %d: %s", id, job.ID, job.Payload),
            Error:  nil,
        }
    }
}

func main() {
    numWorkers := 3
    numJobs := 10

    jobs := make(chan Job, numJobs)
    results := make(chan Result, numJobs)

    var wg sync.WaitGroup

    // Start workers
    fmt.Printf("Starting %d workers...\n", numWorkers)
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }

    // Send jobs
    start := time.Now()
    for j := 1; j <= numJobs; j++ {
        jobs <- Job{ID: j, Payload: fmt.Sprintf("Task %d data", j)}
    }
    close(jobs)

    // Wait for workers in separate goroutine
    go func() {
        wg.Wait()
        close(results)
    }()

    // Collect results
    for result := range results {
        fmt.Println(result.Output)
    }

    fmt.Printf("\nProcessed %d jobs in %v\n", numJobs, time.Since(start))
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128295;</span>
                <h3>Rate Limiter Implementation</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type RateLimiter struct {
    tokens   chan struct{}
    interval time.Duration
    stop     chan struct{}
}

func NewRateLimiter(ratePerSecond int) *RateLimiter {
    rl := &RateLimiter{
        tokens:   make(chan struct{}, ratePerSecond),
        interval: time.Second / time.Duration(ratePerSecond),
        stop:     make(chan struct{}),
    }

    // Fill initial tokens
    for i := 0; i < ratePerSecond; i++ {
        rl.tokens <- struct{}{}
    }

    // Refill tokens periodically
    go func() {
        ticker := time.NewTicker(rl.interval)
        defer ticker.Stop()

        for {
            select {
            case <-ticker.C:
                select {
                case rl.tokens <- struct{}{}:
                default: // Bucket full
                }
            case <-rl.stop:
                return
            }
        }
    }()

    return rl
}

func (rl *RateLimiter) Wait() {
    <-rl.tokens
}

func (rl *RateLimiter) Stop() {
    close(rl.stop)
}

func main() {
    // Allow 5 requests per second
    limiter := NewRateLimiter(5)
    defer limiter.Stop()

    var wg sync.WaitGroup
    start := time.Now()

    // Try to make 10 requests quickly
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go func(reqID int) {
            defer wg.Done()

            limiter.Wait() // Block until allowed
            elapsed := time.Since(start)
            fmt.Printf("Request %d processed at %v\n", reqID, elapsed.Round(time.Millisecond))
        }(i)
    }

    wg.Wait()
    fmt.Printf("\nAll requests completed in %v\n", time.Since(start).Round(time.Millisecond))
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#9889;</span>
                <h3>Circuit Breaker Pattern</h3>
            </div>

            <div class="diagram-container">
                <div class="diagram-title">Circuit Breaker State Machine</div>
                <div class="mermaid">
stateDiagram-v2
    [*] --> Closed
    Closed --> Open : Failures >= Threshold
    Open --> HalfOpen : Timeout Elapsed
    HalfOpen --> Closed : Success
    HalfOpen --> Open : Failure
                </div>
            </div>

            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "errors"
    "fmt"
    "sync"
    "time"
)

type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

type CircuitBreaker struct {
    mu            sync.Mutex
    state         State
    failures      int
    threshold     int
    resetTimeout  time.Duration
    lastFailure   time.Time
}

func NewCircuitBreaker(threshold int, resetTimeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:        StateClosed,
        threshold:    threshold,
        resetTimeout: resetTimeout,
    }
}

func (cb *CircuitBreaker) Execute(fn func() error) error {
    cb.mu.Lock()

    if cb.state == StateOpen {
        if time.Since(cb.lastFailure) > cb.resetTimeout {
            cb.state = StateHalfOpen
            cb.failures = 0
            fmt.Println("Circuit: Open -> HalfOpen")
        } else {
            cb.mu.Unlock()
            return errors.New("circuit breaker is open")
        }
    }
    cb.mu.Unlock()

    err := fn()

    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err != nil {
        cb.failures++
        cb.lastFailure = time.Now()

        if cb.failures >= cb.threshold {
            cb.state = StateOpen
            fmt.Printf("Circuit: -> Open (failures: %d)\n", cb.failures)
        }
        return err
    }

    if cb.state == StateHalfOpen {
        cb.state = StateClosed
        fmt.Println("Circuit: HalfOpen -> Closed")
    }
    cb.failures = 0
    return nil
}

func main() {
    cb := NewCircuitBreaker(3, 50*time.Millisecond)

    callCount := 0
    callService := func() error {
        callCount++
        if callCount <= 4 {
            return errors.New("service unavailable")
        }
        return nil
    }

    // Make 10 calls
    for i := 1; i <= 10; i++ {
        err := cb.Execute(callService)
        if err != nil {
            fmt.Printf("Call %d: Failed - %v\n", i, err)
        } else {
            fmt.Printf("Call %d: Success\n", i)
        }
        time.Sleep(5 * time.Millisecond)
    }

    // Wait for reset
    fmt.Println("\nWaiting for circuit to reset...")
    time.Sleep(60 * time.Millisecond)

    callCount = 5
    err := cb.Execute(callService)
    if err != nil {
        fmt.Printf("After reset: Failed - %v\n", err)
    } else {
        fmt.Println("After reset: Success")
    }
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128721;</span>
                <h3>Graceful Shutdown</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

type Server struct {
    wg      sync.WaitGroup
    running bool
    mu      sync.Mutex
}

func (s *Server) HandleRequest(ctx context.Context, reqID int) {
    s.mu.Lock()
    if !s.running {
        s.mu.Unlock()
        fmt.Printf("Request %d rejected: server shutting down\n", reqID)
        return
    }
    s.wg.Add(1)
    s.mu.Unlock()

    defer s.wg.Done()

    fmt.Printf("Request %d: Started\n", reqID)

    select {
    case <-time.After(50 * time.Millisecond):
        fmt.Printf("Request %d: Completed\n", reqID)
    case <-ctx.Done():
        fmt.Printf("Request %d: Cancelled\n", reqID)
    }
}

func (s *Server) Start() {
    s.mu.Lock()
    s.running = true
    s.mu.Unlock()
    fmt.Println("Server started")
}

func (s *Server) Shutdown(timeout time.Duration) {
    fmt.Println("Initiating graceful shutdown...")

    s.mu.Lock()
    s.running = false
    s.mu.Unlock()

    done := make(chan struct{})
    go func() {
        s.wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("All requests completed, shutdown successful")
    case <-time.After(timeout):
        fmt.Println("Shutdown timeout, some requests may be incomplete")
    }
}

func main() {
    server := &Server{}
    server.Start()

    ctx := context.Background()

    // Simulate incoming requests
    for i := 1; i <= 3; i++ {
        go server.HandleRequest(ctx, i)
        time.Sleep(5 * time.Millisecond)
    }

    time.Sleep(10 * time.Millisecond)
    server.Shutdown(500 * time.Millisecond)
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128230;</span>
                <h3>Concurrent Map with sync.Map</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

type Cache struct {
    data sync.Map
}

func (c *Cache) Set(key string, value interface{}) {
    c.data.Store(key, value)
}

func (c *Cache) Get(key string) (interface{}, bool) {
    return c.data.Load(key)
}

func (c *Cache) GetOrSet(key string, defaultValue interface{}) interface{} {
    actual, _ := c.data.LoadOrStore(key, defaultValue)
    return actual
}

func main() {
    cache := &Cache{}
    var wg sync.WaitGroup

    // Concurrent writes
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("user:%d", id)
            cache.Set(key, fmt.Sprintf("User %d data", id))
        }(i)
    }

    wg.Wait()

    // Read values
    if value, ok := cache.Get("user:5"); ok {
        fmt.Println("Found:", value)
    }

    // GetOrSet - atomic check and set
    result := cache.GetOrSet("user:100", "New User 100")
    fmt.Println("GetOrSet result:", result)

    // Second call returns existing value
    result2 := cache.GetOrSet("user:100", "Different Value")
    fmt.Println("Second GetOrSet:", result2)

    // Iterate all entries
    fmt.Println("\nAll cache entries:")
    cache.data.Range(func(key, value interface{}) bool {
        fmt.Printf("  %s: %s\n", key, value)
        return true
    })
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>

        <div class="topic-block">
            <div class="block-header">
                <span class="block-icon">&#128260;</span>
                <h3>Fan-Out/Fan-In Pattern</h3>
            </div>
            <div class="code-example">
                <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func producer(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            time.Sleep(5 * time.Millisecond)
            out <- n * n
        }
        close(out)
    }()
    return out
}

func merge(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    output := func(c <-chan int) {
        defer wg.Done()
        for n := range c {
            out <- n
        }
    }

    wg.Add(len(channels))
    for _, c := range channels {
        go output(c)
    }

    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}

func main() {
    start := time.Now()

    // Create input
    in := producer(1, 2, 3, 4, 5, 6, 7, 8)

    // Fan-out to 3 workers
    c1 := square(in)
    c2 := square(in)
    c3 := square(in)

    // Fan-in results
    results := merge(c1, c2, c3)

    // Collect results
    var sum int
    count := 0
    for n := range results {
        fmt.Printf("Got: %d\n", n)
        sum += n
        count++
    }

    fmt.Printf("\nProcessed %d items, sum: %d\n", count, sum)
    fmt.Printf("Time: %v\n", time.Since(start).Round(time.Millisecond))
}</code></pre>
                <button class="run-code-btn" data-language="go">Run Code</button>
            </div>
        </div>
    </section>
</div>

<style>
/* Enhanced Guide Page Styles - Go Theme */
.guide-page {
    max-width: 1100px;
    margin: 0 auto;
    padding: 2rem;
}

/* Breadcrumb */
.breadcrumb {
    margin-bottom: 1.5rem;
    font-size: 0.9rem;
}

.breadcrumb a {
    color: #00ADD8;
    text-decoration: none;
}

.breadcrumb a:hover {
    text-decoration: underline;
}

.breadcrumb-sep {
    margin: 0 0.5rem;
    color: var(--color-text-muted, #94a3b8);
}

/* Guide Header */
.guide-header {
    text-align: center;
    margin-bottom: 2.5rem;
    padding: 2.5rem;
    background: linear-gradient(135deg, #00ADD810 0%, #5DC9E210 100%);
    border-radius: 1rem;
    border: 1px solid #00ADD830;
}

.guide-badge {
    display: inline-block;
    padding: 0.35rem 1rem;
    background: linear-gradient(135deg, #00ADD8 0%, #5DC9E2 100%);
    color: white;
    border-radius: 2rem;
    font-size: 0.85rem;
    font-weight: 600;
    margin-bottom: 1rem;
}

.guide-header h1 {
    margin: 0.5rem 0;
    font-size: 2.5rem;
    background: linear-gradient(135deg, #00ADD8 0%, #007d9c 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.guide-description {
    color: var(--color-text-secondary, #475569);
    font-size: 1.15rem;
    margin-bottom: 1.5rem;
}

.guide-stats {
    display: flex;
    justify-content: center;
    gap: 2rem;
    flex-wrap: wrap;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--color-text-secondary, #475569);
    font-size: 0.9rem;
}

.stat-icon {
    font-size: 1.1rem;
}

/* Navigation */
.guide-nav {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    margin-bottom: 2rem;
    padding: 0.75rem;
    background: var(--color-bg-primary, #ffffff);
    border-radius: 1rem;
    border: 1px solid var(--color-border, #e2e8f0);
    position: sticky;
    top: 70px;
    z-index: 50;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    flex-wrap: wrap;
}

.guide-nav-link {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.6rem 1.2rem;
    border-radius: 0.5rem;
    text-decoration: none;
    color: var(--color-text-secondary, #475569);
    font-weight: 500;
    font-size: 0.9rem;
    transition: all 0.2s;
}

.guide-nav-link:hover {
    background: var(--color-bg-secondary, #f8fafc);
    color: var(--color-text-primary, #0f172a);
}

.guide-nav-link.active {
    background: linear-gradient(135deg, #00ADD8 0%, #007d9c 100%);
    color: white;
}

.nav-icon {
    font-size: 1rem;
}

/* Section Headers */
.section-header {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 3px solid #00ADD8;
}

.section-header h2 {
    font-size: 1.75rem;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.section-icon {
    font-size: 1.5rem;
}

.section-description {
    color: var(--color-text-secondary, #475569);
    font-size: 1.05rem;
    margin: 0;
}

/* Guide Section */
.guide-section {
    margin-bottom: 3rem;
    padding-top: 1rem;
}

/* Topic Block */
.topic-block {
    background: var(--color-bg-primary, #ffffff);
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 1rem;
    padding: 1.75rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.topic-block.highlight-block {
    background: linear-gradient(135deg, #00ADD808 0%, #ffffff 100%);
    border-color: #00ADD840;
}

.block-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1rem;
}

.block-header.warning-header {
    color: #f59e0b;
}

.block-icon {
    font-size: 1.5rem;
}

.topic-block h3 {
    font-size: 1.3rem;
    margin: 0;
    color: var(--color-text-primary, #0f172a);
}

.topic-block h4 {
    font-size: 1.1rem;
    margin-top: 1.75rem;
    margin-bottom: 0.75rem;
    color: #00ADD8;
}

.topic-block p {
    color: var(--color-text-secondary, #475569);
    margin-bottom: 1rem;
    line-height: 1.7;
}

.topic-block ul, .topic-block ol {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
    color: var(--color-text-secondary, #475569);
}

.topic-block li {
    margin-bottom: 0.5rem;
    line-height: 1.6;
}

.topic-block code {
    background: #00ADD815;
    padding: 0.2rem 0.5rem;
    border-radius: 0.25rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.875rem;
    color: #00ADD8;
}

/* Concept Grid */
.concept-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1.5rem;
}

.concept-card {
    background: var(--color-bg-secondary, #f8fafc);
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 0.75rem;
    padding: 1.25rem;
    text-align: center;
    transition: all 0.2s;
}

.concept-card:hover {
    border-color: #00ADD8;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 173, 216, 0.15);
}

.concept-icon {
    font-size: 2rem;
    display: block;
    margin-bottom: 0.75rem;
}

.concept-card h4 {
    margin: 0 0 0.5rem 0;
    color: var(--color-text-primary, #0f172a);
    font-size: 1rem;
}

.concept-card p {
    margin: 0;
    font-size: 0.85rem;
    color: var(--color-text-muted, #94a3b8);
}

/* Feature List */
.feature-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin: 1.5rem 0;
}

.feature-item {
    display: flex;
    gap: 1rem;
    align-items: flex-start;
    padding: 1rem;
    background: var(--color-bg-secondary, #f8fafc);
    border-radius: 0.75rem;
    border-left: 4px solid #00ADD8;
}

.feature-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.feature-item strong {
    color: var(--color-text-primary, #0f172a);
    display: block;
    margin-bottom: 0.25rem;
}

.feature-item p {
    margin: 0;
    font-size: 0.9rem;
}

/* Info Box */
.info-box {
    background: linear-gradient(135deg, #00ADD810 0%, #5DC9E210 100%);
    border: 1px solid #00ADD840;
    border-radius: 0.75rem;
    padding: 1.25rem;
    margin: 1.5rem 0;
}

.info-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: #00ADD8;
}

.info-icon {
    font-size: 1.25rem;
}

.info-box p {
    margin: 0;
    line-height: 1.6;
}

/* Diagram Container */
.diagram-container {
    background: var(--color-bg-secondary, #f8fafc);
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin: 1.5rem 0;
    overflow-x: auto;
}

.diagram-title {
    font-weight: 600;
    color: var(--color-text-primary, #0f172a);
    margin-bottom: 1rem;
    text-align: center;
}

/* Comparison Table */
.comparison-table {
    margin: 1.5rem 0;
    border: 1px solid var(--color-border, #e2e8f0);
    border-radius: 0.75rem;
    overflow: hidden;
}

.comparison-header {
    background: linear-gradient(135deg, #00ADD8 0%, #007d9c 100%);
    padding: 0.75rem 1rem;
}

.comparison-title {
    color: white;
    font-weight: 600;
    margin: 0;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
}

.comparison-table th,
.comparison-table td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border, #e2e8f0);
}

.comparison-table th {
    background: var(--color-bg-secondary, #f8fafc);
    font-weight: 600;
    color: var(--color-text-primary, #0f172a);
}

.comparison-table td {
    color: var(--color-text-secondary, #475569);
    font-size: 0.9rem;
}

.comparison-table tr:last-child td {
    border-bottom: none;
}

/* Code Example */
.code-example {
    position: relative;
    margin: 1.25rem 0;
}

.code-example pre {
    background: #1e293b;
    border-radius: 0.75rem;
    padding: 1.25rem;
    padding-top: 3rem;
    overflow-x: auto;
    margin: 0;
    border: 1px solid #334155;
}

.code-example pre code {
    background: none;
    padding: 0;
    color: #e2e8f0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    line-height: 1.6;
}

.run-code-btn {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    padding: 0.5rem 1.25rem;
    background: linear-gradient(135deg, #00ADD8 0%, #007d9c 100%);
    color: white;
    border: none;
    border-radius: 0.5rem;
    cursor: pointer;
    font-size: 0.8rem;
    font-weight: 600;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 0.4rem;
}

.run-code-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 173, 216, 0.4);
}

.run-code-btn:disabled {
    background: #64748b;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Code Output */
.code-output {
    margin-top: 0.5rem;
}

.code-output pre {
    padding: 1rem;
    border-radius: 0.5rem;
    font-size: 0.85rem;
    max-height: 300px;
    overflow-y: auto;
}

.success-output {
    background: #0f172a;
    border: 1px solid #10b98140;
    color: #4ade80;
}

.error-output {
    background: #1e0a0a;
    border: 1px solid #ef444440;
    color: #f87171;
}

/* Mermaid diagrams */
.mermaid {
    display: flex;
    justify-content: center;
}

/* Responsive */
@media (max-width: 768px) {
    .guide-page {
        padding: 1rem;
    }

    .guide-header {
        padding: 1.5rem;
    }

    .guide-header h1 {
        font-size: 1.75rem;
    }

    .guide-stats {
        gap: 1rem;
    }

    .guide-nav {
        position: static;
        flex-direction: column;
    }

    .guide-nav-link {
        justify-content: center;
    }

    .concept-grid {
        grid-template-columns: 1fr;
    }

    .comparison-table {
        font-size: 0.85rem;
    }

    .code-example pre {
        padding-top: 3.5rem;
    }
}
</style>

<script>
(function() {
    // Navigation highlighting
    const navLinks = document.querySelectorAll('.guide-nav-link');
    const sections = document.querySelectorAll('.guide-section');

    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            navLinks.forEach(l => l.classList.remove('active'));
            this.classList.add('active');
        });
    });

    // Scroll spy
    window.addEventListener('scroll', function() {
        let current = '';
        sections.forEach(section => {
            const sectionTop = section.offsetTop - 150;
            if (pageYOffset >= sectionTop) {
                current = section.getAttribute('id');
            }
        });

        navLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('data-section') === current) {
                link.classList.add('active');
            }
        });
    });

    // Run code buttons
    document.querySelectorAll('.run-code-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const codeBlock = this.parentElement.querySelector('code');
            const code = codeBlock.textContent;
            const language = this.dataset.language || 'go';

            this.disabled = true;
            this.textContent = 'Running...';

            fetch('/api/run', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({code: code, language: language})
            })
            .then(response => response.json())
            .then(data => {
                if (data.id) {
                    let pollCount = 0;
                    const maxPolls = 120;
                    const checkResult = () => {
                        pollCount++;
                        fetch('/api/execution/' + data.id)
                        .then(r => r.json())
                        .then(result => {
                            if (result.state === 'complete' || result.state === 'error' || result.state === 'stopped') {
                                this.disabled = false;
                                this.textContent = 'Run Code';

                                let outputDiv = this.parentElement.querySelector('.code-output');
                                if (!outputDiv) {
                                    outputDiv = document.createElement('div');
                                    outputDiv.className = 'code-output';
                                    this.parentElement.appendChild(outputDiv);
                                }

                                if (result.error) {
                                    outputDiv.innerHTML = '<pre class="error-output">' + escapeHtml(result.error) + '</pre>';
                                } else {
                                    outputDiv.innerHTML = '<pre class="success-output">' + escapeHtml(result.output || 'No output') + '</pre>';
                                }
                            } else if (pollCount >= maxPolls) {
                                this.disabled = false;
                                this.textContent = 'Run Code';
                                let outputDiv = this.parentElement.querySelector('.code-output');
                                if (!outputDiv) {
                                    outputDiv = document.createElement('div');
                                    outputDiv.className = 'code-output';
                                    this.parentElement.appendChild(outputDiv);
                                }
                                outputDiv.innerHTML = '<pre class="error-output">Execution timed out</pre>';
                            } else {
                                setTimeout(checkResult, 500);
                            }
                        });
                    };
                    checkResult();
                }
            })
            .catch(err => {
                this.disabled = false;
                this.textContent = 'Run Code';
                alert('Error: ' + err.message);
            });
        });
    });

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Initialize Mermaid if available
    if (typeof mermaid !== 'undefined') {
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    }

    // Highlight code if hljs available
    if (typeof hljs !== 'undefined') {
        document.querySelectorAll('.code-example pre code').forEach(block => {
            hljs.highlightElement(block);
        });
    }
})();
</script>
