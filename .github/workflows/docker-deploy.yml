# Docker Compose Deployment via SSH
#
# This workflow deploys a Docker Compose application to a remote server using
# a single SSH session. It handles code synchronization, container management,
# and environment variable handling safely.
#
# Required Secrets:
#   - SSH_PRIVATE_KEY: Private key for SSH authentication to the server (required)
#   - SSH_HOST: Server IP or hostname (can be in Secrets or Variables)
#   - SSH_USERNAME: SSH user (can be in Secrets or Variables)
#   - GITHUB_SSH_KEY: SSH private key for GitHub repo access (required for cloning)
#
# Optional Secrets:
#   - SSH_PORT: SSH port (default: 22)
#   - ENV_FILE: Content of .env file for the application (optional)
#   - ENV_VARS: Environment variables (optional, base64 encoded for safety)

name: Deploy Docker Compose

on:
  # Automatic deployment on push (currently disabled)
  # Uncomment to enable automatic deployment on push to main/master
  # push:
  #   branches:
  #     - main
  #     - master

  # Manual trigger only
  workflow_dispatch:
    inputs:
      force_restart:
        description: 'Force restart (teardown and rebuild all containers)'
        required: false
        default: false
        type: boolean
      project_path:
        description: 'Custom project path on server (default: /projects/<repo-name>)'
        required: false
        type: string

env:
  DEFAULT_PROJECT_BASE: /projects

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      ssh_host: ${{ steps.check.outputs.ssh_host }}
      ssh_username: ${{ steps.check.outputs.ssh_username }}
      ssh_port: ${{ steps.check.outputs.ssh_port }}
      has_env_file: ${{ steps.check.outputs.has_env_file }}
      has_env_vars: ${{ steps.check.outputs.has_env_vars }}
      validation_passed: ${{ steps.check.outputs.validation_passed }}
    steps:
      - name: Check required secrets and variables
        id: check
        run: |
          echo "=========================================="
          echo "  Configuration Validation"
          echo "=========================================="
          echo ""

          VALIDATION_PASSED=true
          MISSING_KEYS=""

          # Check SSH_HOST (can be secret or variable)
          echo "[Checking] SSH_HOST..."
          if [ -n "${{ secrets.SSH_HOST }}" ]; then
            echo "  ✓ SSH_HOST: Present (from Secrets)"
            echo "ssh_host=${{ secrets.SSH_HOST }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ vars.SSH_HOST }}" ]; then
            echo "  ✓ SSH_HOST: Present (from Variables)"
            echo "ssh_host=${{ vars.SSH_HOST }}" >> $GITHUB_OUTPUT
          else
            echo "  ✗ SSH_HOST: MISSING"
            MISSING_KEYS="${MISSING_KEYS}\n  - SSH_HOST (Add to Secrets or Variables)"
            VALIDATION_PASSED=false
          fi

          # Check SSH_USERNAME (can be secret or variable)
          echo "[Checking] SSH_USERNAME..."
          if [ -n "${{ secrets.SSH_USERNAME }}" ]; then
            echo "  ✓ SSH_USERNAME: Present (from Secrets)"
            echo "ssh_username=${{ secrets.SSH_USERNAME }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ vars.SSH_USERNAME }}" ]; then
            echo "  ✓ SSH_USERNAME: Present (from Variables)"
            echo "ssh_username=${{ vars.SSH_USERNAME }}" >> $GITHUB_OUTPUT
          else
            echo "  ✗ SSH_USERNAME: MISSING"
            MISSING_KEYS="${MISSING_KEYS}\n  - SSH_USERNAME (Add to Secrets or Variables)"
            VALIDATION_PASSED=false
          fi

          # Check SSH_PRIVATE_KEY (must be secret)
          echo "[Checking] SSH_PRIVATE_KEY..."
          if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "  ✓ SSH_PRIVATE_KEY: Present (from Secrets)"
          else
            echo "  ✗ SSH_PRIVATE_KEY: MISSING (REQUIRED)"
            MISSING_KEYS="${MISSING_KEYS}\n  - SSH_PRIVATE_KEY (MUST be added to Secrets, not Variables)"
            VALIDATION_PASSED=false
          fi

          # Check SSH_PORT (optional, can be secret or variable)
          echo "[Checking] SSH_PORT..."
          if [ -n "${{ secrets.SSH_PORT }}" ]; then
            echo "  ✓ SSH_PORT: Present (from Secrets)"
            echo "ssh_port=${{ secrets.SSH_PORT }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ vars.SSH_PORT }}" ]; then
            echo "  ✓ SSH_PORT: Present (from Variables)"
            echo "ssh_port=${{ vars.SSH_PORT }}" >> $GITHUB_OUTPUT
          else
            echo "  ○ SSH_PORT: Not set (will use default: 22)"
            echo "ssh_port=22" >> $GITHUB_OUTPUT
          fi

          # Check SSH_USE_CLOUDFLARE_TUNNEL (optional)
          echo "[Checking] SSH_USE_CLOUDFLARE_TUNNEL..."
          if [ -n "${{ secrets.SSH_USE_CLOUDFLARE_TUNNEL }}" ] || [ -n "${{ vars.SSH_USE_CLOUDFLARE_TUNNEL }}" ]; then
            echo "  ✓ SSH_USE_CLOUDFLARE_TUNNEL: Enabled"
            echo "ssh_use_cloudflare_tunnel=true" >> $GITHUB_OUTPUT
          else
            echo "  ○ SSH_USE_CLOUDFLARE_TUNNEL: Not set (will use direct SSH)"
            echo "ssh_use_cloudflare_tunnel=false" >> $GITHUB_OUTPUT
          fi

          # Check ENV_FILE (optional)
          echo "[Checking] ENV_FILE..."
          if [ -n "${{ secrets.ENV_FILE }}" ]; then
            echo "  ✓ ENV_FILE: Present (from Secrets)"
            echo "has_env_file=true" >> $GITHUB_OUTPUT
          else
            echo "  ○ ENV_FILE: Not configured (optional)"
            echo "has_env_file=false" >> $GITHUB_OUTPUT
          fi

          # Check ENV_VARS (optional)
          echo "[Checking] ENV_VARS..."
          if [ -n "${{ secrets.ENV_VARS }}" ]; then
            echo "  ✓ ENV_VARS: Present (from Secrets)"
            echo "has_env_vars=true" >> $GITHUB_OUTPUT
          else
            echo "  ○ ENV_VARS: Not configured (optional)"
            echo "has_env_vars=false" >> $GITHUB_OUTPUT
          fi

          # Check GITHUB_SSH_KEY (required for cloning repo via SSH)
          echo "[Checking] GITHUB_SSH_KEY..."
          if [ -n "${{ secrets.GITHUB_SSH_KEY }}" ]; then
            echo "  ✓ GITHUB_SSH_KEY: Present (from Secrets)"
            echo "has_github_ssh_key=true" >> $GITHUB_OUTPUT
          else
            echo "  ✗ GITHUB_SSH_KEY: MISSING (REQUIRED for cloning repo)"
            MISSING_KEYS="${MISSING_KEYS}\n  - GITHUB_SSH_KEY (SSH key for GitHub repo access - add to Secrets)"
            VALIDATION_PASSED=false
          fi

          echo ""
          echo "=========================================="

          if [ "$VALIDATION_PASSED" = "false" ]; then
            echo ""
            echo "❌ VALIDATION FAILED"
            echo ""
            echo "Missing required configuration:"
            echo -e "$MISSING_KEYS"
            echo ""
            echo "=========================================="
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo ""
          echo "✅ All required configuration present"
          echo "validation_passed=true" >> $GITHUB_OUTPUT

  test-connection:
    name: Test SSH Connection
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.validation_passed == 'true'
    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Only scan host key if NOT using Cloudflare Tunnel
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" != "true" ]; then
            ssh-keyscan -p ${{ needs.validate.outputs.ssh_port }} -H ${{ needs.validate.outputs.ssh_host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          fi

      - name: Install cloudflared (if using Cloudflare Tunnel)
        if: needs.validate.outputs.ssh_use_cloudflare_tunnel == 'true'
        run: |
          curl -L https://pkg.cloudflare.com/cloudflare-release-key.gpg | sudo apt-key add -
          echo 'deb http://pkg.cloudflare.com/ focal main' | sudo tee /etc/apt/sources.list.d/cloudflare-main.list
          sudo apt-get update
          sudo apt-get install -y cloudflared

      - name: Test SSH connection
        run: |
          echo "=========================================="
          echo "  SSH Connection Test"
          echo "=========================================="
          echo "Host: ${{ needs.validate.outputs.ssh_host }}"
          echo "User: ${{ needs.validate.outputs.ssh_username }}"
          echo "Port: ${{ needs.validate.outputs.ssh_port }}"
          echo "Cloudflare Tunnel: ${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}"
          echo "=========================================="

          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            ssh -v -o BatchMode=yes \
                -o ConnectTimeout=30 \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "echo 'SSH connection via Cloudflare Tunnel successful'; uname -a; docker --version; docker compose version" 2>&1 || {
              echo "=========================================="
              echo "SSH Connection FAILED (via Cloudflare Tunnel)"
              echo ""
              echo "Troubleshooting tips:"
              echo "1. Verify cloudflared is installed on the runner"
              echo "2. Verify SSH_HOST is the Cloudflare Tunnel endpoint"
              echo "3. Verify SSH_PRIVATE_KEY matches the server's authorized_keys"
              echo "4. Verify SSH_USERNAME is correct"
              echo "=========================================="
              exit 1
            }
          else
            ssh -v -o BatchMode=yes \
                -o ConnectTimeout=30 \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p ${{ needs.validate.outputs.ssh_port }} \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "echo 'SSH connection successful'; uname -a; docker --version; docker compose version" 2>&1 || {
              echo "=========================================="
              echo "SSH Connection FAILED (direct)"
              echo ""
              echo "Troubleshooting tips:"
              echo "1. Verify SSH_HOST is correct and reachable"
              echo "2. Verify SSH_USERNAME has SSH access"
              echo "3. Verify SSH_PRIVATE_KEY matches the public key on the server"
              echo "4. Check if the server allows SSH on port ${{ needs.validate.outputs.ssh_port }}"
              echo "5. Ensure the server's firewall allows incoming SSH connections"
              echo "=========================================="
              exit 1
            }
          fi

          echo "=========================================="
          echo "Connection test PASSED"
          echo "=========================================="

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [validate, test-connection]
    if: needs.validate.outputs.validation_passed == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare ENV_VARS (base64 encode for safety)
        id: env_vars
        run: |
          if [ -n "${{ secrets.ENV_VARS }}" ]; then
            echo "ENV_VARS_B64=$(printf '%s' '${{ secrets.ENV_VARS }}' | base64 -w0)" >> $GITHUB_ENV
            echo "has_env_vars=true" >> $GITHUB_OUTPUT
          else
            echo "has_env_vars=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Only scan host key if NOT using Cloudflare Tunnel
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" != "true" ]; then
            ssh-keyscan -p ${{ needs.validate.outputs.ssh_port }} -H ${{ needs.validate.outputs.ssh_host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          fi

      - name: Install cloudflared (if using Cloudflare Tunnel)
        if: needs.validate.outputs.ssh_use_cloudflare_tunnel == 'true'
        run: |
          curl -L https://pkg.cloudflare.com/cloudflare-release-key.gpg | sudo apt-key add -
          echo 'deb http://pkg.cloudflare.com/ focal main' | sudo tee /etc/apt/sources.list.d/cloudflare-main.list
          sudo apt-get update
          sudo apt-get install -y cloudflared

      - name: Determine project path
        id: project
        run: |
          if [ -n "${{ inputs.project_path }}" ]; then
            PROJECT_PATH="${{ inputs.project_path }}"
          else
            PROJECT_PATH="${{ env.DEFAULT_PROJECT_BASE }}/${{ github.event.repository.name }}"
          fi
          echo "path=$PROJECT_PATH" >> $GITHUB_OUTPUT
          echo "Project will be deployed to: $PROJECT_PATH"

      - name: Ensure project directory exists
        run: |
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "mkdir -p '${{ steps.project.outputs.path }}'"
          else
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p ${{ needs.validate.outputs.ssh_port }} \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "mkdir -p '${{ steps.project.outputs.path }}'"
          fi

      - name: Deploy ENV_FILE if present
        if: needs.validate.outputs.has_env_file == 'true'
        run: |
          # SCP ENV_FILE to the server (directory now exists)
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            scp -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                "${{ secrets.ENV_FILE }}" \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }}:${{ steps.project.outputs.path }}/.env 2>/dev/null || {
              echo "WARNING: Failed to SCP ENV_FILE to server (via Cloudflare Tunnel)"
              exit 0
            }
          else
            scp -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -P ${{ needs.validate.outputs.ssh_port }} \
                "${{ secrets.ENV_FILE }}" \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }}:${{ steps.project.outputs.path }}/.env 2>/dev/null || {
              echo "WARNING: Failed to SCP ENV_FILE to server (direct SSH)"
              exit 0
            }
          fi

      - name: Deploy GitHub SSH key to server
        run: |
          echo "=========================================="
          echo "  Deploying GitHub SSH key to server"
          echo "=========================================="

          # Create temp file with GitHub SSH key
          echo "${{ secrets.GITHUB_SSH_KEY }}" > /tmp/github_deploy_key
          chmod 600 /tmp/github_deploy_key

          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            # Setup .ssh directory on server
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "mkdir -p ~/.ssh && chmod 700 ~/.ssh"

            # Copy GitHub SSH key to server
            scp -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                /tmp/github_deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }}:~/.ssh/github_deploy_key

            # Configure SSH for GitHub
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "chmod 600 ~/.ssh/github_deploy_key && cat > ~/.ssh/config << 'SSHCONFIG'
Host github.com
  HostName github.com
  User git
  IdentityFile ~/.ssh/github_deploy_key
  StrictHostKeyChecking accept-new
SSHCONFIG
chmod 600 ~/.ssh/config"
          else
            # Setup .ssh directory on server
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p ${{ needs.validate.outputs.ssh_port }} \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "mkdir -p ~/.ssh && chmod 700 ~/.ssh"

            # Copy GitHub SSH key to server
            scp -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -P ${{ needs.validate.outputs.ssh_port }} \
                /tmp/github_deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }}:~/.ssh/github_deploy_key

            # Configure SSH for GitHub
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p ${{ needs.validate.outputs.ssh_port }} \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "chmod 600 ~/.ssh/github_deploy_key && cat > ~/.ssh/config << 'SSHCONFIG'
Host github.com
  HostName github.com
  User git
  IdentityFile ~/.ssh/github_deploy_key
  StrictHostKeyChecking accept-new
SSHCONFIG
chmod 600 ~/.ssh/config"
          fi

          rm -f /tmp/github_deploy_key
          echo "GitHub SSH key deployed to server"

      - name: Deploy application to server
        env:
          PROJECT_PATH: ${{ steps.project.outputs.path }}
          REPO_URL: git@github.com:${{ github.repository }}.git
          REPO_BRANCH: ${{ github.ref_name }}
          FORCE_RESTART: ${{ inputs.force_restart || 'false' }}
          ENV_VARS_B64: ${{ env.ENV_VARS_B64 }}
          SSH_USER: ${{ needs.validate.outputs.ssh_username }}
          SSH_HOST: ${{ needs.validate.outputs.ssh_host }}
          SSH_PORT: ${{ needs.validate.outputs.ssh_port }}
          USE_CLOUDFLARE: ${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}
        run: |
          echo "=========================================="
          echo "  Deploying Application"
          echo "=========================================="
          echo "Repository: $REPO_URL"
          echo "Branch: $REPO_BRANCH"
          echo "Project Path: $PROJECT_PATH"
          echo "Force Restart: $FORCE_RESTART"
          echo "=========================================="

          # Build SSH command based on tunnel option
          if [ "$USE_CLOUDFLARE" = "true" ]; then
            SSH_CMD="ssh -o BatchMode=yes -o StrictHostKeyChecking=no -o ProxyCommand=\"cloudflared access ssh --hostname %h\" -i ~/.ssh/deploy_key ${SSH_USER}@${SSH_HOST}"
          else
            SSH_CMD="ssh -o BatchMode=yes -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key -p ${SSH_PORT} ${SSH_USER}@${SSH_HOST}"
          fi

          # Execute deployment script on server
          eval $SSH_CMD << DEPLOY_SCRIPT
          set -e

          echo ""
          echo "[Step 1/4] Synchronizing Code"
          echo "─────────────────────────────────────────"

          cd $PROJECT_PATH || { echo "Failed to cd to $PROJECT_PATH"; exit 1; }

          # Clone or update repository
          if [ ! -d ".git" ]; then
            echo "Cloning repository..."
            cd ..
            rm -rf \$(basename $PROJECT_PATH)
            git clone $REPO_URL \$(basename $PROJECT_PATH)
            cd \$(basename $PROJECT_PATH)
          else
            echo "Updating existing repository..."
            git fetch origin
          fi

          # Checkout and update branch
          git checkout $REPO_BRANCH || git checkout -b $REPO_BRANCH origin/$REPO_BRANCH
          git reset --hard origin/$REPO_BRANCH

          COMMIT_HASH=\$(git rev-parse --short HEAD)
          COMMIT_MSG=\$(git log -1 --pretty=%B | head -1)
          echo "✔ Repository synchronized"
          echo "  Commit: \$COMMIT_HASH - \$COMMIT_MSG"

          echo ""
          echo "[Step 2/4] Configure Environment"
          echo "─────────────────────────────────────────"

          # Apply ENV_VARS if provided (base64 encoded)
          if [ -n "$ENV_VARS_B64" ]; then
            echo "Applying environment variable overrides..."
            printf '%s' "$ENV_VARS_B64" | base64 -d > .env.override
            chmod 600 .env.override
            echo "✔ Environment overrides applied"
          else
            echo "○ No environment overrides"
          fi

          echo ""
          echo "[Step 3/4] Docker Operations"
          echo "─────────────────────────────────────────"

          # Force restart if requested
          if [ "$FORCE_RESTART" = "true" ]; then
            echo "Tearing down existing containers (force restart)..."
            docker compose down --remove-orphans --timeout 30 || true
          fi

          echo "Pulling images and building containers..."
          docker compose pull --ignore-pull-failures || true
          docker compose up -d --build --remove-orphans

          echo "✔ Containers started"

          echo ""
          echo "[Step 4/4] Health Check"
          echo "─────────────────────────────────────────"

          sleep 5
          docker compose ps

          RUNNING=\$(docker compose ps --format '{{.Status}}' | grep -c 'running\|Up' || echo '0')
          TOTAL=\$(docker compose ps -q | wc -l)
          echo ""
          echo "✔ \$RUNNING/\$TOTAL containers running"

          echo ""
          echo "=========================================="
          echo "  Deployment Complete!"
          echo "  Branch: $REPO_BRANCH @ \$COMMIT_HASH"
          echo "=========================================="

          DEPLOY_SCRIPT

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          echo "SSH key cleaned up"
