# Docker Compose Deployment via SSH
#
# This workflow deploys a Docker Compose application to a remote server using
# a single SSH session. It handles code synchronization, container management,
# and environment variable handling safely.
#
# Required Secrets:
#   - SSH_PRIVATE_KEY: Private key for SSH authentication (required)
#   - SSH_HOST: Server IP or hostname (can be in Secrets or Variables)
#   - SSH_USERNAME: SSH user (can be in Secrets or Variables)
#
# Optional Secrets:
#   - SSH_PORT: SSH port (default: 22)
#   - ENV_FILE: Content of .env file for the application (optional)
#   - ENV_VARS: Environment variables (optional, base64 encoded for safety)

name: Deploy Docker Compose

on:
  # Automatic deployment on push (currently disabled)
  # Uncomment to enable automatic deployment on push to main/master
  # push:
  #   branches:
  #     - main
  #     - master

  # Manual trigger only
  workflow_dispatch:
    inputs:
      force_restart:
        description: 'Force restart (teardown and rebuild all containers)'
        required: false
        default: false
        type: boolean
      project_path:
        description: 'Custom project path on server (default: /projects/<repo-name>)'
        required: false
        type: string

env:
  DEFAULT_PROJECT_BASE: /projects

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      ssh_host: ${{ steps.check.outputs.ssh_host }}
      ssh_username: ${{ steps.check.outputs.ssh_username }}
      ssh_port: ${{ steps.check.outputs.ssh_port }}
      has_env_file: ${{ steps.check.outputs.has_env_file }}
      has_env_vars: ${{ steps.check.outputs.has_env_vars }}
      validation_passed: ${{ steps.check.outputs.validation_passed }}
    steps:
      - name: Check required secrets and variables
        id: check
        run: |
          echo "=========================================="
          echo "  Configuration Validation"
          echo "=========================================="
          echo ""

          VALIDATION_PASSED=true
          MISSING_KEYS=""

          # Check SSH_HOST (can be secret or variable)
          echo "[Checking] SSH_HOST..."
          if [ -n "${{ secrets.SSH_HOST }}" ]; then
            echo "  ✓ SSH_HOST: Present (from Secrets)"
            echo "ssh_host=${{ secrets.SSH_HOST }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ vars.SSH_HOST }}" ]; then
            echo "  ✓ SSH_HOST: Present (from Variables)"
            echo "ssh_host=${{ vars.SSH_HOST }}" >> $GITHUB_OUTPUT
          else
            echo "  ✗ SSH_HOST: MISSING"
            MISSING_KEYS="${MISSING_KEYS}\n  - SSH_HOST (Add to Secrets or Variables)"
            VALIDATION_PASSED=false
          fi

          # Check SSH_USERNAME (can be secret or variable)
          echo "[Checking] SSH_USERNAME..."
          if [ -n "${{ secrets.SSH_USERNAME }}" ]; then
            echo "  ✓ SSH_USERNAME: Present (from Secrets)"
            echo "ssh_username=${{ secrets.SSH_USERNAME }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ vars.SSH_USERNAME }}" ]; then
            echo "  ✓ SSH_USERNAME: Present (from Variables)"
            echo "ssh_username=${{ vars.SSH_USERNAME }}" >> $GITHUB_OUTPUT
          else
            echo "  ✗ SSH_USERNAME: MISSING"
            MISSING_KEYS="${MISSING_KEYS}\n  - SSH_USERNAME (Add to Secrets or Variables)"
            VALIDATION_PASSED=false
          fi

          # Check SSH_PRIVATE_KEY (must be secret)
          echo "[Checking] SSH_PRIVATE_KEY..."
          if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "  ✓ SSH_PRIVATE_KEY: Present (from Secrets)"
          else
            echo "  ✗ SSH_PRIVATE_KEY: MISSING (REQUIRED)"
            MISSING_KEYS="${MISSING_KEYS}\n  - SSH_PRIVATE_KEY (MUST be added to Secrets, not Variables)"
            VALIDATION_PASSED=false
          fi

          # Check SSH_PORT (optional, can be secret or variable)
          echo "[Checking] SSH_PORT..."
          if [ -n "${{ secrets.SSH_PORT }}" ]; then
            echo "  ✓ SSH_PORT: Present (from Secrets)"
            echo "ssh_port=${{ secrets.SSH_PORT }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ vars.SSH_PORT }}" ]; then
            echo "  ✓ SSH_PORT: Present (from Variables)"
            echo "ssh_port=${{ vars.SSH_PORT }}" >> $GITHUB_OUTPUT
          else
            echo "  ○ SSH_PORT: Not set (will use default: 22)"
            echo "ssh_port=22" >> $GITHUB_OUTPUT
          fi

          # Check SSH_USE_CLOUDFLARE_TUNNEL (optional)
          echo "[Checking] SSH_USE_CLOUDFLARE_TUNNEL..."
          if [ -n "${{ secrets.SSH_USE_CLOUDFLARE_TUNNEL }}" ] || [ -n "${{ vars.SSH_USE_CLOUDFLARE_TUNNEL }}" ]; then
            echo "  ✓ SSH_USE_CLOUDFLARE_TUNNEL: Enabled"
            echo "ssh_use_cloudflare_tunnel=true" >> $GITHUB_OUTPUT
          else
            echo "  ○ SSH_USE_CLOUDFLARE_TUNNEL: Not set (will use direct SSH)"
            echo "ssh_use_cloudflare_tunnel=false" >> $GITHUB_OUTPUT
          fi

          # Check ENV_FILE (optional)
          echo "[Checking] ENV_FILE..."
          if [ -n "${{ secrets.ENV_FILE }}" ]; then
            echo "  ✓ ENV_FILE: Present (from Secrets)"
            echo "has_env_file=true" >> $GITHUB_OUTPUT
          else
            echo "  ○ ENV_FILE: Not configured (optional)"
            echo "has_env_file=false" >> $GITHUB_OUTPUT
          fi

          # Check ENV_VARS (optional)
          echo "[Checking] ENV_VARS..."
          if [ -n "${{ secrets.ENV_VARS }}" ]; then
            echo "  ✓ ENV_VARS: Present (from Secrets)"
            echo "has_env_vars=true" >> $GITHUB_OUTPUT
          else
            echo "  ○ ENV_VARS: Not configured (optional)"
            echo "has_env_vars=false" >> $GITHUB_OUTPUT
          fi

          echo ""
          echo "=========================================="

          if [ "$VALIDATION_PASSED" = "false" ]; then
            echo ""
            echo "❌ VALIDATION FAILED"
            echo ""
            echo "Missing required configuration:"
            echo -e "$MISSING_KEYS"
            echo ""
            echo "=========================================="
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo ""
          echo "✅ All required configuration present"
          echo "validation_passed=true" >> $GITHUB_OUTPUT

  test-connection:
    name: Test SSH Connection
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.validation_passed == 'true'
    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Only scan host key if NOT using Cloudflare Tunnel
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" != "true" ]; then
            ssh-keyscan -p ${{ needs.validate.outputs.ssh_port }} -H ${{ needs.validate.outputs.ssh_host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          fi

      - name: Install cloudflared (if using Cloudflare Tunnel)
        if: needs.validate.outputs.ssh_use_cloudflare_tunnel == 'true'
        run: |
          curl -L https://pkg.cloudflare.com/cloudflare-release-key.gpg | sudo apt-key add -
          echo 'deb http://pkg.cloudflare.com/ focal main' | sudo tee /etc/apt/sources.list.d/cloudflare-main.list
          sudo apt-get update
          sudo apt-get install -y cloudflared

      - name: Test SSH connection
        run: |
          echo "=========================================="
          echo "  SSH Connection Test"
          echo "=========================================="
          echo "Host: ${{ needs.validate.outputs.ssh_host }}"
          echo "User: ${{ needs.validate.outputs.ssh_username }}"
          echo "Port: ${{ needs.validate.outputs.ssh_port }}"
          echo "Cloudflare Tunnel: ${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}"
          echo "=========================================="

          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            ssh -v -o BatchMode=yes \
                -o ConnectTimeout=30 \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "echo 'SSH connection via Cloudflare Tunnel successful'; uname -a; docker --version; docker compose version" 2>&1 || {
              echo "=========================================="
              echo "SSH Connection FAILED (via Cloudflare Tunnel)"
              echo ""
              echo "Troubleshooting tips:"
              echo "1. Verify cloudflared is installed on the runner"
              echo "2. Verify SSH_HOST is the Cloudflare Tunnel endpoint"
              echo "3. Verify SSH_PRIVATE_KEY matches the server's authorized_keys"
              echo "4. Verify SSH_USERNAME is correct"
              echo "=========================================="
              exit 1
            }
          else
            ssh -v -o BatchMode=yes \
                -o ConnectTimeout=30 \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p ${{ needs.validate.outputs.ssh_port }} \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "echo 'SSH connection successful'; uname -a; docker --version; docker compose version" 2>&1 || {
              echo "=========================================="
              echo "SSH Connection FAILED (direct)"
              echo ""
              echo "Troubleshooting tips:"
              echo "1. Verify SSH_HOST is correct and reachable"
              echo "2. Verify SSH_USERNAME has SSH access"
              echo "3. Verify SSH_PRIVATE_KEY matches the public key on the server"
              echo "4. Check if the server allows SSH on port ${{ needs.validate.outputs.ssh_port }}"
              echo "5. Ensure the server's firewall allows incoming SSH connections"
              echo "=========================================="
              exit 1
            }
          fi

          echo "=========================================="
          echo "Connection test PASSED"
          echo "=========================================="

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [validate, test-connection]
    if: needs.validate.outputs.validation_passed == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare ENV_VARS (base64 encode for safety)
        id: env_vars
        run: |
          if [ -n "${{ secrets.ENV_VARS }}" ]; then
            echo "ENV_VARS_B64=$(printf '%s' '${{ secrets.ENV_VARS }}' | base64 -w0)" >> $GITHUB_ENV
            echo "has_env_vars=true" >> $GITHUB_OUTPUT
          else
            echo "has_env_vars=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Only scan host key if NOT using Cloudflare Tunnel
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" != "true" ]; then
            ssh-keyscan -p ${{ needs.validate.outputs.ssh_port }} -H ${{ needs.validate.outputs.ssh_host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          fi

      - name: Install cloudflared (if using Cloudflare Tunnel)
        if: needs.validate.outputs.ssh_use_cloudflare_tunnel == 'true'
        run: |
          curl -L https://pkg.cloudflare.com/cloudflare-release-key.gpg | sudo apt-key add -
          echo 'deb http://pkg.cloudflare.com/ focal main' | sudo tee /etc/apt/sources.list.d/cloudflare-main.list
          sudo apt-get update
          sudo apt-get install -y cloudflared

      - name: Determine project path
        id: project
        run: |
          if [ -n "${{ inputs.project_path }}" ]; then
            PROJECT_PATH="${{ inputs.project_path }}"
          else
            PROJECT_PATH="${{ env.DEFAULT_PROJECT_BASE }}/${{ github.event.repository.name }}"
          fi
          echo "path=$PROJECT_PATH" >> $GITHUB_OUTPUT
          echo "Project will be deployed to: $PROJECT_PATH"

      - name: Ensure project directory exists
        run: |
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "mkdir -p '${{ steps.project.outputs.path }}'"
          else
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p ${{ needs.validate.outputs.ssh_port }} \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }} \
                "mkdir -p '${{ steps.project.outputs.path }}'"
          fi

      - name: Deploy ENV_FILE if present
        if: needs.validate.outputs.has_env_file == 'true'
        run: |
          # SCP ENV_FILE to the server (directory now exists)
          if [ "${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}" = "true" ]; then
            scp -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                "${{ secrets.ENV_FILE }}" \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }}:${{ steps.project.outputs.path }}/.env 2>/dev/null || {
              echo "WARNING: Failed to SCP ENV_FILE to server (via Cloudflare Tunnel)"
              exit 0
            }
          else
            scp -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -P ${{ needs.validate.outputs.ssh_port }} \
                "${{ secrets.ENV_FILE }}" \
                ${{ needs.validate.outputs.ssh_username }}@${{ needs.validate.outputs.ssh_host }}:${{ steps.project.outputs.path }}/.env 2>/dev/null || {
              echo "WARNING: Failed to SCP ENV_FILE to server (direct SSH)"
              exit 0
            }
          fi

      - name: Deploy to server via deploy.sh (single SSH session)
        env:
          SSH_HOST: ${{ needs.validate.outputs.ssh_host }}
          SSH_USER: ${{ needs.validate.outputs.ssh_username }}
          SSH_PORT: ${{ needs.validate.outputs.ssh_port }}
          SSH_USE_CLOUDFLARE_TUNNEL: ${{ needs.validate.outputs.ssh_use_cloudflare_tunnel }}
          PROJECT_PATH: ${{ steps.project.outputs.path }}
          REPO_BRANCH: ${{ github.ref_name }}
          FORCE_RESTART: ${{ inputs.force_restart || 'false' }}
          ENV_VARS_B64: ${{ env.ENV_VARS_B64 }}
        run: |
          if [ "$SSH_USE_CLOUDFLARE_TUNNEL" = "true" ]; then
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -o ProxyCommand="cloudflared access ssh --hostname %h" \
                -i ~/.ssh/deploy_key \
                "$SSH_USER@$SSH_HOST" << 'DEPLOY_SESSION'
          else
            ssh -o BatchMode=yes \
                -o StrictHostKeyChecking=no \
                -i ~/.ssh/deploy_key \
                -p "$SSH_PORT" \
                "$SSH_USER@$SSH_HOST" << 'DEPLOY_SESSION'
          fi
          
          set -e

          echo "=========================================="
          echo "  GitHub Actions Deployment"
          echo "  $(date)"
          echo "=========================================="

          cd "$PROJECT_PATH"

          # Call deploy.sh (single source of truth for ALL deployment logic)
          chmod +x scripts/deploy.sh
          
          echo ""
          echo "Invoking deploy.sh (single source of truth)..."
          echo "=========================================="
          
          # Export SSH variables for deploy.sh to use
          export SSH_HOST="$SSH_HOST"
          export SSH_USERNAME="$SSH_USER"
          export SSH_PORT="$SSH_PORT"
          export SSH_USE_CLOUDFLARE_TUNNEL="$SSH_USE_CLOUDFLARE_TUNNEL"
          export FORCE_RESTART="$FORCE_RESTART"
          export ENV_VARS_B64="$ENV_VARS_B64"
          
          ./scripts/deploy.sh

          DEPLOY_SESSION

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          echo "SSH key cleaned up"
